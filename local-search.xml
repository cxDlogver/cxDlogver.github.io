<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>text</title>
    <link href="/2024/07/21/text/"/>
    <url>/2024/07/21/text/</url>
    
    <content type="html"><![CDATA[<img src="/2024/07/21/text/image-20221116110134821.png" class title="image-20221116110134821">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/07/21/hello-world/"/>
    <url>/2024/07/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>层次分析法</title>
    <link href="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <url>/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>层次分析法（AHP）用于解决评价类问题。是一种系统分析与决策的<u><strong>综合评价方法</strong></u>。</p><span id="more"></span><blockquote><p><strong>官方解释：</strong>AHP的主要特点是通过建立递阶层次结构，把人类的判断转化到若干因素两两之间重要度的比较上，从而把难于量化的定性判断转化为可操作的重要度的比较上面。在许多情况下，决策者可以直接使用AHP进行决策，极大地提高了决策的有效性、可靠性和可行性，但其本质是一种思维方式，它把复杂问题分解成多个组成因素，又将这些因素按支配关系分别形成递阶层次结构，通过两两比较的方法确定决策方案相对重要度的总排序。</p></blockquote><h1 id="评价类问题"><a href="#评价类问题" class="headerlink" title="评价类问题"></a>评价类问题</h1><p>先不看官方的解释，首先我们针对<strong>评价类问题</strong>。解决任何一个评价类问题，首先要想到三个问题：</p><ol><li>评价的目标是什么？</li><li>选择的方案有哪些？</li><li>评价的准则或者说指标有哪些？</li></ol><p><strong>抛出例子：</strong>小明同学想出去旅游，在查阅了网上的攻略后，他初步选择了苏杭、北戴河和桂林三地之一作为目标景点。通过分析回答三个问题。</p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221114001445027.png" class title="image-20221114001445027"><p>那么解决完这三个问题以后，我们可以列出一张表格：</p><p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/%E8%A1%A8%E6%A0%BC.png" alt="image-20221114001705898"></p><p>很明显如果这张表能够填完，我们就可以用<strong>加权平均法</strong>计算每种方案所占的比重。即需要知道<u><strong>每一种方案里每一项指标的权重</strong></u>。且每种方案权重之和应该为1<br>$$<br>wi1 + wi2 + wi3+wi4+wi5&#x3D;1<br>$$</p><p>但是一次直接考虑5各指标分别所占的权重是不靠谱的。</p><blockquote><p>在确定影响某因素的诸因子在该因素中所占的比重时，遇到的主要困难是这些比重常常不易定量化。此外，当影响某因素的因子较多时，直接考虑各因子对该因素有多大程度的影响时，常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据，甚至有可能提出一组隐含矛盾的数据</p><p>——选自司守奎[kuí]老师的《数学建模算法与应用》</p></blockquote><p>所以我们可以两两进行比较，现在我们在回过头去看层次分析法的官方解释，就能有一些头绪了。</p><h1 id="层次分析法思想"><a href="#层次分析法思想" class="headerlink" title="层次分析法思想"></a>层次分析法思想</h1><blockquote><p>简单来说，层次分析法就是来求属性（即指标）的权重。</p></blockquote><p><strong>步骤：</strong></p><ol><li>得到判断矩阵或者一致矩阵。</li></ol><h2 id="判断矩阵"><a href="#判断矩阵" class="headerlink" title="判断矩阵"></a>判断矩阵</h2><p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%E6%80%9D%E6%83%B3.png" alt="层次分析法思想"></p><p>只比较两个指标之间的重要程度，两两比较就可以得到对应的<u><strong>判断矩阵</strong></u>。</p><p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221114013142584.png" alt="判断矩阵"></p><p>得到一个5X5的矩阵，用<code>aij</code>表示第i行第j列。这个判断矩阵有几个规律：</p><ul><li>是一个对称矩阵，<code>aij</code> x <code>aji</code> &#x3D; 1</li><li><code>aij</code>表示的相比指标j来说，i的重要程度。</li><li>如果<code>aij</code> x<code> ajk</code> &gt;&#x3D;1 则应有<code>aik</code>&gt;&#x3D;1。反之也是。</li></ul><p>满足这三个条件的判断矩阵称为<u><strong>正互反矩阵</strong></u>。前面两个很好理解，第三个的意思是：如果A比B重要，B比C重要，那么A应该比C重要；如果A比B是强烈重要，C比B是稍微重要，A也应该比B重要。这是判断矩阵需要满足的条件。<u><strong>如果不满足，则判断矩阵需要进行修正</strong></u>。</p><p>第三个条件如果特殊的是<code>aij</code> X <code>ajk</code> &#x3D; <code>aik</code>。满足这个条件，则会发现<strong>各行（各列）之间成倍数关系</strong>。这是的判断矩阵称为<u><strong>一致矩阵</strong></u>。</p><h2 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h2><blockquote><p>检验我们构造的判断矩阵和一致矩阵是否有太大的差别。</p></blockquote><p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221114015355099.png" alt="image-20221114015355099"></p><p>涉及到线性代数的知识自行查阅~</p><blockquote><p><strong>结论：</strong>n阶一致矩阵有唯一的一个特征值n。当矩阵越不一致时，一定满足R&gt;n，最大特征值R与n相差就越大，R越大。</p></blockquote><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-2022111401445027.png" class title="image-20221116104602653"><ul><li><strong>RI</strong>是通过多个样本数据训练出现的平均随机一致性指标，是一个定值。</li></ul><p>一致性检测通过以后才可以进行到下一步，计算属性权重。</p><h2 id="计算属性权重"><a href="#计算属性权重" class="headerlink" title="计算属性权重"></a>计算属性权重</h2><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116105827481.png" class title="image-20221116105827481"><blockquote><p>属性计算将上面的两种表进行<u><strong>归一化</strong></u>。</p></blockquote><p><img src="/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95%5Cimage-20221116110134821.png" alt="image-20221116110134821"></p><blockquote><p>表一归一化得到上图的第一行，即每一种方案在景色指标中所占的比例。表二归一化得到上图的第一列，即每一种指标在所有方案中所占的比重。</p></blockquote><h3 id="算术平均法求权重"><a href="#算术平均法求权重" class="headerlink" title="算术平均法求权重"></a>算术平均法求权重</h3><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116110637442.png" class title="image-20221116110637442"><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116110713089.png" class title="image-20221116110713089"><h3 id="几何平均法求权重"><a href="#几何平均法求权重" class="headerlink" title="几何平均法求权重"></a>几何平均法求权重</h3><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116110808975.png" class title="image-20221116110808975"><h3 id="特征值法求权重"><a href="#特征值法求权重" class="headerlink" title="特征值法求权重"></a>特征值法求权重</h3><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116111335756.png" class title="image-20221116111335756"><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116111406084.png" class title="image-20221116111406084"><p>最后就可以得到权重矩阵</p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116111520915.png" class title="image-20221116111520915"><h1 id="层次分析法实现（Python）"><a href="#层次分析法实现（Python）" class="headerlink" title="层次分析法实现（Python）"></a>层次分析法实现（Python）</h1><blockquote><p><strong>先对三大问题进行分析后才能开始层次分析法</strong></p></blockquote><h2 id="建立系统的递阶层次结构"><a href="#建立系统的递阶层次结构" class="headerlink" title="建立系统的递阶层次结构"></a>建立系统的递阶层次结构</h2><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116112508674.png" class title="image-20221116112508674"><blockquote><p><strong>专用软件：亿图图示</strong></p></blockquote><h2 id="构建判断矩阵"><a href="#构建判断矩阵" class="headerlink" title="构建判断矩阵"></a>构建判断矩阵</h2><p>判断矩阵不能随意填写，应该有一定的依据，通过**<u><a href="#%E8%B5%84%E6%96%99%E6%9F%A5%E9%98%85">查阅资料</a></u>**判断两两属性之间的重要程度。</p><h2 id="一致性检验-1"><a href="#一致性检验-1" class="headerlink" title="一致性检验"></a>一致性检验</h2><p>判断是不是一致矩阵，第一步计算特征值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#计算矩阵的秩</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> linalg <span class="hljs-keyword">as</span> LA<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getEIG</span>(<span class="hljs-params">array</span>):<br>    W, V = LA.eig(array) <span class="hljs-comment">#求得矩阵的特征值和特征向量</span><br>    <span class="hljs-keyword">return</span> W, V<br>    <br>sight = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">1</span>/<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>/<span class="hljs-number">4</span>,<span class="hljs-number">1</span>/<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]])<br>w, v = getEIG(sight)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;w = &quot;</span> + <span class="hljs-built_in">str</span>(w))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;v = &quot;</span> + <span class="hljs-built_in">str</span>(v))<br><span class="hljs-comment"># w 是特征值，其中特征值为3</span><br><span class="hljs-comment">#每个特征值根据其多重性重复。特征值不一定是有序的。生成的数组将是复数类型，除非虚部为零，在这种情况下它将被转换为实数类型。</span><br><span class="hljs-comment"># v归一化（单位“长度”）特征向量，使得该列v[:,i]是对应于特征值的特征向量w[i]</span><br><span class="hljs-comment"># 特征值为3 的特征向量是 [8.72871561e-01, 4.36435780e-01, 2.18217890e-01];</span><br><br>sight1 = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>/<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>/<span class="hljs-number">5</span>,<span class="hljs-number">1</span>/<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]])<br>w1, v1 = getEIG(sight1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;w = &quot;</span> + <span class="hljs-built_in">str</span>(w1))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;v = &quot;</span> + <span class="hljs-built_in">str</span>(v1))<br><span class="hljs-comment">#如果矩阵的一致性越差，得到的特征值就越大于 n。</span><br></code></pre></td></tr></table></figure><blockquote><p>如果特征值中有虚数，则比较的是特征值的模长。</p></blockquote><p>然后计算一致性指标CI和一致性比例CR</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">CI = (w1[<span class="hljs-number">0</span>] - sight1.shape[<span class="hljs-number">0</span>])/ (sight1.shape[<span class="hljs-number">0</span>] -<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CI =&quot;</span> + <span class="hljs-built_in">str</span>(CI))<br>RI = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.52</span>,<span class="hljs-number">0.89</span>,<span class="hljs-number">1.12</span>,<span class="hljs-number">1.26</span>,<span class="hljs-number">1.36</span>,<span class="hljs-number">1.41</span>,<span class="hljs-number">1.46</span>,<span class="hljs-number">1.49</span>,<span class="hljs-number">1.52</span>,<span class="hljs-number">1.54</span>,<span class="hljs-number">1.56</span>,<span class="hljs-number">1.58</span>,<span class="hljs-number">1.59</span>])<br>CR = CI/RI[sight1.shape[<span class="hljs-number">0</span>] -<span class="hljs-number">1</span> ]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CR =&quot;</span> + <span class="hljs-built_in">str</span>(CR))<br></code></pre></td></tr></table></figure><p>如果CR  &gt; 0.1，则调整矩阵，往一致矩阵上调整，即让各行尽量满足倍数关系。</p><h2 id="计算属性权重-1"><a href="#计算属性权重-1" class="headerlink" title="计算属性权重"></a>计算属性权重</h2><p>满足一致性检验以后，可以开始计算权重了，按照刚刚的计算，我们<u><strong>已经得到了特征向量</strong></u>。所以如果按照特征值法求权重，便可以直接将特征向量归一化以后作为权重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#算术平均法求权重</span><br>n = sight1.shape[<span class="hljs-number">0</span>]<br>m = sight1.shape[<span class="hljs-number">1</span>]<br><br>weight = np.zeros(n)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-built_in">sum</span> += sight1[k][j]<br>        weight[i] += sight1[i][j] / <span class="hljs-built_in">sum</span><br>    weight[i] /= n<br><span class="hljs-built_in">print</span>(weight)<br><span class="hljs-built_in">print</span>(weight.<span class="hljs-built_in">sum</span>())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#几何平均法求矩阵</span><br>n = sight1.shape[<span class="hljs-number">0</span>]<br>m = sight1.shape[<span class="hljs-number">1</span>]<br><br>weight = np.zeros(n)<br>mul = np.zeros(m)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    muli = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        muli *= sight1[i][j]<br>    mul[i] = np.power(muli,<span class="hljs-number">1</span>/n)<br><br><span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-built_in">sum</span> += mul[i]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    weight[i] = mul[i]/<span class="hljs-built_in">sum</span><br><span class="hljs-built_in">print</span>(weight)<br><span class="hljs-built_in">print</span>(weight.<span class="hljs-built_in">sum</span>())<br></code></pre></td></tr></table></figure><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221116111520915.png" class title="image-20221116111520915"><p>最终得到如图的权重矩阵</p><h2 id="计算得分"><a href="#计算得分" class="headerlink" title="计算得分"></a>计算得分</h2><p>使用EXCEL可以很方便的统计得分</p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221117160645331.png" class title="image-20221117160645331"><p>在空格处打上 <code>= </code>号，加上对应的数</p><p><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/CX_appoincation\Typora\Node\Blog\cxDlogver\source_posts\层次分析法\image-20221117160841944.png" alt="image-20221117160841944"></p><p>加上<code>$</code>固定因数。然后右下角向右一拖，就可以自动统计结果。</p><h1 id="层次分析法的局限性"><a href="#层次分析法的局限性" class="headerlink" title="层次分析法的局限性"></a>层次分析法的局限性</h1><img src="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/image-20221117161337059.png" class title="image-20221117161337059"><p>如果决策层已经由数据，则不能使用层次分析法，更多的使用<u><strong>多决策分析法</strong></u>。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>评价模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出基础原理</title>
    <link href="/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    <url>/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a><span id="more"></span></h1><h2 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h2><ol><li>进程的内存主要由哪几部分构成，其中栈结构主要保存什么内容？</li><li>栈帧结构是什么样的？寄存器起到哪些作用？</li><li>X86和X86_64的栈结构有哪些不同之处？</li><li>对栈操作的大致过程是怎样的？</li><li>栈溢出的原理是什么？</li></ol><h2 id="基础栈介绍"><a href="#基础栈介绍" class="headerlink" title="基础栈介绍"></a><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/#_2">基础栈介绍</a></h2><p>每个程序在运行时都有<strong>虚拟地址空间</strong>，其中某一部分就是该程序对应的栈，用于<strong>保存<u>函数调用信息</u>和<u>局部变量</u><strong>。此外，常见的操作也是压栈与出栈。需要注意的是，</strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。</p><img src="/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/image-20220213224820235.png" class title="栈结构"><p>进程使用的内存大致可以分成四个部分：代码区、数据区、堆区、栈区。这个将在《程序员的自我修养》读书笔记中重点分析。</p><p>32 位和 64 位程序有以下简单的区别</p><ul><li>x86<strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</li><li>x64中前六个整型或指针参数依次保存在<strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</li></ul><h2 id="C语言函数调用栈（一）"><a href="#C语言函数调用栈（一）" class="headerlink" title="C语言函数调用栈（一）"></a><a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">C语言函数调用栈（一）</a></h2><p>程序的执行可以看作是连续的函数调用，函数调用的过程通常使用堆栈实现。其中栈上的主要保存：</p><ol><li>函数参数</li><li>函数返回地址</li><li>临时保存寄存器原有值(即函数调用的上下文)</li><li>存储本地局部变量</li></ol><p>栈帧指针寄存器FP，在Intel CPU中用BP作帧指针。</p><img src="/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/image-20220213231828239.png" class title="寄存器使用"><blockquote><p>寄存器<u><strong>%eax、%edx和%ecx</strong></u>主调函数保存寄存器由主调函数显式的保存到栈中，先于返回地址进入栈中。</p><p>寄存器<u><strong>%ebx、%esi和%edi</strong></u>被调函数保存寄存器由被调函数保存到栈中，后于返回地址进入栈中。</p></blockquote><h3 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a><strong>栈帧结构</strong></h3><img src="/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/271650059007975.jpg" class title="栈帧"><blockquote><p><strong>实参N-1 -&gt; 主调函数返回地址 -&gt; 主调函数帧基指针EBP -&gt; 被调函数局部变量1-N</strong></p></blockquote><p>x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。</p><p>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(通常都是EAX)</p><h2 id="C语言函数调用栈-二"><a href="#C语言函数调用栈-二" class="headerlink" title="C语言函数调用栈(二)"></a><a href="https://www.cnblogs.com/clover-toeic/p/3756668.html">C语言函数调用栈(二)</a></h2><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a><strong>函数调用约定</strong></h3><p>函数通过选择特定的调用约定，来表明其希望以<strong>特定方式</strong>接收参数。主要有几个方面</p><ol><li><strong>函数参数的传递顺序和方式：</strong> 最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。</li><li><strong>栈的维护方式：</strong> 主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。</li><li><strong>名字修饰策略：</strong>又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。</li></ol><h4 id="cdecl调用约定"><a href="#cdecl调用约定" class="headerlink" title="cdecl调用约定"></a><strong>cdecl调用约定</strong></h4><ul><li>C调用约定，是C&#x2F;C++编译器默认的函数调用约定。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。</li><li>可以支持可变参数函数，即参数的数量不定。最左边的参数最接近栈顶位置。调用时即使实参和形参数目不符也不会导致堆栈错误</li></ul><h4 id="stdcall调用约定"><a href="#stdcall调用约定" class="headerlink" title="stdcall调用约定"></a><strong>stdcall调用约定</strong></h4><ul><li>WinAPI采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。</li><li>仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；</li></ul><h4 id="x86函数参数传递方法"><a href="#x86函数参数传递方法" class="headerlink" title="x86函数参数传递方法"></a><strong>x86函数参数传递方法</strong></h4><p>x86处理器ABI规范中规定，所有传递给被调函数的参数都通过堆栈来完成，其压栈顺序是以函数参数从右到左的顺序。当向被调函数传递参数时，所有参数最后形成一个数组。由于采用从右到左的压栈顺序，数组中参数的顺序(下标0<del>N-1)与函数参数声明顺序(Para1</del> N)一致。因此，在函数中若知道第一个参数地址和各参数占用字节数，就可通过访问数组的方式去访问每个参数。</p><p>X86_64 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</p><h2 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stackoverflow-basic/">栈溢出原理</a></h2><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><p>前提：PIE保护关闭</p><p><a href="http://tttang.com/archive/1361/#toc__1">寻找危险函数</a></p><p><a href="http://tttang.com/archive/1361/#toc__2">确定填充长度</a></p><img src="/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/image-20220214161648989.png" class title="栈表"><blockquote><p>s表示<code>push ebp</code>的地址，r表示函数的返回地址，指定地址应该覆盖r所在的地址</p></blockquote><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><blockquote><p>问题1：进程的内存主要由哪几部分构成，其中栈结构主要保存什么内容？</p></blockquote><p>进程的内存主要由代码段、数据段、堆段、栈段构成。函数的调用关系等信息会动态地保存在内存的栈区，因此栈结构用于保存<u><strong>函数调用信息</strong></u>和<u><strong>局部变量</strong></u>。包括<u><strong>函数参数</strong></u>（例如主调函数传递给被调函数的参数）、<u><strong>函数返回地址</strong></u>（被调函数执行结束以后需要返回到主调函数）、<u><strong>函数局部变量</strong></u>、<u><strong>寄存器的值</strong></u>（被调函数调用一些寄存器之前，可能需要先将寄存器中的值保存到栈中，因为寄存器中可能保存着主调函数需要使用的值）。</p><blockquote><p>问题2：栈帧结构是什么样的？寄存器起到哪些作用？</p></blockquote><p>寄存器用于存放程序执行中用到的数据和指令。在函数调用的过程中起到重要的作用。<u><strong>栈帧</strong></u>是每一个函数占用的一个独立的区域，栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。</p><p><strong>EBP（帧基指针）：</strong>EBP指向是每一个栈帧的基址。一个栈的基址存放的是函数的返回地址。当调用函数栈帧压入堆栈的时候。执行的指令是 :<code>push eip</code> <code>mov ebp esp</code>。函数返回之前，EBP始终指向栈帧的基址，因此函数中对大部分数据的访问都基于EBP进行，通常用<strong>EBP + 偏移地址</strong>作为一个符号的地址。</p><p><strong>ESP（栈顶指针）：</strong>ESP通常指向一个栈帧的顶点，但是在出栈入栈的时候ESP的值是不断发生改变的。</p><p>其他寄存器在函数存档和函数返回参数的时候也会起到作用。若返回值不超过4字节，通常将其保存在EAX寄存器中。具体内容看<strong>“函数使用约定”</strong>和<strong>“ x86函数返回值传递方法”</strong>。</p><blockquote><p>问题3：X86和X86_64的栈结构有哪些不同之处？</p></blockquote><p>最大的不同就是x86平台将参数压入调用栈中。而x86_64平台调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。<strong>这一点需要重点注意</strong>。</p><blockquote><p>问题4：对栈操作的大致过程是怎样的？</p></blockquote><ol><li>当主调函数调用被调函数的时候，操作系统需要使用寄存器先对主调函数进行存档，然后，按照将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。此时EBP并没有发生改变，所以函数参数是存放在主调函数的栈帧中的。<u>同时主调函数可能会把一些不希望被调函数覆盖的寄存器（如%eax、%edx和%ecx）中的值先压入栈（保存了主调函数信息的值）</u></li><li>使用CALL等跳转指令以后，EIP发生的跳转，被调函数的栈帧进入栈中。然后返回地址放入被调函数的基地址<u><strong>（<code>push eip</code>）</strong></u>，随后设置帧基指针EBP<u><strong>（<code>mov ebp esp</code>）</strong></u>。</li><li>被调函数局部变量依次被压入栈，如果将数组压入栈，会执行<code>sub esp X</code>分配X大小的栈空间给数组。<u>同时被调函数也会把一些不能被覆盖的寄存器中的值压入栈</u>，才能调用寄存器。</li><li>被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。</li><li>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。</li><li>一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放<u><strong>（<code>mov esp ebp</code>）</strong></u>。然后 恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器<u>（**<code>pop ebp</code><strong>）</strong></u>。两个指令合并称为leave指令**</li><li>被调函数将控制权交还主调函数(使用<strong>ret</strong>指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。</li><li>主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。</li></ol><p><strong>需要注意的点：</strong></p><ul><li>我们不能直观的判断出被调函数的某个局部变量或者某个参数距离返回地址之间的大小。因为<u><strong>返回地址前后都不定数量的寄存器被压入栈</strong></u>。只能通过调试软件进行分析。</li><li>一定要注意x86平台是将参数直接压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。</li></ul><blockquote><p>问题5：栈溢出的原理是什么？</p></blockquote><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。那么就可以：</p><ul><li>修改相邻栈中变量的值。</li><li>修改函数的返回地址，使返回地址跳转到我们希望进入的地址。</li></ul>]]></content>
    
    
    <categories>
      
      <category>漏洞利用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="/2022/04/19/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/04/19/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
