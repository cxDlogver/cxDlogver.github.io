<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTML核心内容</title>
    <link href="/2026/01/10/HTMLCSS/CSS%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/"/>
    <url>/2026/01/10/HTMLCSS/CSS%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h1><h2 id="1-Flex-是什么"><a href="#1-Flex-是什么" class="headerlink" title="1. Flex 是什么"></a>1. Flex 是什么</h2><p><strong>Flex（Flexible Box）是一种一维布局模型</strong>，用于在<strong>一条主轴</strong>上对元素进行排列、对齐与分配空间。</p><p>适用场景：</p><ul><li>横向或纵向排列的组件（导航栏、列表、工具栏）</li><li>不确定数量、不确定尺寸的子元素布局</li><li>响应式布局中的局部结构</li></ul><h2 id="2-Flex-的基本概念"><a href="#2-Flex-的基本概念" class="headerlink" title="2. Flex 的基本概念"></a>2. Flex 的基本概念</h2><h3 id="【两个角色】"><a href="#【两个角色】" class="headerlink" title="【两个角色】"></a>【两个角色】</h3><ul><li><strong>Flex Container（容器）</strong>：设置了 <code>display: flex</code> 的元素</li><li><strong>Flex Item（项目）</strong>：容器的直接子元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="【两根轴】"><a href="#【两根轴】" class="headerlink" title="【两根轴】"></a>【两根轴】</h3><p>Flex 布局中最重要的概念是 <strong>轴向系统</strong>：</p><ul><li><strong>主轴（main axis）</strong><br> 元素排列的方向，由 <code>flex-direction</code> 决定</li><li><strong>交叉轴（cross axis）</strong><br> 垂直于主轴的方向</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row;        <span class="hljs-comment">/* 主轴：水平方向（默认） */</span><br><span class="hljs-attribute">flex-direction</span>: column;     <span class="hljs-comment">/* 主轴：垂直方向 */</span><br></code></pre></td></tr></table></figure><h2 id="3-容器属性（决定整体布局规则）"><a href="#3-容器属性（决定整体布局规则）" class="headerlink" title="3. 容器属性（决定整体布局规则）"></a>3. 容器属性（决定整体布局规则）</h2><h3 id="1-display"><a href="#1-display" class="headerlink" title="1. display"></a>1. display</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: flex;        <span class="hljs-comment">/* 块级 flex */</span><br><span class="hljs-attribute">display</span>: inline-flex;<span class="hljs-comment">/* 行内 flex */</span><br></code></pre></td></tr></table></figure><hr><h3 id="2-flex-direction（主轴方向）"><a href="#2-flex-direction（主轴方向）" class="headerlink" title="2. flex-direction（主轴方向）"></a>2. flex-direction（主轴方向）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row;            <span class="hljs-comment">/* 默认，从左到右 */</span><br><span class="hljs-attribute">flex-direction</span>: row-reverse;    <span class="hljs-comment">/* 从右到左 */</span><br><span class="hljs-attribute">flex-direction</span>: column;         <span class="hljs-comment">/* 从上到下 */</span><br><span class="hljs-attribute">flex-direction</span>: column-reverse; <span class="hljs-comment">/* 从下到上 */</span><br></code></pre></td></tr></table></figure><p>影响的是：</p><ul><li>主轴方向</li><li><code>justify-content</code> 的方向</li><li><code>flex-basis</code> 的参考方向</li></ul><h3 id="3-flex-wrap（是否换行）"><a href="#3-flex-wrap（是否换行）" class="headerlink" title="3. flex-wrap（是否换行）"></a>3. flex-wrap（是否换行）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-wrap</span>: nowrap;  <span class="hljs-comment">/* 默认，不换行 */</span><br><span class="hljs-attribute">flex-wrap</span>: wrap;    <span class="hljs-comment">/* 自动换行 */</span><br><span class="hljs-attribute">flex-wrap</span>: wrap-reverse;<br></code></pre></td></tr></table></figure><p>常见误区：</p><ul><li><strong>Flex 默认是单行布局</strong></li><li>多行布局必须显式开启 <code>wrap</code></li></ul><h3 id="4-flex-flow"><a href="#4-flex-flow" class="headerlink" title="4. flex-flow"></a>4. flex-flow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-flow</span>: row wrap;<br></code></pre></td></tr></table></figure><h3 id="5-justify-content（主轴对齐方式）"><a href="#5-justify-content（主轴对齐方式）" class="headerlink" title="5. justify-content（主轴对齐方式）"></a>5. justify-content（主轴对齐方式）</h3><p>控制 <strong>项目在主轴上的分布方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start;<br><span class="hljs-attribute">justify-content</span>: flex-end;<br><span class="hljs-attribute">justify-content</span>: center;<br><span class="hljs-attribute">justify-content</span>: space-between;<br><span class="hljs-attribute">justify-content</span>: space-around;<br><span class="hljs-attribute">justify-content</span>: space-evenly;<br></code></pre></td></tr></table></figure><p>核心理解：</p><ul><li>对齐的是 <strong>整体剩余空间</strong></li><li>不改变元素本身尺寸</li></ul><h3 id="6-align-items（交叉轴对齐，单行）"><a href="#6-align-items（交叉轴对齐，单行）" class="headerlink" title="6. align-items（交叉轴对齐，单行）"></a>6. align-items（交叉轴对齐，单行）</h3><p>控制 <strong>项目在交叉轴上的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-items</span>: stretch;    <span class="hljs-comment">/* 默认，拉伸 */</span><br><span class="hljs-attribute">align-items</span>: flex-start;<br><span class="hljs-attribute">align-items</span>: flex-end;<br><span class="hljs-attribute">align-items</span>: center;<br><span class="hljs-attribute">align-items</span>: baseline;<br></code></pre></td></tr></table></figure><p>常见用途：</p><ul><li>垂直居中（row 模式）</li><li>横向居中（column 模式）</li></ul><h3 id="7-align-content"><a href="#7-align-content" class="headerlink" title="7. align-content"></a>7. align-content</h3><p>只对 <strong>多行 flex</strong> 生效（必须 <code>wrap</code>）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">align-content</span>: flex-start;<br><span class="hljs-attribute">align-content</span>: flex-end;<br><span class="hljs-attribute">align-content</span>: center;<br><span class="hljs-attribute">align-content</span>: space-between;<br><span class="hljs-attribute">align-content</span>: space-around;<br><span class="hljs-attribute">align-content</span>: stretch;<br></code></pre></td></tr></table></figure><p>重要区分：</p><ul><li><code>align-items</code>：控制 <strong>每一行内的元素</strong></li><li><code>align-content</code>：控制 <strong>多行整体</strong></li></ul><h2 id="4-项目属性（控制单个元素行为）"><a href="#4-项目属性（控制单个元素行为）" class="headerlink" title="4. 项目属性（控制单个元素行为）"></a>4. 项目属性（控制单个元素行为）</h2><h3 id="1-order（排列顺序）"><a href="#1-order（排列顺序）" class="headerlink" title="1. order（排列顺序）"></a>1. order（排列顺序）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>默认值为 <code>0</code></li><li>数值越小，越靠前</li><li><strong>只影响视觉顺序，不影响 DOM 顺序</strong></li></ul><h3 id="2-flex-grow（放大比例）"><a href="#2-flex-grow（放大比例）" class="headerlink" title="2. flex-grow（放大比例）"></a>2. flex-grow（放大比例）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>含义：</p><ul><li>当容器有剩余空间时，按比例分配</li><li>默认值为 <code>0</code>（不参与扩展）</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.itemA</span> &#123; <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>; &#125;<br><span class="hljs-selector-class">.itemB</span> &#123; <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">2</span>; &#125;<br></code></pre></td></tr></table></figure><p>A:B &#x3D; 1:2</p><h3 id="3-flex-shrink（缩小比例）"><a href="#3-flex-shrink（缩小比例）" class="headerlink" title="3. flex-shrink（缩小比例）"></a>3. flex-shrink（缩小比例）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>含义：</p><ul><li>空间不足时，按比例压缩</li><li>默认值为 <code>1</code></li></ul><p>常见问题：</p><ul><li>子元素被压缩到小于内容宽度</li><li>可通过 <code>flex-shrink: 0</code> 禁止缩小</li></ul><h3 id="4-flex-basis（初始尺寸）"><a href="#4-flex-basis（初始尺寸）" class="headerlink" title="4. flex-basis（初始尺寸）"></a>4. flex-basis（初始尺寸）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>含义：</p><ul><li><strong>主轴方向上的初始尺寸</strong></li><li>优先级高于 <code>width / height</code></li></ul><p>规则优先级：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">max-width</span>/<span class="hljs-attribute">min-width</span><br>↓<br><span class="hljs-attribute">flex-basis</span><br>↓<br><span class="hljs-attribute">width</span> / <span class="hljs-attribute">height</span><br>↓<br><span class="hljs-attribute">content</span> size<br></code></pre></td></tr></table></figure><h3 id="5-flex"><a href="#5-flex" class="headerlink" title="5. flex"></a>5. flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;              <span class="hljs-comment">/* 1 1 0% */</span><br><span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">0</span> auto;<br><span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br></code></pre></td></tr></table></figure><p>工程常用写法：</p><ul><li><code>flex: 1</code>：自适应填满</li><li><code>flex: none</code>：等价于 <code>0 0 auto</code></li><li><code>flex: 0 0 100px</code>：固定尺寸</li></ul><h3 id="6-align-self（单个项目的交叉轴对齐）"><a href="#6-align-self（单个项目的交叉轴对齐）" class="headerlink" title="6. align-self（单个项目的交叉轴对齐）"></a>6. align-self（单个项目的交叉轴对齐）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">align-self</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>会覆盖 <code>align-items</code></p><h2 id="5-Flex-布局计算流程"><a href="#5-Flex-布局计算流程" class="headerlink" title="5. Flex 布局计算流程"></a>5. Flex 布局计算流程</h2><p>Flex 布局的核心步骤：</p><ol><li>确定主轴方向</li><li>计算每个 item 的 <strong>flex-basis</strong></li><li>计算剩余空间（或溢出空间）</li><li>根据 <code>flex-grow / flex-shrink</code> 分配空间</li><li>再执行 <code>justify-content / align-items</code></li></ol><p>理解这一流程，有助于排查：</p><ul><li>为什么元素被压缩</li><li>为什么宽度不生效</li><li>为什么居中失败</li></ul><h2 id="6-常见布局场景总结"><a href="#6-常见布局场景总结" class="headerlink" title="6. 常见布局场景总结"></a>6. 常见布局场景总结</h2><h3 id="1-水平-垂直居中"><a href="#1-水平-垂直居中" class="headerlink" title="1. 水平 + 垂直居中"></a>1. 水平 + 垂直居中</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-两栏布局（左固定，右自适应）"><a href="#2-两栏布局（左固定，右自适应）" class="headerlink" title="2. 两栏布局（左固定，右自适应）"></a>2. 两栏布局（左固定，右自适应）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Flex-常见坑与注意点"><a href="#7-Flex-常见坑与注意点" class="headerlink" title="7. Flex 常见坑与注意点"></a>7. Flex 常见坑与注意点</h2><ol><li><strong>flex 默认不换行</strong></li><li><code>align-content</code> 对单行无效</li><li><code>flex-basis</code> 会覆盖 <code>width</code></li><li><code>flex: 1</code> 等价于 <code>1 1 0%</code></li><li>子元素最小宽度可能来自内容（<code>min-width: auto</code>）</li><li>Flex 是一维布局，不适合复杂二维网格（用 Grid）</li></ol>]]></content>
    
    
    <categories>
      
      <category>HTMLCSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3进阶学习</title>
    <link href="/2026/01/09/Vue/Vue3%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2026/01/09/Vue/Vue3%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本文记录了Vue组件生命周期流程，Vue中的异步问题，以及this.$nextTick的使用。</p><span id="more"></span><h1 id="1-Vue-组件生命周期"><a href="#1-Vue-组件生命周期" class="headerlink" title="1.Vue 组件生命周期"></a>1.Vue 组件生命周期</h1><h2 id="Vue-组件生命周期流程"><a href="#Vue-组件生命周期流程" class="headerlink" title="Vue 组件生命周期流程"></a>Vue 组件生命周期流程</h2><p>Vue 组件的生命周期包括一系列的钩子函数，这些函数在组件的不同阶段被调用。了解这些生命周期钩子可以帮助你在合适的时机执行特定的操作。</p><img src="/2026/01/09/Vue/Vue3%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE1.png" class title="图1"><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><ol><li>**<code>beforeCreate()</code>**：当组件实例被创建之后，此时数据观测和事件配置都还未进行，例如<code>watch</code>事件此时也还未开始监听数据。此时 <code>data</code> 和 <code>methods</code> 尚不可用。</li><li>**<code>created()</code>**： 组件实例创建完成，数据观测和事件配置已经完成，此时 <code>data</code> 和 <code>methods</code> 可用。可以在这里进行数据初始化和 API 请求。如果<code>watch</code>监听事件使用了<code>immediate:true</code>属性，那么<code>handler</code>已经调用完成。</li></ol><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ol><li><strong><code>beforeMount()</code></strong>: 组件挂载之前调用，此时模板已编译完成，<code>render</code> 函数已被调用，Vue 已经生成了组件的虚拟 DOM，但实际的 DOM 元素还没有生成和被插入到页面中。</li><li><strong><code>mounted</code></strong>: 组件挂载完成，此时 真实DOM 已经被插入到页面中。可以在这里进行 DOM 操作、第三方库初始化等操作。</li></ol><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ol><li><strong><code>beforeUpdate</code></strong>: 数据发生变化后，DOM 更新之前调用。Vue 已经更新了组件的虚拟 DOM，可以在这里进行数据处理或保存当前状态。</li><li><strong><code>updated</code></strong>: DOM 更新完成后调用。可以在这里执行依赖于最新 DOM 状态的操作。</li></ol><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a><strong>销毁阶段</strong></h3><ol><li><strong><code>beforeDestroy</code></strong>: 组件销毁之前调用。可以在这里进行清理操作，如取消定时器、解绑事件监听等。</li><li><strong><code>destroyed</code></strong>: 组件销毁完成后调用。此时组件的所有子组件都已销毁，DOM 也被删除。</li></ol><p><strong>注意点：</strong></p><ul><li>创建阶段和销毁阶段是对应的。挂载和更新是类似的，挂载是在组件在创建的时候执行，因为需要将DOM插入到页面中，更新阶段只有新的DOM节点会插入的页面中，已有的DOM节点不会动。</li><li>渲染包括是指将组件的模板转化为实际的 DOM 元素。这个过程包括生成虚拟 DOM 和最终将其转换为真实的 DOM。因此渲染既存在挂载也存在更新阶段。<strong>渲染并不直接对应钩子函数</strong>。</li></ul><blockquote><p><a href="https://blog.csdn.net/m0_65335111/article/details/125610342">https://blog.csdn.net/m0_65335111/article/details/125610342</a></p></blockquote><h2 id="父组件与子组件的生命周期流程"><a href="#父组件与子组件的生命周期流程" class="headerlink" title="父组件与子组件的生命周期流程"></a>父组件与子组件的生命周期流程</h2><p>首先以下面代码为例。</p><p><font color="#0077b4">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;ChildComponent v-if=&quot;showComponent&quot; :newArr=&quot;arr&quot;&gt;&lt;/ChildComponent&gt;<br>    &lt;el-button @click=&quot;addData&quot;&gt;增加父组件数据&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;()=&gt;&#123;showComponent=!showComponent&#125;&quot;&gt;控制组件&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;()=&gt;&#123;arr.push(&#x27;newdata&#x27;)&#125;&quot;&gt;更改数组&lt;/el-button&gt;<br>    &#123;&#123; data &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>  data() &#123;<br>    return &#123;<br>      arr : [&quot;父组件初始数据&quot;],<br>      data : 0,<br>      showComponent : true,<br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    addData()&#123;<br>      this.data++;<br>    &#125;<br>  &#125;,<br>  beforeCreate()&#123;<br>    console.log(&quot;父组件beforeCreate方法调用&quot;);<br>  &#125;,<br>  created()&#123;<br>    console.log(&quot;父组件created方法调用&quot;);<br>  &#125;,<br>  beforeMount()&#123;<br>    console.log(&quot;父组件beforeMount方法调用&quot;);<br>  &#125;,<br>  mounted()&#123;<br>    console.log(&quot;父组件mounted方法调用&quot;);<br>  &#125;,<br>  beforeDestroy()&#123;<br>    console.log(&quot;父组件beforeDestroy方法调用&quot;);<br>  &#125;,<br>  destroyed()&#123;<br>    console.log(&quot;父组件destroyed方法调用&quot;);<br>  &#125;,<br>  beforeUpdate()&#123;<br>    console.log(&quot;父组件beforeUpdate方法调用&quot;);<br>  &#125;,<br>  updated()&#123;<br>    console.log(&quot;父组件updated方法调用&quot;);<br>  &#125;,<br>  deactivated()&#123;<br>    console.log(&quot;父组件deactivated方法调用&quot;);<br>  &#125;,<br>  activated()&#123;<br>    console.log(&quot;父组件activated方法调用&quot;);<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="#1677ff">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>    &lt;el-button @click=&quot;addData&quot;&gt;增加数据&lt;/el-button&gt;<br>    &#123;&#123; data &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props:&#123;<br>    newArr:&#123;<br>      type: Array,<br>      default: ()=&gt;[&quot;初始参数&quot;]<br>    &#125;<br>  &#125;,<br>  data()&#123;<br>    return&#123;<br>      arr:[&quot;子组件初始数据&quot;],<br>      data:0,<br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    addData()&#123;<br>      console.log(&quot;addData方法&quot;)<br>      this.data++;<br>    &#125;<br>  &#125;,<br>  watch:&#123;<br>    newArr()&#123;<br>      console.log(&quot;监听事件调用&quot;)<br>    &#125;<br>  &#125;,<br>  beforeCreate()&#123;<br>    console.log(&quot;子组件beforeCreate方法调用&quot;);<br>  &#125;,<br>  created()&#123;<br>    console.log(&quot;子组件created方法调用&quot;);<br>    console.log(this.arr)<br>    console.log(this.newArr)<br>    console.log(this.data)<br>  &#125;,<br>  beforeMount()&#123;<br>    console.log(&quot;子组件beforeMount方法调用&quot;);<br>  &#125;,<br>  mounted()&#123;<br>    console.log(&quot;子组件mounted方法调用&quot;);<br>  &#125;,<br>  beforeDestroy()&#123;<br>    console.log(&quot;子组件beforeDestroy方法调用&quot;);<br>  &#125;,<br>  destroyed()&#123;<br>    console.log(&quot;子组件destroyed方法调用&quot;);<br>  &#125;,<br>  beforeUpdate()&#123;<br>    console.log(&quot;子组件beforeUpdate方法调用&quot;);<br>  &#125;,<br>  updated()&#123;<br>    console.log(&quot;子组件updated方法调用&quot;);<br>  &#125;,<br>  deactivated()&#123;<br>    console.log(&quot;子组件deactivated方法调用&quot;);<br>  &#125;,<br>  activated()&#123;<br>    console.log(&quot;子组件activated方法调用&quot;);<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2026/01/09/Vue/Vue3%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE2.png" class title="图2"><p><strong>组件创建的生命周期如下：</strong></p><p>父组件<code>beforeCreate</code>——&gt;（父组件数据和事件开始初始化）——&gt; 父组件<code>created</code>——&gt;（此时父组件数据和事件都初始化完成，data数据已经准备好，虚拟DOM开始创建）——&gt; 父组件<code>beforeMount</code>——&gt;（虚拟DOM已经创建，页面渲染开始，真实DOM创建并开始挂载到页面，直到渲染到子组件DOM）——&gt; 子组件<code>beforeCreate</code>——&gt;（子组件数据和事件开始初始化，包括传递的参数props，初始化的数据watch还没有开始监听）——&gt; 子组件<code>created</code>——&gt;（此时子组件数据初始化完成，watch已经开始监听，虚拟DOM开始创建）——&gt; 子组件<code>beforeMount</code>——&gt;（虚拟DOM已经创建，页面渲染开始，真实DOM创建并开始挂载到页面）——&gt; 子组件<code>mounted</code>——&gt; （子组件挂载完成，返回到父组件继续渲染）——&gt; 父组件<code>mounted</code>——&gt;（父组件挂载完成）</p><p><font color="#1677ff">注意点：</font></p><ul><li>销毁周期和创建周期是相同的。组件的创建生命周期是深度优先遍历的顺序，如果子组件还有子组件，会先创建最深层的子组件。</li></ul><img src="/2026/01/09/Vue/Vue3%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE3.png" class title="图3"><p><font color="#1677ff">注意点：</font></p><ul><li><code>beforeUpdate</code>和<code>updated</code>生命周期钩子的执行时间和<code>beforeMounte</code>和<code>mounted</code>是类似的。因此上述流程很好理解了。 </li><li><code>beforeUpdate</code>和<code>updated</code>生命周期钩子<font color="#1677ff">只在页面需要重写渲染的时候才会执行，而与数据变化无关</font>，如果数据改变但不影响页面，页面无需更新，则不会重写渲染。</li></ul><blockquote><p>与路由相关的两个是 <code>activeted</code> 和 <code>deactivated</code> 配合 <code>keep-alive</code>，用于组件缓存不销毁时候使用。</p></blockquote><h2 id="异步问题对生命周期的影响"><a href="#异步问题对生命周期的影响" class="headerlink" title="异步问题对生命周期的影响"></a>异步问题对生命周期的影响</h2><p>在 Vue.js 中，生命周期钩子函数本身是<strong>同步的</strong>，即它们按照特定的顺序执行，并在生命周期的特定阶段被调用。然而，生命周期钩子函数中可以包含异步操作，如数据请求、定时器等。以下是有关生命周期钩子函数的详细信息：</p><p>生命周期钩子的同步行为:</p><ul><li><strong>同步执行</strong>：生命周期钩子函数（如 <code>created</code>、<code>mounted</code>、<code>updated</code> 等）是同步执行的，即它们会按照定义的顺序被调用，并在生命周期的特定阶段完成执行。</li><li><strong>顺序调用</strong>：Vue.js 会在组件生命周期的不同阶段调用这些钩子函数，从组件实例的创建、挂载到更新和销毁，每个钩子函数都有特定的调用时机。</li></ul><p><font color="#1677ff">尽管生命周期钩子函数本身是同步的，但可以在这些钩子函数中执行异步操作。这些异步操作不会影响钩子函数的同步执行，但可能会影响组件的状态和视图更新。</font></p><h3 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick()"></a><code>this.$nextTick()</code></h3><p>当你更新一个响应式数据，Vue 不会立即同步更新 DOM。相反，Vue 会等到事件循环的下一个 “tick” 才执行这些更新，以进行批量处理和优化。<code>this.$nextTick()</code> 的作用就是在这个更新完成之后，执行你指定的回调函数。<font color="#1677ff">使用 <code>this.$nextTick()</code> 的关键是确保在需要等待 Vue 更新 DOM 后再执行的场景下使用</font></p><p><strong>异步执行</strong>：<code>this.$nextTick()</code> 的回调函数是异步执行的，因此它不会阻塞主线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p ref=&quot;paragraph&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;updateMessage&quot;&gt;Update Message&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      message: &quot;Hello, Vue!&quot;<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    updateMessage() &#123;<br>      this.message = &quot;Hello, World!&quot;;<br>      this.$nextTick(() =&gt; &#123;<br>        console.log(this.$refs.paragraph.offsetHeight); // 获取的是更新后的 DOM 高度<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>/* 样式 */<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>上述例子如果没有<code>this.$nextTick()</code>，当点击按钮后，<code>this.message</code> 更新为 “Hello, World!”，但是 <code>console.log(this.$refs.paragraph.offsetHeight);</code> 可能获取的是更新前的 <code>p</code> 元素的高度，因为此时 DOM 还未更新。</p><p>虽然没有使用 <code>this.$nextTick()</code>，Vue 仍会更新 DOM，但是在数据更新后立即访问 DOM 时，可能会获取到更新前的状态。使用 <code>this.$nextTick()</code> 能够确保你的操作在 DOM 更新后执行，获取到最新的 DOM 状态，从而保证操作的准确性和一致性。</p><h2 id="Vue2-3-生命周期钩子对照表"><a href="#Vue2-3-生命周期钩子对照表" class="headerlink" title="Vue2&#x2F;3 生命周期钩子对照表"></a>Vue2&#x2F;3 生命周期钩子对照表</h2><h3 id="1️⃣-创建阶段（Creation）"><a href="#1️⃣-创建阶段（Creation）" class="headerlink" title="1️⃣ 创建阶段（Creation）"></a>1️⃣ 创建阶段（Creation）</h3><table><thead><tr><th>阶段含义</th><th>Vue2</th><th>Vue3（Options API）</th><th>Vue3（Composition API）</th></tr></thead><tbody><tr><td>实例创建前</td><td><code>beforeCreate</code></td><td><code>beforeCreate</code></td><td>❌ 无</td></tr><tr><td>实例创建完成</td><td><code>created</code></td><td><code>created</code></td><td>❌ 无</td></tr></tbody></table><p><strong>关键点</strong></p><ul><li><code>beforeCreate / created</code> <strong>在 Composition API 中被“setup 取代”</strong></li><li><code>setup()</code> ≈ <code>beforeCreate + created</code></li><li>在 <code>setup()</code> 中：<ul><li><strong>能访问 props</strong></li><li><strong>不能访问 this</strong></li><li><strong>响应式系统已建立</strong></li></ul></li></ul><hr><h3 id="2️⃣-挂载阶段（Mount）"><a href="#2️⃣-挂载阶段（Mount）" class="headerlink" title="2️⃣ 挂载阶段（Mount）"></a>2️⃣ 挂载阶段（Mount）</h3><table><thead><tr><th>阶段含义</th><th>Vue2</th><th>Vue3（Options API）</th><th>Vue3（Composition API）</th></tr></thead><tbody><tr><td>挂载前</td><td><code>beforeMount</code></td><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td></tr><tr><td>挂载完成</td><td><code>mounted</code></td><td><code>mounted</code></td><td><code>onMounted</code></td></tr></tbody></table><p><strong>关键点</strong></p><ul><li><code>mounted / onMounted</code> 是：<ul><li><strong>DOM 已经真实存在</strong></li><li>第三方库初始化（ECharts &#x2F; Map &#x2F; DOM 操作）的<strong>唯一安全位置</strong></li></ul></li></ul><hr><h3 id="3️⃣-更新阶段（Update）"><a href="#3️⃣-更新阶段（Update）" class="headerlink" title="3️⃣ 更新阶段（Update）"></a>3️⃣ 更新阶段（Update）</h3><table><thead><tr><th>阶段含义</th><th>Vue2</th><th>Vue3（Options API）</th><th>Vue3（Composition API）</th></tr></thead><tbody><tr><td>DOM 更新前</td><td><code>beforeUpdate</code></td><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td></tr><tr><td>DOM 更新后</td><td><code>updated</code></td><td><code>updated</code></td><td><code>onUpdated</code></td></tr></tbody></table><p><strong>关键点</strong></p><ul><li>更新阶段可能触发 <strong>多次</strong></li><li><code>updated</code> <strong>不要修改会再次触发更新的状态</strong>（否则死循环）</li></ul><hr><h3 id="4️⃣-销毁-卸载阶段（Unmount）"><a href="#4️⃣-销毁-卸载阶段（Unmount）" class="headerlink" title="4️⃣ 销毁 &#x2F; 卸载阶段（Unmount）"></a>4️⃣ 销毁 &#x2F; 卸载阶段（Unmount）</h3><table><thead><tr><th>阶段含义</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>卸载前</td><td><code>beforeDestroy</code></td><td><code>beforeUnmount</code> &#x2F; <code>onBeforeUnmount</code></td></tr><tr><td>卸载完成</td><td><code>destroyed</code></td><td><code>unmounted</code> &#x2F; <code>onUnmounted</code></td></tr></tbody></table><p><strong>关键点</strong></p><ul><li>Vue3 用 <strong>Unmount</strong> 代替 Destroy（语义更贴近真实 DOM）</li><li>清理逻辑：<ul><li>定时器</li><li>事件监听</li><li>WebSocket</li><li>地图 &#x2F; 图表实例</li></ul></li></ul><h3 id="Vue3-中-setup-与生命周期的关系："><a href="#Vue3-中-setup-与生命周期的关系：" class="headerlink" title="Vue3 中 setup() 与生命周期的关系："></a>Vue3 中 <code>setup()</code> 与生命周期的关系：</h3><blockquote><p><strong><code>setup()</code> 本身就是 Vue3 的“创建阶段”</strong></p></blockquote><p>对应关系：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">Vue2:<br><span class="hljs-function"><span class="hljs-title">beforeCreate</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">created</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">beforeMount</span> -&gt;</span> mounted<br><br>Vue3:<br><span class="hljs-function"><span class="hljs-title">setup</span>() -&gt;</span> <span class="hljs-function"><span class="hljs-title">onBeforeMount</span> -&gt;</span> onMounted<br></code></pre></td></tr></table></figure><p>示例（Vue3）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; onMounted, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 相当于 beforeCreate + created</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setup&#x27;</span>)<br><br>    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM ready&#x27;</span>)<br>    &#125;)<br><br>    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cleanup&#x27;</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>生命周期的<strong>阶段和语义保持一致</strong>，但 Vue3：</p><ol><li>用 <code>setup()</code> 替代了 <code>beforeCreate / created</code></li><li>用 <code>onXxx</code> 组合式 API 替代选项式钩子</li><li>将 <code>destroy</code> 改为 <code>unmount</code>，语义更清晰</li></ol></blockquote><h1 id="2-Vue的响应式原理"><a href="#2-Vue的响应式原理" class="headerlink" title="2. Vue的响应式原理"></a>2. Vue的响应式原理</h1><blockquote><p><a href="..%5C%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%5C5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md">链接</a></p></blockquote><h1 id="3-Vue的模板解析过程"><a href="#3-Vue的模板解析过程" class="headerlink" title="3. Vue的模板解析过程"></a>3. Vue的模板解析过程</h1><p>Vue 的核心目标是：<strong>当数据变化时，让视图以尽可能小的代价更新</strong>。<br> 它靠两套系统配合完成：</p><ul><li><strong>响应式系统</strong>：决定“什么时候需要更新”（数据变了，谁受影响）</li><li><strong>渲染系统（VDOM + Diff + Patch）</strong>：决定“怎么更新更省”（只改动必要 DOM）</li></ul><p><strong>一条更新链路（你要记住的主线）</strong></p><ol><li><strong>Template 编译</strong>：<code>template</code> &#x2F; <code>render</code> → 生成 <code>render()</code> 函数（Vue2 还会生成静态渲染函数数组）</li><li><strong>首次渲染</strong>：执行 <code>render()</code> → 产出 <strong>VNode 树</strong>（虚拟 DOM）</li><li><strong>Patch 挂载</strong>：<code>patch(oldVnode, vnode)</code> → 把 VNode 变成真实 DOM 并插入页面</li><li><strong>依赖收集</strong>：渲染时读取响应式数据 → 触发 getter → 收集依赖（把“谁用过我”记录下来）</li><li><strong>更新触发</strong>：数据变化 → setter 通知依赖 → watcher 入队 → nextTick 统一刷新</li><li><strong>Diff + Patch</strong>：新旧 VNode 对比（Diff）→ 只把最小差异同步到真实 DOM</li></ol><h2 id="1-从-template-到-render？"><a href="#1-从-template-到-render？" class="headerlink" title="1. 从 template 到 render？"></a>1. 从 template 到 render？</h2><h3 id="1-1-为什么要编译？"><a href="#1-1-为什么要编译？" class="headerlink" title="1.1 为什么要编译？"></a>1.1 为什么要编译？</h3><p>浏览器看得懂的是 HTML、CSS、JS，但 Vue 的模板里有：</p><ul><li>插值：<code>&#123;&#123; msg &#125;&#125;</code></li><li>指令：<code>v-if / v-for / v-model</code></li><li>事件：<code>@click=&quot;fn&quot;</code></li><li>动态绑定：<code>:class=&quot;...&quot;</code></li></ul><p>这些都不是原生 HTML 能直接执行的，所以 Vue 需要把模板<strong>编译成 JavaScript 函数</strong>，渲染时执行这个函数得到“页面结构描述”。</p><p>最终产物就是：<strong>render 函数</strong>。</p><hr><h3 id="1-2-编译的-3-步：Parse-→-Optimize（Vue2）→-Generate"><a href="#1-2-编译的-3-步：Parse-→-Optimize（Vue2）→-Generate" class="headerlink" title="1.2 编译的 3 步：Parse → Optimize（Vue2）→ Generate"></a>1.2 编译的 3 步：Parse → Optimize（Vue2）→ Generate</h3><p>以 Vue2 典型的编译流程为例：</p><h4 id="1-Parse：模板-→-AST"><a href="#1-Parse：模板-→-AST" class="headerlink" title="(1) Parse：模板 → AST"></a>(1) Parse：模板 → AST</h4><p>Vue 会把模板解析成一棵 <strong>AST（抽象语法树）</strong>。</p><p>模板：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>AST 的直观结构类似：</p><ul><li>div (attrs: id&#x3D;app)<ul><li>p<ul><li>text( expression: msg )</li></ul></li></ul></li></ul><p>你可以把 AST 理解为：<strong>“结构化的模板”</strong>，后续所有分析与生成都基于它。</p><h4 id="2-Optimize（Vue2-典型）：标记静态节点"><a href="#2-Optimize（Vue2-典型）：标记静态节点" class="headerlink" title="(2) Optimize（Vue2 典型）：标记静态节点"></a>(2) Optimize（Vue2 典型）：标记静态节点</h4><p>Vue2 会标记哪些节点是<strong>静态的</strong>（不依赖响应式数据），例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>固定文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 静态 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- 动态 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>静态节点的好处：更新时不需要重新创建&#x2F;对比这些部分。</p><blockquote><p>Vue3 的思路更进一步：不仅标静态，还会在编译期给动态点打“更新标记”（后面讲）。</p></blockquote><h4 id="3-Generate：AST-→-render-代码"><a href="#3-Generate：AST-→-render-代码" class="headerlink" title="(3) Generate：AST → render 代码"></a>(3) Generate：AST → render 代码</h4><p>Vue 会把 AST 生成一段 JS 代码字符串，再变成真正的函数。</p><p>简化理解即可：<strong>模板最终会变成一堆“创建虚拟节点”的调用</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-Router知识进阶</title>
    <link href="/2026/01/08/Vue/Vue-Router%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6/"/>
    <url>/2026/01/08/Vue/Vue-Router%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Vue-Router-快速上手"><a href="#1-Vue-Router-快速上手" class="headerlink" title="1. Vue Router 快速上手"></a>1. <code>Vue Router</code> 快速上手</h2><p><a href="https://cxdlogver.github.io/2025/12/17/Vue/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#4-%E8%B7%AF%E7%94%B1">Vue Router快速上手 - 相</a></p><h2 id="2-路由守卫"><a href="#2-路由守卫" class="headerlink" title="2. 路由守卫"></a>2. 路由守卫</h2><p>1）全局：<code>beforeEach / beforeResolve / afterEach</code></p><p>2）路由独享：<code>beforeEnter</code></p><p>3）组件内：<code>beforeRouteEnter / beforeRouteUpdate(onBeforeRouteUpdate) / beforeRouteLeave(onBeforeRouteLeave)</code></p><h3 id="【beforeEach】"><a href="#【beforeEach】" class="headerlink" title="【beforeEach】"></a>【<code>beforeEach</code>】</h3><p>作用：全局前置守卫。每次路由跳转前触发，适合做“进入前拦截”。</p><p>触发时机：导航被确认前，组件解析&#x2F;渲染之前。任何路由变化（push&#x2F;replace&#x2F;回退前进）都会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// router.ts</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./routes&quot;</span>;<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  routes,<br>&#125;);<br><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-title function_">async</span> (to, <span class="hljs-keyword">from</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 1) 鉴权：未登录 -&gt; 跳登录页</span><br>  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span> &amp;&amp; !token) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Login&quot;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">redirect</span>: to.<span class="hljs-property">fullPath</span> &#125; &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 2) 已登录访问登录页 -&gt; 跳首页</span><br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">name</span> === <span class="hljs-string">&quot;Login&quot;</span> &amp;&amp; token) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Home&quot;</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 3) 权限：无角色/无权限 -&gt; 403</span><br>  <span class="hljs-keyword">const</span> role = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;role&quot;</span>);<br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">roles</span> &amp;&amp; !to.<span class="hljs-property">meta</span>.<span class="hljs-property">roles</span>.<span class="hljs-title function_">includes</span>(role)) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Forbidden&quot;</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 4) 异步：拉取用户信息后再放行</span><br>  <span class="hljs-comment">// if (!store.userLoaded) await store.fetchMe()</span><br><br>  <span class="hljs-comment">// 放行：return true 或不写 return</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p>关键点</p><ul><li>返回值控制导航：<ul><li><code>return false</code> 取消导航</li><li><code>return &#123; path/name/query &#125;</code> 重定向</li><li><code>return true</code> 或不返回 放行</li></ul></li><li>必须避免死循环：重定向目标不要再触发同一条拦截逻辑导致反复跳转</li><li>复杂条件建议用 <code>to.meta</code> 驱动（如 <code>requiresAuth</code>、<code>roles</code>）</li><li>做全局 Loading&#x2F;NProgress 更合适（跳转开始就开启）</li></ul><p><strong>典型使用场景</strong></p><ul><li>登录态校验、登录页重定向</li><li>RBAC&#x2F;ABAC 权限控制（角色、权限点、资源范围）</li><li>白名单路由、灰度路由、维护模式拦截</li><li>动态路由注入前置检查（首次进入系统拉取菜单并 addRoute）</li><li>路由级数据预取的兜底（不建议把大量业务请求都塞进这里，容易拖慢首屏）</li></ul><blockquote><p>Vue Router3 需要用<code>next()</code>放行</p></blockquote><table><thead><tr><th>Vue Router 3</th><th>Vue Router 4</th></tr></thead><tbody><tr><td><code>next()</code></td><td><code>return true</code> 或 <code>return</code></td></tr><tr><td><code>next(false)</code></td><td><code>return false</code></td></tr><tr><td><code>next(&#39;/login&#39;)</code></td><td><code>return &#39;/login&#39;</code></td></tr><tr><td><code>next(&#123; name: &#39;Login&#39; &#125;)</code></td><td><code>return &#123; name: &#39;Login&#39; &#125;</code></td></tr><tr><td><code>next(error)</code></td><td><code>throw error</code></td></tr></tbody></table><h3 id="【afterEach】"><a href="#【afterEach】" class="headerlink" title="【afterEach】"></a>【<code>afterEach</code>】</h3><p>作用：全局后置守卫。路由跳转完成后触发，不可拦截导航，适合做“事后收尾”。</p><p>触发时机：导航确认完成、URL 已变更后触发。无返回值控制能力。</p><p>使用方法（Vue Router 4）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, failure</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 1) 设置页面标题</span><br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>) <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-title class_">String</span>(to.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>);<br><br>  <span class="hljs-comment">// 2) 关闭全局 Loading/NProgress</span><br>  <span class="hljs-comment">// NProgress.done()</span><br><br>  <span class="hljs-comment">// 3) 埋点统计（PV、路由来源）</span><br>  <span class="hljs-comment">// trackPageView(&#123; to: to.fullPath, from: from.fullPath, failure: !!failure &#125;)</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>关键点</p><ul><li>不能阻止跳转；如果要拦截必须用 <code>beforeEach</code>&#x2F;路由独享守卫</li><li><code>failure</code> 可用于判断是否发生导航失败（例如重复导航、取消等），做日志更稳</li><li>不要在这里做重定向或写会引发再次导航的逻辑，容易造成不可控链路</li></ul><p><strong>典型使用场景</strong></p><ul><li>统一设置 <code>document.title</code>、面包屑同步、滚动行为补充</li><li>关闭全局 Loading、结束进度条</li><li>路由埋点、性能统计、导航日志记录</li><li>清理临时状态（如关闭全局弹窗、收起侧边栏等“跳转后收尾”）</li></ul><h3 id="【beforeResolve】"><a href="#【beforeResolve】" class="headerlink" title="【beforeResolve】"></a>【<code>beforeResolve</code>】</h3><p>作用：全局解析守卫。与 <code>beforeEach</code> 类似，但触发更靠后，适合做“依赖组件已解析后的最后一道拦截”。</p><p>触发时机：在所有组件内守卫、路由独享守卫都通过后，组件也已解析完成，但导航还没最终确认之前触发。</p><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeResolve</span>(<span class="hljs-title function_">async</span> (to, <span class="hljs-keyword">from</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 适合做：进入页面前必须完成的“最后预取”</span><br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">prefetch</span>) &#123;<br>    <span class="hljs-keyword">await</span> to.<span class="hljs-property">meta</span>.<span class="hljs-title function_">prefetch</span>(); <span class="hljs-comment">// 例如拉取页面关键数据</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用场景</p><ul><li>页面进入前的“最终数据预取&#x2F;兜底加载”（确保组件可用后再请求关键数据）</li><li>配合进度条：在这里更精确地做“即将完成导航”的阶段控制</li><li>复杂跳转链路的最后一次统一校验（例如依赖动态路由已注入完成）</li></ul><h3 id="【onBeforeRouteLeave】"><a href="#【onBeforeRouteLeave】" class="headerlink" title="【onBeforeRouteLeave】"></a>【<code>onBeforeRouteLeave</code>】</h3><p>作用：离开当前组件对应路由时触发，常用于“未保存内容拦截离开”。</p><p>触发时机：从当前路由离开前，组件仍在。</p><p>使用方法（Composition API）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; onBeforeRouteLeave &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-title function_">onBeforeRouteLeave</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (hasUnsaved.<span class="hljs-property">value</span>) &#123;<br>    <span class="hljs-comment">// 可配合弹窗：确认后再放行（通过状态控制二次跳转）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用场景</p><ul><li>表单未保存提示</li><li>离开页面前清理资源（WS&#x2F;定时器&#x2F;地图实例），其中“拦截”用守卫，“释放”也可在 unmount 做兜底</li></ul><h3 id="【onBeforeRouteUpdate】"><a href="#【onBeforeRouteUpdate】" class="headerlink" title="【onBeforeRouteUpdate】"></a>【<code>onBeforeRouteUpdate</code>】</h3><p>作用:同一组件复用时（路由参数变了但仍复用组件）触发，用于处理 params&#x2F;query 变化带来的数据刷新。</p><p>触发时机:当前组件未卸载，路由更新（如 <code>/user/1</code> -&gt; <code>/user/2</code>）。</p><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; onBeforeRouteUpdate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-title function_">onBeforeRouteUpdate</span>(<span class="hljs-title function_">async</span> (to, <span class="hljs-keyword">from</span>) =&gt; &#123;<br>  <span class="hljs-comment">// 例如：to.params.id 变化后重新拉数据</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchDetail</span>(<span class="hljs-title class_">String</span>(to.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用场景</p><ul><li>详情页复用组件：根据 id 刷新数据</li><li>列表页 query 变更：分页、筛选条件变化触发重新请求</li><li>避免 watch(route) 写得过散，把“路由驱动更新”集中到守卫里</li></ul><h3 id="【beforeEnter】"><a href="#【beforeEnter】" class="headerlink" title="【beforeEnter】"></a>【<code>beforeEnter</code>】</h3><p>作用:写在某条路由配置上，只对该路由及其进入行为生效，比全局守卫更“精确”。</p><p>触发时机:进入该路由记录前触发（通常在全局 beforeEach 之后、组件内守卫之前的链路中）。</p><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/admin&quot;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./Admin.vue&quot;</span>),<br>  <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>] &#125;,<br>  <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> role = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;role&quot;</span>);<br>    <span class="hljs-keyword">if</span> (role !== <span class="hljs-string">&quot;admin&quot;</span>) <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Forbidden&quot;</span> &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>使用场景</p><ul><li>某一组路由的权限控制（后台区、运营区）</li><li>进入某页面前必须满足条件（必须带 query、必须来自特定来源页）</li><li>“仅对部分路由生效”的拦截：比全局守卫写 if 更清晰</li><li>首次进入子路由也会触发。</li></ul><blockquote><p>beforeEnter对路由的子路由也拦截吗?</p></blockquote><p><code>beforeEnter</code> 只在“该路由记录是新进入的”时触发</p><h3 id="【matched】"><a href="#【matched】" class="headerlink" title="【matched】"></a>【<code>matched</code>】</h3><p><code>route.matched</code> 表示：<br> <strong>从根路由开始，到当前路由为止，逐级命中的所有路由记录（父 → 子）</strong></p><p><strong>每次导航都会生成一个新的 matched 结果</strong></p><p>示例路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/demo&quot;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-title class_">DemoLayout</span>,<br>  <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">DemoA</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">DemoB</span> &#125;,<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><p>访问 <code>/demo/a</code> 时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useRoute</span>().<span class="hljs-property">matched</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">path</span>);<br><span class="hljs-comment">// [&quot;/demo&quot;, &quot;/demo/a&quot;]</span><br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>父路由 <code>/demo</code> <strong>一定在 matched 中</strong></li><li>子路由 <code>/demo/a</code> 紧随其后</li></ul><blockquote><p>但——<strong>进入 <code>matched</code> ≠ 触发父路由的 <code>beforeEnter</code></strong></p></blockquote><p>场景 1：首次进入子路由（会触发）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/login  →  /demo/a<br></code></pre></td></tr></table></figure><p>matched 变化：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">from:</span> []<br><span class="hljs-symbol">to:</span>   [ /demo, <span class="hljs-keyword">/demo/</span>a ]<br></code></pre></td></tr></table></figure><ul><li><code>/demo</code> 是新进入的</li><li><code>/demo.beforeEnter</code> 触发一次</li><li><code>/demo/a.beforeEnter</code> 触发（如果有）</li></ul><hr><p>场景 2：子路由之间切换（不会触发）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/demo/</span>a  →  <span class="hljs-regexp">/demo/</span>b<br></code></pre></td></tr></table></figure><p>matched 变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">from</span>: [ <span class="hljs-regexp">/demo, /</span>demo/a ]<br><span class="hljs-attr">to</span>:   [ <span class="hljs-regexp">/demo, /</span>demo/b ] <span class="hljs-comment">// 每次导航都会生成一个新的 matched 结果</span><br></code></pre></td></tr></table></figure><p>对比：</p><ul><li><code>/demo</code> 之前就在 matched 中</li><li>不是“新进入”</li><li><strong>父路由的 <code>beforeEnter</code> 不会再触发</strong></li></ul><h3 id="【没有onBeforeRouteEnter】"><a href="#【没有onBeforeRouteEnter】" class="headerlink" title="【没有onBeforeRouteEnter】"></a>【没有<code>onBeforeRouteEnter</code>】</h3><ul><li><strong>Vue Router 4 仍然有 <code>beforeRouteEnter</code></strong></li><li><strong>但没有 <code>onBeforeRouteEnter</code></strong></li><li>它是<strong>唯一一个拿不到组件实例的组件内守卫</strong></li><li>只能通过 <code>next(vm =&gt; &#123;&#125;)</code> 的“回调形式”访问组件实例</li></ul><p>这是一个<strong>历史兼容 + 语义上无法用 Composition API 封装</strong>的特例。</p><p>先对比一下：</p><table><thead><tr><th>守卫</th><th>是否存在 <code>onXxx</code></th></tr></thead><tbody><tr><td>beforeRouteLeave</td><td><code>onBeforeRouteLeave</code></td></tr><tr><td>beforeRouteUpdate</td><td><code>onBeforeRouteUpdate</code></td></tr><tr><td>beforeRouteEnter</td><td><strong>没有 <code>onBeforeRouteEnter</code></strong></td></tr></tbody></table><p><strong>根本原因：</strong></p><blockquote><p><code>beforeRouteEnter</code> 触发时，组件实例还不存在，Composition API 的 <code>setup()</code> 尚未执行，所以无法提供 <code>onBeforeRouteEnter</code></p></blockquote><hr><p>beforeRouteEnter&#96; 的真实定位</p><p>作用</p><p>在<strong>进入组件之前</strong>执行逻辑，并且<strong>可以在组件创建完成后访问组件实例</strong></p><p>触发时机</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">路由确认前<br>↓<br>beforeRouteEnter<br>↓<br>创建组件实例<br>↓<br>执行 <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;&#125;)<br>↓<br>mounted<br></code></pre></td></tr></table></figure><p>只能写在组件中（选项式 API）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-function">(<span class="hljs-params">vm</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// vm 是组件实例</span><br>      vm.<span class="hljs-title function_">loadData</span>();<br>    &#125;);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>这里仍然使用 <code>next</code></strong></li><li>这是 Vue Router 4 中 <strong>唯一保留 <code>next</code> 的地方</strong></li><li><code>return</code> 在这里<strong>不适用</strong></li></ul><p>为什么这里不能用 <code>return</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) &#123;<br>  <span class="hljs-comment">// 错误：此时没有组件实例</span><br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><ul><li>守卫执行时组件还没创建</li><li><code>this === undefined</code></li><li><code>setup()</code> 也还没执行</li><li>所以只能通过 <code>next(vm =&gt; &#123;&#125;)</code> 延迟访问实例</li></ul><h3 id="【生命周期】"><a href="#【生命周期】" class="headerlink" title="【生命周期】"></a>【生命周期】</h3><h4 id="一、导航开始阶段（Router-层）"><a href="#一、导航开始阶段（Router-层）" class="headerlink" title="一、导航开始阶段（Router 层）"></a>一、导航开始阶段（Router 层）</h4><h5 id="1-触发导航"><a href="#1-触发导航" class="headerlink" title="1. 触发导航"></a>1. 触发导航</h5><p>触发方式包括：</p><ul><li><code>router.push / replace</code></li><li><code>&lt;router-link&gt;</code></li><li>浏览器前进 &#x2F; 后退</li><li>地址栏直接输入</li></ul><p>此时：</p><ul><li>仅是“意图导航”</li><li>页面尚未发生任何变化</li></ul><hr><h5 id="2-路由匹配（resolve）"><a href="#2-路由匹配（resolve）" class="headerlink" title="2. 路由匹配（resolve）"></a>2. 路由匹配（resolve）</h5><p>Router 根据目标 URL：</p><ul><li>解析 path &#x2F; params &#x2F; query</li><li>生成目标路由对象 <code>to</code></li><li>计算 <code>to.matched</code>（父 → 子的路由记录链）</li></ul><hr><h4 id="二、导航守卫阶段（核心）"><a href="#二、导航守卫阶段（核心）" class="headerlink" title="二、导航守卫阶段（核心）"></a>二、导航守卫阶段（核心）</h4><h5 id="3-执行组件离开守卫（leaving）"><a href="#3-执行组件离开守卫（leaving）" class="headerlink" title="3. 执行组件离开守卫（leaving）"></a>3. 执行组件离开守卫（leaving）</h5><p>对 <strong>即将被卸载的组件</strong> 执行：</p><ul><li><code>onBeforeRouteLeave</code></li><li><code>beforeRouteLeave</code>（选项式）</li></ul><p>用途：</p><ul><li>未保存内容拦截</li><li>资源释放确认</li></ul><p>若返回 <code>false</code>：</p><ul><li>导航直接中断</li></ul><hr><h5 id="4-执行全局前置守卫"><a href="#4-执行全局前置守卫" class="headerlink" title="4. 执行全局前置守卫"></a>4. 执行全局前置守卫</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">router.beforeEach(<span class="hljs-keyword">to</span>, <span class="hljs-keyword">from</span>)<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>每次导航必走</li><li>适合鉴权、白名单、动态路由注入</li><li>可 return 控制导航</li></ul><hr><h5 id="5-执行路由独享守卫（beforeEnter）"><a href="#5-执行路由独享守卫（beforeEnter）" class="headerlink" title="5. 执行路由独享守卫（beforeEnter）"></a>5. 执行路由独享守卫（beforeEnter）</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  <span class="hljs-selector-tag">path</span>: <span class="hljs-string">&#x27;/demo&#x27;</span>,<br>  beforeEnter: ...<br>&#125;<br></code></pre></td></tr></table></figure><p>触发规则：</p><ul><li>仅对 <strong>新进入 matched 的路由记录</strong> 触发</li><li>父路由已在 matched 中时不会重复触发</li></ul><hr><h5 id="6-执行组件进入守卫（beforeRouteEnter）"><a href="#6-执行组件进入守卫（beforeRouteEnter）" class="headerlink" title="6. 执行组件进入守卫（beforeRouteEnter）"></a>6. 执行组件进入守卫（beforeRouteEnter）</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span><span class="hljs-params">(to, from, next)</span></span><br></code></pre></td></tr></table></figure><p>关键特性：</p><ul><li><strong>此时组件实例尚未创建</strong></li><li>拿不到 <code>this</code></li><li>可通过 <code>next(vm =&gt; &#123;&#125;)</code> 延迟访问实例</li></ul><p>这是唯一仍使用 <code>next</code> 的守卫。</p><hr><h5 id="7-执行组件更新守卫（复用组件）"><a href="#7-执行组件更新守卫（复用组件）" class="headerlink" title="7. 执行组件更新守卫（复用组件）"></a>7. 执行组件更新守卫（复用组件）</h5><p>当组件被复用（如 <code>/user/1 → /user/2</code>）：</p><ul><li><code>onBeforeRouteUpdate</code></li><li><code>beforeRouteUpdate</code></li></ul><p>用途：</p><ul><li>响应 params &#x2F; query 变化</li><li>刷新数据而不重建组件</li></ul><hr><h5 id="8-执行全局解析守卫"><a href="#8-执行全局解析守卫" class="headerlink" title="8. 执行全局解析守卫"></a>8. 执行全局解析守卫</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">router.beforeResolve(<span class="hljs-keyword">to</span>, <span class="hljs-keyword">from</span>)<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>所有守卫中 <strong>最靠后</strong></li><li>组件已解析但未挂载</li><li>适合做“最后一道校验 &#x2F; 关键数据兜底预取”</li></ul><hr><h4 id="三、组件创建与渲染阶段（Vue-层）"><a href="#三、组件创建与渲染阶段（Vue-层）" class="headerlink" title="三、组件创建与渲染阶段（Vue 层）"></a>三、组件创建与渲染阶段（Vue 层）</h4><h5 id="9-创建组件实例（vm）"><a href="#9-创建组件实例（vm）" class="headerlink" title="9. 创建组件实例（vm）"></a>9. 创建组件实例（vm）</h5><p>Vue 开始创建新组件实例：</p><ul><li>初始化 props、inject、生命周期容器</li><li>实例存在，但逻辑尚未运行</li></ul><hr><h5 id="10-执行-setup"><a href="#10-执行-setup" class="headerlink" title="10. 执行 setup()"></a>10. 执行 <code>setup()</code></h5><ul><li>建立响应式状态</li><li>注册 <code>onMounted</code> &#x2F; <code>onUnmounted</code></li><li>返回 render &#x2F; bindings</li></ul><p>注意：</p><ul><li><code>setup</code> <strong>发生在 beforeRouteEnter 之后</strong></li><li><code>setup</code> <strong>早于 data（Vue 3 中）</strong></li></ul><hr><h5 id="11-初始化-data（选项式）"><a href="#11-初始化-data（选项式）" class="headerlink" title="11. 初始化 data（选项式）"></a>11. 初始化 data（选项式）</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>() &#123;</span><br><span class="hljs-class">  <span class="hljs-title">return</span> &#123; ... &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时：</p><ul><li>响应式数据已就绪</li><li>methods &#x2F; computed 可用</li></ul><hr><h5 id="12-执行-created"><a href="#12-执行-created" class="headerlink" title="12. 执行 created"></a>12. 执行 created</h5><p>组件逻辑层已准备完成，但 DOM 未生成。</p><hr><h5 id="13-渲染并挂载"><a href="#13-渲染并挂载" class="headerlink" title="13. 渲染并挂载"></a>13. 渲染并挂载</h5><ul><li>执行 render</li><li>patch 到真实 DOM</li><li>触发 <code>mounted</code></li></ul><p>页面此时已显示。</p><hr><h5 id="14-执行-beforeRouteEnter-的-next-回调"><a href="#14-执行-beforeRouteEnter-的-next-回调" class="headerlink" title="14. 执行 beforeRouteEnter 的 next 回调"></a>14. 执行 <code>beforeRouteEnter</code> 的 next 回调</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">next(vm <span class="hljs-operator">=</span>&gt; &#123;<br>  vm.loadData()<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>此时：</p><ul><li><code>vm</code> 完整可用</li><li>data &#x2F; methods &#x2F; refs 基本可访问</li><li>若依赖 DOM，建议再 <code>nextTick</code></li></ul><hr><h4 id="四、导航完成阶段"><a href="#四、导航完成阶段" class="headerlink" title="四、导航完成阶段"></a>四、导航完成阶段</h4><h5 id="15-执行全局后置守卫"><a href="#15-执行全局后置守卫" class="headerlink" title="15. 执行全局后置守卫"></a>15. 执行全局后置守卫</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">router.afterEach(<span class="hljs-keyword">to</span>, <span class="hljs-keyword">from</span>)<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>不可拦截</li><li>只做收尾</li></ul><p>常见用途：</p><ul><li>设置 document.title</li><li>关闭 Loading &#x2F; NProgress</li><li>埋点统计</li></ul><hr><h4 id="五、完整顺序速查（面试版）"><a href="#五、完整顺序速查（面试版）" class="headerlink" title="五、完整顺序速查（面试版）"></a>五、完整顺序速查（面试版）</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vim">触发导航<br>↓<br>解析 <span class="hljs-keyword">to</span>.matched<br>↓<br>beforeRouteLeave<br>↓<br>beforeEach<br>↓<br>beforeEnter<br>↓<br>beforeRouteEnter（无 <span class="hljs-keyword">vm</span>）<br>↓<br>beforeRouteUpdate（若复用）<br>↓<br>beforeResolve<br>↓<br>创建组件实例<br>↓<br>setup<br>↓<br>data<br>↓<br>created<br>↓<br>render / mounted<br>↓<br>beforeRouteEnter <span class="hljs-keyword">next</span>(<span class="hljs-keyword">vm</span>)<br>↓<br>afterEach<br></code></pre></td></tr></table></figure><hr><h4 id="六、关键结论总结"><a href="#六、关键结论总结" class="headerlink" title="六、关键结论总结"></a>六、关键结论总结</h4><ul><li><code>beforeRouteEnter</code> <strong>早于组件创建</strong></li><li><code>data / setup</code> <strong>都发生在它之后</strong></li><li>父路由一定在 <code>matched</code> 中，但不一定触发 <code>beforeEnter</code></li><li>组件复用不会走 <code>beforeRouteEnter</code>，而是 <code>beforeRouteUpdate</code></li><li>Vue Router 4 基本不用 <code>next</code>，<strong>只有 <code>beforeRouteEnter</code> 是特例</strong></li></ul><h2 id="3"><a href="#3" class="headerlink" title="3. &lt;router-link&gt;"></a>3. <code>&lt;router-link&gt;</code></h2><p><code>&lt;router-link&gt;</code> 渲染后本质是一个 <code>&lt;a&gt;</code> 标签。 当它所指向的路由 <strong>处于激活状态</strong> 时，Vue Router 会自动给它加上一个类名，用于样式高亮。</p><p>默认行为（Vue Router 4）：</p><ul><li>激活时自动加：<code>router-link-active</code></li><li>精确匹配时再加：<code>router-link-exact-active</code></li></ul><p><code>router-link</code> 的 <strong><code>active-class</code></strong> 用来控制：</p><blockquote><p><strong>当前路由与该链接匹配时，自动添加到链接元素上的 CSS 类名</strong>。 </p></blockquote><h3 id="【active-class】"><a href="#【active-class】" class="headerlink" title="【active-class】"></a>【active-class】</h3><p><code>active-class</code> 用来<strong>覆盖默认的 <code>router-link-active</code> 类名</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span><br><span class="hljs-tag">  <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/demo&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;menu-active&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>  Demo<br><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>/demo</code> 被认为是“激活路由”时，DOM 会变成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-active&quot;</span>&gt;</span>Demo<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>非精确匹配（默认）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/demo&quot;</span>&gt;</span>Demo<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下路径都会命中激活态：</p><ul><li><code>/demo</code></li><li><code>/demo/a</code></li><li><code>/demo/b</code></li></ul><p>原因：</p><ul><li><code>/demo</code> 是 <code>/demo/a</code> 的父路径</li><li>属于“包含式匹配”</li></ul><h3 id="【exact-active-class】"><a href="#【exact-active-class】" class="headerlink" title="【exact-active-class】"></a>【exact-active-class】</h3><p>如果你只希望 <strong>完全匹配时才高亮</strong>，使用：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;router-link<br>  to<span class="hljs-operator">=</span><span class="hljs-string">&quot;/demo&quot;</span><br>  exact-active-class<span class="hljs-operator">=</span><span class="hljs-string">&quot;menu-exact-active&quot;</span><br>&gt;<br>  Demo<br>&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>触发条件：</p><ul><li>只有当前路径 <strong>严格等于</strong> <code>/demo</code> 才会生效</li><li><code>/demo/a</code> 不会触发</li></ul><hr><h3 id="active-class-vs-exact-active-class"><a href="#active-class-vs-exact-active-class" class="headerlink" title="active-class vs exact-active-class"></a>active-class vs exact-active-class</h3><table><thead><tr><th>属性</th><th>触发条件</th><th>常见用途</th></tr></thead><tbody><tr><td>active-class</td><td>包含式匹配</td><td>侧边栏父菜单高亮</td></tr><tr><td>exact-active-class</td><td>完全匹配</td><td>顶部 Tab、单页按钮</td></tr></tbody></table><h3 id="【全局配置】"><a href="#【全局配置】" class="headerlink" title="【全局配置】"></a>【全局配置】</h3><p>可以在创建 router 时统一配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  routes,<br>  <span class="hljs-attr">linkActiveClass</span>: <span class="hljs-string">&quot;menu-active&quot;</span>,<br>  <span class="hljs-attr">linkExactActiveClass</span>: <span class="hljs-string">&quot;menu-exact-active&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="4-路由懒加载"><a href="#4-路由懒加载" class="headerlink" title="4.路由懒加载"></a>4.路由懒加载</h2><p><strong>路由懒加载</strong>： 把“路由对应页面组件”的代码拆分成独立的 chunk，<strong>只有当路由被访问时才加载该组件</strong>，而不是在首屏一次性下载全部页面代码。</p><p>本质：<strong>代码分割（Code Splitting）+ 按需加载（On-Demand Loading）</strong>。</p><p>1）最常用方式：<code>import()</code> 动态加载</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const routes = [<br>  &#123;<br>    path: <span class="hljs-string">&quot;/demo&quot;</span>,<br>    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/demo/index.vue&quot;</span>),<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><ul><li><code>import()</code> 会被构建工具（Vite &#x2F; Webpack）拆成独立 chunk</li><li>只有访问 <code>/demo</code> 时才请求该 JS 文件</li></ul><p>2）对比：非懒加载（不推荐）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Demo <span class="hljs-keyword">from</span> &quot;@/views/demo/index.vue&quot;;<br><br>&#123;<br>  <span class="hljs-type">path</span>: &quot;/demo&quot;,<br>  component: Demo,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>所有页面代码都会进首包</li><li>首屏 JS 体积膨胀</li></ul><p>1）显著降低首屏体积</p><ul><li>首次加载只包含：首页 + 公共依赖</li><li>非首屏页面不参与首包下载</li><li><strong>TTI &#x2F; FCP 明显改善</strong></li></ul><hr><p>2）提升用户真实体验</p><ul><li>用户通常不会一次访问所有页面</li><li>懒加载让“没访问的页面不付费”</li><li>首次进入更快，交互更早可用</li></ul><h2 id="5-router-addRoute"><a href="#5-router-addRoute" class="headerlink" title="5. router.addRoute"></a>5. <code>router.addRoute</code></h2><p><code>router.addRoute</code> 用于在运行时把路由记录动态注入到 Router 中，常见于“登录后按权限加载菜单&#x2F;路由”“微前端子应用挂载”“插件化模块路由”等场景。以下按概念、API、实现流程、关键坑点紧凑整理（Vue Router 4）。</p><hr><p>动态注入的核心概念</p><ul><li>静态路由：打包时写死在 routes 里，初始化 router 时一次性注册</li><li>动态路由：运行时通过 <code>router.addRoute</code> 添加，适合权限变化、模块按需加载</li><li>路由记录（RouteRecordRaw）：<code>path/name/component/children/meta</code> 等配置项</li><li>注入时机：通常在登录成功后、首次进入受保护页面前，或刷新后恢复会话时</li></ul><hr><h3 id="addRoute-基本-API"><a href="#addRoute-基本-API" class="headerlink" title="addRoute 基本 API"></a><code>addRoute</code> 基本 API</h3><ul><li><code>router.addRoute(record)</code>：添加顶层路由</li><li><code>router.addRoute(parentName, record)</code>：添加到某个父路由（按 name 挂 children）</li><li><code>router.hasRoute(name)</code>：判断是否已存在同名路由</li><li><code>router.removeRoute(name)</code>：移除路由（常用于退出登录&#x2F;切换角色）</li><li><code>router.getRoutes()</code>：查看当前所有路由（调试用）</li></ul><h3 id="登录后注入菜单路由"><a href="#登录后注入菜单路由" class="headerlink" title="登录后注入菜单路由"></a>登录后注入菜单路由</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// asyncRoutes.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> asyncRoutes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/admin&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/layouts/AdminLayout.vue&quot;</span>),<br>    <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">roles</span>: [<span class="hljs-string">&quot;admin&quot;</span>] &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;users&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;AdminUsers&quot;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/admin/users.vue&quot;</span>),<br>        <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;用户管理&quot;</span> &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>];<br><span class="hljs-comment">// inject.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">RouteRecordRaw</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectRoutes</span>(<span class="hljs-params"><span class="hljs-attr">router</span>: <span class="hljs-title class_">Router</span>, <span class="hljs-attr">routes</span>: <span class="hljs-title class_">RouteRecordRaw</span>[]</span>) &#123;<br>  routes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (r.<span class="hljs-property">name</span> &amp;&amp; router.<span class="hljs-title function_">hasRoute</span>(r.<span class="hljs-property">name</span>)) <span class="hljs-keyword">return</span>;<br>    router.<span class="hljs-title function_">addRoute</span>(r);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>推荐落地流程（权限路由）<br> 1）初始化 router：只注册“公共路由”</p><ul><li><code>/login</code>、<code>/404</code>、基础布局路由（如 <code>/</code> 入口）<br> 2）登录成功：拉取后端菜单&#x2F;权限树<br> 3）把权限树转换为 RouteRecordRaw（组件映射、path 拼接、meta 填充）<br> 4）<code>router.addRoute</code> 注入<br> 5）“重试”当前导航：确保刚注入的路由能命中（关键）</li></ul><p>示例（重试导航的写法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-title function_">async</span> (to) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!token &amp;&amp; to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/login&quot;</span>;<br><br>  <span class="hljs-comment">// 仅首次注入</span><br>  <span class="hljs-keyword">if</span> (token &amp;&amp; !store.<span class="hljs-property">routesInited</span>) &#123;<br>    <span class="hljs-keyword">const</span> menu = <span class="hljs-keyword">await</span> api.<span class="hljs-title function_">getMenu</span>();                 <span class="hljs-comment">// 后端返回</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">async</span> = <span class="hljs-title function_">buildRoutesFromMenu</span>(menu);          <span class="hljs-comment">// 转换为路由</span><br>    <span class="hljs-keyword">async</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">name</span> &amp;&amp; !router.<span class="hljs-title function_">hasRoute</span>(r.<span class="hljs-property">name</span>) &amp;&amp; router.<span class="hljs-title function_">addRoute</span>(r));<br>    store.<span class="hljs-property">routesInited</span> = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 关键：重试当前导航，否则这次匹配时还没有这些路由</span><br>    <span class="hljs-keyword">return</span> to.<span class="hljs-property">fullPath</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>要点</p><ul><li>“重试导航”用 <code>return to.fullPath</code>（或 <code>replace: true</code> 形式）让路由重新匹配</li><li>注入完成后不要反复注入，设置 <code>routesInited</code> 标记</li><li>刷新页面会丢失运行时注入的路由，必须在刷新后重新拉取并注入（靠 token + store 恢复）</li></ul><hr><h3 id="父路由挂载-children"><a href="#父路由挂载-children" class="headerlink" title="父路由挂载 children"></a>父路由挂载 children</h3><p> 适合：先有 Layout 父路由，子页面按权限动态加进去</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 先确保父路由（Layout）是静态存在的，并且有 name</span><br>&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RootLayout&quot;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/layouts/RootLayout.vue&quot;</span>),<br>  <span class="hljs-attr">children</span>: [],<br>&#125;<br><span class="hljs-comment">// 动态把子路由加到 RootLayout 下</span><br>router.<span class="hljs-title function_">addRoute</span>(<span class="hljs-string">&quot;RootLayout&quot;</span>, &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;demo&quot;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Demo&quot;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/demo/index.vue&quot;</span>),<br>  <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;演示&quot;</span> &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>要点</p><ul><li><code>parentName</code> 必须是已存在路由记录的 <code>name</code></li><li>子路由的 path 写相对路径（不以 <code>/</code> 开头）更符合嵌套语义</li></ul><hr><h3 id="动态路由与-404-的配合"><a href="#动态路由与-404-的配合" class="headerlink" title="动态路由与 404 的配合"></a>动态路由与 404 的配合</h3><p> 建议在注入完成后再注册兜底 404（避免误判）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">addRoute</span>(&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/:pathMatch(.*)*&quot;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;NotFound&quot;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;@/views/404.vue&quot;</span>),<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p>退出登录&#x2F;切换角色：移除动态路由</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> names = [<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-string">&quot;AdminUsers&quot;</span>];<br>names.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> router.<span class="hljs-title function_">hasRoute</span>(n) &amp;&amp; router.<span class="hljs-title function_">removeRoute</span>(n));<br>store.<span class="hljs-property">routesInited</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>要点</p><ul><li>路由 name 需要唯一且稳定，否则无法 remove</li><li>也可在 store 里维护“已注入路由 name 列表”用于批量清理</li></ul><hr><p>高频坑点清单</p><ul><li>刷新后路由消失：动态路由只存在于内存，刷新必须重新注入</li><li>name 冲突：同名路由会覆盖&#x2F;导致行为异常，注入前用 <code>hasRoute</code></li><li>父子 path 拼接：children 用相对 path；绝对 path 会变成新的顶层路径语义</li></ul><h2 id="6"><a href="#6" class="headerlink" title="6. &lt;keep-alive&gt;"></a>6. <code>&lt;keep-alive&gt;</code></h2><h3 id="keep-alive-的本质"><a href="#keep-alive-的本质" class="headerlink" title="keep-alive 的本质"></a><code>keep-alive</code> 的本质</h3><ul><li>Vue 内置组件，用于<strong>缓存组件实例</strong>，避免卸载重建</li><li>只对<strong>组件实例</strong>生效，不缓存路由、不缓存数据请求</li><li>缓存命中条件：<strong>组件 name 匹配 + 未被主动排除</strong></li></ul><hr><p><code>keep-alive</code> 缓存的是什么</p><ul><li>组件实例（data &#x2F; setup state &#x2F; computed &#x2F; methods）</li><li>生命周期变化：<ul><li>首次进入：<code>mounted</code></li><li>再次进入：<code>activated</code></li><li>离开但被缓存：<code>deactivated</code></li><li>不缓存才会：<code>unmounted</code></li></ul></li></ul><hr><p>与路由的关系（关键）</p><ul><li><code>keep-alive</code> <strong>不认识路由</strong></li><li>实际缓存的是：<code>&lt;router-view&gt;</code> 渲染出来的<strong>组件</strong></li><li>所以：<strong>router-view 放哪，决定缓存边界</strong></li></ul><hr><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[componentName]&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></td></tr></table></figure><p>含义</p><ul><li>当前 router-view 渲染的<strong>所有路由页面</strong>都会被缓存</li></ul><p>适用场景</p><ul><li>Tab 页面切换</li><li>多个“平级页面”来回切换（列表 ↔ 详情 ↔ 编辑）</li><li>页面状态需要完整保留（滚动、筛选、表单）</li></ul><p>注意点</p><ul><li>必须配合 <code>include / exclude</code> 或 <code>route.meta.keepAlive</code></li><li>否则缓存会无限增长</li><li>组件不定义默认没有组件名，文件名并不是默认的zu’jian</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-title function_">defineOptions</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;DemoPage&quot;</span>,<br>&#125;);<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="常见写法（推荐）"><a href="#常见写法（推荐）" class="headerlink" title="常见写法（推荐）"></a>常见写法（推荐）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;Component&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;route.meta.keepAlive&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;route.fullPath&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;Component&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-else</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;route.fullPath&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>含义</p><ul><li>Layout 不缓存</li><li>Layout 下的页面按需缓存</li><li>缓存边界清晰，最推荐</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><hr><p>include &#x2F; exclude 的规则（必会）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[ListPage,DetailPage]&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>匹配的是<strong>组件 name</strong>，不是路由 name</li><li>组件必须显式声明：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;ListPage&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>key 的作用（高频误区）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;Component&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;route.fullPath&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>key</code> 变化 → 强制新实例</li><li>想“同一路由参数变化仍复用”：<ul><li>用 <code>route.name</code></li></ul></li><li>想“参数变化就新实例”：<ul><li>用 <code>route.fullPath</code></li></ul></li></ul><hr><p>常见错误清单</p><ul><li>忘记给组件写 <code>name</code>，导致 include 无效</li><li>动态路由 + keep-alive 未清理，造成状态错乱</li><li>依赖 DOM 的逻辑写在 <code>mounted</code>，却没处理 <code>activated</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2026/01/08/README/"/>
    <url>/2026/01/08/README/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>El-Menu如何绑定Vue Router？</title>
    <link href="/2026/01/08/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/El-Menu%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9AVue-Router/"/>
    <url>/2026/01/08/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/El-Menu%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9AVue-Router/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite如何配置全局SCSS?</title>
    <link href="/2026/01/07/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Vite%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80SCSS/"/>
    <url>/2026/01/07/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/Vite%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80SCSS/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite如何配置全局SCSS"><a href="#Vite如何配置全局SCSS" class="headerlink" title="Vite如何配置全局SCSS?"></a>Vite如何配置全局SCSS?</h1><p>前端项目一旦进入多人协作阶段，样式如果没有“全局设计体系”，后期会出现：颜色不统一、组件风格割裂、暗色&#x2F;主题难切换、维护成本暴涨。</p><p>这篇文章用一个<strong>“科技蓝”风格</strong>为例，搭建一套可扩展的全局 SCSS 体系，包括：</p><ul><li>设计变量（SCSS Tokens）</li><li>运行时主题（CSS Variables）</li><li>Reset 基础重置</li><li>Vite 全局注入（组件里无需重复 import）</li></ul><hr><h2 id="Step-0：最终目录结构（先定工程边界）"><a href="#Step-0：最终目录结构（先定工程边界）" class="headerlink" title="Step 0：最终目录结构（先定工程边界）"></a>Step 0：最终目录结构（先定工程边界）</h2><p>在 <code>src/styles/</code> 下建立以下文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">src<span class="hljs-regexp">/styles/</span><br>├─ index.scss                 <span class="hljs-comment"># 全局样式入口（唯一被 main.ts 引入）</span><br>├─ reset.scss                 <span class="hljs-comment"># 基础重置（只做“清底盘”）</span><br>├─ variables.tokens.scss      <span class="hljs-comment"># 变量文件 1：SCSS 设计 tokens（给编译期用）</span><br>└─ variables.theme.scss       <span class="hljs-comment"># 变量文件 2：CSS 主题变量（给运行时切换用）</span><br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><code>index.scss</code> 是唯一入口，所有全局样式统一从这里聚合，避免“到处引入导致依赖混乱”。</li><li>两套变量体系是有意义的：<ul><li><strong>tokens（SCSS 变量）</strong>：编译期，给 mixin、计算、生成样式用</li><li><strong>theme（CSS 变量）</strong>：运行时，可实现亮&#x2F;暗切换、动态换肤</li></ul></li></ul><hr><h2 id="Step-1：安装-sass"><a href="#Step-1：安装-sass" class="headerlink" title="Step 1：安装 sass"></a>Step 1：安装 sass</h2><p>Vite 使用 SCSS 需要 <code>sass</code>：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D sass<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong><br> <code>sass</code> 是预处理器编译依赖，不是运行时依赖，所以安装到 devDependencies。</p><hr><h2 id="Step-2：编写科技蓝-Tokens（variables-tokens-scss）"><a href="#Step-2：编写科技蓝-Tokens（variables-tokens-scss）" class="headerlink" title="Step 2：编写科技蓝 Tokens（variables.tokens.scss）"></a>Step 2：编写科技蓝 Tokens（variables.tokens.scss）</h2><p>文件：<code>src/styles/variables.tokens.scss</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* 编译期 Tokens：用于生成样式、mixin、计算等（不会直接输出到 CSS 变量） */</span><br><br><span class="hljs-comment">/* 品牌色（科技蓝） */</span><br><span class="hljs-variable">$color-brand-500</span>: <span class="hljs-number">#1677ff</span>;<br><span class="hljs-variable">$color-brand-600</span>: <span class="hljs-number">#125fd6</span>;<br><span class="hljs-variable">$color-brand-700</span>: <span class="hljs-number">#0d47a1</span>;<br><br><span class="hljs-comment">/* 中性色 */</span><br><span class="hljs-variable">$color-gray-0</span>: <span class="hljs-number">#ffffff</span>;<br><span class="hljs-variable">$color-gray-50</span>: <span class="hljs-number">#f7f9fc</span>;<br><span class="hljs-variable">$color-gray-100</span>: <span class="hljs-number">#eef2f7</span>;<br><span class="hljs-variable">$color-gray-200</span>: <span class="hljs-number">#d9e2ef</span>;<br><span class="hljs-variable">$color-gray-700</span>: <span class="hljs-number">#344054</span>;<br><span class="hljs-variable">$color-gray-900</span>: <span class="hljs-number">#101828</span>;<br><br><span class="hljs-comment">/* 语义色 */</span><br><span class="hljs-variable">$color-success</span>: <span class="hljs-number">#2ecc71</span>;<br><span class="hljs-variable">$color-warning</span>: <span class="hljs-number">#f5a623</span>;<br><span class="hljs-variable">$color-danger</span>: <span class="hljs-number">#ff4d4f</span>;<br><br><span class="hljs-comment">/* 尺寸与排版 */</span><br><span class="hljs-variable">$radius-sm</span>: <span class="hljs-number">6px</span>;<br><span class="hljs-variable">$radius-md</span>: <span class="hljs-number">10px</span>;<br><span class="hljs-variable">$radius-lg</span>: <span class="hljs-number">14px</span>;<br><br><span class="hljs-variable">$shadow-soft</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">30px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">16</span>, <span class="hljs-number">24</span>, <span class="hljs-number">40</span>, <span class="hljs-number">0.08</span>);<br><span class="hljs-variable">$shadow-glow-blue</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">22</span>, <span class="hljs-number">119</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.18</span>);<br><br><span class="hljs-variable">$font-family-base</span>: ui-sans-serif, system-ui, -apple-system, <span class="hljs-string">&quot;Segoe UI&quot;</span>, Roboto,<br>  <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, Arial, <span class="hljs-string">&quot;Noto Sans&quot;</span>, <span class="hljs-string">&quot;PingFang SC&quot;</span>, <span class="hljs-string">&quot;Microsoft YaHei&quot;</span>, sans-serif;<br><br><span class="hljs-variable">$font-size-base</span>: <span class="hljs-number">14px</span>;<br><span class="hljs-variable">$line-height-base</span>: <span class="hljs-number">1.6</span>;<br><br><span class="hljs-comment">/* 动画与过渡 */</span><br><span class="hljs-variable">$transition-fast</span>: <span class="hljs-number">120ms</span> ease;<br><span class="hljs-variable">$transition-base</span>: <span class="hljs-number">200ms</span> ease;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li>Tokens 建议用“语义 + 强度”的命名（如 brand-500），便于扩展与统一。</li><li>不要用 <code>$blue</code> &#x2F; <code>$darkBlue</code> 这种“描述颜色长相”的变量名，后期换色会很痛苦。</li></ul><hr><h2 id="Step-3：编写运行时主题变量（variables-theme-scss）"><a href="#Step-3：编写运行时主题变量（variables-theme-scss）" class="headerlink" title="Step 3：编写运行时主题变量（variables.theme.scss）"></a>Step 3：编写运行时主题变量（variables.theme.scss）</h2><p>文件：<code>src/styles/variables.theme.scss</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* 运行时主题：用 CSS Variables，便于动态切换亮/暗或多主题 */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-comment">/* 背景与文本 */</span><br>  <span class="hljs-attr">--bg</span>: <span class="hljs-number">#0b1220</span>;              <span class="hljs-comment">/* 深蓝黑背景（科技感） */</span><br>  <span class="hljs-attr">--bg-elevated</span>: <span class="hljs-number">#0f1b2e</span>;     <span class="hljs-comment">/* 卡片/面板背景 */</span><br>  <span class="hljs-attr">--text</span>: <span class="hljs-number">#e6edf7</span>;            <span class="hljs-comment">/* 主文本 */</span><br>  <span class="hljs-attr">--text-muted</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">230</span>, <span class="hljs-number">237</span>, <span class="hljs-number">247</span>, <span class="hljs-number">0.72</span>);<br><br>  <span class="hljs-comment">/* 边框与分割线 */</span><br>  <span class="hljs-attr">--border</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">120</span>, <span class="hljs-number">170</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.18</span>);<br><br>  <span class="hljs-comment">/* 品牌（科技蓝） */</span><br>  <span class="hljs-attr">--primary</span>: <span class="hljs-number">#1677ff</span>;<br>  <span class="hljs-attr">--primary-hover</span>: <span class="hljs-number">#2f88ff</span>;<br>  <span class="hljs-attr">--primary-active</span>: <span class="hljs-number">#125fd6</span>;<br><br>  <span class="hljs-comment">/* 高亮与光晕 */</span><br>  <span class="hljs-attr">--glow</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">22</span>, <span class="hljs-number">119</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.25</span>);<br><br>  <span class="hljs-comment">/* 状态色 */</span><br>  <span class="hljs-attr">--success</span>: <span class="hljs-number">#2ecc71</span>;<br>  <span class="hljs-attr">--warning</span>: <span class="hljs-number">#f5a623</span>;<br>  <span class="hljs-attr">--danger</span>: <span class="hljs-number">#ff4d4f</span>;<br><br>  <span class="hljs-comment">/* 圆角与阴影 */</span><br>  <span class="hljs-attr">--radius</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-attr">--shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">30px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.35</span>);<br><br>  <span class="hljs-comment">/* 字体 */</span><br>  <span class="hljs-attr">--font</span>: ui-sans-serif, system-ui, -apple-system, <span class="hljs-string">&quot;Segoe UI&quot;</span>, Roboto,<br>    <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, Arial, <span class="hljs-string">&quot;Noto Sans&quot;</span>, <span class="hljs-string">&quot;PingFang SC&quot;</span>, <span class="hljs-string">&quot;Microsoft YaHei&quot;</span>, sans-serif;<br>&#125;<br><br><span class="hljs-comment">/* 可选：提供亮色主题（如果你未来要支持切换） */</span><br><span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&quot;light&quot;</span>]</span> &#123;<br>  <span class="hljs-attr">--bg</span>: <span class="hljs-number">#f6f9ff</span>;<br>  <span class="hljs-attr">--bg-elevated</span>: <span class="hljs-number">#ffffff</span>;<br>  <span class="hljs-attr">--text</span>: <span class="hljs-number">#0b1220</span>;<br>  <span class="hljs-attr">--text-muted</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">32</span>, <span class="hljs-number">0.65</span>);<br>  <span class="hljs-attr">--border</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">22</span>, <span class="hljs-number">119</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.16</span>);<br>  <span class="hljs-attr">--shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">12px</span> <span class="hljs-number">30px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">16</span>, <span class="hljs-number">24</span>, <span class="hljs-number">40</span>, <span class="hljs-number">0.12</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li>主题变量建议用 <code>--bg / --text / --border / --primary</code> 这种“语义化”命名。</li><li>用 <code>[data-theme=&quot;light&quot;]</code> 这种方式，为未来主题切换留扩展口子。</li></ul><hr><h2 id="Step-4：写-Reset（reset-scss）"><a href="#Step-4：写-Reset（reset-scss）" class="headerlink" title="Step 4：写 Reset（reset.scss）"></a>Step 4：写 Reset（reset.scss）</h2><p>文件：<code>src/styles/reset.scss</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* Reset：只做“清底盘”，不做业务样式，不做组件样式 */</span><br><br>*,<br>*<span class="hljs-selector-pseudo">::before</span>,<br>*<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><br><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-built_in">var</span>(--font);<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.6</span>;<br><br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--bg);<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--text);<br><br>  <span class="hljs-comment">/* 字体渲染优化 */</span><br>  -webkit-<span class="hljs-attribute">font-smoothing</span>: antialiased;<br>  -moz-osx-<span class="hljs-attribute">font-smoothing</span>: grayscale;<br>&#125;<br><br><span class="hljs-selector-tag">img</span>,<br><span class="hljs-selector-tag">svg</span>,<br><span class="hljs-selector-tag">video</span>,<br><span class="hljs-selector-tag">canvas</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">button</span>,<br><span class="hljs-selector-tag">input</span>,<br><span class="hljs-selector-tag">textarea</span>,<br><span class="hljs-selector-tag">select</span> &#123;<br>  <span class="hljs-attribute">font</span>: inherit;<br>  <span class="hljs-attribute">color</span>: inherit;<br>&#125;<br><br><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">cursor</span>: pointer;<br>  <span class="hljs-attribute">background</span>: none;<br>  <span class="hljs-attribute">border</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: inherit;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>&#125;<br><br><span class="hljs-selector-tag">ul</span>,<br><span class="hljs-selector-tag">ol</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><br><span class="hljs-selector-pseudo">:focus-visible</span> &#123;<br>  <span class="hljs-attribute">outline</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">var</span>(--primary);<br>  <span class="hljs-attribute">outline-offset</span>: <span class="hljs-number">2px</span>;<br>&#125;<br><br><span class="hljs-comment">/* 可选：滚动条（偏科技感，谨慎使用） */</span><br>::-webkit-scrollbar &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br>::-webkit-scrollbar-thumb &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">22</span>, <span class="hljs-number">119</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.22</span>);<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">999px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid transparent;<br>  <span class="hljs-attribute">background-clip</span>: padding-box;<br>&#125;<br><br>::-webkit-scrollbar-thumb:hover &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">22</span>, <span class="hljs-number">119</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.35</span>);<br>  <span class="hljs-attribute">background-clip</span>: padding-box;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li>Reset 的目标：统一浏览器默认行为，减少样式差异。</li><li>Reset 里不要出现 <code>.page</code>、<code>.header</code> 这类业务 class，否则会污染全局。</li></ul><hr><h2 id="Step-5：全局样式入口（index-scss）"><a href="#Step-5：全局样式入口（index-scss）" class="headerlink" title="Step 5：全局样式入口（index.scss）"></a>Step 5：全局样式入口（index.scss）</h2><p>文件：<code>src/styles/index.scss</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* 全局入口：统一组织全局样式层级 */</span><br><br><span class="hljs-comment">/* 1) 主题变量（运行时） */</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;./variables.theme.scss&quot;</span>;<br><br><span class="hljs-comment">/* 2) Reset（清底盘） */</span><br><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;./reset.scss&quot;</span>;<br><br><span class="hljs-comment">/* 3) 可选：全局基础风格（少量、谨慎） */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attribute">color-scheme</span>: dark;<br>&#125;<br><br><span class="hljs-comment">/* 卡片类基础样式（如果你想要全站统一的“科技蓝卡片感”） */</span><br><span class="hljs-selector-class">.app-surface</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<br>    <span class="hljs-number">180deg</span>,<br>    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">22</span>, <span class="hljs-number">119</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.10</span>),<br>    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">22</span>, <span class="hljs-number">119</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.02</span>)<br>  );<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">var</span>(--border);<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-built_in">var</span>(--radius);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-built_in">var</span>(--shadow);<br>  backdrop-<span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">8px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><code>index.scss</code> 统一入口，保证全局样式加载顺序可控。</li><li><code>.app-surface</code> 这种属于“通用容器风格”，可保留，但不要扩展为一堆业务类。</li></ul><hr><h2 id="Step-6：在-main-ts-引入一次全局样式"><a href="#Step-6：在-main-ts-引入一次全局样式" class="headerlink" title="Step 6：在 main.ts 引入一次全局样式"></a>Step 6：在 main.ts 引入一次全局样式</h2><p><code>src/main.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/styles/index.scss&quot;</span>;<br><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li>全局样式只引入一次，且在应用入口引入，避免组件重复加载造成不可控。</li></ul><hr><h2 id="Step-7：让每个组件自动可用-SCSS-Tokens（Vite-注入）"><a href="#Step-7：让每个组件自动可用-SCSS-Tokens（Vite-注入）" class="headerlink" title="Step 7：让每个组件自动可用 SCSS Tokens（Vite 注入）"></a>Step 7：让每个组件自动可用 SCSS Tokens（Vite 注入）</h2><p>你已经有 <code>variables.tokens.scss</code> 了，但组件里如果每次都写 <code>@use</code> 会很烦。<br> 工程上用 Vite 的 <code>additionalData</code> 统一注入。</p><p><code>vite.config.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@vitejs/plugin-vue&quot;</span>;<br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;path&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&quot;@&quot;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src&quot;</span>),<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>      <span class="hljs-attr">scss</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`</span><br><span class="hljs-string">          @use &quot;@/styles/variables.tokens.scss&quot; as *;</span><br><span class="hljs-string">        `</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>现在组件里可以直接写：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">&lt;style scoped lang=&quot;scss&quot;&gt;<br><span class="hljs-selector-class">.panel</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$radius-md</span>;<br>  <span class="hljs-attribute">transition</span>: <span class="hljs-variable">$transition-base</span>;<br>&#125;<br><span class="hljs-selector-class">.panel</span><span class="hljs-selector-pseudo">:focus-within</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$shadow-glow-blue</span>;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><code>additionalData</code> 是编译期注入，不会在运行时报错。</li><li>只注入 tokens（SCSS 变量），不要注入 reset&#x2F;theme，避免污染组件作用域概念。</li></ul><hr><h2 id="Step-8：验证“科技蓝风格”是否生效（快速自检）"><a href="#Step-8：验证“科技蓝风格”是否生效（快速自检）" class="headerlink" title="Step 8：验证“科技蓝风格”是否生效（快速自检）"></a>Step 8：验证“科技蓝风格”是否生效（快速自检）</h2><p>在 <code>App.vue</code> 写一个简单面板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div style=&quot;min-height: 100vh; padding: 24px;&quot;&gt;<br>    &lt;div class=&quot;app-surface panel&quot;&gt;<br>      &lt;h2&gt;Tech Blue Dashboard&lt;/h2&gt;<br>      &lt;p&gt;全局主题变量 + Reset + Tokens 注入已生效。&lt;/p&gt;<br>      &lt;button class=&quot;btn&quot;&gt;Primary Action&lt;/button&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped lang=&quot;scss&quot;&gt;<br>.panel &#123;<br>  padding: 18px;<br>  border-radius: $radius-lg;<br>&#125;<br><br>h2 &#123;<br>  margin: 0 0 10px 0;<br>&#125;<br><br>.btn &#123;<br>  margin-top: 14px;<br>  padding: 10px 14px;<br>  border-radius: $radius-sm;<br>  background: var(--primary);<br>  color: #fff;<br>  transition: $transition-fast;<br>&#125;<br>.btn:hover &#123;<br>  background: var(--primary-hover);<br>&#125;<br>.btn:active &#123;<br>  background: var(--primary-active);<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li>按职责：<ul><li><code>var(--primary)</code> 负责主题色（运行时）</li><li><code>$radius-sm</code> 等负责统一设计尺度（编译期）</li></ul></li></ul><hr><h2 id="Step-9：主题切换"><a href="#Step-9：主题切换" class="headerlink" title="Step 9：主题切换"></a>Step 9：主题切换</h2><p>如果未来要支持亮&#x2F;暗，直接改根节点属性即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;data-theme&quot;</span>, <span class="hljs-string">&quot;light&quot;</span>);<br><span class="hljs-comment">// 恢复暗色（默认）</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&quot;data-theme&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li>切主题只改 DOM 属性，不需要重编译，不需要重载 CSS。</li></ul><h2 id="SCSS的用法"><a href="#SCSS的用法" class="headerlink" title="SCSS的用法"></a>SCSS的用法</h2><h3 id="【定义变量】"><a href="#【定义变量】" class="headerlink" title="【定义变量】"></a>【定义变量】</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$radius-md</span>: <span class="hljs-number">10px</span>;<br></code></pre></td></tr></table></figure><ul><li><code>$radius-md</code> <strong>只在编译时存在</strong></li><li>编译后，浏览器根本不知道这个变量的存在</li></ul><p>编译结果：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.panel</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【-use-与命名空间】"><a href="#【-use-与命名空间】" class="headerlink" title="【@use 与命名空间】"></a>【<code>@use</code> 与命名空间】</h3><p>你在项目中用的是：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;@/styles/variables.tokens.scss&quot;</span> as *;<br></code></pre></td></tr></table></figure><p>这意味着：</p><ul><li><code>@use</code> 是 <strong>官方推荐</strong>（替代老的 <code>@import</code>）</li><li><code>as *</code> 表示“展开为全局变量”</li></ul><p>如果不用 <code>as *</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@use</span> <span class="hljs-string">&quot;@/styles/variables.tokens.scss&quot;</span> as tokens;<br><br><span class="hljs-selector-class">.panel</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: tokens.<span class="hljs-variable">$radius-md</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工程建议：</strong></p><ul><li><strong>全局注入用 <code>as \*</code></strong></li><li>模块内部或库开发用命名空间，避免变量污染</li></ul><h3 id="【SCSS-嵌套】"><a href="#【SCSS-嵌套】" class="headerlink" title="【SCSS 嵌套】"></a>【SCSS 嵌套】</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.panel</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">16px</span>;<br><br>  &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">$shadow-glow-blue</span>;<br>  &#125;<br><br>  <span class="hljs-selector-class">.title</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">600</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工程铁律：</strong></p><ul><li>嵌套不超过 <strong>3 层</strong></li><li>禁止 <code>.a .b .c .d</code></li></ul><h2 id="CSS-Variables"><a href="#CSS-Variables" class="headerlink" title="CSS Variables"></a>CSS Variables</h2><p>在前面的章节中，我们已经在项目中使用了如下代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--bg</span>: <span class="hljs-number">#0b1220</span>;<br>  <span class="hljs-attr">--text</span>: <span class="hljs-number">#e6edf7</span>;<br>  <span class="hljs-attr">--primary</span>: <span class="hljs-number">#1677ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>并在 reset &#x2F; 组件中这样使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--bg);<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--text);<br>&#125;<br></code></pre></td></tr></table></figure><p>这一节，我们就来彻底讲清楚：<strong>CSS Variables 到底解决了什么问题，以及它是如何支撑“动态主题系统”的</strong>。</p><h3 id="最直观的定义"><a href="#最直观的定义" class="headerlink" title="最直观的定义"></a>最直观的定义</h3><p><strong>CSS Variables（CSS 自定义属性）</strong> 是：</p><blockquote><p><strong>存在于浏览器运行时的变量，可被 CSS 和 JavaScript 同时读写。</strong></p></blockquote><p>语法形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--primary</span>: <span class="hljs-number">#1677ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--primary);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="root"><a href="#root" class="headerlink" title=":root"></a><code>:root</code></h3><p><code>:root</code> 是什么？</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-pseudo">:root</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><ul><li>表示 <strong>文档树的根节点</strong></li><li>在 HTML 中等价于 <code>html</code></li><li>但 <code>:root</code> 的 <strong>CSS 变量优先级更高</strong></li></ul><blockquote><p>所以：<strong>全局主题变量，统一定义在 <code>:root</code> 是最佳实践</strong></p></blockquote><hr><p>为什么不用 <code>body</code>？</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attr">--bg</span>: <span class="hljs-number">#0b1220</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法的问题：</p><ul><li>CSS 变量的作用域是“向下继承”</li><li><code>body</code> 的变量在某些场景（如 portal &#x2F; iframe &#x2F; shadow DOM）会出现边界问题</li></ul><p>工程上统一用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--bg</span>: ...;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS-Variables-的“作用域机制”"><a href="#CSS-Variables-的“作用域机制”" class="headerlink" title="CSS Variables 的“作用域机制”"></a>CSS Variables 的“作用域机制”</h3><p>CSS Variables <strong>遵循 CSS 作用域规则</strong>。</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--primary</span>: <span class="hljs-number">#1677ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有子节点都能使用。</p><hr><h4 id="局部覆盖"><a href="#局部覆盖" class="headerlink" title="局部覆盖"></a>局部覆盖</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&quot;light&quot;</span>]</span> &#123;<br>  <span class="hljs-attr">--bg</span>: <span class="hljs-number">#f6f9ff</span>;<br>  <span class="hljs-attr">--text</span>: <span class="hljs-number">#0b1220</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这意味着：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;html <span class="hljs-attribute">data-theme</span>=<span class="hljs-string">&quot;light&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>时：</p><ul><li><code>--bg</code> &#x2F; <code>--text</code> 会覆盖 <code>:root</code> 中的定义</li><li>未定义的变量仍然从 <code>:root</code> 继承</li></ul><blockquote><p>这就是“主题切换”的<strong>底层原理</strong></p></blockquote><h3 id="亮-暗主题切换"><a href="#亮-暗主题切换" class="headerlink" title="亮 &#x2F; 暗主题切换"></a>亮 &#x2F; 暗主题切换</h3><h4 id="默认主题（暗色-·-科技蓝）"><a href="#默认主题（暗色-·-科技蓝）" class="headerlink" title="默认主题（暗色 · 科技蓝）"></a>默认主题（暗色 · 科技蓝）</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--bg</span>: <span class="hljs-number">#0b1220</span>;<br>  <span class="hljs-attr">--text</span>: <span class="hljs-number">#e6edf7</span>;<br>  <span class="hljs-attr">--primary</span>: <span class="hljs-number">#1677ff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="亮色主题覆盖"><a href="#亮色主题覆盖" class="headerlink" title="亮色主题覆盖"></a>亮色主题覆盖</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[data-theme=<span class="hljs-string">&quot;light&quot;</span>]</span> &#123;<br>  <span class="hljs-attr">--bg</span>: <span class="hljs-number">#f6f9ff</span>;<br>  <span class="hljs-attr">--text</span>: <span class="hljs-number">#0b1220</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="切换时发生了什么？"><a href="#切换时发生了什么？" class="headerlink" title="切换时发生了什么？"></a>切换时发生了什么？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;data-theme&quot;</span>, <span class="hljs-string">&quot;light&quot;</span>);<br></code></pre></td></tr></table></figure><p>浏览器执行流程：</p><ol><li>DOM 属性变化</li><li>CSS 选择器 <code>[data-theme=&quot;light&quot;]</code> 生效</li><li>对应的 CSS Variables 被覆盖</li><li>所有使用 <code>var(--bg)</code> 的地方自动更新</li></ol><p><strong>没有 JS 操作样式，没有重绘逻辑，没有额外计算。</strong></p><h3 id="JS-如何操作-CSS-Variables（核心-API）"><a href="#JS-如何操作-CSS-Variables（核心-API）" class="headerlink" title="JS 如何操作 CSS Variables（核心 API）"></a>JS 如何操作 CSS Variables（核心 API）</h3><h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">document</span>.documentElement.style.setProperty(<span class="hljs-string">&quot;--primary&quot;</span>, <span class="hljs-string">&quot;#ff4d4f&quot;</span>);<br></code></pre></td></tr></table></figure><hr><h4 id="读取变量（调试或计算）"><a href="#读取变量（调试或计算）" class="headerlink" title="读取变量（调试或计算）"></a>读取变量（调试或计算）</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const value <span class="hljs-operator">=</span> getComputedStyle(document.documentElement)<br>  .getPropertyValue(<span class="hljs-string">&quot;--primary&quot;</span>)<br>  .trim()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><hr><h4 id="移除变量（回退到-CSS-定义）"><a href="#移除变量（回退到-CSS-定义）" class="headerlink" title="移除变量（回退到 CSS 定义）"></a>移除变量（回退到 CSS 定义）</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">document.documentElement.style.removeProperty(<span class="hljs-string">&quot;--primary&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.OpenLayers地图绘制</title>
    <link href="/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/15-%E4%BA%8C%E7%BB%B4%E5%9C%B0%E5%9B%BE%E7%BB%98%E5%88%B6/"/>
    <url>/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/15-%E4%BA%8C%E7%BB%B4%E5%9C%B0%E5%9B%BE%E7%BB%98%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="OpenLayers地图绘制"><a href="#OpenLayers地图绘制" class="headerlink" title="OpenLayers地图绘制"></a><code>OpenLayers</code>地图绘制</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/641436984">国内常用地图瓦片源地址汇总 - 知乎</a></p><p><a href="http://lbs.tianditu.gov.cn/server/MapService.html">天地图API</a></p></blockquote><h3 id="1-从0到1绘制一个地图"><a href="#1-从0到1绘制一个地图" class="headerlink" title="1.从0到1绘制一个地图"></a>1.从0到1绘制一个地图</h3><h4 id="【第-1-步：画出一个“地图容器”】"><a href="#【第-1-步：画出一个“地图容器”】" class="headerlink" title="【第 1 步：画出一个“地图容器”】"></a>【第 1 步：画出一个“地图容器”】</h4><p>在页面放一个 div，让 <code>OpenLayers </code> 把地图渲染到这个 div 里。</p><p>所有 Web 地图的本质就是：<strong>把画布挂到 DOM 容器上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;map-container&quot;&gt;<br>    &lt;div id=&quot;mapView&quot; class=&quot;mapView&quot;&gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.map-container &#123; width: 100%; height: 100%; &#125;<br>.mapView &#123; width: 100%; height: 100%; &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h4 id="【第-2-步：初始化-OpenLayers-Map】"><a href="#【第-2-步：初始化-OpenLayers-Map】" class="headerlink" title="【第 2 步：初始化 OpenLayers Map】"></a>【第 2 步：初始化 OpenLayers Map】</h4><p>创建 <code>new Map(&#123; target, layers, view &#125;)</code></p><ul><li><code>target</code>：渲染到哪个 DOM</li><li><code>layers</code>：地图显示什么</li><li><code>view</code>：中心点、投影、缩放等</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span> setup&gt;<br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Map</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/Map&quot;</span>; <span class="hljs-comment">// 地图类</span><br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/View&quot;</span>; <span class="hljs-comment">// 地图视图</span><br>  <span class="hljs-keyword">import</span> &#123; ref, onMounted, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>; <span class="hljs-comment">// vue 响应式 API</span><br><br>  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 地图实例</span><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    map.<span class="hljs-property">value</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(&#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;mapView&quot;</span>, <span class="hljs-comment">// 地图容器 DOM 元素 ID , 挂载到 mapView 元素上</span><br>      <span class="hljs-attr">view</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>(&#123; <span class="hljs-comment">// 地图视图配置</span><br>        <span class="hljs-attr">center</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        <span class="hljs-attr">zoom</span>: <span class="hljs-number">2</span>,<br>      &#125;),<br>    &#125;);<br>  &#125;);<br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    map.<span class="hljs-property">value</span>.<span class="hljs-title function_">setTarget</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 移除地图容器引用，防止内存泄漏</span><br>  &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>此时还是空白，因为没有图层。</p><h4 id="【第-3-步：添加“底图”】"><a href="#【第-3-步：添加“底图”】" class="headerlink" title="【第 3 步：添加“底图”】"></a>【第 3 步：添加“底图”】</h4><p>用 <code>XYZ</code> 作为瓦片数据源，用 <code>Tile</code> 作为瓦片图层。</p><p>底图是地图用户的“参照系”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span> setup&gt;<br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Map</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/Map&quot;</span>; <span class="hljs-comment">// 地图类</span><br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/View&quot;</span>; <span class="hljs-comment">// 地图视图</span><br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Tile</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/layer/Tile&quot;</span>; <span class="hljs-comment">// 瓦片图层类</span><br>  <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">XYZ</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/source/XYZ&quot;</span>; <span class="hljs-comment">// XYZ 数据源类</span><br><br>  <span class="hljs-keyword">import</span> &#123; ref, onMounted, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>; <span class="hljs-comment">// vue 响应式 API</span><br><br>  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 地图实例</span><br><br>  <span class="hljs-comment">// 添加天地图图层</span><br>  <span class="hljs-keyword">const</span> tiandituMapSource = <span class="hljs-keyword">new</span> <span class="hljs-title function_">XYZ</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://t0.tianditu.com/DataServer?T=vec_w&amp;tk=d212aa1b10fc6b036280ee9eab8b389c&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&quot;</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> tiandiMapLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tile</span>(&#123;<br>    <span class="hljs-attr">zindex</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;矢量底图&quot;</span>,<br>    <span class="hljs-attr">source</span>: tiandituMapSource,<br>  &#125;);<br><br><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    map.<span class="hljs-property">value</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(&#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;mapView&quot;</span>, <span class="hljs-comment">// 地图容器 DOM 元素 ID , 挂载到 mapView 元素上</span><br>      <span class="hljs-attr">layers</span>: [tiandiMapLayer],<br>      <span class="hljs-attr">view</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>(&#123; <span class="hljs-comment">// 地图视图配置</span><br>        <span class="hljs-attr">center</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        <span class="hljs-attr">zoom</span>: <span class="hljs-number">2</span>,<br>      &#125;),<br>    &#125;);<br>  &#125;);<br>  <br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    map.<span class="hljs-property">value</span>.<span class="hljs-title function_">setTarget</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 移除地图容器引用，防止内存泄漏</span><br>  &#125;);<br><br>  <span class="hljs-comment">// map.value.addLayer(tiandiMapLayer);</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/15-%E4%BA%8C%E7%BB%B4%E5%9C%B0%E5%9B%BE%E7%BB%98%E5%88%B6/image-20260106231408318.png" class title="image-20260106231408318"><h3 id="2-Layer图层"><a href="#2-Layer图层" class="headerlink" title="2.Layer图层"></a>2.<code>Layer</code>图层</h3><p>在 OpenLayers 中：</p><ul><li><strong>Layer（图层）</strong>：负责“怎么显示、显示顺序、是否可见、透明度”</li><li><strong>Source（数据源）</strong>：负责“数据从哪里来、怎么加载、加载策略”</li></ul><p>从架构上看，OpenLayers 的图层主要分为 <strong>三大类</strong>：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Layer</span><br> ├── <span class="hljs-built_in">Raster</span>（栅格图层）<br> │     ├── <span class="hljs-variable">Tile</span><br> │     └── <span class="hljs-built_in">Image</span><br> ├── <span class="hljs-variable">Vector</span>（矢量图层）<br> └── <span class="hljs-variable">Specialized</span>（特殊用途图层）<br></code></pre></td></tr></table></figure><p>不同的图层，本质区别在于 <strong>“数据是图片还是矢量、是否切片、渲染发生在前端还是后端”</strong>。</p><h4 id="【Tile-图层】"><a href="#【Tile-图层】" class="headerlink" title="【Tile 图层】"></a>【Tile 图层】</h4><p>Tile 图层将地图按固定规则切分成大量 <strong>小图片（瓦片）</strong>，浏览器只加载当前视野内需要的瓦片。</p><h5 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h5><ul><li>图片是 <strong>提前切好的</strong></li><li>每张瓦片大小固定（通常 256×256）</li><li>支持多级缩放</li><li>浏览器只请求必要瓦片</li><li>性能非常稳定</li></ul><h5 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h5><ul><li>快速显示大范围地图</li><li>支撑高并发访问</li><li>保证缩放、拖拽流畅</li></ul><h5 id="不能解决什么"><a href="#不能解决什么" class="headerlink" title="不能解决什么"></a>不能解决什么</h5><ul><li>不能对单个地图要素做交互</li><li>样式不可动态修改（样式已经“画死”在瓦片里）</li></ul><h5 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h5><ul><li>底图（行政区划、道路、水系）</li><li>卫星影像</li><li>全国、省级地图展示</li><li>天地图、高德、OSM</li></ul><h5 id="工程举例"><a href="#工程举例" class="headerlink" title="工程举例"></a>工程举例</h5><ul><li>WebGIS 项目中：<ul><li>第一层：Tile 底图</li><li>上面再叠加业务图层</li></ul></li><li>城市管理系统中：<ul><li>永远存在一个不可编辑的基础底图</li></ul></li></ul><h4 id="【Image-图层】"><a href="#【Image-图层】" class="headerlink" title="【Image 图层】"></a>【Image 图层】</h4><p>Image 图层在 <strong>当前视图范围内只请求一整张图片</strong>，不进行瓦片拆分。</p><h5 id="核心特点-1"><a href="#核心特点-1" class="headerlink" title="核心特点"></a>核心特点</h5><ul><li>每次视图变化重新请求整张图</li><li>图片通常由服务器动态生成</li><li>渲染逻辑主要在后端</li></ul><h5 id="解决什么问题-1"><a href="#解决什么问题-1" class="headerlink" title="解决什么问题"></a>解决什么问题</h5><ul><li>后端动态制图</li><li>复杂符号、专题渲染</li><li>不方便切片的数据</li></ul><h5 id="不能解决什么-1"><a href="#不能解决什么-1" class="headerlink" title="不能解决什么"></a>不能解决什么</h5><ul><li>拖动和缩放时性能不如 Tile</li><li>频繁视图变化会频繁请求新图</li></ul><h5 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h5><ul><li>WMS 服务</li><li>专题分析图</li><li>统计热区、等值线、分析结果</li></ul><h5 id="工程举例-1"><a href="#工程举例-1" class="headerlink" title="工程举例"></a>工程举例</h5><ul><li>管网压力分布图</li><li>泄漏概率专题图</li><li>实时计算的风险热区图</li></ul><h4 id="【Vector-图层】"><a href="#【Vector-图层】" class="headerlink" title="【Vector 图层】"></a>【Vector 图层】</h4><p>Vector 图层将 <strong>点、线、面要素直接加载到浏览器内存中</strong>，由前端负责渲染和交互。</p><h5 id="核心特点-2"><a href="#核心特点-2" class="headerlink" title="核心特点"></a>核心特点</h5><ul><li>每一个要素是独立对象</li><li>支持样式函数</li><li>支持事件监听</li><li>可编辑、可选中</li></ul><h5 id="解决什么问题-2"><a href="#解决什么问题-2" class="headerlink" title="解决什么问题"></a>解决什么问题</h5><ul><li>业务对象展示</li><li>用户交互</li><li>编辑与绘制</li></ul><h5 id="不能解决什么-2"><a href="#不能解决什么-2" class="headerlink" title="不能解决什么"></a>不能解决什么</h5><ul><li>不适合超大规模数据</li><li>几十万要素会明显卡顿</li></ul><h5 id="典型应用场景-2"><a href="#典型应用场景-2" class="headerlink" title="典型应用场景"></a>典型应用场景</h5><ul><li>实时点位</li><li>管线、区域标注</li><li>用户绘制、编辑功能</li></ul><h5 id="工程举例-2"><a href="#工程举例-2" class="headerlink" title="工程举例"></a>工程举例</h5><ul><li>地图上点击某个监测点弹出信息</li><li>管网中某条管道高亮</li><li>WebSocket 推送实时设备位置</li></ul><h4 id="【VectorImage-图层】"><a href="#【VectorImage-图层】" class="headerlink" title="【VectorImage 图层】"></a>【VectorImage 图层】</h4><p>数据仍然是矢量，但在渲染阶段 <strong>先转成图片再显示</strong>。</p><h5 id="核心特点-3"><a href="#核心特点-3" class="headerlink" title="核心特点"></a>核心特点</h5><ul><li>渲染性能优于 Vector</li><li>保留部分样式能力</li><li>交互能力弱于 Vector</li></ul><h5 id="解决什么问题-3"><a href="#解决什么问题-3" class="headerlink" title="解决什么问题"></a>解决什么问题</h5><ul><li>中等规模矢量性能问题</li><li>需要样式但不需要复杂交互</li></ul><h5 id="不能解决什么-3"><a href="#不能解决什么-3" class="headerlink" title="不能解决什么"></a>不能解决什么</h5><ul><li>不适合高频交互</li><li>要素级事件能力受限</li></ul><h5 id="典型应用场景-3"><a href="#典型应用场景-3" class="headerlink" title="典型应用场景"></a>典型应用场景</h5><ul><li>不需要点选的业务区域</li><li><strong>静态展示但样式复杂的图层</strong></li></ul><h5 id="工程举例-3"><a href="#工程举例-3" class="headerlink" title="工程举例"></a>工程举例</h5><ul><li>管网分区背景层</li><li>风险等级区域渲染层</li></ul><h4 id="【VectorTile-图层】"><a href="#【VectorTile-图层】" class="headerlink" title="【VectorTile 图层】"></a>【VectorTile 图层】</h4><p>将矢量数据 <strong>在服务端切成瓦片</strong>，前端按瓦片加载矢量要素。</p><h5 id="核心特点-4"><a href="#核心特点-4" class="headerlink" title="核心特点"></a>核心特点</h5><ul><li>结合 Tile 的性能优势</li><li>保留矢量样式能力</li><li>前端控制样式</li><li>支持超大规模数据</li></ul><h5 id="解决什么问题-4"><a href="#解决什么问题-4" class="headerlink" title="解决什么问题"></a>解决什么问题</h5><ul><li>全国级、城市级矢量数据展示</li><li>高性能 + 可定制样式</li></ul><h5 id="不能解决什么-4"><a href="#不能解决什么-4" class="headerlink" title="不能解决什么"></a>不能解决什么</h5><ul><li>服务端复杂度较高</li><li>数据更新成本较高</li></ul><h5 id="典型应用场景-4"><a href="#典型应用场景-4" class="headerlink" title="典型应用场景"></a>典型应用场景</h5><ul><li>城市道路、建筑物</li><li>大规模管网</li><li>行政区划动态渲染</li></ul><h5 id="工程举例-4"><a href="#工程举例-4" class="headerlink" title="工程举例"></a>工程举例</h5><ul><li>城市级管网全量展示</li><li>道路等级随缩放变化显示</li></ul><h3 id="3-天地图API"><a href="#3-天地图API" class="headerlink" title="3. 天地图API"></a>3. 天地图API</h3><p>天地图本质是一个 <strong>WMTS 服务集</strong>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">天地图 WMTS<br> ├── 矢量地图（vec）<br> ├── 影像地图（img）<br> ├── 地形地图（ter）<br> ├── 注记图层（cva <span class="hljs-regexp">/ cia /</span> cta）<br></code></pre></td></tr></table></figure><p><strong>所有类型：</strong></p><ul><li>请求方式相同</li><li>瓦片规则相同</li><li>API 结构相同</li></ul><p><strong>区别只在一个参数：layer 名称</strong></p><table><thead><tr><th>注记类型</th><th>对应底图</th></tr></thead><tbody><tr><td>cva</td><td>矢量注记</td></tr><tr><td>cia</td><td>影像注记</td></tr><tr><td>cta</td><td>地形注记</td></tr></tbody></table><p>拆分原因非常工程化：</p><ol><li>注记是 <strong>语言相关的</strong></li><li>注记更新频率高</li><li>注记样式可能变化</li></ol><p>如果注记和底图绑死：</p><ul><li>缓存效率极低</li><li>多语言难以支持</li></ul><h3 id="4-加载不同底图"><a href="#4-加载不同底图" class="headerlink" title="4. 加载不同底图"></a>4. 加载不同底图</h3><p>可以在<code>Layer</code>添加不同的地图，通过<code>zIndex</code>设置层级。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span> setup&gt;<br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Map</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/Map&quot;</span>; <span class="hljs-comment">// 地图类</span><br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/View&quot;</span>; <span class="hljs-comment">// 地图视图</span><br>  <span class="hljs-keyword">import</span> <span class="hljs-title class_">Tile</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/layer/Tile&quot;</span>; <span class="hljs-comment">// 瓦片图层类</span><br>  <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">XYZ</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/source/XYZ&quot;</span>; <span class="hljs-comment">// XYZ 数据源类</span><br><br>  <span class="hljs-keyword">import</span> &#123; ref, onMounted, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>; <span class="hljs-comment">// vue 响应式 API</span><br><br>  <span class="hljs-keyword">const</span> map = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 地图实例</span><br><br>  <span class="hljs-comment">// 添加天地图图层</span><br>  <span class="hljs-keyword">const</span> tiandituMapSource = <span class="hljs-keyword">new</span> <span class="hljs-title function_">XYZ</span>(&#123;<br>    <span class="hljs-attr">url</span>: <br>      <span class="hljs-string">&quot;http://t0.tianditu.gov.cn/vec_w/wmts?&quot;</span> +<br>      <span class="hljs-string">&quot;SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&quot;</span> +<br>      <span class="hljs-string">&quot;&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=w&quot;</span> +<br>      <span class="hljs-string">&quot;&amp;FORMAT=tiles&amp;TILEMATRIX=&#123;z&#125;&amp;TILEROW=&#123;y&#125;&amp;TILECOL=&#123;x&#125;&quot;</span> +<br>      <span class="hljs-string">&quot;&amp;tk=d212aa1b10fc6b036280ee9eab8b389c&quot;</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> tiandiMapLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tile</span>(&#123;<br>    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">source</span>: tiandituMapSource,<br>  &#125;);<br><br>  <span class="hljs-comment">//全球境界</span><br>  <span class="hljs-keyword">const</span> tiandituBoundarySource = <span class="hljs-keyword">new</span> <span class="hljs-title function_">XYZ</span>(&#123;<br>    <span class="hljs-attr">url</span>:<br>      <span class="hljs-string">&quot;http://t0.tianditu.gov.cn/ibo_w/wmts?&quot;</span> +<br>      <span class="hljs-string">&quot;SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&quot;</span> +<br>      <span class="hljs-string">&quot;&amp;LAYER=ibo&amp;STYLE=default&amp;TILEMATRIXSET=w&quot;</span> +<br>      <span class="hljs-string">&quot;&amp;FORMAT=tiles&amp;TILEMATRIX=&#123;z&#125;&amp;TILEROW=&#123;y&#125;&amp;TILECOL=&#123;x&#125;&quot;</span> +<br>      <span class="hljs-string">&quot;&amp;tk=d212aa1b10fc6b036280ee9eab8b389c&quot;</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> tiandituBoundaryLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tile</span>(&#123;<br>    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">source</span>: tiandituBoundarySource,<br>  &#125;);<br><br>  <span class="hljs-comment">//天地图矢量注记</span><br>  <span class="hljs-keyword">const</span> tiandituMessageSource = <span class="hljs-keyword">new</span> <span class="hljs-title function_">XYZ</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://t0.tianditu.com/DataServer?T=cia_w&amp;x=&#123;x&#125;&amp;y=&#123;y&#125;&amp;l=&#123;z&#125;&amp;tk=d212aa1b10fc6b036280ee9eab8b389c&quot;</span>,<br>    <span class="hljs-attr">tilePixelRatio</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 固定设置为2以获得更高清晰度</span><br>    <span class="hljs-attr">crossOrigin</span>: <span class="hljs-string">&quot;anonymous&quot;</span>, <span class="hljs-comment">// 添加跨域支持</span><br>  &#125;);<br><br>  <span class="hljs-keyword">const</span> tiandituMessageLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tile</span>(&#123;<br>    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-attr">source</span>: tiandituMessageSource,<br>    <span class="hljs-attr">minZoom</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">maxZoom</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">preload</span>: <span class="hljs-title class_">Infinity</span>, <span class="hljs-comment">// 预加载所有瓦片</span><br>  &#125;);<br><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    map.<span class="hljs-property">value</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(&#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;mapView&quot;</span>, <span class="hljs-comment">// 地图容器 DOM 元素 ID , 挂载到 mapView 元素上</span><br>      <span class="hljs-attr">layers</span>: [tiandiMapLayer, tiandituBoundaryLayer, tiandituMessageLayer],<br>      <span class="hljs-attr">view</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>(&#123; <span class="hljs-comment">// 地图视图配置</span><br>        <span class="hljs-attr">center</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        <span class="hljs-attr">zoom</span>: <span class="hljs-number">2</span>,<br>      &#125;),<br>    &#125;);<br>  &#125;);<br>  <br>  <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    map.<span class="hljs-property">value</span>.<span class="hljs-title function_">setTarget</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 移除地图容器引用，防止内存泄漏</span><br>  &#125;);<br><br>  <span class="hljs-comment">// map.value.addLayer(tiandiMapLayer);</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/15-%E4%BA%8C%E7%BB%B4%E5%9C%B0%E5%9B%BE%E7%BB%98%E5%88%B6/image-20260107011810940.png" class title="image-20260107011810940"><h3 id="5-VectorLayer"><a href="#5-VectorLayer" class="headerlink" title="5. VectorLayer"></a>5. VectorLayer</h3><blockquote><p>VectorLayer 是 OpenLayers 中唯一支持要素级渲染、样式控制和交互的图层类型，适合承载所有“需要参与业务逻辑”的地图对象，而 TileLayer 只适合作为视觉底图。</p></blockquote><p><strong>VectorLayer &#x3D; 客户端可计算、可交互的矢量要素图层</strong></p><p>它与 TileLayer 的本质区别在于：</p><table><thead><tr><th>对比维度</th><th>VectorLayer</th><th>TileLayer</th></tr></thead><tbody><tr><td>数据形态</td><td>点 &#x2F; 线 &#x2F; 面（Feature）</td><td>已渲染图片</td></tr><tr><td>渲染位置</td><td>浏览器端</td><td>服务端</td></tr><tr><td>是否可交互</td><td>可以</td><td>不可以</td></tr><tr><td>样式控制</td><td>完全前端可控</td><td>不可控</td></tr><tr><td>常见用途</td><td>标注、选中、高亮、分析</td><td>底图、影像、行政区描边</td></tr></tbody></table><p>一句话总结：</p><blockquote><p><strong>只要你要与用户交互，就必须用 VectorLayer。</strong></p></blockquote><h4 id="【三层结构】"><a href="#【三层结构】" class="headerlink" title="【三层结构】"></a>【三层结构】</h4><p>一个 VectorLayer 至少由三层结构构成：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Feature</span>（要素）<br>   ↓<br>VectorSource（数据容器）<br>   ↓<br>VectorLayer（渲染与交互载体）<br></code></pre></td></tr></table></figure><p>缺一不可。</p><p><strong>1. 引入核心模块</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">VectorLayer</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/layer/Vector&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VectorSource</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/source/Vector&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Feature</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/Feature&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/geom/Point&quot;</span>;<br></code></pre></td></tr></table></figure><hr><p><strong>2. 创建一个点 Feature</strong></p><p>注意：<strong>OpenLayers 默认坐标系是 EPSG:3857</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pointFeature = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Feature</span>(&#123;<br>  <span class="hljs-attr">geometry</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]),<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test-point&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>3. 创建 VectorSource</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vectorSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VectorSource</span>(&#123;<br>  <span class="hljs-attr">features</span>: [pointFeature],<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>4. 创建 VectorLayer</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vectorLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VectorLayer</span>(&#123;<br>  <span class="hljs-attr">source</span>: vectorSource,<br>  <span class="hljs-attr">zIndex</span>: <span class="hljs-number">10</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p><strong>5. 加入地图</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">map.<span class="hljs-title function_">addLayer</span>(vectorLayer);<br></code></pre></td></tr></table></figure><p>到这一步，一个“什么样式都没设”的矢量点已经存在了。</p><h4 id="【VectorLayer-的样式机制】"><a href="#【VectorLayer-的样式机制】" class="headerlink" title="【VectorLayer 的样式机制】"></a>【VectorLayer 的样式机制】</h4><p>VectorLayer 不像 TileLayer 那样“自带样式”，因为：</p><ul><li>Feature 是几何数据</li><li>样式完全由前端决定</li><li>样式可以是函数（与属性、缩放级别有关）</li></ul><h4 id="最基本的-Style-写法"><a href="#最基本的-Style-写法" class="headerlink" title="最基本的 Style 写法"></a>最基本的 Style 写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Style</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/style/Style&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CircleStyle</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/style/Circle&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Fill</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/style/Fill&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Stroke</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ol/style/Stroke&quot;</span>;<br><br>pointFeature.<span class="hljs-title function_">setStyle</span>(<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>(&#123;<br>    <span class="hljs-attr">image</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>(&#123;<br>      <span class="hljs-attr">radius</span>: <span class="hljs-number">6</span>,<br>      <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;red&quot;</span> &#125;),<br>      <span class="hljs-attr">stroke</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>(&#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#fff&quot;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>,<br>      &#125;),<br>    &#125;),<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><h5 id="给整个图层统一样式（推荐工程做法）"><a href="#给整个图层统一样式（推荐工程做法）" class="headerlink" title="给整个图层统一样式（推荐工程做法）"></a>给整个图层统一样式（推荐工程做法）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vectorLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VectorLayer</span>(&#123;<br>  <span class="hljs-attr">source</span>: vectorSource,<br>  <span class="hljs-attr">style</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>(&#123;<br>    <span class="hljs-attr">image</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>(&#123;<br>      <span class="hljs-attr">radius</span>: <span class="hljs-number">5</span>,<br>      <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#409eff&quot;</span> &#125;),<br>    &#125;),<br>  &#125;),<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h5 id="样式函数（进阶但常用）"><a href="#样式函数（进阶但常用）" class="headerlink" title="样式函数（进阶但常用）"></a>样式函数（进阶但常用）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vectorLayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VectorLayer</span>(&#123;<br>  <span class="hljs-attr">source</span>: vectorSource,<br>  <span class="hljs-attr">style</span>: <span class="hljs-function">(<span class="hljs-params">feature, resolution</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> type = feature.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;type&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>(&#123;<br>      <span class="hljs-attr">image</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>(&#123;<br>        <span class="hljs-attr">radius</span>: type === <span class="hljs-string">&quot;warning&quot;</span> ? <span class="hljs-number">8</span> : <span class="hljs-number">4</span>,<br>        <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123;<br>          <span class="hljs-attr">color</span>: type === <span class="hljs-string">&quot;warning&quot;</span> ? <span class="hljs-string">&quot;red&quot;</span> : <span class="hljs-string">&quot;blue&quot;</span>,<br>        &#125;),<br>      &#125;),<br>    &#125;);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h4 id="【VectorLayer-的交互能力】"><a href="#【VectorLayer-的交互能力】" class="headerlink" title="【VectorLayer 的交互能力】"></a>【VectorLayer 的交互能力】</h4><h5 id="1-点击要素（最常用）"><a href="#1-点击要素（最常用）" class="headerlink" title="1. 点击要素（最常用）"></a>1. 点击要素（最常用）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">map.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;singleclick&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> &#123;<br>  map.<span class="hljs-title function_">forEachFeatureAtPixel</span>(evt.<span class="hljs-property">pixel</span>, <span class="hljs-function">(<span class="hljs-params">feature</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(feature.<span class="hljs-title function_">getProperties</span>());<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h5 id="2-高亮选中（典型模式）"><a href="#2-高亮选中（典型模式）" class="headerlink" title="2. 高亮选中（典型模式）"></a>2. 高亮选中（典型模式）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> selectedFeature = <span class="hljs-literal">null</span>;<br><br>map.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;singleclick&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (selectedFeature) &#123;<br>    selectedFeature.<span class="hljs-title function_">setStyle</span>(defaultStyle);<br>    selectedFeature = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  map.<span class="hljs-title function_">forEachFeatureAtPixel</span>(evt.<span class="hljs-property">pixel</span>, <span class="hljs-function">(<span class="hljs-params">feature</span>) =&gt;</span> &#123;<br>    selectedFeature = feature;<br>    feature.<span class="hljs-title function_">setStyle</span>(highlightStyle);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="【生命周期】"><a href="#【生命周期】" class="headerlink" title="【生命周期】"></a>【生命周期】</h4><h5 id="1-创建时机"><a href="#1-创建时机" class="headerlink" title="1. 创建时机"></a>1. 创建时机</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  map.<span class="hljs-title function_">addLayer</span>(vectorLayer);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h5 id="2-销毁时机（防内存泄漏）"><a href="#2-销毁时机（防内存泄漏）" class="headerlink" title="2. 销毁时机（防内存泄漏）"></a>2. 销毁时机（防内存泄漏）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  vectorSource.<span class="hljs-title function_">clear</span>();<br>  map.<span class="hljs-title function_">removeLayer</span>(vectorLayer);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-自定义瓦片加载"><a href="#6-自定义瓦片加载" class="headerlink" title="6. 自定义瓦片加载"></a>6. 自定义瓦片加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//渲染地图（qgs服务的地图数据）,低分辨率</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createQgjZoomLayer1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> customTileGrid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TileGrid</span>(&#123;<br>    <span class="hljs-attr">tileSize</span>: <span class="hljs-number">1024</span>, <span class="hljs-comment">// 修改瓦片大小</span><br>    <span class="hljs-comment">// 以下参数需根据实际坐标系和服务端配置调整</span><br>    <span class="hljs-attr">origin</span>: [-<span class="hljs-number">180</span>, <span class="hljs-number">90</span>], <span class="hljs-comment">// 瓦片网格原点（示例为 EPSG:4326 常用值）</span><br>    <span class="hljs-attr">resolutions</span>: [<br>      <span class="hljs-comment">// 分辨率数组（需与服务端支持的缩放级别匹配）</span><br>      <span class="hljs-number">0.703125</span>, <span class="hljs-comment">// 缩放级别 0</span><br>      <span class="hljs-number">0.3515625</span>, <span class="hljs-comment">// 缩放级别 1</span><br>      <span class="hljs-number">0.17578125</span>, <span class="hljs-comment">// 缩放级别 2（根据实际情况扩展）</span><br>    ],<br>  &#125;);<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;leiyangUser&quot;</span>))?.<span class="hljs-property">token</span>;<br><br>  <span class="hljs-keyword">const</span> qgjMapSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TileWMS</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;baseURL&#125;</span>/map/getmap`</span>,<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">SERVICE</span>: <span class="hljs-string">&quot;WMS&quot;</span>,<br>      <span class="hljs-attr">VERSION</span>: <span class="hljs-string">&quot;1.1.0&quot;</span>,<br>      <span class="hljs-attr">REQUEST</span>: <span class="hljs-string">&quot;GetMap&quot;</span>,<br>      <span class="hljs-title class_">Map</span>: props.<span class="hljs-property">qgsMapPath</span>,<br>      <span class="hljs-attr">LAYERS</span>: props.<span class="hljs-property">tifMapPath</span>,<br>      <span class="hljs-attr">FORMAT</span>: <span class="hljs-string">&quot;image/png&quot;</span>,<br>      <span class="hljs-attr">CRS</span>: <span class="hljs-string">&quot;EPSG:4326&quot;</span>,<br>      <span class="hljs-attr">language</span>: locale.<span class="hljs-property">value</span>,<br>    &#125;,<br>    <span class="hljs-attr">tileGrid</span>: customTileGrid,<br>    <span class="hljs-attr">serverType</span>: <span class="hljs-string">&quot;geoserver&quot;</span>,<br><br>    <span class="hljs-comment">// 自定义 tile 加载函数</span><br>    <span class="hljs-attr">tileLoadFunction</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">imageTile, src</span>) &#123;<br>      <span class="hljs-title function_">fetch</span>(src, &#123;<br>        <span class="hljs-attr">headers</span>: &#123;<br>          <span class="hljs-title class_">Token</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;token&#125;</span>`</span>,<br>        &#125;,<br>      &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Network response was not ok&quot;</span>);<br>          &#125;<br>          <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">blob</span>();<br>        &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> objectUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);<br>          imageTile.<span class="hljs-title function_">getImage</span>().<span class="hljs-property">src</span> = objectUrl;<br>        &#125;)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Tile loading error:&quot;</span>, err);<br>        &#125;);<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tile</span>(&#123;<br>    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">source</span>: qgjMapSource,<br>    <span class="hljs-attr">minZoom</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">maxZoom</span>: <span class="hljs-number">12</span>,<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="【创建阶段】"><a href="#【创建阶段】" class="headerlink" title="【创建阶段】"></a>【创建阶段】</h4><h5 id="1-创建-customTileGrid"><a href="#1-创建-customTileGrid" class="headerlink" title="1. 创建 customTileGrid"></a>1. 创建 <code>customTileGrid</code></h5><p>你定义了：</p><ul><li><code>origin</code>：瓦片网格的左上角起点（决定 x&#x2F;y 怎么编号）</li><li><code>tileSize</code>：每块瓦片图片的像素大小（例如 256&#x2F;512&#x2F;1024）</li><li><code>resolutions</code>：每个 zoom 级别“一个像素代表多少地理单位（度&#x2F;像素）”</li></ul><p>这三者决定了：</p><blockquote><p>在 zoom&#x3D;z 时，视图范围会被切成哪些瓦片（z&#x2F;x&#x2F;y），每块瓦片对应什么地理范围 BBOX。 <strong>通常使用自定义的即可</strong></p></blockquote><h5 id="2-创建-TileWMS"><a href="#2-创建-TileWMS" class="headerlink" title="2. 创建 TileWMS"></a>2. 创建 <code>TileWMS</code></h5><p>你传入：</p><ul><li><code>url: /map/getmap</code></li><li><code>params: &#123;...&#125;</code> WMS 请求参数（SERVICE&#x2F;REQUEST&#x2F;LAYERS&#x2F;FORMAT&#x2F;CRS…）</li><li><code>tileGrid: customTileGrid</code></li><li><code>tileLoadFunction: ...</code></li></ul><p>这一步只是把“规则”装配好，<strong>并没有发请求</strong>。</p><h5 id="3-创建-TileLayer"><a href="#3-创建-TileLayer" class="headerlink" title="3. 创建 TileLayer"></a>3. 创建 <code>TileLayer</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tile</span>(&#123; <span class="hljs-attr">source</span>: qgjMapSource &#125;)<br></code></pre></td></tr></table></figure><p>图层对象准备好，等被 <code>map.addLayer(layer)</code> 后，才会开始触发加载。</p><h4 id="【触发阶段】"><a href="#【触发阶段】" class="headerlink" title="【触发阶段】"></a>【触发阶段】</h4><p>当你执行（显式或隐式）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">map.<span class="hljs-title function_">addLayer</span>(tileLayer)<br></code></pre></td></tr></table></figure><p>地图开始渲染，进入一次 render frame。</p><p>地图渲染引擎会问这个图层：</p><blockquote><p>“以当前 View（center&#x2F;zoom&#x2F;resolution）和屏幕大小，我需要哪些瓦片才能铺满可视区域？”</p></blockquote><h4 id="【瓦片计算阶段】"><a href="#【瓦片计算阶段】" class="headerlink" title="【瓦片计算阶段】"></a>【瓦片计算阶段】</h4><h5 id="3-1-View-给出当前分辨率-resolution"><a href="#3-1-View-给出当前分辨率-resolution" class="headerlink" title="3.1 View 给出当前分辨率 resolution"></a>3.1 View 给出当前分辨率 resolution</h5><p>例如 zoom&#x3D;2 对应 <code>resolutions[2]</code></p><h5 id="3-2-用-TileGrid-切分屏幕覆盖的地理范围"><a href="#3-2-用-TileGrid-切分屏幕覆盖的地理范围" class="headerlink" title="3.2 用 TileGrid 切分屏幕覆盖的地理范围"></a>3.2 用 TileGrid 切分屏幕覆盖的地理范围</h5><p>TileGrid 依据：</p><ul><li><code>origin</code></li><li><code>tileSize</code></li><li><code>resolution</code><br> 计算出可视范围覆盖的瓦片坐标集合：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(z, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">y</span>) 的列表<br></code></pre></td></tr></table></figure><p>这一步决定了要加载的瓦片数量和编号。</p><h4 id="【URL-生成阶段】"><a href="#【URL-生成阶段】" class="headerlink" title="【URL 生成阶段】"></a>【URL 生成阶段】</h4><p>TileWMS 拼出每块瓦片的 GetMap 请求</p><p>对每一个 (z, x, y)，TileWMS 会算出该瓦片对应的 BBOX：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">BBOX</span> = [minLon, minLat, maxLon, maxLat]<br><span class="hljs-variable constant_">WIDTH</span> = tileSize<br><span class="hljs-variable constant_">HEIGHT</span> = tileSize<br></code></pre></td></tr></table></figure><p>然后生成完整 URL（逻辑形态类似）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">/map/getmap?<br>  <span class="hljs-variable constant_">SERVICE</span>=<span class="hljs-variable constant_">WMS</span><br>  <span class="hljs-variable constant_">REQUEST</span>=<span class="hljs-title class_">GetMap</span><br>  <span class="hljs-variable constant_">VERSION</span>=<span class="hljs-number">1.1</span><span class="hljs-number">.0</span><br>  <span class="hljs-variable constant_">LAYERS</span>=...<br>  <span class="hljs-variable constant_">FORMAT</span>=image/png<br>  <span class="hljs-variable constant_">CRS</span>=<span class="hljs-attr">EPSG</span>:<span class="hljs-number">4326</span><br>  <span class="hljs-variable constant_">WIDTH</span>=<span class="hljs-number">1024</span><br>  <span class="hljs-variable constant_">HEIGHT</span>=<span class="hljs-number">1024</span><br>  <span class="hljs-variable constant_">BBOX</span>=minx,miny,maxx,maxy<br>  language=...<br>  <span class="hljs-title class_">Map</span>=...<br></code></pre></td></tr></table></figure><p>到这里为止：</p><ul><li>TileWMS 已经把每块瓦片的“请求地址”算出来了</li><li>但默认行为本应是：<code>img.src = url</code></li></ul><h4 id="【加载阶段】"><a href="#【加载阶段】" class="headerlink" title="【加载阶段】"></a>【加载阶段】</h4><p>tileLoadFunction 接管默认加载</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">tileLoadFunction</span><span class="hljs-params">(imageTile, src)</span></span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>所以 OpenLayers 对每个瓦片会调用这个函数：</p><ul><li><code>imageTile</code>：当前瓦片对象（里面有对应的 <code>&lt;img&gt;</code>）</li><li><code>src</code>：刚才生成的那条 GetMap URL</li></ul><p>你在这里做了：</p><h5 id="5-1-fetch-请求（带-Token-Header）"><a href="#5-1-fetch-请求（带-Token-Header）" class="headerlink" title="5.1 fetch 请求（带 Token Header）"></a>5.1 fetch 请求（带 Token Header）</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">fetch(<span class="hljs-attribute">src</span>, &#123; headers: &#123; Token: token &#125; &#125;)<br></code></pre></td></tr></table></figure><p>这是你不能用 XYZ 的关键原因之一：<code>&lt;img src&gt;</code> 不能带自定义 Header，而 fetch 可以。</p><h5 id="5-2-取回-PNG-二进制"><a href="#5-2-取回-PNG-二进制" class="headerlink" title="5.2 取回 PNG 二进制"></a>5.2 取回 PNG 二进制</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">response<span class="hljs-selector-class">.blob</span>()<br></code></pre></td></tr></table></figure><h5 id="5-3-转换成浏览器可用的图片-URL"><a href="#5-3-转换成浏览器可用的图片-URL" class="headerlink" title="5.3 转换成浏览器可用的图片 URL"></a>5.3 转换成浏览器可用的图片 URL</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const objectUrl <span class="hljs-operator">=</span> URL.createObjectURL(blob)<br></code></pre></td></tr></table></figure><h5 id="5-4-把瓦片的-img-指向这个-objectUrl"><a href="#5-4-把瓦片的-img-指向这个-objectUrl" class="headerlink" title="5.4 把瓦片的 img 指向这个 objectUrl"></a>5.4 把瓦片的 img 指向这个 objectUrl</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">imageTile<span class="hljs-selector-class">.getImage</span>()<span class="hljs-selector-class">.src</span> = objectUrl<br></code></pre></td></tr></table></figure><p>此时浏览器开始解码 PNG，瓦片进入“可渲染”状态。</p><h4 id="【渲染阶段】"><a href="#【渲染阶段】" class="headerlink" title="【渲染阶段】"></a>【渲染阶段】</h4><p>当 <code>&lt;img&gt;</code> 完成加载后：</p><ul><li>OpenLayers 将该瓦片标记为 loaded</li><li>在下一帧 render 时，把这块瓦片贴到正确位置</li><li>多块瓦片拼接起来，构成你看到的完整地图</li></ul><h4 id="【服务端视角：每次瓦片请求服务端在做什么】"><a href="#【服务端视角：每次瓦片请求服务端在做什么】" class="headerlink" title="【服务端视角：每次瓦片请求服务端在做什么】"></a>【服务端视角：每次瓦片请求服务端在做什么】</h4><p>你后端收到每个 GetMap 请求后，典型逻辑是：</p><ol><li>校验 Token 权限</li><li>解析 Map&#x2F;QGS、LAYERS、language 等业务参数</li><li>根据 BBOX + WIDTH&#x2F;HEIGHT 从源数据（tif&#x2F;工程&#x2F;数据库）裁剪</li><li>渲染成 PNG</li><li>返回给前端</li></ol><p>你看到的“瓦片”，是服务端<strong>按 BBOX 实时渲染</strong>出来的，不一定是磁盘上提前存好的 <code>/z/x/y.png</code>。</p><h3 id="7-绘制内容"><a href="#7-绘制内容" class="headerlink" title="7. 绘制内容"></a>7. 绘制内容</h3><p>在 OpenLayers 中，<strong>矢量图层 &#x3D; 几何 + 样式 + 属性</strong>，常见可绘制内容包括：</p><h4 id="【几何】"><a href="#【几何】" class="headerlink" title="【几何】"></a>【几何】</h4><p>几何对象的标准分类只有三种：</p><ol><li><p><strong>点（Point）</strong></p><ul><li>表示单一空间位置</li><li>由一个坐标对 <code>(x, y)</code> 定义</li><li>可附带任意属性与样式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Point</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ol/geom/Point&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Feature</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ol/Feature&#x27;</span>;<br><br><span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Feature</span>(&#123;<br>  <span class="hljs-attr">geometry</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>([x, y]) <span class="hljs-comment">// 通常需是 EPSG:3857</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>线（LineString &#x2F; MultiLineString）</strong></p><ul><li>表示由多个点按顺序连接形成的路径</li><li>至少包含两个坐标点</li><li>常用于轨迹、线路、边界线表达</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">LineString</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ol/geom/LineString&#x27;</span>;<br><br><span class="hljs-keyword">const</span> line = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Feature</span>(&#123;<br>  <span class="hljs-attr">geometry</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineString</span>([<br>    [x1, y1],<br>    [x2, y2],<br>    [x3, y3]<br>  ])<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>分段绘制线</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Feature</span>(&#123;<br>  <span class="hljs-attr">geometry</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineString</span>([p1, p2])<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>每两个相邻点生成一段线</li><li>连续追加 Feature 形成完整轨迹</li><li>非常适合实时或回放场景</li></ul></li><li><p><strong>面（Polygon &#x2F; MultiPolygon）</strong></p><ul><li>表示由闭合线围成的区域</li><li>具备内部区域与边界</li><li>常用于范围、区域、缓冲区表达</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Polygon</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ol/geom/Polygon&#x27;</span>;<br><br><span class="hljs-keyword">const</span> polygon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Feature</span>(&#123;<br>  <span class="hljs-attr">geometry</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Polygon</span>([[<br>    [x1, y1],<br>    [x2, y2],<br>    [x3, y3],<br>    [x1, y1] <span class="hljs-comment">// 闭合</span><br>  ]])<br>&#125;);<br><br></code></pre></td></tr></table></figure></li></ol><p>在 OpenLayers 中：</p><ul><li><strong>几何（Geometry）</strong> 决定“画什么”</li><li><strong>样式（Style）</strong> 决定“怎么画”</li></ul><p>因此：</p><ul><li>圆点、图标、文字，本质上都是 <strong>Point</strong></li><li>车辆、人员、设备，只是 <strong>Point + Icon 样式</strong></li><li>高亮、闪烁、分级配色，是 <strong>Style 的变化</strong></li></ul><h4 id="【样式】"><a href="#【样式】" class="headerlink" title="【样式】"></a>【样式】</h4><p>一个完整的矢量样式通常由以下几部分组成：</p><ul><li><code>image</code>：点要素的图形样式（圆点、图标等）</li><li><code>stroke</code>：线或面的边框样式</li><li><code>fill</code>：面或圆点的填充样式</li><li><code>text</code>：文字标注样式</li><li><code>zIndex</code>：绘制层级顺序</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">Style<br>├─ <span class="hljs-selector-tag">image</span>   → 仅对 Point / MultiPoint 生效<br>│   ├─ CircleStyle<br>│   │    ├─ <span class="hljs-attribute">fill</span>   → 圆点内部填充<br>│   │    └─ <span class="hljs-attribute">stroke</span> → 圆点描边<br>│   └─ <span class="hljs-attribute">Icon</span><br>│        └─ rotation / <span class="hljs-attribute">scale</span> / <span class="hljs-attribute">src</span><br>│<br>├─ <span class="hljs-attribute">stroke</span>  → 对 LineString / <span class="hljs-selector-tag">Polygon</span> 边界生效<br>│<br>├─ <span class="hljs-attribute">fill</span>    → 仅对 <span class="hljs-selector-tag">Polygon</span> 内部区域生效<br>│<br>├─ <span class="hljs-selector-tag">text</span>    → 对所有几何都可叠加（文字标注）<br>│   ├─ <span class="hljs-attribute">fill</span>   → 文字颜色<br>│   └─ <span class="hljs-attribute">stroke</span> → 文字描边<br>│<br>└─ zIndex  → 整个 Style 的绘制顺序<br><br></code></pre></td></tr></table></figure><h5 id="1-圆点样式（CircleStyle）"><a href="#1-圆点样式（CircleStyle）" class="headerlink" title="1. 圆点样式（CircleStyle）"></a>1. 圆点样式（CircleStyle）</h5><p>适用于：采样点、监测点、事件点、浓度点。</p><p><strong>常见可配置项</strong></p><ul><li><code>radius</code>：圆点半径</li><li><code>fill.color</code>：填充颜色</li><li><code>stroke.color / width</code>：描边颜色与宽度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>(&#123;<br>  <span class="hljs-attr">radius</span>: <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#ff0000&#x27;</span> &#125;),<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#ffffff&#x27;</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">1</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>常见用途：</p><ul><li>半径表达权重或级别</li><li>颜色表达数值分级</li><li>描边用于增强可读性或选中态</li></ul><hr><h5 id="2-图标样式（Icon）"><a href="#2-图标样式（Icon）" class="headerlink" title="2. 图标样式（Icon）"></a>2. 图标样式（Icon）</h5><p>适用于：车辆、设备、人员、方向性目标。</p><p><strong>常见可配置项</strong></p><ul><li><code>src</code>：图片地址</li><li><code>scale</code>：缩放比例</li><li><code>rotation</code>：旋转角度（弧度）</li><li><code>anchor</code>：锚点（决定旋转与定位中心）</li><li><code>opacity</code>：透明度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Icon</span>(&#123;<br>  <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;car.png&#x27;</span>,<br>  <span class="hljs-attr">scale</span>: <span class="hljs-number">0.6</span>,<br>  <span class="hljs-attr">rotation</span>: angle,<br>  <span class="hljs-attr">anchor</span>: [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>],<br>  <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>常见用途：</p><ul><li>方向随轨迹变化</li><li>缩放区分对象类型</li><li>通过 rotation 表示运动方向</li></ul><hr><h5 id="3-点文字标注（Text）"><a href="#3-点文字标注（Text）" class="headerlink" title="3. 点文字标注（Text）"></a>3. 点文字标注（Text）</h5><p>适用于：点位名称、数值显示、编号。</p><p><strong>常见可配置项</strong></p><ul><li><code>text</code>：显示内容</li><li><code>font</code>：字体大小与类型</li><li><code>fill.color</code>：文字颜色</li><li><code>stroke</code>：文字描边（增强对比）</li><li><code>offsetX / offsetY</code>：文字偏移</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(&#123;<br>  <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;监测点A&#x27;</span>,<br>  <span class="hljs-attr">font</span>: <span class="hljs-string">&#x27;12px sans-serif&#x27;</span>,<br>  <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#000&#x27;</span> &#125;),<br>  <span class="hljs-attr">stroke</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#fff&#x27;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">2</span> &#125;),<br>  <span class="hljs-attr">offsetY</span>: -<span class="hljs-number">15</span><br>&#125;)<br></code></pre></td></tr></table></figure><hr><h5 id="4-线条基础样式（Stroke）"><a href="#4-线条基础样式（Stroke）" class="headerlink" title="4. 线条基础样式（Stroke）"></a>4. 线条基础样式（Stroke）</h5><p>适用于：轨迹、路径、管线、边界线。</p><p><strong>常见可配置项</strong></p><ul><li><code>color</code>：线颜色</li><li><code>width</code>：线宽</li><li><code>lineDash</code>：虚线样式</li><li><code>lineCap</code>：线端样式</li><li><code>lineJoin</code>：转角样式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#12FF9B&#x27;</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">lineDash</span>: [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>],<br>  <span class="hljs-attr">lineCap</span>: <span class="hljs-string">&#x27;round&#x27;</span>,<br>  <span class="hljs-attr">lineJoin</span>: <span class="hljs-string">&#x27;round&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>常见用途：</p><ul><li>实线 &#x2F; 虚线区分状态</li><li>线宽表示重要程度</li><li>颜色表示类型或告警级别</li></ul><hr><h5 id="6-线文字标注（沿线标注）"><a href="#6-线文字标注（沿线标注）" class="headerlink" title="6. 线文字标注（沿线标注）"></a>6. 线文字标注（沿线标注）</h5><p>适用于：道路名称、管线编号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>(&#123;<br>  <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;轨迹&#x27;</span>,<br>  <span class="hljs-attr">placement</span>: <span class="hljs-string">&#x27;line&#x27;</span>,<br>  <span class="hljs-attr">font</span>: <span class="hljs-string">&#x27;12px sans-serif&#x27;</span>,<br>  <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#000&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="7-面填充（Fill）"><a href="#7-面填充（Fill）" class="headerlink" title="7. 面填充（Fill）"></a>7. 面填充（Fill）</h5><p>适用于：区域、范围、影响区、行政区。</p><p><strong>常见可配置项</strong></p><ul><li><code>color</code>：填充颜色（通常使用半透明）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;rgba(255,0,0,0.3)&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><hr><h5 id="2-面边界（Stroke）"><a href="#2-面边界（Stroke）" class="headerlink" title="2. 面边界（Stroke）"></a>2. 面边界（Stroke）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Stroke</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#ff0000&#x27;</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">2</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>常见组合：</p><ul><li>半透明填充 + 实线边界</li><li>不同颜色表示不同风险等级</li></ul><hr><h4 id="【样式的三种使用方式】"><a href="#【样式的三种使用方式】" class="headerlink" title="【样式的三种使用方式】"></a>【样式的三种使用方式】</h4><h5 id="1-图层统一样式"><a href="#1-图层统一样式" class="headerlink" title="1. 图层统一样式"></a>1. 图层统一样式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">VectorLayer</span>(&#123;<br>  source,<br>  <span class="hljs-attr">style</span>: fixedStyle<br>&#125;)<br></code></pre></td></tr></table></figure><p>适用于：</p><ul><li>静态要素</li><li>样式一致的图层</li></ul><hr><h5 id="2-基于-Feature-的样式函数"><a href="#2-基于-Feature-的样式函数" class="headerlink" title="2. 基于 Feature 的样式函数"></a>2. 基于 Feature 的样式函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">style</span>: <span class="hljs-function"><span class="hljs-params">feature</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>(&#123;<br>    <span class="hljs-attr">image</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleStyle</span>(&#123;<br>      <span class="hljs-attr">radius</span>: feature.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;radius&#x27;</span>),<br>      <span class="hljs-attr">fill</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fill</span>(&#123; <span class="hljs-attr">color</span>: feature.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;color&#x27;</span>) &#125;)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>适用于：</p><ul><li>实时数据</li><li>数值分级渲染</li><li>同一图层不同样式</li></ul><hr><h5 id="3-交互中动态-setStyle"><a href="#3-交互中动态-setStyle" class="headerlink" title="3. 交互中动态 setStyle"></a>3. 交互中动态 setStyle</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">feature.<span class="hljs-title function_">setStyle</span>(highlightStyle);<br></code></pre></td></tr></table></figure><p>适用于：</p><ul><li>点击高亮</li><li>选中态</li><li>告警态切换</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.浏览器渲染触发的两个事件</title>
    <link href="/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%A7%A6%E5%8F%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BA%8B%E4%BB%B6/"/>
    <url>/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/14-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%A7%A6%E5%8F%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>浏览器渲染触发的两个事件</p><span id="more"></span><h2 id="浏览器渲染触发的两个事件"><a href="#浏览器渲染触发的两个事件" class="headerlink" title="浏览器渲染触发的两个事件"></a><strong>浏览器渲染触发的两个事件</strong></h2><p><a href="https://cxdlogver.github.io/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2">浏览器页面渲染流程 - 相</a></p><blockquote><p>浏览器渲染过程中有两个关键事件：DOMContentLoaded 和 load。DOMContentLoaded 在 HTML 解析完成、DOM 树构建完成时触发，此时可以安全操作 DOM，但不等待图片等外部资源加载；load 事件在页面所有资源，包括图片、CSS、iframe 等全部加载完成后触发，通常用于依赖完整资源的逻辑。二者的主要区别在于是否等待外部资源，且 DOMContentLoaded 一定早于 load 触发。</p></blockquote><h3 id="1-DOMContentLoaded"><a href="#1-DOMContentLoaded" class="headerlink" title="1. DOMContentLoaded"></a>1. DOMContentLoaded</h3><h4 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h4><blockquote><p><strong>HTML 文档解析完成，DOM 树构建完成时触发</strong></p></blockquote><p>此时浏览器已经：</p><ul><li>下载并解析了 HTML</li><li>构建完成 DOM 树</li></ul><p>但<strong>尚未保证</strong>：</p><ul><li>图片是否加载完成</li><li>CSS、字体、iframe 是否全部加载完成</li></ul><hr><h4 id="触发时，浏览器完成了什么"><a href="#触发时，浏览器完成了什么" class="headerlink" title="触发时，浏览器完成了什么"></a>触发时，浏览器完成了什么</h4><ul><li>DOM 节点可以被安全访问</li><li><code>document.querySelector</code> 等 DOM API 可用</li><li>JS 可以开始操作页面结构</li></ul><hr><h4 id="不包含的内容"><a href="#不包含的内容" class="headerlink" title="不包含的内容"></a>不包含的内容</h4><ul><li>不等待图片加载</li><li>不等待视频、音频</li><li>不等待 iframe</li><li>不保证所有 CSS 已下载完成（但会阻塞渲染）</li></ul><hr><h4 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h4><ul><li>初始化页面逻辑</li><li>绑定事件</li><li>操作 DOM</li><li>启动框架（Vue &#x2F; React 挂载）</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">document.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> DOM 已就绪<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h4 id="面试一句话回答"><a href="#面试一句话回答" class="headerlink" title="面试一句话回答"></a>面试一句话回答</h4><blockquote><p>DOMContentLoaded 表示 HTML 已解析完成，DOM 树已构建完成，可以安全操作 DOM，但不关心图片等资源是否加载完成。</p></blockquote><hr><h3 id="2-load"><a href="#2-load" class="headerlink" title="2. load"></a>2. load</h3><h4 id="触发时机-1"><a href="#触发时机-1" class="headerlink" title="触发时机"></a>触发时机</h4><blockquote><p><strong>页面中所有资源加载完成后触发</strong></p></blockquote><p>包括：</p><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>图片</li><li>字体</li><li>iframe</li><li>视频、音频等</li></ul><hr><h4 id="触发时，浏览器完成了什么-1"><a href="#触发时，浏览器完成了什么-1" class="headerlink" title="触发时，浏览器完成了什么"></a>触发时，浏览器完成了什么</h4><ul><li>页面所需的所有外部资源都已加载</li><li>页面进入“完全可用”状态</li></ul><hr><h4 id="常见使用场景-1"><a href="#常见使用场景-1" class="headerlink" title="常见使用场景"></a>常见使用场景</h4><ul><li>获取图片真实尺寸</li><li>做页面完整渲染后的统计</li><li>上报首屏&#x2F;页面完全加载时间</li><li>依赖资源加载完成的逻辑</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">window.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> 所有资源加载完成<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h4 id="面试一句话回答-1"><a href="#面试一句话回答-1" class="headerlink" title="面试一句话回答"></a>面试一句话回答</h4><blockquote><p>load 事件表示页面所有资源都已加载完成，包括图片和 iframe，触发时间晚于 DOMContentLoaded。</p></blockquote><hr><h3 id="3-二者的核心对比"><a href="#3-二者的核心对比" class="headerlink" title="3. 二者的核心对比"></a>3. 二者的核心对比</h3><table><thead><tr><th>对比点</th><th>DOMContentLoaded</th><th>load</th></tr></thead><tbody><tr><td>是否等待 DOM</td><td>是</td><td>是</td></tr><tr><td>是否等待图片</td><td>否</td><td>是</td></tr><tr><td>是否等待 CSS</td><td>不保证</td><td>是</td></tr><tr><td>是否等待 iframe</td><td>否</td><td>是</td></tr><tr><td>触发时机</td><td>较早</td><td>较晚</td></tr><tr><td>典型用途</td><td>初始化 DOM</td><td>依赖完整资源</td></tr></tbody></table><h3 id="CSS-会阻塞渲染"><a href="#CSS-会阻塞渲染" class="headerlink" title="CSS 会阻塞渲染"></a>CSS 会阻塞渲染</h3><p>CSS 不阻塞 DOM 构建，但会阻塞 Render Tree 和页面绘制。</p><blockquote><p>HTML 解析和 CSS 解析是并发进行的，浏览器在解析 HTML 的过程中，一旦遇到 CSS 会立即下载并解析样式表，但 HTML 解析本身不会被 CSS 阻塞。不过，CSS 会阻塞页面渲染，因为渲染需要同时依赖 DOM 和 CSSOM，在 CSSOM 构建完成之前，浏览器无法确定元素的最终样式，因此不会进行绘制。</p></blockquote><h3 id="HTML-解析过程"><a href="#HTML-解析过程" class="headerlink" title="HTML 解析过程"></a>HTML 解析过程</h3><blockquote><p>浏览器在加载 HTML 后，会自上而下解析文档，将 HTML 字符流进行词法和语法分析，生成对应的 DOM 节点，并按照父子关系逐步构建 DOM 树。解析过程是边下载边解析的，遇到外部资源会并行请求；在 DOM 树构建完成后，浏览器才能结合 CSSOM 进入后续的渲染流程。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0.前端面试题一</title>
    <link href="/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/0-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <url>/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/0-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="资源汇总"><a href="#资源汇总" class="headerlink" title="资源汇总"></a>资源汇总</h2><blockquote><p><a href="https://www.bilibili.com/opus/379030881059278529">2025最新Web前端学习路线 - 哔哩哔哩</a></p><p><a href="https://www.yuque.com/cuggz/feplus">前端知识进阶</a></p><p><a href="https://www.yuque.com/cuggz/interview">前端面试题汇总</a></p><p><a href="https://github.com/febobo/web-interview">febobo&#x2F;web-interview: 语音打卡社群维护的前端面试题库，包含不限于Vue面试题，React面试题，JS面试题，HTTP面试题，工程化面试题，CSS面试题，算法面试题，大厂面试题，高频面试题</a></p><p><a href="https://www.mianshiya.com/bank/1810644471159848962">前端 JavaScript 基础面试题 - 面试鸭 - 程序员求职面试刷题神器</a></p><p><a href="https://github.com/lgwebdream/FE-Interview/tree/master">lgwebdream&#x2F;FE-Interview: 🔥🔥🔥 前端面试，独有前端面试题详解，前端面试刷题必备，1000+前端面试真题，Html、Css、JavaScript、Vue、React、Node、TypeScript、Webpack、算法、网络与安全、浏览器</a></p><p><a href="https://github.com/paddingme/Front-end-Web-Development-Interview-Question">paddingme&#x2F;Front-end-Web-Development-Interview-Question: 前端开发面试题大收集，前端面试集锦 :gift_heart: :cupid:</a></p></blockquote><h2 id="1-会话控制"><a href="#1-会话控制" class="headerlink" title="1. 会话控制"></a>1. 会话控制</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6">会话控制 - 相</a></p></blockquote><h2 id="2-常用的-npm-pnpm-yarn-命令"><a href="#2-常用的-npm-pnpm-yarn-命令" class="headerlink" title="2. 常用的 npm &#x2F; pnpm &#x2F; yarn 命令"></a>2. 常用的 <strong>npm &#x2F; pnpm &#x2F; yarn</strong> <strong>命令</strong></h2><blockquote><p><a href="https://cxdlogver.github.io/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#Yarn%E5%92%8CPnpm"> npm &#x2F; pnpm &#x2F; yarn 命令</a></p></blockquote><h2 id="3-RESTful-规则"><a href="#3-RESTful-规则" class="headerlink" title="3.  RESTful 规则"></a>3.  RESTful 规则</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#RESTFul%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1">RESTful 规则</a></p></blockquote><h2 id="4-Chrome-DevTools-常用面板总览"><a href="#4-Chrome-DevTools-常用面板总览" class="headerlink" title="4. Chrome DevTools 常用面板总览"></a>4. Chrome DevTools 常用面板总览</h2><table><thead><tr><th>面板</th><th>主要作用</th><th>解决的问题</th></tr></thead><tbody><tr><td>Elements</td><td>DOM &#x2F; CSS 调试</td><td>页面结构与样式问题</td></tr><tr><td>Console</td><td>JS 输出与交互</td><td>运行时错误、调试</td></tr><tr><td>Sources</td><td>源码调试</td><td>断点、调用栈</td></tr><tr><td>Network</td><td>网络请求</td><td>接口、资源加载</td></tr><tr><td>Performance</td><td>性能分析</td><td>卡顿、首屏慢</td></tr><tr><td>Memory</td><td>内存分析</td><td>内存泄漏</td></tr><tr><td>Application</td><td>存储与缓存</td><td>Cookie &#x2F; Storage</td></tr><tr><td>Security</td><td>安全信息</td><td>HTTPS &#x2F; 证书</td></tr><tr><td>Lighthouse</td><td>质量评估</td><td>性能、SEO、PWA</td></tr></tbody></table><p><strong>Elements</strong><br> 用于查看浏览器实际渲染后的 DOM 结构和样式来源，重点排查 CSS 覆盖、优先级和继承问题；通过实时修改样式验证布局方案，并结合盒模型分析 margin、padding 导致的布局偏移；同时利用节点高亮和事件信息，快速确认交互区域对应的具体元素。</p><p><strong>Console</strong><br> 用于查看运行时错误、警告和调用栈信息，辅助快速定位异常；在调试过程中输出关键变量、接口返回和异常分支结果；必要时在控制台直接执行 JavaScript，用于验证逻辑或读取当前页面状态，提高问题排查效率。</p><p><strong>Sources</strong><br> 配合 SourceMap 进行 JavaScript 断点调试，通过行断点或条件断点单步跟踪执行流程，查看作用域和闭包变量；在处理异步逻辑时，重点分析 Promise 和 async&#x2F;await 的执行顺序，并通过 XHR &#x2F; fetch 断点定位请求触发的具体代码位置。</p><p><strong>Network</strong><br> 用于分析网络请求和资源加载过程，重点查看请求的 URL、方法、状态码、参数以及响应内容；排查跨域、Cookie 携带和缓存命中情况；通过瀑布图分析性能瓶颈所在阶段（如 DNS、TCP、TTFB 或下载），并结合弱网模拟和禁用缓存复现首屏加载问题。</p><p><strong>Application</strong><br> 用于检查和管理浏览器侧的存储与缓存，包括 Cookie、localStorage、sessionStorage、IndexedDB 和 Cache Storage；验证登录态和会话信息是否正确写入；在使用 Service Worker 或 PWA 场景下，确认请求是否被接管以及缓存策略是否生效，并在必要时进行缓存清理和版本切换。</p><p><strong>Performance</strong><br> 用于分析页面运行性能，通过录制时间线定位卡顿原因，判断是 JavaScript 长任务还是频繁的布局和绘制操作导致主线程阻塞；在首屏分析中重点关注脚本执行、样式计算和渲染阶段的耗时分布。</p><p>下面逐个说明。</p><h3 id="1-Elements（元素面板）"><a href="#1-Elements（元素面板）" class="headerlink" title="1. Elements（元素面板）"></a>1. Elements（元素面板）</h3><p><strong>作用</strong>：<br> 用于查看和修改 <strong>DOM 结构与 CSS 样式</strong>。</p><p><strong>常见使用场景</strong>：</p><ul><li>查看真实渲染后的 DOM（不是源码）</li><li>临时修改 CSS，验证布局效果</li><li>定位样式覆盖、优先级问题</li><li>查看盒模型（margin &#x2F; border &#x2F; padding）</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Elements 面板用于调试“页面长什么样、为什么这么显示”。</p></blockquote><hr><h3 id="2-Console（控制台）"><a href="#2-Console（控制台）" class="headerlink" title="2. Console（控制台）"></a>2. Console（控制台）</h3><p><strong>作用</strong>：<br> 用于 <strong>JavaScript 输出、报错查看和即时执行代码</strong>。</p><p><strong>常见使用场景</strong>：</p><ul><li>查看运行时错误和警告</li><li>使用 <code>console.log / warn / error</code></li><li>即时执行 JS（查看变量、调用函数）</li><li>查看 Promise 未捕获异常</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Console 是前端的“运行时窗口”。</p></blockquote><hr><h3 id="3-Sources（源码面板）"><a href="#3-Sources（源码面板）" class="headerlink" title="3. Sources（源码面板）"></a>3. Sources（源码面板）</h3><p><strong>作用</strong>：<br> 用于 <strong>调试 JavaScript 源码</strong>。</p><p><strong>核心能力</strong>：</p><ul><li>打断点（行断点、条件断点）</li><li>单步执行（step over &#x2F; into &#x2F; out）</li><li>查看调用栈（Call Stack）</li><li>查看作用域变量（Scope）</li><li>调试 SourceMap 映射后的源码</li></ul><p><strong>典型场景</strong>：</p><ul><li>定位复杂逻辑 Bug</li><li>调试异步代码（Promise &#x2F; async）</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Sources 面板解决的是“代码为什么这样执行”。</p></blockquote><hr><h3 id="4-Network（网络面板）"><a href="#4-Network（网络面板）" class="headerlink" title="4. Network（网络面板）"></a>4. Network（网络面板）</h3><p><strong>作用</strong>：<br> 用于查看 <strong>所有网络请求和资源加载过程</strong>。</p><p><strong>可以看到什么</strong>：</p><ul><li>请求 URL、方法、状态码</li><li>请求头 &#x2F; 响应头</li><li>请求参数 &#x2F; 返回数据</li><li>请求耗时（DNS、TCP、TTFB）</li><li>是否命中缓存（Cache &#x2F; Service Worker）</li></ul><p><strong>常见使用场景</strong>：</p><ul><li>调试接口是否成功</li><li>分析接口慢的原因</li><li>验证缓存、跨域、Cookie</li><li>查看资源加载顺序</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Network 面板是排查“请求为什么慢 &#x2F; 为什么失败”的核心工具。</p></blockquote><hr><h3 id="5-Performance（性能面板）"><a href="#5-Performance（性能面板）" class="headerlink" title="5. Performance（性能面板）"></a>5. Performance（性能面板）</h3><p><strong>作用</strong>：<br> 用于 <strong>分析页面运行性能和卡顿原因</strong>。</p><p><strong>可以分析</strong>：</p><ul><li>JS 执行时间</li><li>渲染（Layout &#x2F; Paint）</li><li>主线程是否被阻塞</li><li>帧率（FPS）</li></ul><p><strong>典型场景</strong>：</p><ul><li>页面卡顿</li><li>滚动不流畅</li><li>首屏加载慢</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Performance 用来回答“页面为什么卡”。</p></blockquote><hr><h3 id="6-Memory（内存面板）"><a href="#6-Memory（内存面板）" class="headerlink" title="6. Memory（内存面板）"></a>6. Memory（内存面板）</h3><p><strong>作用</strong>：<br> 用于分析 <strong>内存占用与内存泄漏</strong>。</p><p><strong>主要功能</strong>：</p><ul><li>Heap Snapshot（堆快照）</li><li>查看对象是否被释放</li><li>对比多次快照找泄漏</li></ul><p><strong>典型场景</strong>：</p><ul><li>页面用久了越来越卡</li><li>SPA 切换页面后内存不降</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Memory 面板用于定位“内存为什么一直涨”。</p></blockquote><hr><h3 id="7-Application（应用面板）"><a href="#7-Application（应用面板）" class="headerlink" title="7. Application（应用面板）"></a>7. Application（应用面板）</h3><p><strong>作用</strong>：<br> 用于查看和管理 <strong>浏览器存储与应用状态</strong>。</p><p><strong>包含内容</strong>：</p><ul><li>Cookie</li><li>localStorage &#x2F; sessionStorage</li><li>IndexedDB</li><li>Cache Storage</li><li>Service Worker</li><li>Manifest</li></ul><p><strong>典型场景</strong>：</p><ul><li>调试登录态</li><li>查看缓存是否生效</li><li>清除存储数据</li><li>调试 PWA</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Application 面板是浏览器存储和离线能力的总控制台。</p></blockquote><hr><h3 id="8-Security（安全面板）"><a href="#8-Security（安全面板）" class="headerlink" title="8. Security（安全面板）"></a>8. Security（安全面板）</h3><p><strong>作用</strong>：<br> 用于查看页面的 <strong>安全状态</strong>。</p><p><strong>可以看到</strong>：</p><ul><li>HTTPS 是否生效</li><li>证书是否可信</li><li>混合内容（HTTP + HTTPS）</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Security 面板用于判断“页面是否安全访问”。</p></blockquote><hr><h3 id="9-Lighthouse（质量评估）"><a href="#9-Lighthouse（质量评估）" class="headerlink" title="9. Lighthouse（质量评估）"></a>9. Lighthouse（质量评估）</h3><p><strong>作用</strong>：<br> 用于生成页面的 <strong>综合质量报告</strong>。</p><p><strong>评估维度</strong>：</p><ul><li>性能（Performance）</li><li>可访问性（Accessibility）</li><li>最佳实践（Best Practices）</li><li>SEO</li><li>PWA</li></ul><p><strong>典型场景</strong>：</p><ul><li>首屏性能评估</li><li>上线前质量检查</li></ul><p><strong>面试理解一句话</strong>：</p><blockquote><p>Lighthouse 是前端页面的“体检报告”。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.浏览器存储方式</title>
    <link href="/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/13-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/13-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>从工程视角看，浏览器存储主要分为四类：协议级存储 Cookie、页面级状态存储 Web Storage、本地数据层 IndexedDB，以及网络缓存层 Cache API。</p><p>Cookie 是 HTTP 协议级存储机制，主要用于会话保持和身份识别，最大特点是会在满足条件时自动随请求发送给服务器，并支持 HttpOnly、Secure、SameSite 等安全属性，因此非常适合存放 Session ID 等高安全信息，但不适合存储业务数据。</p><p>localStorage 和 sessionStorage 属于 Web Storage，用于在前端持久化保存少量状态数据，不参与 HTTP 请求。二者区别在于生命周期：localStorage 是持久化的、同源多标签共享；sessionStorage 只在当前标签页有效。它们都是同步 API，适合存储用户偏好或页面中间态，但不适合高频、大数据或安全敏感信息。</p><p>IndexedDB 是浏览器内置的本地数据库，支持异步 API、对象存储、索引和事务，能够存储大规模结构化数据。所有读写操作必须在事务中完成，通过原子提交和自动回滚保证数据一致性，因此 IndexedDB 通常作为前端的数据层，用于离线应用、大数据缓存或实时系统的数据缓冲。</p><p>Cache API 是用于缓存 HTTP 请求与响应的存储机制，通常与 Service Worker 配合使用，主要解决静态资源缓存、接口响应缓存、离线访问和首屏性能优化等问题。它缓存的是 Request-Response，而不是业务对象，与 IndexedDB 的职责是明确区分的。</p><p>总体来说，浏览器存储并不是相互替代关系，而是协议层、状态层、数据层和网络层各司其职，在实际工程中往往需要组合使用。</p><span id="more"></span><h2 id="浏览器存储方式"><a href="#浏览器存储方式" class="headerlink" title="浏览器存储方式"></a>浏览器存储方式</h2><p>但随着 Web 应用形态从“页面文档”演进为“富客户端应用（Rich Web App）”，浏览器开始承担以下职责：</p><ul><li>保存用户会话状态</li><li>缓存用户配置与偏好</li><li>支持离线访问与断网恢复</li><li>本地持久化大量结构化数据</li><li>优化网络性能与资源加载效率</li></ul><p>单一的存储方案无法同时满足 <strong>安全性、容量、性能、生命周期、网络参与度</strong> 等多维约束，因此浏览器逐步形成了<strong>分层、分工明确的存储体系</strong>。</p><h3 id="1-浏览器存储的整体分层视角"><a href="#1-浏览器存储的整体分层视角" class="headerlink" title="1. 浏览器存储的整体分层视角"></a>1. 浏览器存储的整体分层视角</h3><p>从工程视角看，浏览器存储可以划分为四个层次：</p><ol><li><strong>协议级存储（HTTP 层）</strong><br> Cookie</li><li><strong>页面级状态存储（Web Storage）</strong><br> localStorage &#x2F; sessionStorage</li><li><strong>本地数据层存储（Client-side Database）</strong><br> IndexedDB</li><li><strong>网络资源缓存层（Network Cache）</strong><br> Cache Storage（Service Worker）</li></ol><p>理解这一分层，是后续所有选型与设计的前提。</p><table><thead><tr><th>维度</th><th>Cookie</th><th>localStorage</th><th>sessionStorage</th><th>IndexedDB</th><th>Cache Storage</th></tr></thead><tbody><tr><td>所属层级</td><td>HTTP 协议层</td><td>Web Storage</td><td>Web Storage</td><td>本地数据库层</td><td>网络缓存层</td></tr><tr><td>设计初衷</td><td>会话保持 &#x2F; 身份识别</td><td>持久化前端状态</td><td>页面会话状态</td><td>本地结构化数据存储</td><td>HTTP 响应缓存</td></tr><tr><td>是否随请求发送</td><td>是（自动）</td><td>否</td><td>否</td><td>否</td><td>否（由 SW 控制）</td></tr><tr><td>生命周期</td><td>会话 &#x2F; 持久（可配置）</td><td>永久（手动清除）</td><td>页面生命周期</td><td>永久（可管理）</td><td>由缓存策略控制</td></tr><tr><td>作用域</td><td>同源 + Path &#x2F; Domain</td><td>同源</td><td>同源 + 单标签页</td><td>同源</td><td>同源</td></tr><tr><td>存储容量</td><td>极小（≈4KB&#x2F;条）</td><td>小（≈5–10MB）</td><td>小（≈5MB）</td><td>大（几十 MB 以上）</td><td>不固定（依浏览器策略）</td></tr><tr><td>数据结构</td><td>字符串</td><td>字符串</td><td>字符串</td><td>对象 &#x2F; 索引 &#x2F; Blob</td><td>Request → Response</td></tr><tr><td>API 特性</td><td>自动读写（HTTP）</td><td>同步</td><td>同步</td><td>异步</td><td>异步</td></tr><tr><td>是否阻塞主线程</td><td>否</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>安全控制能力</td><td>很强（HttpOnly &#x2F; Secure &#x2F; SameSite）</td><td>无内建安全</td><td>无内建安全</td><td>同源隔离</td><td>同源 + SW</td></tr><tr><td>XSS 风险</td><td>低（HttpOnly）</td><td>高</td><td>高</td><td>中</td><td>低</td></tr><tr><td>是否适合业务数据</td><td>否</td><td>少量</td><td>临时</td><td>是</td><td>否</td></tr><tr><td>典型使用场景</td><td>登录态、Session、鉴权</td><td>用户配置、偏好</td><td>表单中间态</td><td>离线数据、大缓存</td><td>离线资源、接口缓存</td></tr><tr><td>是否推荐新项目使用</td><td>必须（合理配置）</td><td>适度</td><td>适度</td><td>强烈推荐</td><td>强烈推荐</td></tr></tbody></table><h3 id="1-Cookie存储"><a href="#1-Cookie存储" class="headerlink" title="1. Cookie存储"></a>1. Cookie存储</h3><blockquote><p>Cookie 是一种 HTTP 协议级存储机制，主要用于在无状态的 HTTP 请求之间维持会话和身份信息。它的最大特点是会在满足条件时自动随同源请求发送给服务器。Cookie 支持 HttpOnly、Secure、SameSite 等安全属性，因此非常适合存放 Session ID 等高安全要求的信息。相比 localStorage，Cookie 容量小、但安全性和协议参与度更高，主要用于登录态和服务端身份识别，而不适合存储业务数据。</p></blockquote><h4 id="【什么是-Cookie（定义）】"><a href="#【什么是-Cookie（定义）】" class="headerlink" title="【什么是 Cookie（定义）】"></a>【什么是 Cookie（定义）】</h4><p><strong>Cookie 是浏览器提供的一种 HTTP 协议级存储机制</strong>，用于在<strong>无状态的 HTTP 协议之上维持客户端与服务器之间的会话状态</strong>。</p><p>其核心特征是：</p><ul><li>Cookie 由浏览器统一管理</li><li>Cookie 会在满足条件时 <strong>自动随同源 HTTP 请求发送到服务器</strong></li><li>Cookie 是<strong>协议的一部分，而不是普通前端存储</strong></li></ul><h4 id="【Cookie-的核心作用】"><a href="#【Cookie-的核心作用】" class="headerlink" title="【Cookie 的核心作用】"></a>【Cookie 的核心作用】</h4><p>Cookie 主要用于解决以下问题：</p><ol><li><strong>身份识别（Authentication）</strong></li><li><strong>会话保持（Session Management）</strong></li><li><strong>安全控制（CSRF &#x2F; 风控）</strong></li><li><strong>服务端无状态架构下的客户端标识</strong></li></ol><p>一句话总结：</p><blockquote><p>Cookie 的本质作用是 <strong>让服务器在多次请求中“识别同一个客户端”</strong></p></blockquote><h4 id="【Cookie-的工作机制】"><a href="#【Cookie-的工作机制】" class="headerlink" title="【Cookie 的工作机制】"></a>【Cookie 的工作机制】</h4><ol><li>设置阶段</li></ol><ul><li>服务端通过 <code>Set-Cookie</code> 响应头下发 Cookie</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Set-Cookie: <span class="hljs-attribute">sessionId</span>=abc123; HttpOnly; Secure; <span class="hljs-attribute">SameSite</span>=Lax<br></code></pre></td></tr></table></figure><ol start="2"><li>存储阶段</li></ol><ul><li>浏览器按 <strong>Domain &#x2F; Path &#x2F; Secure &#x2F; SameSite</strong> 等规则保存 Cookie</li></ul><ol start="3"><li>发送阶段</li></ol><ul><li>浏览器在后续请求中 <strong>自动携带匹配的 Cookie</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Cookie: <span class="hljs-attribute">sessionId</span>=abc123<br></code></pre></td></tr></table></figure><p><strong>关键点</strong>：</p><ul><li>前端 JS 不需要（也无法）手动控制发送</li><li>是否发送由浏览器与 Cookie 属性共同决定</li></ul><h4 id="【Cookie-的关键属性】"><a href="#【Cookie-的关键属性】" class="headerlink" title="【Cookie 的关键属性】"></a>【Cookie 的关键属性】</h4><ol><li>生命周期控制</li></ol><ul><li><code>Expires</code> &#x2F; <code>Max-Age</code><ul><li>不设置：会话 Cookie（关闭浏览器失效）</li><li>设置：持久 Cookie（到期才失效）</li></ul></li></ul><ol start="2"><li>作用域控制</li></ol><ul><li><code>Domain</code>：允许子域共享</li><li><code>Path</code>：限制请求路径</li></ul><ol start="3"><li>安全相关属性（重点）</li></ol><p><code>HttpOnly</code></p><ul><li>禁止 JavaScript 访问</li><li>防止 XSS 窃取 Cookie</li></ul><p><code>Secure</code></p><ul><li>仅在 HTTPS 请求中携带</li><li>防止明文传输泄露</li></ul><p><code>SameSite</code></p><ul><li>控制跨站请求是否携带 Cookie</li><li>用于防御 CSRF<ul><li><code>Strict</code>：完全禁止跨站</li><li><code>Lax</code>：默认推荐，安全与可用性平衡</li><li><code>None</code>：允许跨站（必须配合 <code>Secure</code>）</li></ul></li></ul><h4 id="【Cookie-的安全特性与风险】"><a href="#【Cookie-的安全特性与风险】" class="headerlink" title="【Cookie 的安全特性与风险】"></a>【Cookie 的安全特性与风险】</h4><p>安全优势</p><ul><li>支持 HttpOnly，JS 无法读取</li><li>支持 SameSite，防 CSRF</li><li>支持 Secure，防中间人攻击</li></ul><p>安全风险</p><ul><li>若 SameSite 配置不当，可能引发 CSRF</li><li>若未开启 Secure，可能被明文窃听</li><li>若 Domain &#x2F; Path 配置过宽，可能被滥用</li></ul><p><strong>工程结论</strong>：</p><blockquote><p>Cookie 是目前 <strong>唯一具备完整安全控制能力的浏览器存储机制</strong></p></blockquote><h3 id="2-localStorage-sessionStorage"><a href="#2-localStorage-sessionStorage" class="headerlink" title="2. localStorage &#x2F; sessionStorage"></a>2. localStorage &#x2F; sessionStorage</h3><blockquote><p>localStorage 和 sessionStorage 是浏览器提供的 Web Storage 机制，用于在客户端持久化保存前端状态数据，不会参与 HTTP 请求。二者的主要区别在于生命周期：localStorage 是持久化的，在同源下多个标签页共享；sessionStorage 只在当前标签页有效，关闭页面即失效。它们都是同步 API，只适合存储少量、非敏感的前端状态数据，不适合存储高安全信息。</p></blockquote><h4 id="【基础概念】"><a href="#【基础概念】" class="headerlink" title="【基础概念】"></a>【基础概念】</h4><p>localStorage 和 sessionStorage 是浏览器提供的 <strong>Web Storage 机制</strong>，用于在<strong>不参与 HTTP 协议的前提下</strong>，在客户端持久化保存前端状态数据。它们本质上是 <strong>基于同源策略的 Key-Value 存储</strong>。</p><p>一句话总结：</p><blockquote><p>Web Storage 是 <strong>纯前端侧的状态存储方案</strong>。</p></blockquote><p>二者的核心区别（一句话必答）</p><p>localStorage 是 <strong>持久化存储</strong>，关闭浏览器仍然存在；</p><p>sessionStorage 是 <strong>会话级存储</strong>，仅在当前标签页生命周期内有效。</p><h4 id="【共同特性】"><a href="#【共同特性】" class="headerlink" title="【共同特性】"></a>【共同特性】</h4><p>localStorage 和 sessionStorage 具有以下共同点：</p><ol><li><strong>同源限制</strong><ul><li>协议 + 域名 + 端口一致才能访问</li></ul></li><li><strong>Key-Value 存储</strong><ul><li>只能存字符串（对象需序列化）</li></ul></li><li><strong>不参与 HTTP 请求</strong><ul><li>不会自动随请求发送到服务器</li></ul></li><li><strong>同步 API</strong><ul><li>读写会阻塞主线程</li></ul></li><li><strong>前端可直接访问</strong><ul><li>可被 JavaScript 读写</li></ul></li></ol><h4 id="【localStorage-关键点】"><a href="#【localStorage-关键点】" class="headerlink" title="【localStorage 关键点】"></a>【localStorage 关键点】</h4><ol><li>生命周期</li></ol><p>localStorage 的生命周期是 <strong>长期的</strong>：</p><ul><li>页面刷新不会清除</li><li>关闭浏览器不会清除</li><li>仅在手动清除或被浏览器策略回收时失效</li></ul><ol start="2"><li>作用范围</li></ol><p>localStorage 在 <strong>同源下的所有标签页共享</strong>。</p><ol start="3"><li>典型使用场景</li></ol><ul><li>用户偏好设置（主题、语言）</li><li>本地缓存的前端配置</li><li>页面刷新后仍需保留的状态</li><li>token值</li></ul><ol start="4"><li>不适合的场景</li></ol><ul><li>高频读写的数据</li><li>大对象或大数组</li></ul><ol start="5"><li>核心风险</li></ol><p>localStorage 的主要风险在于：</p><ul><li><strong>同步阻塞主线程</strong></li><li><strong>XSS 攻击可直接读取</strong></li><li><strong>缺乏任何安全控制属性</strong></li></ul><h4 id="【sessionStorage-关键点】"><a href="#【sessionStorage-关键点】" class="headerlink" title="【sessionStorage 关键点】"></a>【sessionStorage 关键点】</h4><ol><li>生命周期</li></ol><p>sessionStorage 的生命周期绑定 <strong>单个浏览器标签页</strong>：</p><ul><li>页面刷新仍然存在</li><li>标签页关闭即被销毁</li><li>新开标签页不会共享</li></ul><ol start="2"><li>作用范围</li></ol><p>sessionStorage <strong>仅在当前标签页内有效</strong>，不同标签页相互隔离。</p><ol start="3"><li>典型使用场景</li></ol><ul><li>多步骤表单的中间状态</li><li>页面跳转过程中的临时数据</li><li>不希望跨页面、跨会话保留的状态</li><li>一个页面的临时数据缓存</li></ul><ol start="4"><li>工程定位总结</li></ol><p>sessionStorage 更适合作为<strong>“页面生命周期内的临时状态容器”</strong>。</p><h4 id="【安全性分析】"><a href="#【安全性分析】" class="headerlink" title="【安全性分析】"></a>【安全性分析】</h4><p>Web Storage 的安全特性较弱：</p><ul><li>无 HttpOnly，JS 可直接访问</li><li>无 Secure &#x2F; SameSite</li><li>一旦发生 XSS，数据可能全部泄露</li></ul><p>工程结论：</p><blockquote><p>Web Storage <strong>不适合存储任何高安全敏感信息</strong>。</p></blockquote><h3 id="3-IndexedDB"><a href="#3-IndexedDB" class="headerlink" title="3. IndexedDB"></a>3. IndexedDB</h3><blockquote><p>IndexedDB 是浏览器内置的本地数据库，采用对象存储模型，支持异步 API、索引和事务，主要用于在前端存储大规模、结构化的数据。<br> 在 IndexedDB 中，所有读写操作都必须在事务中完成，事务是数据操作的最小安全执行单元，用来保证一组操作要么全部成功、要么全部失败，从而避免数据处于中间不一致状态。</p><p>事务在创建时指定作用的对象仓库和访问模式（readonly 或 readwrite），在事务内可以执行多次读写请求，最终以 <code>oncomplete</code> 作为真正提交成功的标志；如果过程中发生错误，事务会自动回滚。因此，IndexedDB 通过“异步 + 索引 + 事务”的组合，承担了前端应用中的本地数据层角色，常用于离线应用、大数据缓存和实时系统的数据缓冲。</p></blockquote><h4 id="【为什么会有-IndexedDB】"><a href="#【为什么会有-IndexedDB】" class="headerlink" title="【为什么会有 IndexedDB】"></a>【为什么会有 IndexedDB】</h4><p>在真正的工程场景中，前端很快会遇到以下问题：</p><ol><li>localStorage &#x2F; sessionStorage <strong>容量小</strong></li><li>Web Storage <strong>同步 API，会阻塞主线程</strong></li><li>只能存字符串，<strong>无法高效处理结构化数据</strong></li><li>不支持索引、查询、事务</li><li>无法承担“前端数据层”的角色</li></ol><p>当 Web 应用开始具备以下特征时，<strong>Web Storage 已经不够用</strong>：</p><ul><li>数据量达到 MB 级甚至更高</li><li>需要保存列表、对象、日志、历史记录</li><li>需要离线能力（断网仍可使用）</li><li>不允许阻塞 UI 渲染</li></ul><p><strong>IndexedDB 正是为解决这些问题而设计的。</strong></p><blockquote><p><strong>ndexedDB 是浏览器内置的、基于对象存储的本地数据库系统，提供异步 API、事务机制、索引查询和大容量持久化能力。</strong></p></blockquote><p>工程上可以直接理解为：</p><blockquote><p>IndexedDB 是浏览器中<strong>唯一能够承担“前端数据层”角色的存储机制</strong>，用于存储<strong>大规模、结构化、需要异步处理的数据</strong>。</p></blockquote><p>IndexedDB 是<strong>唯一</strong>适合承担以下职责的浏览器存储方案：</p><ul><li>大规模</li><li>结构化</li><li>异步</li><li>可查询</li><li>可事务</li></ul><h4 id="【IndexedDB核心设计】"><a href="#【IndexedDB核心设计】" class="headerlink" title="【IndexedDB核心设计】"></a>【IndexedDB核心设计】</h4><h5 id="异步-API"><a href="#异步-API" class="headerlink" title="异步 API"></a>异步 API</h5><p>IndexedDB 的所有操作都是<strong>异步的</strong>：</p><ul><li>不阻塞主线程</li><li>不影响页面渲染</li><li>适合大数据操作</li></ul><p>这与 localStorage 的<strong>同步阻塞模型</strong>形成根本区别。</p><p>工程意义：</p><p>IndexedDB 可以在前端安全地处理“真正的数据量”。</p><h5 id="对象存储（不是-Key-Value）"><a href="#对象存储（不是-Key-Value）" class="headerlink" title="对象存储（不是 Key-Value）"></a>对象存储（不是 Key-Value）</h5><p>IndexedDB 存的不是简单字符串，而是<strong>JavaScript 对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">tags</span>: [<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;editor&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不需要 JSON 序列化</li><li>支持嵌套对象</li><li>支持数组、Blob、ArrayBuffer</li></ul><h5 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a>索引（Index）</h5><p>IndexedDB 支持为对象字段建立索引：</p><ul><li>单字段索引</li><li>唯一索引</li><li>多字段（组合）索引</li></ul><p>什么字段建立索引表是用户自己决定的，索引的意义是：</p><blockquote><p><strong>不必全表扫描，也能快速查询数据</strong></p></blockquote><p>这是 Web Storage 完全不具备的能力。</p><hr><h5 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h5><p>IndexedDB 的所有读写都必须在<strong>事务中进行</strong>：</p><ul><li>原子性</li><li>一致性</li><li>失败可回滚</li></ul><p>工程上这意味着：</p><blockquote><p>前端也具备“数据库级别的数据一致性保障”。</p></blockquote><hr><h5 id="同源隔离"><a href="#同源隔离" class="headerlink" title="同源隔离"></a>同源隔离</h5><p>IndexedDB 严格遵循同源策略：</p><ul><li>不同域名之间完全隔离</li><li>提供浏览器级安全边界</li></ul><h3 id="【IndexedDB事务】"><a href="#【IndexedDB事务】" class="headerlink" title="【IndexedDB事务】"></a>【IndexedDB事务】</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * IndexedDB 生命周期流程演示（展开版）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 你需要先理解两条规则：</span><br><span class="hljs-comment"> * 1) 数据库结构（建 store / 建索引）只能在 onupgradeneeded 里做</span><br><span class="hljs-comment"> * 2) 任何读写必须在 transaction（事务）里做；事务会自动提交或回滚</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 运行方式：</span><br><span class="hljs-comment"> * - 打开页面 DevTools Console</span><br><span class="hljs-comment"> * - 复制粘贴运行</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DB_NAME</span> = <span class="hljs-string">&quot;demo_db_lifecycle&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DB_VERSION</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STORE</span> = <span class="hljs-string">&quot;users&quot;</span>;<br><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-comment">// 0. 打开数据库（整个流程入口）</span><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">openDBWithLifecycleLogs</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[0] 调用 indexedDB.open(name, version) 发起打开请求&quot;</span>);<br>    <span class="hljs-keyword">const</span> req = indexedDB.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">DB_NAME</span>, <span class="hljs-variable constant_">DB_VERSION</span>);<br><br>    <span class="hljs-comment">// A) 第一次创建数据库 或 版本号变大时，会进入“升级生命周期”</span><br>    req.<span class="hljs-property">onupgradeneeded</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[A] onupgradeneeded 触发：进入数据库升级/初始化阶段&quot;</span>);<br>      <span class="hljs-keyword">const</span> db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br><br>      <span class="hljs-comment">// 只能在这里做“结构性变更”</span><br>      <span class="hljs-comment">// 建对象仓库（相当于建表）</span><br>      <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">objectStoreNames</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-variable constant_">STORE</span>)) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;    - 创建 ObjectStore:&quot;</span>, <span class="hljs-variable constant_">STORE</span>);<br>        <span class="hljs-keyword">const</span> store = db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-variable constant_">STORE</span>, &#123; <span class="hljs-attr">keyPath</span>: <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span> &#125;);<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;    - 创建索引: email_idx (unique)&quot;</span>);<br>        store.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;email_idx&quot;</span>, <span class="hljs-string">&quot;email&quot;</span>, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> &#125;);<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;    - 创建索引: name_idx (non-unique)&quot;</span>);<br>        store.<span class="hljs-title function_">createIndex</span>(<span class="hljs-string">&quot;name_idx&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, &#123; <span class="hljs-attr">unique</span>: <span class="hljs-literal">false</span> &#125;);<br>      &#125;<br><br>      <span class="hljs-comment">// 注意：onupgradeneeded 并不等于打开成功</span><br>      <span class="hljs-comment">// 升级完成后，还会继续走 onsuccess</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[A] 升级阶段结构定义完成（尚未 onsuccess）&quot;</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// B) 打开成功：拿到 db 连接句柄</span><br>    req.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> db = req.<span class="hljs-property">result</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[B] onsuccess 触发：数据库连接已打开，获得 db 句柄&quot;</span>);<br><br>      <span class="hljs-comment">// 可选：监听版本变化（例如另一个标签页升级了 DB）</span><br>      db.<span class="hljs-property">onversionchange</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[B-1] onversionchange：检测到版本变化，应 close 以允许升级&quot;</span>);<br>        db.<span class="hljs-title function_">close</span>();<br>      &#125;;<br><br>      <span class="hljs-title function_">resolve</span>(db);<br>    &#125;;<br><br>    req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[E] onerror：打开数据库失败&quot;</span>, req.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(req.<span class="hljs-property">error</span>);<br>    &#125;;<br><br>    req.<span class="hljs-property">onblocked</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 常见于：旧连接未关闭，导致升级被阻塞</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[E] onblocked：升级被阻塞，可能有其他页面/连接未关闭&quot;</span>);<br>    &#125;;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-comment">// 1. 一个“事务”的完整生命周期（readwrite）</span><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addUserWithTxLifecycle</span>(<span class="hljs-params">db, user</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n[1] 准备写入：创建 readwrite 事务&quot;</span>);<br>    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-variable constant_">STORE</span>, <span class="hljs-string">&quot;readwrite&quot;</span>); <span class="hljs-comment">// 事务开始（开始于此）</span><br>    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-variable constant_">STORE</span>);<br><br>    <span class="hljs-comment">// 事务生命周期事件</span><br>    tx.<span class="hljs-property">oncomplete</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[1-C] tx.oncomplete：事务成功提交（所有写入/索引更新/落盘完成）&quot;</span>);<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;;<br>    tx.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[1-E] tx.onerror：事务失败（将回滚）&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span> || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;tx failed&quot;</span>));<br>    &#125;;<br>    tx.<span class="hljs-property">onabort</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[1-A] tx.onabort：事务被中止（回滚完成）&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span> || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;tx aborted&quot;</span>));<br>    &#125;;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[1-2] 在事务内发起 store.add 请求（这只是‘发请求’，不是立刻完成）&quot;</span>);<br>    <span class="hljs-keyword">const</span> req = store.<span class="hljs-title function_">add</span>(user);<br><br>    <span class="hljs-comment">// 请求生命周期事件</span><br>    req.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[1-3] add.onsuccess：单条写入请求成功，生成主键 id =&quot;</span>, req.<span class="hljs-property">result</span>);<br>      <span class="hljs-comment">// 注意：此时仍然不代表事务提交完成</span><br>      <span class="hljs-comment">// 事务可能还在更新索引、写入磁盘等</span><br>    &#125;;<br>    req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[1-4] add.onerror：单条写入请求失败&quot;</span>, req.<span class="hljs-property">error</span>);<br>      <span class="hljs-comment">// 这里失败会导致整个事务失败 -&gt; tx.onerror/tx.onabort</span><br>      <span class="hljs-comment">// 典型原因：unique 索引冲突（email 重复）</span><br>    &#125;;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[1-5] 函数末尾：等待事务进入 complete 或 error/abort&quot;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-comment">// 2. 读事务（readonly）的生命周期</span><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getByEmailWithTxLifecycle</span>(<span class="hljs-params">db, email</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n[2] 准备查询：创建 readonly 事务&quot;</span>);<br>    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-variable constant_">STORE</span>, <span class="hljs-string">&quot;readonly&quot;</span>);<br>    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-variable constant_">STORE</span>);<br>    <span class="hljs-keyword">const</span> index = store.<span class="hljs-title function_">index</span>(<span class="hljs-string">&quot;email_idx&quot;</span>);<br><br>    tx.<span class="hljs-property">oncomplete</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[2-C] tx.oncomplete：读事务结束&quot;</span>);<br>    &#125;;<br>    tx.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[2-E] tx.onerror：读事务失败&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span> || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;tx failed&quot;</span>));<br>    &#125;;<br>    tx.<span class="hljs-property">onabort</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[2-A] tx.onabort：读事务中止&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span> || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;tx aborted&quot;</span>));<br>    &#125;;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[2-2] 在事务内发起 index.get(email) 请求&quot;</span>);<br>    <span class="hljs-keyword">const</span> req = index.<span class="hljs-title function_">get</span>(email);<br><br>    req.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[2-3] get.onsuccess：查到结果 =&quot;</span>, req.<span class="hljs-property">result</span> || <span class="hljs-literal">null</span>);<br>      <span class="hljs-title function_">resolve</span>(req.<span class="hljs-property">result</span> || <span class="hljs-literal">null</span>);<br>    &#125;;<br>    req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[2-4] get.onerror：查询失败&quot;</span>, req.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(req.<span class="hljs-property">error</span>);<br>    &#125;;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-comment">// 3. 更新（put）与删除（delete）示例（同理）</span><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateUserWithTxLifecycle</span>(<span class="hljs-params">db, user</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n[3] 准备更新：创建 readwrite 事务&quot;</span>);<br>    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-variable constant_">STORE</span>, <span class="hljs-string">&quot;readwrite&quot;</span>);<br>    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-variable constant_">STORE</span>);<br><br>    tx.<span class="hljs-property">oncomplete</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[3-C] tx.oncomplete：更新事务提交完成&quot;</span>);<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;;<br>    tx.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[3-E] tx.onerror：更新事务失败（回滚）&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span>);<br>    &#125;;<br>    tx.<span class="hljs-property">onabort</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[3-A] tx.onabort：更新事务中止（回滚完成）&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span>);<br>    &#125;;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[3-2] 发起 store.put(user) 请求（有则更新，无则新增）&quot;</span>);<br>    <span class="hljs-keyword">const</span> req = store.<span class="hljs-title function_">put</span>(user);<br><br>    req.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[3-3] put.onsuccess：单条 put 请求成功&quot;</span>);<br>    &#125;;<br>    req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[3-4] put.onerror：单条 put 请求失败&quot;</span>, req.<span class="hljs-property">error</span>);<br>    &#125;;<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteUserWithTxLifecycle</span>(<span class="hljs-params">db, id</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n[4] 准备删除：创建 readwrite 事务&quot;</span>);<br>    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-variable constant_">STORE</span>, <span class="hljs-string">&quot;readwrite&quot;</span>);<br>    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-variable constant_">STORE</span>);<br><br>    tx.<span class="hljs-property">oncomplete</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[4-C] tx.oncomplete：删除事务提交完成&quot;</span>);<br>      <span class="hljs-title function_">resolve</span>();<br>    &#125;;<br>    tx.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[4-E] tx.onerror：删除事务失败（回滚）&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span>);<br>    &#125;;<br>    tx.<span class="hljs-property">onabort</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[4-A] tx.onabort：删除事务中止（回滚完成）&quot;</span>, tx.<span class="hljs-property">error</span>);<br>      <span class="hljs-title function_">reject</span>(tx.<span class="hljs-property">error</span>);<br>    &#125;;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[4-2] 发起 store.delete(id) 请求&quot;</span>);<br>    <span class="hljs-keyword">const</span> req = store.<span class="hljs-title function_">delete</span>(id);<br><br>    req.<span class="hljs-property">onsuccess</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[4-3] delete.onsuccess：单条 delete 请求成功&quot;</span>);<br>    &#125;;<br>    req.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[4-4] delete.onerror：单条 delete 请求失败&quot;</span>, req.<span class="hljs-property">error</span>);<br>    &#125;;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// -------------------------</span><br><span class="hljs-comment">// 5. 把整个生命周期串起来跑一遍</span><br><span class="hljs-comment">// -------------------------</span><br>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">runLifecycleDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 打开数据库：可能经历 onupgradeneeded -&gt; onsuccess</span><br>  <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDBWithLifecycleLogs</span>();<br><br>  <span class="hljs-comment">// 第一次写入：事务生命周期（readwrite）</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">addUserWithTxLifecycle</span>(db, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;alice@example.com&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;);<br><br>  <span class="hljs-comment">// 再写一条</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">addUserWithTxLifecycle</span>(db, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;bob@example.com&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;);<br><br>  <span class="hljs-comment">// 查询：读事务生命周期（readonly）</span><br>  <span class="hljs-keyword">const</span> bob = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getByEmailWithTxLifecycle</span>(db, <span class="hljs-string">&quot;bob@example.com&quot;</span>);<br><br>  <span class="hljs-comment">// 更新：put（仍然是事务）</span><br>  bob.<span class="hljs-property">age</span> = <span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">updateUserWithTxLifecycle</span>(db, bob);<br><br>  <span class="hljs-comment">// 删除：delete（仍然是事务）</span><br>  <span class="hljs-comment">// 这里为了演示，删 Alice（主键一般是 1，但增强健壮性应先查）</span><br>  <span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getByEmailWithTxLifecycle</span>(db, <span class="hljs-string">&quot;alice@example.com&quot;</span>);<br>  <span class="hljs-keyword">if</span> (alice) <span class="hljs-keyword">await</span> <span class="hljs-title function_">deleteUserWithTxLifecycle</span>(db, alice.<span class="hljs-property">id</span>);<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;\n[Done] 全流程结束，关闭 db&quot;</span>);<br>  db.<span class="hljs-title function_">close</span>();<br>&#125;)();<br><br></code></pre></td></tr></table></figure><p>把上面流程理解成两段“生命周期”就够了：第一段是数据库连接生命周期，调用 <code>indexedDB.open()</code> 后，如果是首次创建或版本升级会先触发 <code>onupgradeneeded</code>，在这个阶段只能做结构定义（建对象仓库、建索引），结构定义结束后并不代表可用，最终一定会进入 <code>onsuccess</code> 才算拿到 <code>db</code> 连接句柄，才可以开始读写；第二段是事务生命周期，每一次读或写都会先创建事务 <code>db.transaction(storeName, mode)</code>，这一步就意味着事务开始了，随后你在事务里发起一个或多个请求（add&#x2F;put&#x2F;get&#x2F;delete 或索引查询），单个请求成功只代表该请求成功，不代表事务已提交，事务最终以 <code>tx.oncomplete</code> 作为“真正提交成功”的标志；如果过程中任何请求失败（比如 unique 索引冲突、空间不足、权限问题），事务会进入 <code>tx.onerror</code> 或 <code>tx.onabort</code>，并回滚整个事务内的改动，从而保证不会出现“写了一半导致数据和索引不一致”的中间态。这就是事务存在的核心意义：把一组读写和索引维护、落盘过程绑定成一个不可分割的安全单元。</p><h3 id="4-Cache-API"><a href="#4-Cache-API" class="headerlink" title="4. Cache API"></a>4. Cache API</h3><blockquote><p>Cache API 是浏览器提供的用于缓存 HTTP 请求与响应的存储机制，通常与 Service Worker 配合使用。它以 Request 为 key、Response 为值，用于实现离线访问、资源预缓存和网络性能优化。Cache API 不适合存储业务数据，而是专门用于缓存网络结果，开发者需要自行控制缓存策略和更新时机。在工程中，Cache API 主要用于静态资源和接口响应的缓存，与 IndexedDB 这种本地数据存储方案职责不同。</p></blockquote><h4 id="【什么是Cache-API】"><a href="#【什么是Cache-API】" class="headerlink" title="【什么是Cache API】"></a>【什么是Cache API】</h4><blockquote><p><strong>Cache API（Cache Storage）是浏览器提供的一种用于存储 HTTP 请求与响应（Request → Response）的缓存机制</strong>，主要配合 <strong>Service Worker</strong> 使用，用于实现离线访问、资源缓存和网络性能优化。</p></blockquote><p>一句话理解：</p><blockquote><p>Cache API 不是“存数据”，而是<strong>缓存网络请求结果</strong>。</p></blockquote><h4 id="【Cache-API-的核心作用】"><a href="#【Cache-API-的核心作用】" class="headerlink" title="【Cache API 的核心作用】"></a>【Cache API 的核心作用】</h4><p>Cache API 主要解决三个问题：</p><ol><li><strong>离线访问</strong><ul><li>无网络时仍能返回缓存的资源或接口响应</li></ul></li><li><strong>网络性能优化</strong><ul><li>减少重复请求</li><li>加快资源加载速度</li></ul></li><li><strong>请求控制</strong><ul><li>前端可以决定：是用缓存、走网络，还是两者结合</li></ul></li></ol><h4 id="【Cache-API-的工作机制】"><a href="#【Cache-API-的工作机制】" class="headerlink" title="【Cache API 的工作机制】"></a>【Cache API 的工作机制】</h4><p>Cache API 的基本逻辑是：</p><ol><li><strong>拦截请求（通常由 Service Worker 完成）</strong></li><li><strong>根据策略查找 Cache</strong></li><li><strong>命中则直接返回 Response</strong></li><li><strong>未命中则走网络，并可选择写入 Cache</strong></li></ol><p>核心点在于：</p><blockquote><p>Cache API 存的是 <strong>完整的 HTTP Response 对象</strong>， 而不是普通的 JS 数据。</p></blockquote><h4 id="【Cache-API-的关键特性】"><a href="#【Cache-API-的关键特性】" class="headerlink" title="【Cache API 的关键特性】"></a>【Cache API 的关键特性】</h4><h5 id="1-面向-Request-Response"><a href="#1-面向-Request-Response" class="headerlink" title="1. 面向 Request &#x2F; Response"></a>1. 面向 Request &#x2F; Response</h5><ul><li>缓存单位是一次 HTTP 请求的完整响应</li><li>不适合存业务对象或状态数据</li></ul><h5 id="2-异步-API"><a href="#2-异步-API" class="headerlink" title="2. 异步 API"></a>2. 异步 API</h5><ul><li>不阻塞主线程</li><li>适合处理大资源或批量缓存</li></ul><h5 id="3-不自动失效"><a href="#3-不自动失效" class="headerlink" title="3. 不自动失效"></a>3. 不自动失效</h5><ul><li>Cache API <strong>不遵循 HTTP 缓存头</strong></li><li>是否更新、何时删除，<strong>完全由开发者控制</strong></li></ul><h5 id="4-通常由-Service-Worker-管理"><a href="#4-通常由-Service-Worker-管理" class="headerlink" title="4. 通常由 Service Worker 管理"></a>4. 通常由 Service Worker 管理</h5><ul><li>在页面 JS 中也可用</li><li>但真正发挥价值必须结合 SW 的 <code>fetch</code> 拦截</li></ul><h4 id="【Cache-API-的典型缓存策略】"><a href="#【Cache-API-的典型缓存策略】" class="headerlink" title="【Cache API 的典型缓存策略】"></a>【Cache API 的典型缓存策略】</h4><ol><li>Cache First（缓存优先）</li></ol><ul><li>先查缓存</li><li>缓存没有再请求网络</li><li>适合：静态资源</li></ul><ol start="2"><li>Network First（网络优先）</li></ol><ul><li>先请求网络</li><li>失败再用缓存</li><li>适合：数据接口</li></ul><h4 id="【Cache-API-的基本使用模型】"><a href="#【Cache-API-的基本使用模型】" class="headerlink" title="【Cache API 的基本使用模型】"></a>【Cache API 的基本使用模型】</h4><ol><li>打开一个缓存空间</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;v1&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>向缓存中写入请求响应</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">cache.<span class="hljs-title function_">put</span>(request, response);<br></code></pre></td></tr></table></figure><ol start="3"><li>从缓存中读取</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">caches.<span class="hljs-title function_">match</span>(request);<br></code></pre></td></tr></table></figure><ol start="4"><li>删除旧缓存</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">caches.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&quot;v0&quot;</span>);<br></code></pre></td></tr></table></figure><p>你可以把它理解为：</p><blockquote><p><strong>一个由浏览器维护的、以 Request 为 key 的 Response Map</strong></p></blockquote><h4 id="【Cache-API-应用】"><a href="#【Cache-API-应用】" class="headerlink" title="【Cache API 应用】"></a>【Cache API 应用】</h4><table><thead><tr><th>场景</th><th>Cache API 解决的核心问题</th></tr></thead><tbody><tr><td>静态资源</td><td>减少重复下载</td></tr><tr><td>接口缓存</td><td>减少重复请求</td></tr><tr><td>离线应用</td><td>断网仍可用</td></tr><tr><td>首屏优化</td><td>加快首次可见</td></tr></tbody></table><p>在静态资源场景中，一个典型例子是前端项目构建后生成的 <code>index.html</code>、<code>app.js</code>、<code>vendor.js</code>、<code>main.css</code> 以及站点中的图片和字体文件。这些资源在一次版本发布周期内对所有用户都是相同的，如果每次页面刷新都重新从服务器下载，会浪费带宽并拉长白屏时间。使用 Cache API 后，这些文件在首次访问时被缓存，后续刷新或再次访问时浏览器可以直接从本地缓存中读取，从而避免重复下载，大幅提升加载速度和稳定性。</p><p>在接口响应缓存场景中，一个常见例子是首页的只读数据接口，例如 <code>GET /api/articles?page=1</code> 或 <code>GET /api/config</code>。这些接口在短时间内返回的数据基本不变，但用户可能频繁刷新页面或多次进入同一页面。如果不做缓存，每次都会发起网络请求，既增加接口压力，也在弱网情况下影响体验。通过 Cache API 缓存这些 GET 请求的响应结果，后续访问可以直接返回缓存数据，在网络失败时仍能展示上一次成功获取的内容，从而减少重复请求并提高页面响应速度。</p><p>在离线应用场景中，一个典型例子是巡检系统或移动端 Web 应用，用户可能在地铁、电梯或网络不稳定的环境中打开页面。没有缓存时，一旦断网，HTML、JS 或接口请求失败，页面将无法加载或直接报错。通过 Service Worker 配合 Cache API，将页面骨架资源和关键接口响应提前缓存，即使在完全断网的情况下，应用仍然可以正常打开并展示已有数据，实现“断网可用”的基础体验。</p><p>在首屏性能优化场景中，一个常见例子是用户第二次打开一个内容型网站或后台管理系统。首屏渲染依赖的 HTML、核心 JS 和 CSS 如果每次都等待网络返回，会直接拖慢首次内容绘制时间。借助 Cache API，这些首屏关键资源可以在本地直接命中缓存，页面几乎立即开始渲染，显著缩短白屏时间和首屏可见时间，从而提升用户对“页面很快”的主观感受。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.ECharts从0到1</title>
    <link href="/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/12-ECharts%E4%BB%8E0%E5%88%B01/"/>
    <url>/2026/01/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/12-ECharts%E4%BB%8E0%E5%88%B01/</url>
    
    <content type="html"><![CDATA[<p>ECharts记录</p><span id="more"></span><h2 id="ECharts从0到1"><a href="#ECharts从0到1" class="headerlink" title="ECharts从0到1"></a>ECharts从0到1</h2><blockquote><p><a href="https://echarts.apache.org/handbook/zh/get-started">快速上手 - 使用手册 - Apache ECharts</a></p></blockquote><h3 id="1-ECharts-的整体设计思想"><a href="#1-ECharts-的整体设计思想" class="headerlink" title="1. ECharts 的整体设计思想"></a>1. ECharts 的整体设计思想</h3><h4 id="1-1-ECharts-的核心思想一句话概括"><a href="#1-1-ECharts-的核心思想一句话概括" class="headerlink" title="1.1 ECharts 的核心思想一句话概括"></a>1.1 ECharts 的核心思想一句话概括</h4><blockquote><p><strong>用声明式配置（option）描述图表结构，由内部组件系统维护状态并进行高效重绘。</strong></p></blockquote><p>这意味着三点：</p><ol><li>你并不直接“画线 &#x2F; 画点”</li><li>你描述“我想要什么图”</li><li>ECharts 决定“如何画、如何更新、如何优化”</li></ol><hr><h4 id="1-2-ECharts-与-DOM-操作-Canvas-原生绘制的本质区别"><a href="#1-2-ECharts-与-DOM-操作-Canvas-原生绘制的本质区别" class="headerlink" title="1.2 ECharts 与 DOM 操作 &#x2F; Canvas 原生绘制的本质区别"></a>1.2 ECharts 与 DOM 操作 &#x2F; Canvas 原生绘制的本质区别</h4><table><thead><tr><th>对比维度</th><th>原生 Canvas</th><th>ECharts</th></tr></thead><tbody><tr><td>绘制方式</td><td>命令式</td><td>声明式</td></tr><tr><td>状态管理</td><td>手动</td><td>内部维护</td></tr><tr><td>更新策略</td><td>全量重画</td><td>增量更新</td></tr><tr><td>工程复杂度</td><td>高</td><td>可控</td></tr></tbody></table><h3 id="2-ECharts-构建的完整生命周期"><a href="#2-ECharts-构建的完整生命周期" class="headerlink" title="2. ECharts 构建的完整生命周期"></a>2. ECharts 构建的完整生命周期</h3><h4 id="2-1-生命周期总览（标准工程模型）"><a href="#2-1-生命周期总览（标准工程模型）" class="headerlink" title="2.1 生命周期总览（标准工程模型）"></a>2.1 生命周期总览（标准工程模型）</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">DOM 挂载<br>  ↓<br>echarts.init<br>  ↓<br><span class="hljs-keyword">set</span>Option（首次渲染）<br>  ↓<br><span class="hljs-keyword">set</span>Option（数据 / 配置更新）<br>  ↓<br>resize（尺寸变化）<br>  ↓<br>dispose（资源释放）<br></code></pre></td></tr></table></figure><p>这套流程在 Vue &#x2F; React &#x2F; 原生 JS 中完全一致。</p><hr><h4 id="2-2-init-阶段：实例与-DOM-的绑定"><a href="#2-2-init-阶段：实例与-DOM-的绑定" class="headerlink" title="2.2 init 阶段：实例与 DOM 的绑定"></a>2.2 init 阶段：实例与 DOM 的绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> chart = echarts.<span class="hljs-title function_">init</span>(dom, theme, opts);<br></code></pre></td></tr></table></figure><p><strong>init 本质做了三件事：</strong></p><ol><li>绑定 DOM 容器</li><li>创建渲染上下文（Canvas &#x2F; SVG）</li><li>初始化内部组件管理器（坐标系、series、组件）</li></ol><p><strong>工程级注意点（面试高频）：</strong></p><ul><li>DOM <strong>必须已有尺寸</strong>，否则无法计算坐标系</li><li>一个 DOM 只能 init 一个实例</li><li>theme 只在 init 时生效</li></ul><hr><h4 id="2-3-setOption：ECharts-的“状态驱动核心”"><a href="#2-3-setOption：ECharts-的“状态驱动核心”" class="headerlink" title="2.3 setOption：ECharts 的“状态驱动核心”"></a>2.3 setOption：ECharts 的“状态驱动核心”</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">chart.<span class="hljs-title function_">setOption</span>(option, notMerge, lazyUpdate);<br></code></pre></td></tr></table></figure><h4 id="setOption-的真实含义"><a href="#setOption-的真实含义" class="headerlink" title="setOption 的真实含义"></a>setOption 的真实含义</h4><blockquote><p><strong>setOption 并不是“重新画一张图”，而是“基于 option 描述去更新内部组件状态”。</strong></p></blockquote><p><strong>默认行为：增量合并</strong></p><ul><li>新 option 与旧 option 合并</li><li>未传字段保持不变</li><li>series 会按 index &#x2F; id 匹配</li></ul><p><strong>强制全量更新</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">chart.<span class="hljs-title function_">setOption</span>(option, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>或：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">chart.<span class="hljs-title function_">clear</span>();<br>chart.<span class="hljs-title function_">setOption</span>(option);<br></code></pre></td></tr></table></figure><p><strong>工程经验：</strong></p><ul><li>实时更新 → 只改 <code>series.data</code></li><li>结构变化 → clear + setOption</li></ul><hr><h4 id="2-4-更新阶段：为什么“只更新-data”很重要"><a href="#2-4-更新阶段：为什么“只更新-data”很重要" class="headerlink" title="2.4 更新阶段：为什么“只更新 data”很重要"></a>2.4 更新阶段：为什么“只更新 data”很重要</h4><p>错误方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">chart.<span class="hljs-title function_">setOption</span>(&#123;<br>  <span class="hljs-attr">xAxis</span>: &#123;...&#125;,<br>  <span class="hljs-attr">yAxis</span>: &#123;...&#125;,<br>  <span class="hljs-attr">series</span>: [&#123; data &#125;]<br>&#125;);<br></code></pre></td></tr></table></figure><p>正确方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">chart.<span class="hljs-title function_">setOption</span>(&#123;<br>  <span class="hljs-attr">series</span>: [&#123; data &#125;]<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>原因：</strong></p><ul><li>坐标轴重建代价高</li><li>layout 重新计算</li><li>tooltip &#x2F; legend 重新绑定</li></ul><hr><h4 id="2-5-resize：为什么必须手动调用"><a href="#2-5-resize：为什么必须手动调用" class="headerlink" title="2.5 resize：为什么必须手动调用"></a>2.5 resize：为什么必须手动调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">chart.<span class="hljs-title function_">resize</span>();<br></code></pre></td></tr></table></figure><p>原因不是“ECharts 不智能”，而是：</p><ul><li>DOM 尺寸变化是浏览器行为</li><li>Canvas&#x2F;SVG 不会自动重排</li><li>ECharts 无法监听所有布局变化</li></ul><p><strong>工程常见触发场景：</strong></p><ul><li>window.resize</li><li>flex &#x2F; grid 布局变化</li><li>sidebar 折叠</li></ul><hr><h4 id="2-6-dispose：为什么这是必须的"><a href="#2-6-dispose：为什么这是必须的" class="headerlink" title="2.6 dispose：为什么这是必须的"></a>2.6 dispose：为什么这是必须的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">chart.<span class="hljs-title function_">dispose</span>();<br></code></pre></td></tr></table></figure><p>不 dispose 会导致：</p><ul><li>Canvas 未释放</li><li>内部事件监听残留</li><li>WebSocket &#x2F; 定时器无法 GC</li></ul><p><strong>一句面试总结：</strong></p><blockquote><p>ECharts 是有状态对象，不是纯函数，必须手动销毁。</p></blockquote><h3 id="3-ECharts-组件体系"><a href="#3-ECharts-组件体系" class="headerlink" title="3. ECharts 组件体系"></a>3. ECharts 组件体系</h3><p>一个工程里最常见的“直角坐标系图表”骨架：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">option = &#123;<br>  <span class="hljs-comment">// 1) 全局：颜色/字体/动画/背景等</span><br>  backgroundColor,<br>  animation,<br><br>  <span class="hljs-comment">// 2) 展示组件：标题、图例、提示等</span><br>  title,<br>  legend,<br>  tooltip,<br><br>  <span class="hljs-comment">// 3) 布局与坐标系：grid + axis</span><br>  grid,<br>  xAxis,<br>  yAxis,<br><br>  <span class="hljs-comment">// 4) 数据组件：series（挂到坐标系）</span><br>  series,<br><br>  <span class="hljs-comment">// 5) 交互组件：缩放、工具箱、视觉映射等</span><br>  dataZoom,<br>  toolbox,<br>  visualMap,<br><br>  <span class="hljs-comment">// 6) 其他：graphic 自定义图层等</span><br>  graphic<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-backgroundColor-animation-textStyle"><a href="#3-1-backgroundColor-animation-textStyle" class="headerlink" title="3.1 backgroundColor &#x2F; animation &#x2F; textStyle"></a>3.1 backgroundColor &#x2F; animation &#x2F; textStyle</h4><p>模板：监控类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;transparent&#x27;</span>,<br><span class="hljs-attr">animation</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">textStyle</span>: &#123;<br>  <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">&#x27;Inter, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>工程说明</p><ul><li>实时图表尽量 <code>animation: false</code>（否则 burst 数据会抖）</li><li>textStyle 统一后，组件里的字体配置会更少</li></ul><hr><h4 id="3-2-title（标题）"><a href="#3-2-title（标题）" class="headerlink" title="3.2 title（标题）"></a>3.2 title（标题）</h4><p>常用模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">title</span>: &#123;<br>  <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;主标题&#x27;</span>,<br>  <span class="hljs-attr">subtext</span>: <span class="hljs-string">&#x27;副标题&#x27;</span>,<br>  <span class="hljs-attr">left</span>: <span class="hljs-number">12</span>,<br>  <span class="hljs-attr">top</span>: <span class="hljs-number">8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>工程建议</p><ul><li>企业系统里标题常常由外层 UI 接管</li><li>ECharts title 更适合“可导出图”的场景（截图&#x2F;导出时带标题）</li></ul><hr><h4 id="3-3-legend（图例）"><a href="#3-3-legend（图例）" class="headerlink" title="3.3 legend（图例）"></a>3.3 legend（图例）</h4><p>legend 是<strong>series 的管理入口</strong>：显示&#x2F;隐藏、筛选、多系列对比。</p><p><strong>关键点：绑定规则</strong></p><ul><li>legend 项来自 <code>series[i].name</code>（或 legend.data 显式指定）</li><li>点击 legend 会改变 series 的 selected 状态，从而影响渲染</li></ul><p><strong>常用模板（顶部横排）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">legend</span>: &#123;<br>  <span class="hljs-attr">top</span>: <span class="hljs-number">8</span>,<br>  <span class="hljs-attr">left</span>: <span class="hljs-string">&#x27;center&#x27;</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-comment">// 系列多时必须用 scroll</span><br>  <span class="hljs-attr">data</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工程坑</strong></p><ul><li>series 没有 name → legend 无法控制</li></ul><hr><h4 id="3-4-tooltip（提示框）"><a href="#3-4-tooltip（提示框）" class="headerlink" title="3.4 tooltip（提示框）"></a>3.4 tooltip（提示框）</h4><p>tooltip 是“解释数据”的核心，也是面试高频。</p><p><strong>trigger 的两种主流模式</strong></p><ul><li><code>axis</code>：适合 line &#x2F; bar（同一 x 下多个 series 一起显示）</li><li><code>item</code>：适合 pie &#x2F; scatter（一个点一个提示）</li></ul><p><strong>模板：折线&#x2F;柱状（axis）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">tooltip</span>: &#123;<br>  <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;axis&#x27;</span>,<br>  <span class="hljs-attr">axisPointer</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;line&#x27;</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模板：饼图（item）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">tooltip</span>: &#123;<br>  <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;item&#x27;</span>,<br>  <span class="hljs-attr">formatter</span>: <span class="hljs-string">&#x27;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-grid（直角坐标系容器）"><a href="#3-5-grid（直角坐标系容器）" class="headerlink" title="3.5 grid（直角坐标系容器）"></a>3.5 grid（直角坐标系容器）</h4><p>grid 决定了“画布里真正绘图区域”的位置和大小。</p><p><strong>强烈推荐模板</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">grid</span>: &#123;<br>  <span class="hljs-attr">left</span>: <span class="hljs-number">56</span>,<br>  <span class="hljs-attr">right</span>: <span class="hljs-number">24</span>,<br>  <span class="hljs-attr">top</span>: <span class="hljs-number">56</span>,<br>  <span class="hljs-attr">bottom</span>: <span class="hljs-number">48</span>,<br>  <span class="hljs-attr">containLabel</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>containLabel 的意义</p><ul><li>true：把坐标轴文字算进布局，避免被裁剪</li><li>false：图更大，但容易裁字（更适合你自己精细控边距的场景）</li></ul><hr><h4 id="3-6-xAxis-yAxis（轴组件）"><a href="#3-6-xAxis-yAxis（轴组件）" class="headerlink" title="3.6 xAxis &#x2F; yAxis（轴组件）"></a>3.6 xAxis &#x2F; yAxis（轴组件）</h4><p>轴组件不仅显示刻度，更决定：</p><ul><li>数据如何映射到坐标</li><li>tooltip &#x2F; dataZoom 如何工作</li><li>布局计算与缩放行为</li></ul><h5 id="xAxis-常用类型"><a href="#xAxis-常用类型" class="headerlink" title="xAxis 常用类型"></a>xAxis 常用类型</h5><ul><li><code>category</code>：离散类目（周一、周二）</li><li><code>time</code>：时间序列（实时最推荐）</li><li><code>value</code>：连续数值（散点图常用）</li><li><code>log</code>：对数轴</li></ul><p>模板：time 轴</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">xAxis</span>: &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;time&#x27;</span>,<br>  <span class="hljs-attr">boundaryGap</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">axisLabel</span>: &#123; <span class="hljs-attr">hideOverlap</span>: <span class="hljs-literal">true</span> &#125;<br>&#125;,<br><span class="hljs-attr">yAxis</span>: &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;value&#x27;</span>,<br>  <span class="hljs-attr">scale</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">splitLine</span>: &#123; <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>工程实践</p><ul><li><code>scale: true</code>：避免 y 轴强制从 0 开始（监控曲线更合理）</li><li><code>axisLabel.hideOverlap</code>：类目密集时减少重叠</li><li>时间数据格式推荐 <code>[timestamp, value]</code>，避免字符串解析成本</li></ul><p>核心规律：</p><blockquote><p>series 会通过 <em>某个 index</em> 指向坐标系组件（例如 <code>xAxisIndex / yAxisIndex</code> 或 <code>geoIndex</code>）。</p></blockquote><hr><h4 id="3-7-series：数据表达组件"><a href="#3-7-series：数据表达组件" class="headerlink" title="3.7 series：数据表达组件"></a>3.7 series：数据表达组件</h4><p>series 的公共字段（高频必记）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">series</span>: [&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;A&#x27;</span>,<br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;line&#x27;</span>,<br>  <span class="hljs-attr">data</span>: [],<br>  <span class="hljs-attr">coordinateSystem</span>: <span class="hljs-string">&#x27;cartesian2d&#x27;</span>, <span class="hljs-comment">// 很多时候不用写，默认由轴推导</span><br>  <span class="hljs-attr">xAxisIndex</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">yAxisIndex</span>: <span class="hljs-number">0</span><br>&#125;]<br></code></pre></td></tr></table></figure><p><strong>工程核心：series 与组件的连接</strong></p><ul><li>legend ↔ series.name</li><li>tooltip ↔ series + axisPointer</li><li>visualMap ↔ seriesIndex &#x2F; dimension</li><li>dataZoom ↔ axisIndex（间接影响 series）</li></ul><p>两个图共用一个 canvas，但上下两个 grid：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">grid</span>: [<br>  &#123; <span class="hljs-attr">top</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">160</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">56</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">24</span> &#125;,<br>  &#123; <span class="hljs-attr">top</span>: <span class="hljs-number">250</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">160</span>, <span class="hljs-attr">left</span>: <span class="hljs-number">56</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">24</span> &#125;<br>],<br><span class="hljs-attr">xAxis</span>: [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-attr">gridIndex</span>: <span class="hljs-number">0</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-attr">gridIndex</span>: <span class="hljs-number">1</span> &#125;<br>],<br><span class="hljs-attr">yAxis</span>: [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-attr">gridIndex</span>: <span class="hljs-number">0</span> &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-attr">gridIndex</span>: <span class="hljs-number">1</span> &#125;<br>],<br><span class="hljs-attr">series</span>: [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;line&#x27;</span>, <span class="hljs-attr">xAxisIndex</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">yAxisIndex</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">data</span>: [] &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,  <span class="hljs-attr">xAxisIndex</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">yAxisIndex</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">data</span>: [] &#125;<br>]<br></code></pre></td></tr></table></figure><p><strong>这里体现了组件体系的关键：</strong></p><ul><li>grid 是布局容器</li><li>axis 挂到 gridIndex</li><li>series 再通过 axisIndex 找到坐标系</li></ul><p>这类题在面试里非常加分。</p><hr><h4 id="3-8-交互增强组件（dataZoom-toolbox-brush）"><a href="#3-8-交互增强组件（dataZoom-toolbox-brush）" class="headerlink" title="3.8 交互增强组件（dataZoom &#x2F; toolbox &#x2F; brush）"></a>3.8 交互增强组件（dataZoom &#x2F; toolbox &#x2F; brush）</h4><h5 id="dataZoom（缩放-拖拽）"><a href="#dataZoom（缩放-拖拽）" class="headerlink" title="dataZoom（缩放&#x2F;拖拽）"></a>dataZoom（缩放&#x2F;拖拽）</h5><p>模板：inside + slider（通用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">dataZoom</span>: [<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;inside&#x27;</span>, <span class="hljs-attr">xAxisIndex</span>: [<span class="hljs-number">0</span>] &#125;,<br>  &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;slider&#x27;</span>, <span class="hljs-attr">xAxisIndex</span>: [<span class="hljs-number">0</span>], <span class="hljs-attr">bottom</span>: <span class="hljs-number">8</span> &#125;<br>]<br></code></pre></td></tr></table></figure><p>工程意义</p><ul><li>大数据量不只是“给用户缩放”，更是性能手段：<ul><li>缩放后可视范围减少</li><li>视觉层绘制压力下降</li></ul></li></ul><p>常见坑</p><ul><li>多 xAxis 时，必须正确设置 <code>xAxisIndex</code></li><li>没指定 index 时可能默认作用于第一个 axis，导致“缩放不生效”或“缩错图”</li></ul><hr><h4 id="3-9-toolbox（工具箱）"><a href="#3-9-toolbox（工具箱）" class="headerlink" title="3.9 toolbox（工具箱）"></a>3.9 toolbox（工具箱）</h4><p>模板：导出、还原、缩放</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">toolbox</span>: &#123;<br>  <span class="hljs-attr">feature</span>: &#123;<br>    <span class="hljs-attr">saveAsImage</span>: &#123;&#125;,<br>    <span class="hljs-attr">restore</span>: &#123;&#125;,<br>    <span class="hljs-attr">dataZoom</span>: &#123;&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>工程建议：</p><ul><li>监控系统建议开启 <code>saveAsImage</code></li><li>restore 可以快速回到初始视图</li></ul><h3 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h3><h4 id="1-你怎么理解-ECharts？它解决什么问题？"><a href="#1-你怎么理解-ECharts？它解决什么问题？" class="headerlink" title="1. 你怎么理解 ECharts？它解决什么问题？"></a>1. 你怎么理解 ECharts？它解决什么问题？</h4><p><strong>回答模板：</strong><br> ECharts 是一个以配置（option）驱动为主的前端数据可视化图表库，底层基于 ZRender 完成图形渲染，默认使用 Canvas，也支持 SVG。它的核心价值在于将“数据到图形”的映射过程标准化：开发者通过描述坐标系、系列（series）、视觉映射（visual）、组件（legend、tooltip、dataZoom 等）与交互行为，即可生成具有较强交互能力与较好性能的图表。<br> 在工程中，ECharts 主要解决三类问题：<br> 1）快速构建可视化：无需从底层绘制开始，可直接通过 option 组装常见图表与组件。<br> 2）复杂交互：tooltip、brush、dataZoom、联动、选中高亮等交互能力比较完整。<br> 3）性能与实时：Canvas 渲染和增量更新机制使其适用于中大规模数据量与实时数据流展示。<br> 我通常把 ECharts 当作工程化可视化工具：强调可维护性、可配置性与性能平衡，而不是像 D3 那样强调底层自由度。</p><hr><h4 id="2-ECharts-的整体架构与渲染流程是什么？"><a href="#2-ECharts-的整体架构与渲染流程是什么？" class="headerlink" title="2. ECharts 的整体架构与渲染流程是什么？"></a>2. ECharts 的整体架构与渲染流程是什么？</h4><p><strong>回答模板：</strong><br> ECharts 可以理解为“可视化编排层 + 渲染引擎层”。<br> 1）option 编排层：开发者提供 option，包含 dataset&#x2F;series&#x2F;axis&#x2F;legend&#x2F;tooltip&#x2F;dataZoom 等配置。<br> 2）数据处理与坐标映射：ECharts 会把数据进行解析、维度编码（encode）、计算 scale，执行布局（layout）与坐标变换（例如 grid&#x2F;geo&#x2F;polar）。<br> 3）图形渲染：最终由 ZRender 生成图形元素（shape），并在 Canvas 或 SVG 上绘制。<br> 性能上，ECharts 依赖 Canvas 的批量绘制能力，以及对 option 变化的 diff&#x2F;merge 策略来避免全量重绘。<br> 工程上要理解：series 是渲染核心，坐标系统决定数据如何映射到像素空间，组件（legend、tooltip 等）是围绕 series 的交互与辅助展示。</p><hr><h4 id="3-setOption-的核心机制是什么？notMerge-和-lazyUpdate-的作用是什么？"><a href="#3-setOption-的核心机制是什么？notMerge-和-lazyUpdate-的作用是什么？" class="headerlink" title="3. setOption 的核心机制是什么？notMerge 和 lazyUpdate 的作用是什么？"></a>3. setOption 的核心机制是什么？notMerge 和 lazyUpdate 的作用是什么？</h4><p><strong>回答模板：</strong><br> setOption 是 ECharts 的主要更新入口。它做的事情不是简单“覆盖配置”，而是包含“合并、diff 与重渲染”的过程。<br> 1）merge（默认合并）：默认 notMerge 为 false，会将新 option 与旧 option 做合并，尽量复用现有结构，减少重建成本。<br> 2）diff 更新：ECharts 会识别哪些组件或系列发生变化，尽可能只更新变化部分；尤其是 series.data 的变化通常可以局部刷新而非全图重建。<br> 3）notMerge：当 notMerge 为 true 时，表示整体替换旧 option，通常会导致组件与系列重建，适用于从根本切换图表结构（比如坐标系统变化、系列类型变化、配置差异很大）。<br> 4）lazyUpdate：为 true 时会延迟渲染，适用于短时间内多次 setOption，减少连续渲染抖动；但要注意最终渲染时机，避免用户看到延迟。<br> 工程建议：</p><ul><li>实时数据：尽量保持图表结构不变，只更新 series.data，使用默认合并；必要时限频 setOption。</li><li>图表模式切换（例如从实时折线切换到历史多系列）：若差异巨大，可用 notMerge true 或先 clear 再 setOption。</li></ul><hr><h4 id="4-大数据量（例如-10-万点折线）如何做性能优化？"><a href="#4-大数据量（例如-10-万点折线）如何做性能优化？" class="headerlink" title="4. 大数据量（例如 10 万点折线）如何做性能优化？"></a>4. 大数据量（例如 10 万点折线）如何做性能优化？</h4><p><strong>回答模板：</strong><br> 大数据量优化的目标是减少渲染成本与更新频率，避免每次都做全量重绘和复杂布局计算。常见策略：<br> 1）关闭动画与无必要特效：动画会放大渲染压力，实时场景尤其应禁用。<br> 2）减少图元数量：折线图可以关闭 symbol（点标记），或者只在 hover 附近显示点。<br> 3）降采样&#x2F;采样：如果屏幕像素宽度有限，超过像素密度的数据点对视觉贡献不大，可用采样策略在不明显损失趋势的情况下减少点数。<br> 4）渐进渲染（progressive）：让渲染分批完成，避免一次性卡顿，适合首屏大数据加载。<br> 5）滑动窗口：实时数据只保留最近 N 个点，历史数据通过 dataZoom 或分页请求加载，避免内存与渲染持续增长。<br> 6）限频更新：数据到达频率高时不要每条都 setOption，可以做缓冲队列，按 100ms&#x2F;200ms 批量更新，保证 UI 稳定。<br> 7）避免频繁重建：图表结构固定，只更新 series.data；尽量不频繁更换坐标系、legend 结构等。<br> 实践中我通常组合：关闭动画 + showSymbol false + 滑动窗口 + 限频 setOption，再根据趋势要求加入采样或 progressive。</p><hr><h4 id="5-实时数据图表怎么设计才能稳定、不卡、不断线也不乱？"><a href="#5-实时数据图表怎么设计才能稳定、不卡、不断线也不乱？" class="headerlink" title="5. 实时数据图表怎么设计才能稳定、不卡、不断线也不乱？"></a>5. 实时数据图表怎么设计才能稳定、不卡、不断线也不乱？</h4><p><strong>回答模板：</strong><br> 实时图表的关键是“数据规范化 + 增量更新 + 断流恢复策略”。<br> 1）数据规范化：统一时间戳格式与排序规则；当数据缺失时，用 null 作为占位以保持时间轴连续，避免图表因为缺点造成连线错误或 tooltip 异常。<br> 2）增量更新：不要每次 setOption 全量 option，只更新变化的 series.data；同时控制数据长度，使用滑动窗口避免无限增长。<br> 3）限频渲染：将实时到达的数据先入队列，使用定时器或 requestAnimationFrame 以固定频率合并更新，避免 burst 导致频繁重绘。<br> 4）断流与恢复：</p><ul><li>断流期间继续向时间轴补 null 或保持最后时刻，避免视觉“冻结误判”；</li><li>恢复后将补发数据按时间戳回填，必要时对时间段进行排序与去重；</li><li>对乱序数据要在进入 series 之前完成排序，保证 x 轴单调。<br> 5）状态管理：前端维护当前图表模式（实时&#x2F;历史）、窗口大小、最大点数与最后时间戳；模式切换时清理旧状态，防止历史数据与实时数据混在一起。<br> 面试中我会强调：实时图表不是“画出来”就结束，而是要处理数据流的工程问题，包括限频、乱序、缺失、恢复与资源回收。</li></ul><hr><h4 id="6-你在-Vue-React-中如何封装一个可复用-ECharts-组件？"><a href="#6-你在-Vue-React-中如何封装一个可复用-ECharts-组件？" class="headerlink" title="6. 你在 Vue&#x2F;React 中如何封装一个可复用 ECharts 组件？"></a>6. 你在 Vue&#x2F;React 中如何封装一个可复用 ECharts 组件？</h4><p><strong>回答模板：</strong><br> 我会把 ECharts 封装成“生命周期完整、输入清晰、可控刷新”的组件。核心点：初始化、更新、resize、销毁。<br> 1）初始化：组件挂载后拿到容器 DOM，调用 echarts.init；同时绑定 resize。<br> 2）更新：通过 props 接收 option 或数据，watch&#x2F;efffect 中调用 setOption；区分结构性变化与纯数据变化：</p><ul><li>结构变化大：clear 或 notMerge true</li><li>纯数据变化：只更新 series.data，保持 merge<br> 3）resize：监听窗口变化与容器尺寸变化，调用 chart.resize。对于 flex&#x2F;layout 变化导致的尺寸不稳定，使用 nextTick 或 ResizeObserver，在容器稳定后再 resize。<br> 4）销毁：组件卸载时 removeListener 并 chart.dispose，避免内存泄漏与事件重复绑定。<br> 5）防抖与限频：对高频更新（实时）在组件内部做缓冲与限频，避免父组件传入频繁触发重绘。<br> 我会在封装中暴露必要的能力：getInstance、dispatchAction、导出图片、清空数据等，让业务层只关注数据与交互。</li></ul><hr><h4 id="7-ECharts-的事件体系怎么用？click-hover-后如何拿到业务数据？"><a href="#7-ECharts-的事件体系怎么用？click-hover-后如何拿到业务数据？" class="headerlink" title="7. ECharts 的事件体系怎么用？click&#x2F;hover 后如何拿到业务数据？"></a>7. ECharts 的事件体系怎么用？click&#x2F;hover 后如何拿到业务数据？</h4><p><strong>回答模板：</strong><br> ECharts 提供 chart.on 监听图表交互事件，事件回调会给 params，其中包含系列索引、数据索引、name、value 以及原始数据。<br> 使用方式：<br> 1）注册事件：chart.on(‘click’, handler)。<br> 2）在 handler 中读取 params：</p><ul><li>seriesIndex 标识哪个系列</li><li>dataIndex 标识系列里的点</li><li>value 是坐标值（可能是数值或数组）</li><li>name 是类目轴的类目名<br> 3）映射到业务：如果我需要回到业务对象，我会在 data 中保留业务 id，例如 data 点使用对象结构 { value: [t, v], id: xxx }，点击后从 params.data 读取 id，再做路由跳转或发请求。<br> 注意：</li><li>多图表组件化时避免重复注册事件；</li><li>图表销毁前要 off 或 dispose；</li><li>对于 tooltip&#x2F;axisPointer 的 hover 联动，可以结合 dispatchAction 实现跨图同步。</li></ul><hr><h4 id="8-图表联动怎么做？比如-A-图-hover-某点，B-图同步高亮与-tooltip"><a href="#8-图表联动怎么做？比如-A-图-hover-某点，B-图同步高亮与-tooltip" class="headerlink" title="8. 图表联动怎么做？比如 A 图 hover 某点，B 图同步高亮与 tooltip"></a>8. 图表联动怎么做？比如 A 图 hover 某点，B 图同步高亮与 tooltip</h4><p><strong>回答模板：</strong><br> 联动一般有两种层级：同一实例内部联动与多实例联动。<br> 1）同一实例内部：可用 axisPointer、dataZoom、legend 组件的联动能力，ECharts 自带协调机制。<br> 2）多实例联动：通过 dispatchAction 实现“外部控制内部状态”。典型做法：</p><ul><li>A 图监听 hover&#x2F;click 得到 dataIndex 或时间戳</li><li>在共享状态中记录当前指示点</li><li>B 图收到状态变化后调用 dispatchAction，例如 showTip&#x2F;highlight&#x2F;downplay 以同步展示<br> 关键点：索引一致性。最稳的方式是用“时间戳或业务 id”作为联动键，而不是只用 dataIndex；因为不同图可能有缺失点、过滤点、采样点，导致 index 不一致。<br> 因此我通常会在数据层做“对齐与归一化”，保证联动时能通过时间戳在 B 图中快速定位对应点。</li></ul><hr><h4 id="9-tooltip-不显示-显示异常，你怎么排查？"><a href="#9-tooltip-不显示-显示异常，你怎么排查？" class="headerlink" title="9. tooltip 不显示&#x2F;显示异常，你怎么排查？"></a>9. tooltip 不显示&#x2F;显示异常，你怎么排查？</h4><p><strong>回答模板：</strong><br> 我会按“触发条件—坐标轴—数据格式—层级遮挡”四类排查：<br> 1）触发条件：tooltip.trigger 是否正确（axis 或 item），axisPointer 是否配置；series 是否允许 tooltip。<br> 2）坐标轴：xAxis&#x2F;yAxis 的 type 是否与数据格式一致，时间轴是否使用 time，类目轴是否使用 category。<br> 3）数据格式：时间轴常用 [time, value]，time 必须可解析（时间戳或标准字符串）；如果传字符串且无法解析，tooltip&#x2F;scale 会异常。缺失值用 null。<br> 4）遮挡与层级：自定义 graphic 或外部 DOM 覆盖可能挡住鼠标事件；另外要检查 grid 是否设置合理，导致实际绘制区域不在可触达范围。<br> 最终我会用最小化 option 验证 tooltip 是否能出现，再逐步恢复配置定位问题来源。</p><hr><h4 id="10-resize-失效或图表变形，你怎么解决？"><a href="#10-resize-失效或图表变形，你怎么解决？" class="headerlink" title="10. resize 失效或图表变形，你怎么解决？"></a>10. resize 失效或图表变形，你怎么解决？</h4><p><strong>回答模板：</strong><br> resize 相关问题通常来自“容器尺寸变化与图表 resize 调用不匹配”。我会：<br> 1）确认容器是否有明确宽高：ECharts 需要容器有可计算的尺寸；height: 100% 时父容器必须有高度。<br> 2）检查容器是否经历 display:none：隐藏时 init 或 resize 会得到 0 尺寸，导致回显异常。解决是在容器显示后再 init&#x2F;resize。<br> 3）对布局变化使用 ResizeObserver：比 window resize 更准确，尤其在侧边栏折叠、tab 切换、flex 变化时。<br> 4）在 Vue 中 nextTick 后 resize：确保 DOM 更新后容器尺寸稳定。<br> 5）keep-alive 场景在 activated 中 resize。<br> 工程上，我倾向于：ResizeObserver + nextTick + activated resize，基本能覆盖绝大多数问题。</p><hr><h4 id="11-如何避免内存泄漏与重复渲染？"><a href="#11-如何避免内存泄漏与重复渲染？" class="headerlink" title="11. 如何避免内存泄漏与重复渲染？"></a>11. 如何避免内存泄漏与重复渲染？</h4><p><strong>回答模板：</strong><br> ECharts 的内存泄漏常见来源是“实例未销毁、事件未解绑、定时器未清理”。我会：<br> 1）组件卸载时 chart.dispose，释放 Canvas 与内部缓存。<br> 2）事件监听在 dispose 前 off 或确保只绑定一次，避免重复触发。<br> 3）清理 window resize 监听、ResizeObserver 监听。<br> 4）实时场景清理定时器与缓冲队列，停止向已销毁实例 setOption。<br> 5）避免频繁 init：能复用实例就复用，只更新数据。<br> 面试中我会强调：图表是“长生命周期对象”，必须像管理 WebSocket 一样管理其生命周期与资源。</p><hr><h4 id="12-图表模式切换（实时-历史、多系列切换）你怎么设计更新策略？"><a href="#12-图表模式切换（实时-历史、多系列切换）你怎么设计更新策略？" class="headerlink" title="12. 图表模式切换（实时&#x2F;历史、多系列切换）你怎么设计更新策略？"></a>12. 图表模式切换（实时&#x2F;历史、多系列切换）你怎么设计更新策略？</h4><p><strong>回答模板：</strong><br> 模式切换本质是“结构切换”还是“数据切换”。<br> 1）如果只是数据范围变化（实时窗口大小变、历史时间段变）但图表结构一致：只更新数据（series.data）、dataZoom 范围等，保持 merge，性能最好。<br> 2）如果切换会导致系列数量、坐标轴类型、legend 结构变化明显：建议 clear 或 notMerge true，然后 setOption 全量结构，避免旧配置残留。<br> 3）对可复用部分（grid、tooltip、axisPointer）抽为公共 option，差异部分按模式拼装，减少重复逻辑。<br> 4）切换时要同步重置状态：选中态、highlight、tooltip、dataZoom 游标、缓存队列等，避免出现历史选中影响实时显示。<br> 总结：用“结构是否变化”决定更新策略，用“状态是否可复用”决定是否清空。</p><hr><h4 id="13-你如何解释-ECharts-中常见的“卡顿”根因？"><a href="#13-你如何解释-ECharts-中常见的“卡顿”根因？" class="headerlink" title="13. 你如何解释 ECharts 中常见的“卡顿”根因？"></a>13. 你如何解释 ECharts 中常见的“卡顿”根因？</h4><p><strong>回答模板：</strong><br> 卡顿通常来自三类根因：渲染压力、更新频率、布局复杂度。<br> 1）渲染压力：点数太多、symbol 太多、动画开启、阴影&#x2F;渐变&#x2F;特效过多会显著增加绘制成本。<br> 2）更新频率：实时数据每条都 setOption，导致主线程持续绘制，造成掉帧。<br> 3）布局复杂度：频繁改变坐标轴、legend、grid、dataZoom 结构会触发布局重算；多图联动还可能导致连锁更新。<br> 解决方法对应三类：减少图元与特效、限频与批量更新、保持结构稳定只更新数据，并在必要时使用采样与渐进渲染</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.Websocket从0到1</title>
    <link href="/2025/12/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/11-Websocket%E4%BB%8E0%E5%88%B01/"/>
    <url>/2025/12/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/11-Websocket%E4%BB%8E0%E5%88%B01/</url>
    
    <content type="html"><![CDATA[<ol><li>WebSocket的作用是什么？</li><li>WebSocket的基础用法有哪些？</li><li>WebSocket的完整生命周期有哪些？</li><li>WebSocket的鉴权方法有哪些？</li><li>WebSocket的心跳机制如何实现？</li></ol><span id="more"></span><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="1-WebSocket的诞生-——-HTTP的局限性"><a href="#1-WebSocket的诞生-——-HTTP的局限性" class="headerlink" title="1. WebSocket的诞生 —— HTTP的局限性"></a>1. WebSocket的诞生 —— HTTP的局限性</h3><h4 id="【HTTP的局限性】"><a href="#【HTTP的局限性】" class="headerlink" title="【HTTP的局限性】"></a>【HTTP的局限性】</h4><p>HTTP 协议是 <strong>请求-响应模型</strong>，它的核心特征可以用一句话概括：</p><blockquote><p><strong>客户端先发请求，服务器才能响应</strong></p></blockquote><p>也就是说：</p><ul><li>服务器 <strong>不能主动</strong> 给客户端发消息</li><li>一次请求，对应一次响应</li><li>通信是<strong>短连接</strong>或逻辑上的短会话</li></ul><p>在 Web 应用的发展过程中，“<strong>实时性</strong>”几乎是一个绕不开的话题。聊天室、在线协作、即时通知、游戏状态同步，这些场景都有一个共同点：<strong>服务器需要在“任何时刻”主动把消息推送给客户端</strong>。</p><p>为了“模拟”实时通信，开发者在 HTTP 之上发明了几种方案。</p><h5 id="轮询（Polling）"><a href="#轮询（Polling）" class="headerlink" title="轮询（Polling）"></a>轮询（Polling）</h5><p>客户端每隔一段时间就问一次服务器：</p><blockquote><p>“有新消息吗？”</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">请求 → 没有<br>请求 → 没有<br>请求 → 没有<br>请求 → 有了<br></code></pre></td></tr></table></figure><p><strong>问题：</strong></p><ul><li>大量无意义请求</li><li>延迟取决于轮询间隔</li><li>浪费服务器和网络资源</li></ul><hr><h5 id="长轮询（Long-Polling）"><a href="#长轮询（Long-Polling）" class="headerlink" title="长轮询（Long Polling）"></a>长轮询（Long Polling）</h5><p>客户端发起请求后，服务器<strong>先不立即返回</strong>，等有数据再返回。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">请求 → 等待 → 有消息 → 返回<br></code></pre></td></tr></table></figure><p>然后客户端立刻再发下一次请求。</p><p><strong>比轮询好，但仍然存在问题：</strong></p><ul><li>本质仍是 HTTP 请求</li><li>高并发下服务器压力大</li></ul><hr><h4 id="Server-Sent-Events（SSE）"><a href="#Server-Sent-Events（SSE）" class="headerlink" title="Server-Sent Events（SSE）"></a>Server-Sent Events（SSE）</h4><p>服务器可以<strong>单向</strong>推送数据给客户端。</p><p><strong>限制很明显：</strong></p><ul><li>只能服务端 → 客户端</li><li>客户端不能实时向服务端发送消息</li><li>聊天室、协作编辑等场景不适用</li></ul><hr><p>无论哪种方案，本质问题始终存在：</p><blockquote><p><strong>HTTP 并不是一个为“持续、双向通信”设计的协议</strong></p></blockquote><p>我们真正需要的是：</p><ul><li>一条 <strong>长期存在的连接</strong></li><li>客户端和服务器 <strong>地位对等</strong></li><li>任意一方都能 <strong>随时发送消息</strong></li><li>低延迟、低开销</li></ul><p>这正是 WebSocket 出现的背景。</p><h4 id="【WebSocket的诞生】"><a href="#【WebSocket的诞生】" class="headerlink" title="【WebSocket的诞生】"></a>【WebSocket的诞生】</h4><p>WebSocket 并不是 HTTP 的“改良版”，而是一个<strong>全新的通信协议</strong>，它的目标非常明确：</p><blockquote><p><strong>在浏览器与服务器之间建立一条真正的、持久的、全双工通信通道</strong></p></blockquote><p>关键词拆解一下：</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td>持久</td><td>连接一旦建立，不用反复创建</td></tr><tr><td>全双工</td><td>客户端和服务器可同时发送</td></tr><tr><td>实时</td><td>消息可以立即到达</td></tr><tr><td>低开销</td><td>没有重复的 HTTP 头部</td></tr></tbody></table><h5 id="WebSocket-与-HTTP-的关系"><a href="#WebSocket-与-HTTP-的关系" class="headerlink" title="WebSocket 与 HTTP 的关系"></a>WebSocket 与 HTTP 的关系</h5><p>一个容易误解的点是：</p><blockquote><p>WebSocket <strong>不是</strong> HTTP 的替代品</p></blockquote><p>它们的关系是：</p><ul><li><strong>建立连接时使用 HTTP</strong></li><li><strong>建立完成后不再使用 HTTP</strong></li></ul><p>具体来说：</p><ol><li>浏览器发起一个 <strong>HTTP 请求</strong></li><li>请求中声明：<code>我要升级为 WebSocket</code></li><li>服务器同意升级</li><li>协议从 HTTP <strong>切换为 WebSocket</strong></li><li>后续通信全部走 WebSocket 帧</li></ol><p>你可以理解为：</p><blockquote><p>HTTP 负责“牵线搭桥”，WebSocket 负责“长期交流”</p></blockquote><h5 id="WebSocket-的核心特性"><a href="#WebSocket-的核心特性" class="headerlink" title="WebSocket 的核心特性"></a>WebSocket 的核心特性</h5><ol><li>真正的双向通信（Full-Duplex）</li></ol><p>在 WebSocket 中：</p><ul><li>客户端 <strong>可以随时发消息</strong></li><li>服务器 <strong>也可以随时推送</strong></li><li>不需要“请求—响应”这一前提</li></ul><p>这使得聊天、推送、协作变得非常自然。</p><hr><ol start="2"><li>单连接、长期存在</li></ol><p>WebSocket 连接一旦建立：</p><ul><li>不会频繁创建和销毁</li><li>不需要反复携带 HTTP Header</li><li>网络和 CPU 开销显著降低</li></ul><p>对于高并发场景尤其重要。</p><hr><ol start="3"><li>更轻量的消息格式</li></ol><p>HTTP 每次请求都包含大量头部信息，而 WebSocket 使用的是<strong>二进制帧（Frame）</strong>：</p><ul><li>帧结构简单</li><li>传输效率高</li><li>基于 WebSocket + JWT 鉴权，结合自定义心跳与指数退避重连，解决实时链路假死、断连与权限失效问题，实现多源传感器数据稳定低延迟推送。</li></ul><hr><ol start="4"><li>原生浏览器支持</li></ol><p>现代浏览器内置了 WebSocket API：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const ws <span class="hljs-operator">=</span> new WebSocket(<span class="hljs-string">&quot;ws://example.com&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>无需插件、无需额外协议栈，这使 WebSocket 成为 Web 实时通信的事实标准。</p><h3 id="2-WebSocket-API"><a href="#2-WebSocket-API" class="headerlink" title="2. WebSocket API"></a>2. WebSocket API</h3><h4 id="【HTML-WebSocket-API】"><a href="#【HTML-WebSocket-API】" class="headerlink" title="【HTML WebSocket API】"></a>【HTML WebSocket API】</h4><ol><li>创建连接</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;url&quot;</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li>常用属性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ws.<span class="hljs-property">readyState</span> <span class="hljs-comment">// 连接状态</span><br><span class="hljs-comment">// 0 CONNETING</span><br><span class="hljs-comment">// 1 OPEN</span><br><span class="hljs-comment">// 2 CLOSING</span><br><span class="hljs-comment">// 3 CLOSED</span><br>ws.<span class="hljs-property">url</span> <span class="hljs-comment">// 连接路径</span><br></code></pre></td></tr></table></figure><ol start="3"><li>常用事件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一种写法， 通过事件定义函数</span><br>ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;&#125;)  <span class="hljs-comment">// 开启  ==&gt; 配合 new WebSocket()</span><br>ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;); <span class="hljs-comment">// 获取消息</span><br>ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;); <span class="hljs-comment">// 关闭 ==&gt; 配合 ws.close</span><br>ws.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;); <span class="hljs-comment">// 错误</span><br><br><span class="hljs-comment">// 第二种写法， 通过属性值</span><br>ws.<span class="hljs-property">onopen</span> = <span class="hljs-function">()=&gt;</span>&#123;&#125;<br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;;<br>ws.<span class="hljs-property">onclose</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;;<br>ws.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><table><thead><tr><th>事件</th><th>含义</th></tr></thead><tbody><tr><td><code>open</code></td><td>握手成功</td></tr><tr><td><code>message</code></td><td>服务端推送</td></tr><tr><td><code>close</code></td><td>服务端或客户端关闭</td></tr><tr><td><code>error</code></td><td>连接异常</td></tr></tbody></table><ol start="4"><li>发送与关闭</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;hello&quot;</span>);              <span class="hljs-comment">// 发送文本</span><br>ws.<span class="hljs-title function_">send</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>([<span class="hljs-number">1</span>]));  <span class="hljs-comment">// 发送二进制</span><br>ws.<span class="hljs-title function_">close</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;bye&quot;</span>);         <span class="hljs-comment">// 正常关闭</span><br></code></pre></td></tr></table></figure><h4 id="【NodeJS-ws库-API】"><a href="#【NodeJS-ws库-API】" class="headerlink" title="【NodeJS ws库 API】"></a>【NodeJS ws库 API】</h4><p>分为客户端和服务器端，客户端和HTML API用法相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 连接 </span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);<br><br><span class="hljs-comment">// 常用方法</span><br>ws.<span class="hljs-title function_">send</span>(data);              <span class="hljs-comment">// 发送消息</span><br>ws.<span class="hljs-title function_">close</span>(code, reason);     <span class="hljs-comment">// 主动关闭</span><br>ws.<span class="hljs-title function_">terminate</span>();             <span class="hljs-comment">// 立即断开（不走 close handshake）</span><br></code></pre></td></tr></table></figure><p>ws 更多用在 NodeJS 创建 WebSocket 服务器。</p><ol><li>创建 WebSocket 服务（绑定 HTTP Server)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">WebSocketServer</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>();<br><span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServer</span>(&#123; server &#125;);<br><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>服务器端核心事件 <code>connection</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">ws, request</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ws：单个客户端连接</span><br>  <span class="hljs-comment">// request：HTTP 握手请求</span><br>&#125;);<br><br><span class="hljs-comment">// 单个连接 ws 的事件 ==&gt; 接收 客户端 new WebSocket 的接口。</span><br>wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">ws, req</span>) =&gt;</span> &#123;<br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">data, isBinary</span>) =&gt;</span> &#123;&#125;);<br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">(<span class="hljs-params">code, reason</span>) =&gt;</span> &#123;&#125;);<br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;&#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><strong>服务端的 <code>ws</code> 对象 ≈ 客户端的 <code>ws</code> 对象</strong></li><li>差别在于：<strong>服务端可以管理“多个 ws”</strong></li></ul></blockquote><hr><ol start="3"><li>服务器端独有的能力</li></ol><p>3.1 客户端集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">wss.<span class="hljs-property">clients</span>; <span class="hljs-comment">// Set&lt;WebSocket&gt;</span><br></code></pre></td></tr></table></figure><p>常用于广播：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> client <span class="hljs-keyword">of</span> wss.<span class="hljs-property">clients</span>) &#123;<br>  <span class="hljs-keyword">if</span> (client.<span class="hljs-property">readyState</span> === client.<span class="hljs-property">OPEN</span>) &#123;<br>    client.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;broadcast&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.2 关闭整个服务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">wss.<span class="hljs-title function_">close</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;server closed&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>3.3 鉴权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">ws, req</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(req.<span class="hljs-property">url</span>, <span class="hljs-string">&quot;http://localhost&quot;</span>).<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;token&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!token) &#123;<br>    ws.<span class="hljs-title function_">close</span>(<span class="hljs-number">1008</span>, <span class="hljs-string">&quot;unauthorized&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><hr><p>客户端 vs 服务器端 API 对照表</p><table><thead><tr><th>维度</th><th>ws 客户端</th><th>ws 服务器端</th></tr></thead><tbody><tr><td>创建方式</td><td><code>new WebSocket(url)</code></td><td><code>new WebSocketServer()</code></td></tr><tr><td>角色</td><td>主动连接</td><td>被动接入</td></tr><tr><td>是否有 <code>connection</code> 事件</td><td>否</td><td>是</td></tr><tr><td>是否管理多个连接</td><td>否</td><td>是</td></tr><tr><td>是否有 <code>clients</code></td><td>否</td><td>是</td></tr><tr><td><code>message</code> 事件</td><td>接收服务端消息</td><td>接收客户端消息</td></tr><tr><td><code>send</code></td><td>发给服务端</td><td>发给某个客户端</td></tr><tr><td><code>broadcast</code></td><td>不支持</td><td>自行实现</td></tr></tbody></table><h4 id="【关键点】"><a href="#【关键点】" class="headerlink" title="【关键点】"></a>【关键点】</h4><p><strong>WebSocket 传输的是“帧”，不是 HTTP 请求</strong></p><ul><li>HTTP：请求-响应，一次一条（除非用 SSE&#x2F;长轮询等）</li><li>WebSocket：一次升级握手后，保持长连接，双向随时发</li></ul><p><strong>消息格式建议：统一 JSON 协议</strong></p><p>不要在工程里混发“裸字符串”，建议统一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;chat&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-string">&quot;ts&quot;</span>: <span class="hljs-number">123</span> &#125;<br></code></pre></td></tr></table></figure><p>前后端都按 <code>type</code> 分发处理。</p><h3 id="3-WebSocket-完整生命周期"><a href="#3-WebSocket-完整生命周期" class="headerlink" title="3. WebSocket 完整生命周期"></a>3. WebSocket 完整生命周期</h3><p>WebSocket 是一种基于 TCP 的全双工通信协议。与传统 HTTP 不同，WebSocket 建立的是<strong>长连接</strong>，其复杂度并不在“连接本身”，而在<strong>连接建立之后的生命周期管理</strong>。</p><p>在实现一个WebSocket功能是，需要考虑 WebSocket 从 <strong>建立连接 → 鉴权 → 状态绑定 → 心跳 → 业务处理 → 异常与清理</strong> 的完整生命周期。</p><h4 id="【连接建立阶段（Connection-Establishment）】"><a href="#【连接建立阶段（Connection-Establishment）】" class="headerlink" title="【连接建立阶段（Connection Establishment）】"></a>【连接建立阶段（Connection Establishment）】</h4><h5 id="1-基于-HTTP-的-Upgrade-握手"><a href="#1-基于-HTTP-的-Upgrade-握手" class="headerlink" title="1. 基于 HTTP 的 Upgrade 握手"></a>1. 基于 HTTP 的 Upgrade 握手</h5><p>WebSocket 的连接并不是一开始就使用 WebSocket 协议，而是：</p><ol><li>客户端先发起 <strong>HTTP 请求</strong></li><li>通过 <code>Upgrade: websocket</code> 头部请求协议升级</li><li>服务器返回 <code>101 Switching Protocols</code></li><li>连接从 HTTP 升级为 WebSocket</li></ol><p>此阶段的本质是：</p><blockquote><p><strong>WebSocket 是通过 HTTP 建立连接，但不会继续使用 HTTP 进行通信</strong></p></blockquote><p>一旦握手完成：</p><ul><li>HTTP 协议结束</li><li>后续通信完全基于 WebSocket 帧协议</li></ul><hr><h5 id="2-连接成功的误区"><a href="#2-连接成功的误区" class="headerlink" title="2. 连接成功的误区"></a>2. 连接成功的误区</h5><p>需要特别强调：</p><blockquote><p><strong>WebSocket 连接成功（open） ≠ 用户身份合法 ≠ 业务可用</strong></p></blockquote><p><code>open</code> 事件只说明：</p><ul><li>网络通信正常</li><li>协议升级成功</li></ul><p>并不代表：</p><ul><li>用户已登录</li><li>权限已校验</li></ul><h4 id="【实时通信阶段（WebSocket-Event-Model）】"><a href="#【实时通信阶段（WebSocket-Event-Model）】" class="headerlink" title="【实时通信阶段（WebSocket Event Model）】"></a>【实时通信阶段（WebSocket Event Model）】</h4><p>连接建立后，通信通过 WebSocket 的事件模型进行。</p><h5 id="1-核心事件"><a href="#1-核心事件" class="headerlink" title="1. 核心事件"></a>1. 核心事件</h5><ul><li><code>open</code>：连接建立成功</li><li><code>message</code>：接收对端消息</li><li><code>error</code>：底层通信异常</li><li><code>close</code>：连接关闭</li></ul><h5 id="2-数据收发模型"><a href="#2-数据收发模型" class="headerlink" title="2. 数据收发模型"></a>2. 数据收发模型</h5><ul><li>通过 <code>send()</code> 发送数据</li><li>所有业务消息通过 <code>message</code> 接收</li><li>WebSocket 本身不理解业务数据结构</li></ul><p>因此，<strong>必须在应用层自行定义消息协议</strong>。</p><h4 id="【连接级鉴权（Authentication）】"><a href="#【连接级鉴权（Authentication）】" class="headerlink" title="【连接级鉴权（Authentication）】"></a>【连接级鉴权（Authentication）】</h4><h5 id="1-为什么-WebSocket-必须单独鉴权"><a href="#1-为什么-WebSocket-必须单独鉴权" class="headerlink" title="1. 为什么 WebSocket 必须单独鉴权"></a>1. 为什么 WebSocket 必须单独鉴权</h5><p>WebSocket 与 HTTP API 最大的不同在于：</p><ul><li>没有 request body</li><li>没有 REST 路由</li><li>一次连接，长期存在</li></ul><p>如果不进行连接级鉴权，会导致：</p><ul><li>任意用户可建立长连接占用资源</li><li>可伪造身份发送业务消息</li><li>权限控制完全失效</li></ul><hr><h5 id="2-常见鉴权方式"><a href="#2-常见鉴权方式" class="headerlink" title="2. 常见鉴权方式"></a>2. 常见鉴权方式</h5><p>工程中最常见、最可靠的方式是：</p><ul><li><strong>Token 鉴权（JWT &#x2F; Access Token）</strong></li><li><strong>首包鉴权（open 后第一条消息）</strong></li></ul><p>典型流程：</p><ol><li>HTTP 登录获取 token</li><li>WebSocket 建立连接</li><li>客户端发送 <code>auth</code> 消息</li><li>服务端校验 token</li><li>鉴权成功后才允许业务通信</li></ol><p>这在语义上等价于 HTTP 中的 <code>Authorization</code>。</p><hr><h5 id="3-鉴权状态机"><a href="#3-鉴权状态机" class="headerlink" title="3. 鉴权状态机"></a>3. 鉴权状态机</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">CONNECTED</span><br>   ↓<br>AUTH_PENDING<br>   ↓<br>AUTHED<br></code></pre></td></tr></table></figure><p>在 <code>AUTHED</code> 之前：</p><ul><li>不允许处理任何业务消息</li><li>非法消息直接关闭连接</li></ul><h4 id="【权限控制（Authorization）】"><a href="#【权限控制（Authorization）】" class="headerlink" title="【权限控制（Authorization）】"></a>【权限控制（Authorization）】</h4><h5 id="1-鉴权-≠-授权"><a href="#1-鉴权-≠-授权" class="headerlink" title="1. 鉴权 ≠ 授权"></a>1. 鉴权 ≠ 授权</h5><p>这是非常容易混淆的一点：</p><ul><li><strong>鉴权（Authentication）</strong>：你是谁</li><li><strong>授权（Authorization）</strong>：你能做什么</li></ul><p>例如在聊天室系统中：</p><ul><li>普通用户：发消息、进群</li><li>管理员：踢人、禁言、解散群聊</li></ul><hr><h5 id="2-权限数据来源"><a href="#2-权限数据来源" class="headerlink" title="2. 权限数据来源"></a>2. 权限数据来源</h5><p>权限信息通常存储在：</p><ul><li>数据库</li><li>Redis</li><li>内存缓存</li></ul><p>在鉴权完成后，将权限信息加载并绑定到连接上下文中，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">ws.<span class="hljs-property">userId</span><br>ws.<span class="hljs-property">roles</span> = [<span class="hljs-string">&#x27;admin&#x27;</span>]<br>ws.<span class="hljs-property">permissions</span> = [...]<br></code></pre></td></tr></table></figure><h4 id="【连接状态绑定（Connection-Binding）】"><a href="#【连接状态绑定（Connection-Binding）】" class="headerlink" title="【连接状态绑定（Connection Binding）】"></a>【连接状态绑定（Connection Binding）】</h4><h5 id="1-为什么要做状态绑定"><a href="#1-为什么要做状态绑定" class="headerlink" title="1. 为什么要做状态绑定"></a>1. 为什么要做状态绑定</h5><p>WebSocket 是“连接导向”的协议，业务却是“用户导向”的。</p><p>因此必须建立映射关系：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">user</span>Id  <span class="hljs-variable">&lt;-&gt;</span>  WebSocket 连接<br></code></pre></td></tr></table></figure><p>并考虑：</p><ul><li>一个用户多端登录</li><li>一个用户多个连接</li></ul><hr><h5 id="2-常见映射结构"><a href="#2-常见映射结构" class="headerlink" title="2. 常见映射结构"></a>2. 常见映射结构</h5><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">userId -&gt; <span class="hljs-keyword">Set</span>&lt;WebSocket&gt;<br>roomId -&gt; <span class="hljs-keyword">Set</span>&lt;WebSocket&gt;<br></code></pre></td></tr></table></figure><h4 id="【心跳机制（Heartbeat）】"><a href="#【心跳机制（Heartbeat）】" class="headerlink" title="【心跳机制（Heartbeat）】"></a>【心跳机制（Heartbeat）】</h4><h5 id="1-为什么必须有心跳"><a href="#1-为什么必须有心跳" class="headerlink" title="1. 为什么必须有心跳"></a>1. 为什么必须有心跳</h5><p>WebSocket 的连接在以下情况下不会立即触发 <code>close</code>：</p><ul><li>客户端断网</li><li>NAT &#x2F; 代理回收连接</li><li>移动网络切换</li></ul><p>没有心跳会产生大量“假在线”连接。</p><hr><h5 id="2-心跳实现方式"><a href="#2-心跳实现方式" class="headerlink" title="2. 心跳实现方式"></a>2. 心跳实现方式</h5><p>方式一：协议级 ping &#x2F; pong</p><ul><li>WebSocket 原生支持</li><li>不携带业务信息</li></ul><p>方式二：应用层自定义心跳</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ping&quot;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pong&quot;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h5 id="3-心跳的工程目标"><a href="#3-心跳的工程目标" class="headerlink" title="3. 心跳的工程目标"></a>3. 心跳的工程目标</h5><ul><li>定期确认连接是否存活</li><li>超时即主动关闭</li><li>释放服务端资源</li></ul><h4 id="【业务消息处理（Business-Processing）】"><a href="#【业务消息处理（Business-Processing）】" class="headerlink" title="【业务消息处理（Business Processing）】"></a>【业务消息处理（Business Processing）】</h4><h5 id="1-消息协议设计"><a href="#1-消息协议设计" class="headerlink" title="1. 消息协议设计"></a>1. 消息协议设计</h5><p>WebSocket 只传输字节流，业务语义由应用层定义。</p><p>推荐统一消息格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;chat&quot;</span>,<br>  <span class="hljs-string">&quot;payload&quot;</span>: &#123;&#125;,<br>  <span class="hljs-string">&quot;requestId&quot;</span>: <span class="hljs-string">&quot;uuid&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="2-消息路由"><a href="#2-消息路由" class="headerlink" title="2. 消息路由"></a>2. 消息路由</h5><p>典型处理流程：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span><br> → parse<br> → 校验权限<br> → 业务处理<br> → 推送结果<br></code></pre></td></tr></table></figure><h4 id="【异常处理与重连策略（Error-Reconnect）】"><a href="#【异常处理与重连策略（Error-Reconnect）】" class="headerlink" title="【异常处理与重连策略（Error &amp; Reconnect）】"></a>【异常处理与重连策略（Error &amp; Reconnect）】</h4><h5 id="1-异常来源"><a href="#1-异常来源" class="headerlink" title="1. 异常来源"></a>1. 异常来源</h5><ul><li>网络中断</li><li>心跳超时</li><li>鉴权失败</li><li>协议错误</li></ul><hr><h5 id="2-客户端重连"><a href="#2-客户端重连" class="headerlink" title="2. 客户端重连"></a>2. 客户端重连</h5><p>WebSocket <strong>不会自动重连</strong>，需要客户端自行实现：</p><ul><li>指数退避</li><li>最大重试次数</li><li>网络恢复触发</li></ul><h4 id="【连接关闭与资源清理（Cleanup）】"><a href="#【连接关闭与资源清理（Cleanup）】" class="headerlink" title="【连接关闭与资源清理（Cleanup）】"></a>【连接关闭与资源清理（Cleanup）】</h4><h5 id="1-关闭来源"><a href="#1-关闭来源" class="headerlink" title="1. 关闭来源"></a>1. 关闭来源</h5><ul><li>客户端主动关闭</li><li>服务端踢下线</li><li>心跳失败</li><li>异常断开</li></ul><hr><h5 id="2-必须做的清理工作"><a href="#2-必须做的清理工作" class="headerlink" title="2. 必须做的清理工作"></a>2. 必须做的清理工作</h5><ul><li>从 <code>userId -&gt; ws</code> 映射中移除</li><li>释放内存状态</li><li>停止心跳定时器</li></ul><p><strong>所有资源清理必须放在 <code>close</code> 阶段完成。</strong></p><h4 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h4><p>WebSocket 并不是“连上就完事”的协议，而是一套<strong>贯穿整个连接生命周期的状态管理体系</strong>。</p><p>真正决定系统稳定性与安全性的，从来不是 <code>new WebSocket()</code>，而是：</p><blockquote><p><strong>鉴权是否严格、状态是否清晰、心跳是否可靠、关闭是否彻底。</strong></p></blockquote><h3 id="4-WebSocket-鉴权"><a href="#4-WebSocket-鉴权" class="headerlink" title="4. WebSocket 鉴权"></a>4. WebSocket 鉴权</h3><p>可以将 WebSocket 鉴权抽象为三个核心问题：</p><p><strong>1.  身份确认（Authentication）</strong></p><ul><li>连接的“这个人”是谁？</li><li>是否是合法用户？</li><li>是否被伪造？</li></ul><ol start="2"><li><strong>权限控制（Authorization）</strong></li></ol><ul><li>这个连接<strong>能做什么</strong>？</li><li>能否加入某个房间 &#x2F; 群聊 &#x2F; 频道？</li><li>是否有发送、接收、管理权限？</li></ul><ol start="3"><li><strong>会话可信性（Session Trust）</strong></li></ol><ul><li>连接是否被劫持？</li><li>Token 是否过期？</li><li>是否支持强制下线？</li></ul><p>所有 WebSocket 鉴权方案，本质都遵循：</p><blockquote><p>在连接生命周期内，某个时刻完成一次可信的身份确认。</p></blockquote><p>可用的入口只有三类：</p><ol><li><strong>HTTP 握手阶段</strong></li><li><strong>连接建立后的第一条消息</strong></li><li><strong>连接生命周期内的持续校验</strong></li></ol><h4 id="【HTTP-握手阶段鉴权】"><a href="#【HTTP-握手阶段鉴权】" class="headerlink" title="【HTTP 握手阶段鉴权】"></a>【HTTP 握手阶段鉴权】</h4><h5 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h5><p>WebSocket 建立时，本质是一次 HTTP 请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/ws/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br></code></pre></td></tr></table></figure><p>此时：</p><ul><li>浏览器仍然会发送 <strong>Cookie</strong></li><li>可以附加 <strong>URL Query</strong></li><li>可以在 Node &#x2F; Java &#x2F; Go 服务端拦截</li></ul><h5 id="2-常见携带方式"><a href="#2-常见携带方式" class="headerlink" title="2. 常见携带方式"></a>2. 常见携带方式</h5><p>（1）Cookie 鉴权（最自然）</p><ul><li>前提：<ul><li>已通过 HTTP 登录</li><li>Session &#x2F; Token 已写入 Cookie</li></ul></li><li>握手时浏览器自动携带</li></ul><p>优点：</p><ul><li>前后端无感</li><li>与传统登录系统完全兼容</li></ul><p>风险点：</p><ul><li>CSRF 风险</li></ul><hr><p>（2）URL Query Token</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">WebSocket</span>(</span><br><span class="hljs-function">  <span class="hljs-string">&#x27;wss://example.com/ws?token=JWT_TOKEN&#x27;</span></span><br><span class="hljs-function">)</span><br></code></pre></td></tr></table></figure><p>服务端在 <code>upgrade</code> 阶段解析：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> &#123; token &#125; = <span class="hljs-keyword">new</span> URL(req.url, <span class="hljs-string">&#x27;http://x&#x27;</span>).searchParams<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>实现简单</li><li>适合移动端 &#x2F; 非浏览器客户端</li></ul><p>缺点：</p><ul><li>Token 可能出现在日志中</li><li>不适合长期敏感凭证</li></ul><hr><p>（3）自定义 Header（非浏览器）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">new WebSocket(url, &#123;<br>  headers: &#123;<br>    Authorization: <span class="hljs-string">&#x27;Bearer xxx&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>限制：</p><ul><li>浏览器 <strong>不允许</strong></li><li>Node &#x2F; 原生客户端可用</li></ul><hr><h5 id="3-服务端典型流程"><a href="#3-服务端典型流程" class="headerlink" title="3. 服务端典型流程"></a>3. 服务端典型流程</h5><ol><li><code>upgrade</code> 事件触发</li><li>提取 Token &#x2F; Session</li><li>校验合法性</li><li>失败 → <code>socket.destroy()</code></li><li>成功 → <code>wss.handleUpgrade()</code></li></ol><h4 id="【连接建立后首条消息鉴权】"><a href="#【连接建立后首条消息鉴权】" class="headerlink" title="【连接建立后首条消息鉴权】"></a>【连接建立后首条消息鉴权】</h4><h5 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1. 原理"></a>1. 原理</h5><ul><li>WebSocket 建立成功</li><li><strong>不立即信任</strong></li><li>要求客户端发送一条 <code>AUTH</code> 消息</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;auth&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><hr><h5 id="2-服务端逻辑"><a href="#2-服务端逻辑" class="headerlink" title="2. 服务端逻辑"></a>2. 服务端逻辑</h5><ul><li>初始连接状态：<code>unauthenticated</code></li><li>收到第一条消息：<ul><li>校验 token</li><li>标记该 socket 为已登录用户</li></ul></li><li>未通过鉴权：<ul><li>立即 close</li></ul></li></ul><hr><h5 id="3-优缺点分析"><a href="#3-优缺点分析" class="headerlink" title="3. 优缺点分析"></a>3. 优缺点分析</h5><p>优点：</p><ul><li>不依赖 HTTP 握手</li><li>适合复杂自定义协议</li></ul><p>缺点：</p><ul><li><strong>连接已经建立</strong></li><li>需要额外状态管理</li><li>容易被滥连攻击（DoS）</li></ul><blockquote><p>工程建议：<strong>仅在无法控制握手阶段时使用</strong></p></blockquote><h4 id="【Token（JWT-Session）】"><a href="#【Token（JWT-Session）】" class="headerlink" title="【Token（JWT &#x2F; Session）】"></a>【Token（JWT &#x2F; Session）】</h4><p>在 WebSocket 系统中，<strong>Token 鉴权</strong>是最主流、也是最成熟的方案。根据 Token 是否“自包含状态”，工程上通常分为 <strong>JWT（无状态）模式</strong> 与 <strong>Session &#x2F; Redis（有状态）模式</strong>。两者在设计理念、适用场景与系统代价上存在本质差异。</p><h5 id="1-JWT-模式（无状态鉴权）"><a href="#1-JWT-模式（无状态鉴权）" class="headerlink" title="1 JWT 模式（无状态鉴权）"></a>1 JWT 模式（无状态鉴权）</h5><ol><li>核心设计思想</li></ol><p>JWT（JSON Web Token）是一种<strong>自包含 Token</strong>，其载荷中直接包含身份与有效性信息，服务端不需要保存会话状态。</p><p>一个典型 JWT 中包含：</p><ul><li><code>userId</code>：用户唯一标识</li><li><code>exp</code>：过期时间</li><li><code>iat</code>：签发时间</li><li><code>iss / aud</code>：签发方 &#x2F; 受众</li><li><code>signature</code>：签名，用于防篡改</li></ul><p>服务端只需：</p><ul><li>校验签名</li><li>校验时间有效性</li><li>解析用户信息</li></ul><p>即可完成身份认证。</p><hr><ol start="2"><li>工程特性</li></ol><ul><li><strong>服务端无状态</strong></li><li>不依赖数据库 &#x2F; Redis</li><li>任意节点均可校验</li><li>非常适合横向扩展</li></ul><p>这使得 JWT 成为 WebSocket 场景中<strong>最常见的鉴权方案之一</strong>。</p><hr><ol start="3"><li>适用场景</li></ol><p>JWT 模式尤其适合：</p><ul><li>分布式 WebSocket 服务</li><li>多实例 &#x2F; 多节点部署</li><li>WebSocket Gateway 架构</li><li>云原生、容器化部署</li><li>Serverless &#x2F; 边缘节点</li></ul><p>在这些场景下：</p><blockquote><p>“连接落在哪个节点”是不确定的，JWT 的无状态特性可显著降低系统复杂度</p></blockquote><hr><ol start="4"><li>WebSocket 中的关键问题：Token 过期</li></ol><p>与 HTTP 不同，WebSocket 是<strong>长连接</strong>，这引出一个必须面对的问题：</p><blockquote><p><strong>连接存续期间，JWT 可能会过期</strong></p></blockquote><p>工程上必须提前明确策略：</p><h5 id="策略一：Token-过期后允许连接继续"><a href="#策略一：Token-过期后允许连接继续" class="headerlink" title="策略一：Token 过期后允许连接继续"></a>策略一：Token 过期后允许连接继续</h5><ul><li>优点：实现简单、连接稳定</li><li>风险：安全窗口扩大</li><li>适合：低风险业务、短连接周期</li></ul><h5 id="策略二：Token-过期后强制断连"><a href="#策略二：Token-过期后强制断连" class="headerlink" title="策略二：Token 过期后强制断连"></a>策略二：Token 过期后强制断连</h5><ul><li>优点：安全性高</li><li>代价：用户体验下降</li><li>实现方式：定时检查 &#x2F; 心跳时校验</li></ul><h5 id="策略三：Token-刷新机制（推荐）"><a href="#策略三：Token-刷新机制（推荐）" class="headerlink" title="策略三：Token 刷新机制（推荐）"></a>策略三：Token 刷新机制（推荐）</h5><ul><li>使用短期 Access Token</li><li>配合 Refresh Token</li><li>在连接内完成刷新</li><li>刷新失败则断连</li></ul><p><strong>关键结论</strong>：</p><blockquote><p>JWT 模式在 WebSocket 中，必须显式设计“过期处理策略”，不能沿用 HTTP 的隐式假设。</p></blockquote><hr><ol start="5"><li>JWT 模式的优缺点总结</li></ol><p><strong>优势：</strong></p><ul><li>无状态，扩展性极佳</li><li>实现简单</li><li>适合高并发、大规模连接</li></ul><p><strong>劣势：</strong></p><ul><li>无法主动失效</li><li>过期控制复杂</li><li>权限变更不即时生效（可以手动添加处理）</li></ul><hr><h5 id="2-Session-Redis-模式（有状态鉴权）"><a href="#2-Session-Redis-模式（有状态鉴权）" class="headerlink" title="2. Session &#x2F; Redis 模式（有状态鉴权）"></a>2. Session &#x2F; Redis 模式（有状态鉴权）</h5><ol><li>核心设计思想</li></ol><p>Session 模式的本质是：</p><blockquote><p><strong>Token 只是一个索引，真正的身份状态保存在服务端</strong></p></blockquote><p>流程如下：</p><ol><li>客户端携带 Token</li><li>服务端通过 Token 查询 Redis &#x2F; 内存</li><li>获取 Session 数据（userId &#x2F; roles &#x2F; permissions）</li><li>判定身份与权限</li></ol><hr><ol start="2"><li>工程特性</li></ol><ul><li>服务端<strong>有状态</strong></li><li>依赖 Redis &#x2F; 内存存储</li><li>每次鉴权都需要一次存储访问</li><li>可以随时修改 &#x2F; 删除 Session</li></ul><hr><ol start="3"><li>适用场景</li></ol><p>Session 模式非常适合以下场景：</p><ul><li>强权限控制系统</li><li>管理后台 &#x2F; 运维平台</li><li>需要“强制下线”的系统</li><li>金融、风控、后台管理类业务</li></ul><p>在这些系统中：</p><blockquote><p><strong>“能否立刻失效” 比 “是否无状态” 更重要</strong></p></blockquote><hr><ol start="4"><li>WebSocket 中的优势</li></ol><p>在 WebSocket 场景下，Session 模式具备显著优势：</p><ul><li>可实时踢下线</li><li>权限变更立即生效</li><li>可绑定设备 &#x2F; IP &#x2F; 登录来源</li><li>可限制同时在线数量</li></ul><p>例如：</p><ul><li>管理员修改权限后，连接可立刻失效</li><li>发现异常行为，立即断开连接</li></ul><h3 id="5-WebSocket-心跳机制"><a href="#5-WebSocket-心跳机制" class="headerlink" title="5.WebSocket 心跳机制"></a>5.WebSocket 心跳机制</h3><h4 id="【心跳机制】"><a href="#【心跳机制】" class="headerlink" title="【心跳机制】"></a>【心跳机制】</h4><p>WebSocket 是长连接，以下情况<strong>不会立即触发 <code>close</code> 事件</strong>：</p><ul><li>客户端突然断网</li><li>手机锁屏 &#x2F; 切后台</li><li>NAT &#x2F; 代理回收空闲连接</li><li>路由器重启</li></ul><p>结果是：</p><ul><li>服务端以为连接还在</li><li>客户端也可能以为连接还在</li><li>出现大量“假在线”连接</li></ul><p>没有心跳的后果</p><ul><li>在线人数统计不准确</li><li>消息发送失败但无感知</li><li>连接池被“僵尸连接”占满</li><li>无法及时踢下线、重连</li></ul><p><strong>结论：</strong></p><blockquote><p>在任何生产环境中，WebSocket 必须实现心跳机制。</p></blockquote><p>心跳机制的核心目标</p><ol><li><strong>检测连接是否仍然可达</strong></li><li><strong>尽早发现断线</strong></li><li><strong>触发重连或资源清理</strong></li><li><strong>保证在线状态的真实性</strong></li></ol><h4 id="【两种主流方式】"><a href="#【两种主流方式】" class="headerlink" title="【两种主流方式】"></a>【两种主流方式】</h4><h5 id="协议级-Ping-Pong（WebSocket-原生）"><a href="#协议级-Ping-Pong（WebSocket-原生）" class="headerlink" title="协议级 Ping &#x2F; Pong（WebSocket 原生）"></a>协议级 Ping &#x2F; Pong（WebSocket 原生）</h5><p>这是 WebSocket 协议（RFC 6455）自带的能力。</p><p>特点</p><ul><li>不进入业务层</li><li>不暴露给前端 API（浏览器端无法直接发送 ping）</li><li>Node.js（如 <code>ws</code>）支持</li></ul><p>工作方式</p><ul><li>服务端定期发送 <code>ping</code> 帧</li><li>客户端自动回复 <code>pong</code></li><li>若长时间未收到 <code>pong</code>，判定连接失效</li></ul><p>优点</p><ul><li>轻量</li><li>不干扰业务协议</li><li>标准化</li></ul><p>缺点</p><ul><li>浏览器端无法主动发送 ping</li><li>不适合承载业务级状态（如 token 校验）</li></ul><p><code>server.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">WebSocketServer</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><br><span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketServer</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> &#125;);<br><br><span class="hljs-comment">// 定期心跳间隔（30s）</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">HEARTBEAT_INTERVAL</span> = <span class="hljs-number">30000</span>;<br><br>wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-function">(<span class="hljs-params">ws, req</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;client connected&quot;</span>);<br><br>  <span class="hljs-comment">// 标记连接存活</span><br>  ws.<span class="hljs-property">isAlive</span> = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 收到 pong，说明连接还活着</span><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    ws.<span class="hljs-property">isAlive</span> = <span class="hljs-literal">true</span>;<br>  &#125;);<br><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;client closed&quot;</span>);<br>  &#125;);<br><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;ws error:&quot;</span>, err.<span class="hljs-property">message</span>);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 服务端统一心跳扫描</span><br><span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  wss.<span class="hljs-property">clients</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ws</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (ws.<span class="hljs-property">isAlive</span> === <span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;terminate dead connection&quot;</span>);<br>      <span class="hljs-keyword">return</span> ws.<span class="hljs-title function_">terminate</span>(); <span class="hljs-comment">// 直接断开</span><br>    &#125;<br><br>    <span class="hljs-comment">// 标记为待检测</span><br>    ws.<span class="hljs-property">isAlive</span> = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 发送协议级 ping</span><br>    ws.<span class="hljs-title function_">ping</span>();<br>  &#125;);<br>&#125;, <span class="hljs-variable constant_">HEARTBEAT_INTERVAL</span>);<br><br><span class="hljs-comment">// 进程退出时清理</span><br>wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">clearInterval</span>(interval);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ws server listening on ws://localhost:8080&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>重要说明</p><ul><li>当<strong>服务端 ping</strong>时：<ul><li>客户端会<strong>自动回复 pong</strong></li><li><strong>不会触发 <code>pong</code> 事件</strong></li></ul></li><li><code>pong</code> 事件只在<strong>你主动 <code>ws.ping()</code> 时</strong>才触发</li></ul><p>浏览器 JS 层：</p><ul><li>❌ 看不到 ping</li><li>❌ 看不到 pong</li><li>❌ 不触发 message</li><li>❌ 不触发任何“心跳相关事件”</li></ul><h4 id="【应用层自定义心跳】"><a href="#【应用层自定义心跳】" class="headerlink" title="【应用层自定义心跳】"></a>【应用层自定义心跳】</h4><p>通过普通 WebSocket 消息实现心跳。更为常用。</p><p>特点</p><ul><li>完全由业务层控制</li><li>浏览器、Node 统一</li><li>可结合鉴权、权限、状态校验</li></ul><p>优点</p><ul><li>灵活</li><li>可扩展</li><li>适合 WebSocket 业务系统</li></ul><p>缺点</p><ul><li>需要自己实现逻辑</li><li>稍有额外流量</li></ul><h5 id="客户端心跳职责"><a href="#客户端心跳职责" class="headerlink" title="客户端心跳职责"></a>客户端心跳职责</h5><ul><li>定时发送 <code>ping</code></li><li>监听 <code>pong</code></li><li>在 close &#x2F; error 时触发重连</li><li>页面不可见时（visibilitychange）可降低频率</li></ul><p>客户端示例逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timeoutTimer = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendPing</span>(<span class="hljs-params">ws</span>) &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-string">&quot;123&quot;</span>; <span class="hljs-comment">// 示例，真实用随机值</span><br><br>  <span class="hljs-comment">// 1. 发 ping</span><br>  ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;ping&quot;</span>, id &#125;));<br><br>  <span class="hljs-comment">// 2. 开始等 pong（8 秒）</span><br>  timeoutTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ping 失败：没等到 pong&quot;</span>);<br>    ws.<span class="hljs-title function_">close</span>();<br>  &#125;, <span class="hljs-number">8000</span>);<br>&#125;<br><br><span class="hljs-comment">// 3. 收消息</span><br>ws.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> msg = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>);<br><br>  <span class="hljs-keyword">if</span> (msg.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;pong&quot;</span> &amp;&amp; msg.<span class="hljs-property">id</span> === <span class="hljs-string">&quot;123&quot;</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeoutTimer);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;✅ ping 成功&quot;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p><strong>发 ping 的同时设一个“闹钟”，收到对应 pong 就关闹钟。</strong></p></blockquote><hr><h5 id="服务端心跳职责"><a href="#服务端心跳职责" class="headerlink" title="服务端心跳职责"></a>服务端心跳职责</h5><ul><li>记录每个连接的 <code>lastHeartbeat</code></li><li>收到 <code>ping</code> 立即回复 <code>pong</code></li></ul><p>服务端示例逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> msg = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);<br><br>  <span class="hljs-keyword">if</span> (msg.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;ping&quot;</span>) &#123;<br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;pong&quot;</span>,<br>      <span class="hljs-attr">id</span>: msg.<span class="hljs-property">id</span><br>    &#125;));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>服务端<strong>什么都不用想</strong>：</p><ul><li>不计时</li><li>不存状态</li><li>原样回 <code>id</code></li></ul><h4 id="【区分正常close和异常close】"><a href="#【区分正常close和异常close】" class="headerlink" title="【区分正常close和异常close】"></a>【区分正常close和异常close】</h4><blockquote><p>根据判断正常close和异常close来决定是否处理或者重传。</p></blockquote><p><strong>看 close code</strong></p><ul><li><code>1000</code>：正常关闭</li><li><code>1006</code>：异常关闭（端口&#x2F;网络断）</li></ul><p><strong>看 error 事件</strong></p><ul><li>异常断开：常伴随 <code>error</code></li></ul><h5 id="1）正常关闭（Graceful-Close）"><a href="#1）正常关闭（Graceful-Close）" class="headerlink" title="1）正常关闭（Graceful Close）"></a>1）正常关闭（Graceful Close）</h5><p><strong>定义</strong>：按照 WebSocket 协议完成 <strong>Close 握手</strong>。</p><p><strong>常见场景</strong></p><ul><li>客户端主动退出</li><li>服务端业务结束</li><li>鉴权失败后主动 <code>close()</code></li><li>被“踢下线”（策略性关闭）</li></ul><p><strong>特征</strong></p><ul><li><code>onclose</code> 一定触发</li><li><code>code</code> 为 <strong>1000</strong> 或明确的策略码</li><li>双方都“知道”这次关闭</li></ul><h5 id="2）异常关闭（Abnormal-Close-端口断）"><a href="#2）异常关闭（Abnormal-Close-端口断）" class="headerlink" title="2）异常关闭（Abnormal Close &#x2F; 端口断）"></a>2）异常关闭（Abnormal Close &#x2F; 端口断）</h5><p><strong>定义</strong>：<strong>没有</strong>完成 Close 握手，连接直接消失。</p><p><strong>常见场景</strong></p><ul><li>客户端断网 &#x2F; 进程被杀</li><li>服务端进程崩溃</li><li>NAT &#x2F; 代理回收端口</li><li>TCP 连接被强制重置</li></ul><p><strong>特征</strong></p><ul><li><code>onclose</code> 触发</li><li><code>code</code> 通常为 <strong>1006</strong></li><li><code>reason</code>通常未空</li><li>往往伴随 <code>error</code></li></ul><table><thead><tr><th>code</th><th>含义</th><th>是否正常</th></tr></thead><tbody><tr><td>1000</td><td>Normal Closure</td><td>✅ 正常</td></tr><tr><td>1001</td><td>Going Away</td><td>✅ 正常</td></tr><tr><td>1008</td><td>Policy Violation</td><td>✅ 正常（策略关闭）</td></tr><tr><td>1011</td><td>Internal Error</td><td>⚠️ 服务端异常</td></tr><tr><td><strong>1006</strong></td><td>Abnormal Closure</td><td>❌ 异常（端口&#x2F;网络）</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ws.<span class="hljs-property">onclose</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;code:&quot;</span>, e.<span class="hljs-property">code</span>, <span class="hljs-string">&quot;reason:&quot;</span>, e.<span class="hljs-property">reason</span>, <span class="hljs-string">&quot;wasClean:&quot;</span>, e.<span class="hljs-property">wasClean</span>);<br><br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">code</span> === <span class="hljs-number">1000</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;正常关闭&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.<span class="hljs-property">code</span> === <span class="hljs-number">1006</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;异常断开（端口/网络）&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;其他关闭类型:&quot;</span>, e.<span class="hljs-property">code</span>);<br>  &#125;<br>&#125;;<br><br>ws.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;发生网络或协议错误&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ws.close()</code> <strong>支持传递 <code>code</code> 和 <code>reason</code><strong>，并且这是</strong>工程上强烈推荐</strong>的做法。</p><p>下面把<strong>用法、合法范围、注意事项、与浏览器差异</strong>一次讲清楚。</p><p>最直接的结论</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ws.close</span>(<span class="hljs-meta">code</span>, reason)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li><code>code</code>：<strong>WebSocket Close Code（必需是合法值）</strong></li><li><code>reason</code>：关闭原因（可选，字符串）</li></ul><ol><li>正常关闭</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ws</span>.close(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;normal close&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>鉴权失败 &#x2F; 被踢下线（常用）</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ws</span>.close(<span class="hljs-number">1008</span>, <span class="hljs-string">&quot;unauthorized&quot;</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>服务端异常</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ws</span>.close(<span class="hljs-number">1011</span>, <span class="hljs-string">&quot;internal error&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>官方<code>close code</code></p></blockquote><table><thead><tr><th>code</th><th>含义</th></tr></thead><tbody><tr><td>1000</td><td>正常关闭</td></tr><tr><td>1001</td><td>端点离开（刷新&#x2F;切页）</td></tr><tr><td>1006</td><td>异常断开（浏览器推断，不能手动设置）</td></tr><tr><td>1008</td><td>策略违规（如权限问题，但不够细）</td></tr><tr><td>1011</td><td>服务端内部错误</td></tr></tbody></table><blockquote><p>自定义 <code>close code</code></p></blockquote><table><thead><tr><th>code</th><th>业务含义</th></tr></thead><tbody><tr><td>4001</td><td>JWT 过期</td></tr><tr><td>4003</td><td>无实时权限</td></tr><tr><td>4004</td><td>用户被禁用</td></tr><tr><td>4100</td><td>客户端协议错误</td></tr><tr><td>4500</td><td>服务端业务异常</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.Generator</title>
    <link href="/2025/12/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/10-Generator/"/>
    <url>/2025/12/29/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/10-Generator/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是Generator?</li><li>Generator的功能是什么？</li><li>Generator与<code>async</code>和<code>await</code>的关系是什么？</li></ol><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><h3 id="1-Generator描述"><a href="#1-Generator描述" class="headerlink" title="1. Generator描述"></a>1. Generator描述</h3><p><strong>Generator（生成器）</strong> 是 JavaScript 中一种<strong>可暂停、可恢复执行的函数</strong>。它通过 <code>function*</code> 定义，并使用 <code>yield</code> 将函数的执行过程拆分为多个阶段。调用 Generator 函数并不会立即执行函数体，而是返回一个<strong>迭代器对象</strong>；每次调用迭代器的 <code>next()</code> 方法，函数才会从上一次暂停的位置继续执行，直到遇到下一个 <code>yield</code> 或执行结束。</p><p>在执行过程中，<code>yield</code> 用于<strong>产出当前阶段的值并暂停函数</strong>，而下一次 <code>next(value)</code> 传入的参数会作为<strong>上一次 <code>yield</code> 表达式的返回值</strong>，从而实现外部与函数内部之间的双向数据传递。当函数执行到 <code>return</code> 或自然结束时，Generator 终止，并返回 <code>&#123; done: true &#125;</code> 状态。</p><p>从本质上看，Generator 并不是异步方案，而是一种<strong>流程控制工具</strong>。它常用于实现自定义迭代器、状态机，以及在 <code>async/await</code> 出现之前配合 Promise 执行器控制异步流程。<code>async/await</code> 可以被视为基于 Generator 思想的自动化、工程化实现。</p><h3 id="2-通过案例分析Generator"><a href="#2-通过案例分析Generator" class="headerlink" title="2. 通过案例分析Generator"></a>2. 通过案例分析Generator</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fetchGenerator</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data1&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data2 = <span class="hljs-keyword">yield</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data2&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1, data2);<br>&#125;<br><br><span class="hljs-comment">// 手动执行 Generator</span><br><span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">fetchGenerator</span>();<br><br>gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data1</span> =&gt;</span> gen.<span class="hljs-title function_">next</span>(data1).<span class="hljs-property">value</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data2</span> =&gt;</span> gen.<span class="hljs-title function_">next</span>(data2));<br></code></pre></td></tr></table></figure><p><strong>Generator 只负责“把异步流程拆成可暂停的步骤”，Promise 链负责“真正的异步执行”，开发者手动把两者接起来。</strong></p><p>▶ 第 0 步：创建 Generator（但不执行）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const gen <span class="hljs-operator">=</span> fetchGenerator()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li><code>fetchGenerator()</code> <strong>不会执行函数体</strong></li><li>只返回一个 <strong>Generator 对象（迭代器）</strong></li><li>内部代码一行都没跑</li></ul><p>▶ 第 1 步：第一次 <code>next()</code></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">gen.<span class="hljs-keyword">next</span>()<br></code></pre></td></tr></table></figure><p>Generator 开始执行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> data1 = <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-title">fetch</span>(<span class="hljs-params"><span class="hljs-string">&#x27;/api/data1&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>执行到 <code>yield</code>，发生三件事：</p><ol><li><code>fetch(&#39;/api/data1&#39;)</code> 被 <strong>立即执行</strong></li><li><code>yield</code> 把这个 Promise <strong>交还给外部</strong></li><li>Generator <strong>暂停在这一行</strong></li></ol><p>返回结果是：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">&#123;<br>  value: <span class="hljs-built_in">Promise</span>,   <span class="hljs-regexp">//</span> fetch(<span class="hljs-string">&#x27;/api/data1&#x27;</span>) 返回的 <span class="hljs-built_in">Promise</span><br>  done: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gen.<span class="hljs-keyword">next</span>().value   <span class="hljs-regexp">//</span> === fetch(<span class="hljs-string">&#x27;/api/data1&#x27;</span>) 返回的 Promise<br></code></pre></td></tr></table></figure><p>▶ 第 2 步：处理第一个异步结果</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">gen.next<span class="hljs-params">()</span><span class="hljs-string">.value</span><br>  <span class="hljs-string">.then</span><span class="hljs-params">(<span class="hljs-attr">res</span> =&gt; res.json()</span>)<br>  <span class="hljs-string">.then</span><span class="hljs-params">(<span class="hljs-attr">data1</span> =&gt; gen.next(data1)</span><span class="hljs-string">.value</span>)<br></code></pre></td></tr></table></figure><p>这里发生了关键的一步：</p><p><code>gen.next(data1)</code> 的含义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> data1 = <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-title">fetch</span>(<span class="hljs-params"><span class="hljs-string">&#x27;/api/data1&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const data1 <span class="hljs-operator">=</span> 上一次 yield 的返回值<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>而 <strong>上一次 yield 的返回值 &#x3D; <code>next(data1)</code> 传入的参数</strong>。</p><p>所以：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const data1 <span class="hljs-operator">=</span> data1<span class="hljs-comment">; // 成立</span><br></code></pre></td></tr></table></figure><p>▶ 第 3 步：执行到第二个 yield</p><p>Generator 继续执行下一行：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> data2 = <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-title">fetch</span>(<span class="hljs-params"><span class="hljs-string">&#x27;/api/data2&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>再次发生：</p><ol><li>执行 <code>fetch(&#39;/api/data2&#39;)</code></li><li>把 Promise <code>yield</code> 出去</li><li>Generator 再次暂停</li></ol><p>所以：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gen.<span class="hljs-keyword">next</span>(data1).value   <span class="hljs-regexp">//</span> === fetch(<span class="hljs-string">&#x27;/api/data2&#x27;</span>) 返回的 Promise<br></code></pre></td></tr></table></figure><p>▶ 第 4 步：处理第二个异步结果</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())<br>.then(<span class="hljs-function"><span class="hljs-params">data2</span> =&gt;</span> gen.next(data2));<br></code></pre></td></tr></table></figure><p>这一步：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">gen.<span class="hljs-keyword">next</span>(data2)<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const data2 <span class="hljs-operator">=</span> data2<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后 Generator 继续执行：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data1, data2);<br></code></pre></td></tr></table></figure><p>函数执行结束，相当于：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>最终返回：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123; <span class="hljs-attr">value:</span> <span class="hljs-string">undefined</span>, <span class="hljs-attr">done:</span> <span class="hljs-literal">true</span> &#125;<br></code></pre></td></tr></table></figure><p>Generator <strong>完全结束</strong>。</p><h3 id="3-Generator-与-async-await"><a href="#3-Generator-与-async-await" class="headerlink" title="3.Generator 与 async/await"></a>3.Generator 与 <code>async/await</code></h3><p>在 <code>async/await</code> 出现前：</p><ul><li>JS 没有“自动等待 Promise”</li><li>Generator 提供了：<ul><li><strong>暂停</strong></li><li><strong>恢复</strong></li><li><strong>传值</strong></li></ul></li></ul><p>于是就形成了这种模式：</p><blockquote><p><strong>Generator 负责流程，Promise 负责异步</strong></p></blockquote><p>后来出现了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data1&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-title function_">json</span>());<br>  <span class="hljs-keyword">const</span> data2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data2&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-title function_">json</span>());<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1, data2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这正是 Generator + 执行器 的语法糖</strong></p><p>你这段代码其实等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">gen</span>) &#123;<br>  <span class="hljs-keyword">const</span> g = <span class="hljs-title function_">gen</span>();<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">nextFn, arg</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; value, done &#125; = <span class="hljs-title function_">nextFn</span>(arg);<br>    <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span>;<br>    value.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>         .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">step</span>(g.<span class="hljs-property">next</span>.<span class="hljs-title function_">bind</span>(g), data));<br>  &#125;<br><br>  <span class="hljs-title function_">step</span>(g.<span class="hljs-property">next</span>.<span class="hljs-title function_">bind</span>(g));<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是早期 <code>co</code> 库的核心思想。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.浏览器安全协议</title>
    <link href="/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/9-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
    <url>/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/9-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是HTTPS协议？</li><li>TLS&#x2F;SSL的工作原理是什么？</li><li>数字证书是什么？</li><li>TLS握手</li><li>浏览器的攻击方式有哪些？</li></ol><span id="more"></span><h2 id="浏览器安全问题"><a href="#浏览器安全问题" class="headerlink" title="浏览器安全问题"></a>浏览器安全问题</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98">一个常见的面试题</a></p></blockquote><h3 id="1-HTTPS协议？"><a href="#1-HTTPS协议？" class="headerlink" title="1. HTTPS协议？"></a>1. HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL&#x2F;TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><img src="/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/9-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png" class title="img"><p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p><p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p><h3 id="2-TLS-SSL的工作原理"><a href="#2-TLS-SSL的工作原理" class="headerlink" title="2. TLS&#x2F;SSL的工作原理"></a>2. TLS&#x2F;SSL的工作原理</h3><p><strong>TLS&#x2F;SSL</strong>全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p><p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商<img src="/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/9-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png" class title="img"></li></ul><p><strong>2.1 散列函数hash</strong></p><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p><p><strong>特点：</strong> 在信息传输过程中，散列函数不能都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p><p><strong>2.2 对称加密</strong></p><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p><p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p><p><strong>特点：</strong> 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p><p><strong>2.3 非对称加密</strong></p><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p><p><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p><p>综合上述算法特点，TLS&#x2F;SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p><h4 id="【TLS-思路总结】"><a href="#【TLS-思路总结】" class="headerlink" title="【TLS 思路总结】"></a>【TLS 思路总结】</h4><p><strong>1.为什么要校验数据完整性</strong></p><p>在网络传输中，客户端发送的数据可能面临三类风险：（1）被篡改；（2）被插入伪造内容；（3）在传输过程中发生异常变化。因此，通信双方需要一种机制来判断“接收到的数据是否仍然是原始数据”。</p><p>散列函数正是用于解决这一问题。其基本思路是：发送方对原始数据计算一个摘要值，接收方对接收到的数据再次计算摘要，并将两次结果进行比对。如果两者一致，可以认为数据在传输过程中没有发生变化。</p><p>但需要注意的是： <strong>仅依靠散列函数并不能真正防止篡改。</strong><br> 如果数据和摘要以明文形式传输，中间人完全可以在篡改数据后重新计算摘要，使校验结果依然“正确”。</p><p>因此，完整性校验必须与密钥机制结合，才能具备安全意义。</p><p><strong>2.为什么需要加密数据内容</strong></p><p>为了防止数据在传输过程中被窃听或随意修改，通信内容不能以明文形式传输，而必须转换为密文。TLS 中用于加密实际数据内容的，是<strong>对称加密机制</strong>。</p><p>对称加密的基本特点是：通信双方使用同一把密钥对数据进行加密和解密。这种方式计算效率高，适合对大量数据（如 HTTP 请求和响应）进行加密传输。</p><p>因此，TLS 的基本策略是： <strong>实际业务数据全部使用对称加密进行保护。</strong></p><p><strong>3.对称加密带来的核心问题：密钥如何安全获得</strong></p><p>对称加密的安全性完全依赖于密钥的保密性。一旦密钥在传输过程中被第三方获取，那么后续所有加密通信都会失去意义。</p><p>问题在于：通信双方在建立连接之前，并没有共享密钥，而网络本身又是不安全的，无法直接明文发送密钥。</p><p>因此，对称加密本身无法解决“密钥如何安全传输”的问题。</p><p><strong>4.非对称加密在 TLS 中的作用</strong></p><p>为了解决对称密钥的安全协商问题，TLS 引入了<strong>非对称加密和密钥协商机制</strong>。</p><p>非对称加密的基本特点是：每一方拥有一对密钥（公钥和私钥），公钥可以公开，私钥必须保密。通过这一机制，可以在不事先共享秘密的情况下建立安全关系。</p><p>在 TLS 中，非对称加密并不用于加密大量数据，而主要用于两件事：（1）确认通信对方的身份；（2）在不安全的网络中协助建立对称加密所需的会话密钥。</p><p>常见的密钥协商方式（如 Diffie-Hellman 类机制）并不是“直接传输密钥”，而是通过双方各自参与计算，使客户端和服务器最终得到同一份共享秘密，而这一秘密不会在网络中直接出现。</p><p><strong>5.为什么最终仍然使用对称加密通信</strong></p><p>虽然非对称加密可以解决密钥协商和身份认证问题，但其计算开销较大、效率较低。如果所有数据都使用非对称加密，会严重影响通信性能。</p><p>因此，TLS 采用的是一种“分工协作”的策略：</p><p>（1）使用非对称加密和证书机制完成身份认证和密钥协商；</p><p>（2）在此基础上生成一组对称会话密钥；</p><p>（3）后续所有通信数据，统一使用对称加密和完整性校验机制进行保护。</p><h3 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a>3. 数字证书</h3><p>现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。</p><h3 id="4-TLS-SSL握手"><a href="#4-TLS-SSL握手" class="headerlink" title="4. TLS&#x2F;SSL握手"></a>4. TLS&#x2F;SSL握手</h3><p>从逻辑上看，TLS 握手可以分为四个阶段：</p><ol><li>客户端发起连接并声明能力</li><li>服务器确认参数并证明身份</li><li>双方协商并生成会话密钥</li><li>双方确认握手完整性并进入加密通信</li></ol><h4 id="第一阶段：客户端发起连接（ClientHello）"><a href="#第一阶段：客户端发起连接（ClientHello）" class="headerlink" title="第一阶段：客户端发起连接（ClientHello）"></a>第一阶段：客户端发起连接（ClientHello）</h4><p><strong>客户端发送的主要信息</strong></p><p>客户端在第一次握手消息中，会向服务器发送以下内容：（1）支持的 TLS 协议版本；（2）支持的加密套件列表；（3）客户端随机数；（4）密钥协商所需的参数（在现代 TLS 中通常包含客户端的临时公钥）。</p><p><strong>这一阶段要解决的问题</strong></p><p>这一阶段的核心目的不是加密，而是<strong>能力声明</strong>：</p><ul><li>告诉服务器“我支持哪些安全算法”</li><li>提供客户端随机数，作为后续会话密钥生成的输入</li><li>提前提供密钥协商所需的信息，以减少往返次数</li></ul><p>此时所有数据均为明文传输，但不会直接影响安全性。</p><h4 id="第二阶段：服务器响应与身份认证"><a href="#第二阶段：服务器响应与身份认证" class="headerlink" title="第二阶段：服务器响应与身份认证"></a>第二阶段：服务器响应与身份认证</h4><p>服务器在收到 ClientHello 后，会返回一组消息，用于确认参数并证明自身身份。</p><p><strong>服务器发送的主要信息</strong></p><p>服务器通常会发送：（1）选择使用的 TLS 版本和加密套件；（2）服务器随机数；（3）服务器数字证书；（4）密钥协商所需的参数（如服务器的临时公钥）；（5）表示握手阶段信息发送完毕的标志。</p><p><strong>服务器数字证书的作用</strong></p><p>数字证书的核心作用是：<strong>证明服务器公钥的真实归属</strong>。</p><p>客户端会根据内置的受信任 CA 列表，对证书的签名、有效期和域名进行验证，从而确认当前通信对象确实是目标服务器，而不是中间人。</p><p><strong>这一阶段解决的问题</strong></p><ul><li>服务器确认最终使用的安全参数</li><li>客户端完成服务器身份验证</li><li>双方获得用于密钥协商的全部公开信息</li></ul><h4 id="第三阶段：密钥协商与会话密钥生成"><a href="#第三阶段：密钥协商与会话密钥生成" class="headerlink" title="第三阶段：密钥协商与会话密钥生成"></a><strong>第三阶段：密钥协商与会话密钥生成</strong></h4><p><strong>密钥协商的基本思路</strong></p><p>在 TLS 中，会话密钥不会被直接发送，而是通过密钥协商机制，使客户端和服务器<strong>各自独立计算出相同的共享秘密</strong>。这个共享秘密不会在网络中直接出现。</p><p>客户端和服务器都会参与计算，并结合双方在前面阶段交换的随机数，派生出一组会话密钥。</p><p><strong>会话密钥的特点</strong></p><p>通过握手生成的会话密钥具有以下特性：（1）只用于当前连接；（2）客户端和服务器各自保存；（3）不会被第三方获知；（4）连接结束后即失效。</p><p>这些会话密钥将用于后续所有数据通信。</p><h4 id="第四阶段：握手完整性确认（Finished）"><a href="#第四阶段：握手完整性确认（Finished）" class="headerlink" title="第四阶段：握手完整性确认（Finished）"></a><strong>第四阶段：握手完整性确认（Finished）</strong></h4><p><strong>为什么还需要“最后确认”</strong></p><p>即使完成了密钥协商，仍然需要确认一个问题：<strong>整个握手过程中，所有消息是否被篡改过。</strong></p><p>为此，客户端和服务器会分别发送一条“完成消息”，该消息包含对之前所有握手消息的校验结果，并使用刚刚生成的会话密钥进行保护。</p><p><strong>这一阶段的意义</strong></p><ul><li>确认双方计算出的会话密钥一致</li><li>确认握手过程未被中间人修改</li><li>标志 TLS 握手正式结束</li></ul><p>如果校验失败，连接会被立即中断。</p><h4 id="握手完成后的通信阶段"><a href="#握手完成后的通信阶段" class="headerlink" title="握手完成后的通信阶段"></a>握手完成后的通信阶段</h4><p>TLS 握手完成后，客户端和服务器进入加密通信阶段。此后传输的所有应用层数据都会：</p><ul><li>使用会话密钥进行对称加密；</li><li>结合完整性校验机制防止篡改；</li><li>保证通信内容的机密性和可靠性。</li></ul><p>对应用层（如 HTTP）来说，TLS 的存在是透明的。</p><h3 id="5-TLS-防护常见网络攻击笔记"><a href="#5-TLS-防护常见网络攻击笔记" class="headerlink" title="5. TLS 防护常见网络攻击笔记"></a>5. TLS 防护常见网络攻击笔记</h3><h4 id="【窃听攻击（Eavesdropping-Sniffing）】"><a href="#【窃听攻击（Eavesdropping-Sniffing）】" class="headerlink" title="【窃听攻击（Eavesdropping &#x2F; Sniffing）】"></a>【窃听攻击（Eavesdropping &#x2F; Sniffing）】</h4><p><strong>攻击原理</strong></p><p>窃听攻击属于被动攻击，攻击者无需主动干预网络通信流程，只需将自身接入目标网络链路中，通过网络抓包工具捕获传输的数据包，从而被动监听并获取通信双方的内容。常见的攻击链路场景包括公共 Wi-Fi 热点覆盖的网络环境（如咖啡馆、商场、机场的免费 Wi-Fi）、企业内部局域网以及运营商的网络传输链路等。在未启用加密保护的通信中，传输的数据以明文形式存在，攻击者捕获数据包后可以直接解析出其中包含的关键信息。</p><p><strong>TLS 防护机制</strong></p><p>TLS 的核心防护逻辑在于对传输数据进行加密处理。在 TLS 握手阶段，客户端与服务器会完成服务器身份验证、加密算法协商以及会话密钥的生成；握手完成后，后续所有应用层数据（如 HTTP 请求与响应）都会使用协商好的会话密钥进行加密。即使攻击者成功捕获到全部网络数据包，由于无法获取对应的会话密钥，也无法解析出其中的原始内容，只能得到无意义的密文。</p><p><strong>典型案例</strong></p><p>用户在咖啡馆使用公共 Wi-Fi 登录某购物网站：（1）若网站使用 HTTP 协议，攻击者可通过抓包工具直接解析登录请求中的参数，例如 <code>username=alice&amp;password=123456</code>，从而窃取用户账号密码；（2）若网站使用 HTTPS 协议，攻击者捕获到的仅为加密后的数据流，无法还原任何登录信息、访问内容或请求参数。</p><h4 id="【中间人攻击（Man-in-the-Middle，MITM）】"><a href="#【中间人攻击（Man-in-the-Middle，MITM）】" class="headerlink" title="【中间人攻击（Man-in-the-Middle，MITM）】"></a>【中间人攻击（Man-in-the-Middle，MITM）】</h4><p><strong>攻击原理</strong></p><p>中间人攻击属于主动攻击，攻击者会主动介入客户端与服务器之间的通信链路，构建“客户端—攻击者—服务器”的通信结构。在该模式下，攻击者对客户端冒充服务器、对服务器冒充客户端，不仅能够监听通信内容，还可以篡改、伪造通信数据，并试图让通信双方无法察觉攻击的存在。典型场景包括恶意 Wi-Fi 热点、DNS 劫持以及局域网内的 ARP 欺骗。</p><p><strong>TLS 防护机制</strong></p><p>TLS 通过“数字证书 + 证书链验证”机制抵御中间人攻击。服务器必须持有由可信 CA 签发的数字证书，证书中包含服务器域名、公钥及 CA 的签名。在 TLS 握手阶段，客户端会验证证书的签发机构、域名匹配性、有效期以及签名合法性。由于攻击者无法伪造可信 CA 签发的合法证书，且密钥协商过程与服务器证书绑定，一旦攻击者尝试冒充服务器或篡改协商参数，客户端会检测到异常并拒绝建立连接。</p><p><strong>典型案例</strong></p><p>攻击者在商场搭建名为“免费 Wi-Fi”的恶意热点，诱导用户连接：（1）若用户访问 HTTP 网站，攻击者可返回伪造页面并窃取输入的银行卡或登录信息；（2）若用户访问 HTTPS 网站，攻击者无法提供对应域名的合法证书，浏览器会提示“连接不安全”并中断通信，从而阻断攻击。</p><h4 id="【数据篡改攻击（Tampering）】"><a href="#【数据篡改攻击（Tampering）】" class="headerlink" title="【数据篡改攻击（Tampering）】"></a>【数据篡改攻击（Tampering）】</h4><p><strong>攻击原理</strong></p><p>数据篡改攻击是攻击者在通信过程中主动拦截数据包，对其中内容进行修改后再转发给目标方，试图让通信双方误以为数据未被篡改。常见手段包括在 HTML 中插入恶意脚本、替换资源文件、修改请求参数或业务数据，其前提是通信缺乏有效的完整性校验机制。</p><p><strong>TLS 防护机制</strong></p><p>TLS 在加密数据的同时对数据进行完整性保护。每一条加密数据都会附带完整性校验信息，接收方在解密后会重新计算并比对校验结果。若数据在传输过程中被修改，完整性校验将失败，数据会被直接丢弃并终止连接。</p><p><strong>典型案例</strong></p><p>用户在公共网络访问新闻网站：（1）使用 HTTP 时，攻击者可在 HTML 中插入恶意 JavaScript 并被浏览器正常执行；（2）使用 HTTPS 时，篡改后的数据无法通过完整性校验，浏览器会丢弃数据并中断连接。</p><h4 id="【重放攻击（Replay-Attack）】"><a href="#【重放攻击（Replay-Attack）】" class="headerlink" title="【重放攻击（Replay Attack）】"></a>【重放攻击（Replay Attack）】</h4><p><strong>攻击原理</strong></p><p>重放攻击通过记录一次合法通信的数据包，并在之后原样发送给服务器，试图重复触发某些关键操作。攻击者不需要理解数据内容，只需保证数据包形式完整即可，常见于缺乏时效性或唯一性校验的通信场景。</p><p><strong>TLS 防护机制</strong></p><p>TLS 通过会话绑定机制防止重放攻击。每一次 TLS 连接都会生成独立的会话密钥和加密上下文，数据包还会绑定序列号和通信状态。旧会话中的数据在新会话中无法通过解密和校验，因此无法被服务器接受。</p><p><strong>典型案例</strong></p><p>用户提交一次订单确认请求：（1）在未加密通信中，攻击者可重放请求导致重复下单；（2）在 TLS 保护下，旧会话的加密数据在新会话中无法被识别，服务器会拒绝处理。</p><h4 id="【身份伪造攻击（Impersonation）】"><a href="#【身份伪造攻击（Impersonation）】" class="headerlink" title="【身份伪造攻击（Impersonation）】"></a>【身份伪造攻击（Impersonation）】</h4><p><strong>攻击原理</strong></p><p>身份伪造攻击是攻击者冒充合法服务器，通过仿造域名和页面界面诱导用户提交敏感信息，常见于钓鱼攻击场景。攻击核心在于用户无法仅凭页面外观判断服务器真实身份。</p><p><strong>TLS 防护机制</strong></p><p>TLS 通过服务器身份验证机制防御身份伪造。服务器必须出示由可信 CA 签发的数字证书，客户端会验证证书的签发机构、域名一致性、有效期及签名合法性，只有验证通过才会建立连接。</p><p><strong>典型案例</strong></p><p>攻击者搭建仿冒邮箱网站：（1）HTTP 访问时，用户难以识别真假；（2）HTTPS 访问时，攻击者无法提供合法证书，浏览器会提示证书不可信并阻止访问。</p><h4 id="【会话劫持（Session-Hijacking，传输层角度）】"><a href="#【会话劫持（Session-Hijacking，传输层角度）】" class="headerlink" title="【会话劫持（Session Hijacking，传输层角度）】"></a>【会话劫持（Session Hijacking，传输层角度）】</h4><p><strong>攻击原理</strong></p><p>会话劫持的目标是获取用户的会话标识（如 Session Cookie），并利用该标识冒充用户访问服务器。攻击者通常通过监听网络通信获取会话标识。</p><p><strong>TLS 防护机制</strong></p><p>TLS 对通信数据进行全程加密，会话标识在传输过程中不会以明文出现，攻击者即使抓包也无法解析出有效的会话信息。完整性校验机制还能防止攻击者篡改或伪造会话数据。</p><p><strong>典型案例</strong></p><p>用户登录社交网站：（1）HTTP 通信中，攻击者可抓包获取 Session Cookie 并直接冒充用户；（2）HTTPS 通信中，Cookie 被加密传输，攻击者无法窃取。</p><h4 id="【协议降级攻击（Downgrade-Attack）】"><a href="#【协议降级攻击（Downgrade-Attack）】" class="headerlink" title="【协议降级攻击（Downgrade Attack）】"></a>【协议降级攻击（Downgrade Attack）】</h4><p><strong>攻击原理</strong></p><p>协议降级攻击通过干扰 TLS 握手过程，诱导客户端和服务器使用较低版本协议或弱加密算法，从而为后续攻击创造条件。</p><p><strong>TLS 防护机制</strong></p><p>现代 TLS 会对协商过程进行完整性校验，并明确标识使用的协议版本和加密参数。异常的降级行为会被检测并导致连接失败，服务器和浏览器也可配置为仅支持高安全等级协议。</p><p><strong>典型案例</strong></p><p>攻击者试图诱导客户端从 TLS 1.3 降级到 TLS 1.0，但服务器已配置仅支持 TLS 1.2 及以上版本，浏览器检测到异常后直接终止连接。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.前端页面跳转</title>
    <link href="/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    <url>/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是<code>SPA</code>?</li><li><code>Hash</code>跳转和<code>History</code>跳转的区别是什么？</li><li>浏览器 History 与事件的总时间?</li></ol><span id="more"></span><h2 id="前端页面跳转"><a href="#前端页面跳转" class="headerlink" title="前端页面跳转"></a>前端页面跳转</h2><h3 id="1-SPA（单页应用）"><a href="#1-SPA（单页应用）" class="headerlink" title="1. SPA（单页应用）"></a>1. SPA（单页应用）</h3><p>SPA 的核心思想不是“页面只有一页”，而是：</p><blockquote><p><strong>整个应用生命周期中，浏览器只加载一次 HTML 文档，之后的“页面切换”不再由浏览器完成，而是由前端 JavaScript 接管。</strong></p></blockquote><p><strong>应用周期：</strong>从浏览器首次加载并执行应用入口代码开始，到当前文档被销毁为止，前端应用在同一 HTML 文档内持续运行的整个时间段。</p><p>只要发生<strong>文档级导航</strong>，应用周期立即结束：</p><ul><li>刷新页面（F5）</li><li>地址栏输入新 URL 回车</li><li>跳转到另一个站点</li><li>当前 tab 关闭</li></ul><p>结束意味着：</p><ul><li>HTML 被销毁</li><li>JS 上下文清空</li><li>所有 Router &#x2F; Store &#x2F; 组件全部消失</li></ul><hr><p><strong>一、先从“传统网页”说起</strong></p><p>在传统 Web（也叫 MPA，多页应用）中：</p><ol><li>每次点击链接或提交表单</li><li>浏览器都会发起一次新的 HTTP 请求</li><li>服务器返回一个新的 HTML 文档</li><li>浏览器销毁旧页面，重新解析 HTML、CSS、JS</li><li>页面重新渲染</li></ol><p>也就是说：</p><ul><li><strong>页面跳转 &#x3D; 浏览器行为</strong></li><li><strong>页面内容 &#x3D; 服务器渲染结果</strong></li><li>每一次跳转，都是一次“文档级刷新”</li></ul><p><strong>二、SPA 的根本改变是什么</strong></p><p>SPA 把这套逻辑彻底反过来了。</p><p>在 SPA 中：</p><ol><li>浏览器第一次访问站点</li><li>服务器返回 <strong>一个基础 HTML（通常是 index.html）</strong></li><li>浏览器加载并执行大量 JS</li><li>之后的所有“页面切换”：<ul><li><strong>不再请求新的 HTML</strong></li><li><strong>不刷新页面</strong></li><li>只通过 JS 改变视图内容</li></ul></li></ol><p>也就是说：</p><ul><li>浏览器只负责 <strong>加载一次壳</strong></li><li>前端 JS 负责 <strong>整个应用运行期的页面管理</strong></li></ul><p><strong>三、为什么叫“单页”，但却能有很多页面</strong></p><p>SPA 中常见的现象是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">/home<br>/user/123<br>/settings<br></code></pre></td></tr></table></figure><p>看起来像多个页面，但实际上：</p><ul><li>这些 URL <strong>并不对应多个 HTML 文件</strong></li><li>它们只是：<ul><li>同一个 HTML</li><li>在不同 URL 状态下</li><li>渲染不同的组件树</li></ul></li></ul><p>“单页”指的是：</p><blockquote><p><strong>HTML 文档层面是单一的</strong></p><p>而不是“视觉上只能有一个界面”</p></blockquote><p><strong>四、SPA 中“页面切换”到底发生了什么</strong></p><p>以 Vue SPA 为例，一次路由切换本质上是：</p><ol><li>URL 发生变化（hash 或 history）</li><li>Vue Router 监听到变化</li><li>Router 解析当前路径</li><li>匹配到某个路由规则</li><li>决定哪些组件要挂载 &#x2F; 卸载</li><li>Vue 更新虚拟 DOM</li><li>局部 DOM 发生变化</li></ol><p><strong>整个过程没有浏览器级刷新</strong>。</p><p><strong>五、SPA 必须依赖哪些关键能力</strong></p><p>SPA 并不是凭空出现的，它依赖三类浏览器能力：</p><ol><li>JavaScript 长时间运行</li></ol><p>JS 不再是“点一下执行一下”，而是：</p><ul><li>应用启动即常驻</li><li>控制状态、路由、渲染、交互</li></ul><ol start="2"><li>浏览器 URL 可被“劫持解释”</li></ol><p>浏览器允许：</p><ul><li>hash 不触发刷新</li><li>History API 修改地址栏不刷新</li></ul><p>这使得：</p><ul><li>URL 可以作为“状态表达”</li><li>但页面不会重载</li></ul><ol start="3"><li>DOM 可被 JS 动态重构</li></ol><p>SPA 的页面不是 HTML 写死的，而是：</p><ul><li>数据 → 状态 → 组件 → DOM</li><li>DOM 是 JS 计算出来的结果</li></ul><h3 id="2-Hash和History"><a href="#2-Hash和History" class="headerlink" title="2. Hash和History"></a>2. <code>Hash</code>和<code>History</code></h3><p><strong>从浏览器拿到 URL 开始说起:</strong></p><p>无论你输入的是：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//example.com/<span class="hljs-meta">#/user</span><br></code></pre></td></tr></table></figure><p>还是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//example.com/user</span><br></code></pre></td></tr></table></figure><p>浏览器做的第一件事都是<strong>解析 URL</strong>，拆成固定的结构：</p><ul><li>scheme（协议）</li><li>host（域名）</li><li>port（端口）</li><li>path</li><li>query</li><li>fragment（也就是 hash）</li></ul><p>这是标准化行为，不依赖前端框架。</p><p>接下来浏览器要做一个非常关键的判断：</p><blockquote><p><strong>“这次 URL 变化，是否需要重新请求文档？”</strong></p></blockquote><p>这个判断，几乎完全由 <strong>path &#x2F; query &#x2F; fragment 是否变化</strong> 决定。</p><hr><p><strong>为什么 hash 永远不会触发请求:</strong></p><p>浏览器在网络层有一个硬性规则：</p><blockquote><p><strong>fragment 不参与 HTTP 请求</strong></p></blockquote><p>也就是说，URL 在真正发往服务器之前，浏览器会直接把 <code>#</code> 后面的内容丢弃。</p><p>例如你访问：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/app/</span><span class="hljs-comment">#/user?tab=1</span><br></code></pre></td></tr></table></figure><p>浏览器在网络层看到的是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/app/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br></code></pre></td></tr></table></figure><p>服务器永远不知道你写了 <code>#/user?tab=1</code>。</p><p>这不是 Vue Router 的设计，而是 <strong>HTTP + URL 规范</strong>。</p><hr><p><strong>hash 变化为什么不刷新页面</strong></p><p>当浏览器发现：</p><ul><li>scheme 没变</li><li>host 没变</li><li>path 没变</li><li>query 没变</li><li><strong>只变了 fragment</strong></li></ul><p>浏览器会把这次跳转判定为：</p><blockquote><p><strong>同一文档内的导航（same-document navigation）</strong></p></blockquote><p>同文档导航意味着：</p><ul><li>不重新请求 HTML</li><li>不重新解析 DOM</li><li>不重新执行 JS</li><li>仅更新地址栏</li><li>更新历史记录</li></ul><p>这是 hash 能被 SPA 利用的核心前提。</p><hr><p><strong>浏览器对 hash 的“原生职责”</strong></p><p>在 SPA 出现之前，hash 就已经存在了，它本来就有三层语义。</p><p>第一层语义是<strong>文档锚点</strong>。<br> 如果 hash 对应一个 DOM 元素的 <code>id</code> 或 <code>name</code>，浏览器会自动滚动到该位置。这是 HTML 规范级行为，不需要 JS 参与。</p><p>第二层语义是<strong>状态标记</strong>。<br> hash 的变化不会触发请求，但会反映在地址栏中，因此它天然适合作为“客户端状态”的外显形式。SPA 正是利用这一点，把 <code>#/user/123</code> 当作“当前视图状态”。</p><p>第三层语义是<strong>历史记录节点</strong>。<br> 即使只是改 hash，浏览器也会新增一条 history entry，因此 back &#x2F; forward 都是可用的。</p><p>当 fragment 变化时，浏览器会在内部完成三件事：</p><ol><li>更新地址栏</li><li>写入 history</li><li>在当前执行栈清空后，派发 <code>hashchange</code> 事件</li></ol><p>Vue Router 的 hash 模式，本质上就是：</p><ul><li>修改 <code>location.hash</code></li><li>监听 <code>hashchange</code></li><li>根据新的 hash 做路由匹配</li><li>更新组件树</li></ul><p>Router 并没有“控制浏览器”，只是<strong>利用浏览器已经定义好的行为</strong>。</p><hr><p><strong>History 模式的本质完全不同</strong></p><p>History 模式下，URL 变化的是 <strong>path &#x2F; query</strong>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/user/</span><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>在浏览器看来，这是一次<strong>真正的资源路径变化</strong>。</p><p>因此如果你直接刷新页面，浏览器一定会发请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/user/123</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br></code></pre></td></tr></table></figure><p>如果服务器没有对应路由，就一定会 404。</p><p>这也是为什么 History 模式必须有“服务器兜底”。服务器兜底的核心逻辑不是“帮前端跳转”，而是：</p><blockquote><p><strong>无论请求什么路径，只要是前端路由，都返回同一个 index.html</strong></p></blockquote><p>例如 Nginx：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>  <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样浏览器在访问 <code>/user/123</code> 时：</p><ul><li>URL 不变</li><li>实际拿到的是 index.html</li><li>前端 JS 启动后，再根据 URL 决定渲染什么组件</li></ul><hr><p><strong>Vue Router 在 history 模式下到底做了什么</strong></p><p>当页面首次加载时，流程是这样的：</p><ol><li>浏览器请求 <code>/user/123</code></li><li>服务器返回 index.html</li><li>浏览器解析 HTML，加载 JS</li><li>Vue 应用启动</li><li>Vue Router 读取当前浏览器地址：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">location</span>.pathname // &quot;/user/123&quot;<br><span class="hljs-keyword">location</span>.<span class="hljs-keyword">search</span>   // &quot;&quot;<br><span class="hljs-keyword">location</span>.hash     // &quot;&quot;<br></code></pre></td></tr></table></figure><ol><li>Router 把 pathname 当作“当前路由”</li><li>做路由匹配</li><li><code>&lt;router-view&gt;</code> 渲染对应组件</li></ol><p>注意一个关键点：</p><blockquote><p><strong>history 模式下，Router 并不会“跳转”</strong></p><p>它只是“读取当前 URL，然后解释它”</p></blockquote><p>在页面已经加载完成之后，Vue Router 切换路由时会调用：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">history.pushState(<span class="hljs-keyword">state</span>, &#x27;&#x27;, &#x27;/<span class="hljs-keyword">user</span>/<span class="hljs-number">456</span>&#x27;)<br></code></pre></td></tr></table></figure><p>浏览器对 pushState 的规则是：</p><ul><li>修改地址栏</li><li>写入 history</li><li><strong>不发请求</strong></li><li><strong>不刷新页面</strong></li><li>只在 back &#x2F; forward 时触发 <code>popstate</code></li></ul><p>Router 正是通过监听 <code>popstate</code>，来处理浏览器前进 &#x2F; 后退。</p><h3 id="3-浏览器-History-与事件"><a href="#3-浏览器-History-与事件" class="headerlink" title="3. 浏览器 History 与事件"></a>3. 浏览器 History 与事件</h3><table><thead><tr><th>行为</th><th>URL 是否改变</th><th>是否写入 history</th><th>是否触发 <code>hashchange</code></th><th>是否触发 <code>popstate</code></th><th>是否发请求</th></tr></thead><tbody><tr><td><code>location.hash = &#39;#a&#39;</code></td><td>是（hash）</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>点击 <code>&lt;a href=&quot;#a&quot;&gt;</code></td><td>是（hash）</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>hash 导致浏览器后退</td><td>是（hash）</td><td>指针切换</td><td>是</td><td>否</td><td>否</td></tr><tr><td><code>history.pushState()</code></td><td>是（path&#x2F;query）</td><td>是</td><td>否</td><td>否</td><td>否</td></tr><tr><td><code>history.replaceState()</code></td><td>是（path&#x2F;query）</td><td>是（替换）</td><td>否</td><td>否</td><td>否</td></tr><tr><td>浏览器后退 &#x2F; 前进</td><td>是</td><td>指针切换</td><td>视情况</td><td>是</td><td>否</td></tr><tr><td><code>history.back()</code></td><td>是</td><td>指针切换</td><td>视情况</td><td>是</td><td>否</td></tr><tr><td>地址栏回车</td><td>是</td><td>新导航</td><td>否</td><td>否</td><td>是</td></tr><tr><td>刷新页面</td><td>否</td><td>不变</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><p><strong>为什么 hash 会写 history，但不触发 popstate</strong></p><p>hash 的行为本质</p><p>当你修改 hash 时，浏览器做的是：</p><ol><li>在当前 history entry <strong>后面新增一个 entry</strong></li><li>当前指针移动到新 entry</li><li>触发 <code>hashchange</code></li></ol><p>这一步<strong>不是在“激活已有 entry”</strong>，而是在<strong>创建新 entry</strong>。</p><p>popstate 的唯一触发条件</p><blockquote><p><strong>popstate 只在“激活已有 history entry”时触发</strong></p></blockquote><p>也就是：</p><ul><li>从 entry C → 回到 entry B</li><li>或从 entry B → 前进到 entry C</li></ul><p>而不是“新建 entry”。</p><hr><p>为什么 hash 后退也不触发 popstate</p><p>即便是：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">/#a → /#b → /#c<br></code></pre></td></tr></table></figure><p>后退到 <code>/#b</code>：</p><ul><li>浏览器认为：这是 <strong>hash 导航体系</strong></li><li>事件仍然归类给 <code>hashchange</code></li><li><strong>popstate 仍然不触发</strong></li></ul><p>这是规范中的<strong>刻意分工</strong>，不是 bug。</p><hr><p>pushState 为什么“什么都不触发”</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">history</span><span class="hljs-selector-class">.pushState</span>(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/user/1&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>不触发 <code>popstate</code></li><li>不触发 <code>hashchange</code></li><li>不刷新页面</li><li>只改 URL + history</li></ul><p>这就是为什么：</p><p><strong>Router 在调用 pushState 前，必须自己先更新内部状态</strong></p><hr><p><strong>浏览器后退时，事件是怎么分流的</strong></p><p>情况 A：history 模式（path&#x2F;query 变化）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/user/</span><span class="hljs-number">1</span> → <span class="hljs-regexp">/user/</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>后退：</p><ul><li>激活已有 history entry</li><li>触发 <code>popstate</code></li><li>Router 监听它，同步状态</li></ul><p>情况 B：hash 模式</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">/#a → /#b → /#c<br></code></pre></td></tr></table></figure><p>后退：</p><ul><li>hash 变化</li><li>触发 <code>hashchange</code></li><li><strong>不触发 popstate</strong></li></ul><p>Router hash 模式监听的是 <code>hashchange</code>，不是 <code>popstate</code>。</p><hr><p>直接记下面这四条：</p><ol><li><strong>hash 变化：写 history，永远走 <code>hashchange</code></strong></li><li><strong>pushState：写 history，但不触发任何事件</strong></li><li><strong>popstate：只在激活已有 history entry 时触发</strong></li><li><strong>事件不是“history 改了就触发”，而是“谁改的，走谁的事件”</strong></li></ol><p>映射回 Vue Router</p><table><thead><tr><th>Router 模式</th><th>路由状态放哪</th><th>监听事件</th><th>触发场景</th></tr></thead><tbody><tr><td>hash</td><td>fragment</td><td><code>hashchange</code></td><td>hash 改变 &#x2F; hash 后退</td></tr><tr><td>history</td><td>history entry</td><td><code>popstate</code></td><td>浏览器前进 &#x2F; 后退</td></tr></tbody></table><p>而在 <strong><code>router.push()</code> &#x2F; <code>router.replace()</code></strong> 时：</p><ul><li><strong>两种模式都不靠浏览器事件</strong></li><li>都是 Router <strong>主动更新内部响应式状态</strong></li><li>事件只用于“用户绕过 Router 的行为”</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.前端事件机制（event）</title>
    <link href="/2025/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/7-%E5%89%8D%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88event%EF%BC%89/"/>
    <url>/2025/12/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/7-%E5%89%8D%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88event%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ol><li>如何描述JavaScript DOM？</li><li>如何描述JavaScript的事件？</li><li>JS事件绑定方式有哪些，事件对象是什么，它的常用属性有哪些？</li><li>如何理解事件冒泡和事件委托？</li><li>如何自定义一个JS事件？</li><li>如何描述Vue的事件监听机制？</li></ol><span id="more"></span><h2 id="前端的事件机制（event"><a href="#前端的事件机制（event" class="headerlink" title="前端的事件机制（event)"></a>前端的事件机制（event)</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#JavaScript-DOM">JavaScript DOM &#x2F; event</a></p></blockquote><h3 id="1-JavaScript-DOM"><a href="#1-JavaScript-DOM" class="headerlink" title="1. JavaScript DOM"></a>1. JavaScript DOM</h3><p>DOM（Document Object Model，文档对象模型）是 <strong>Web API 的一部分</strong>，用于将 HTML 页面以一种<strong>树形结构</strong>的方式抽象成对象模型。简单来说，DOM 会把整个页面结构“对象化”，页面中的<strong>标签、文本、注释等都会被表示为节点（Node）</strong>，共同组成一棵 DOM 树。</p><p>在 DOM 中，**<code>document</code> 对象表示整个页面**，它是 JavaScript 访问和操作页面的入口。浏览器会将 HTML 文档解析后，封装成一个 <code>document</code> 对象，通过它可以获取页面中的任意节点，同时也可以访问页面的 URL、域名等信息。</p><p>通过 <code>document</code> 对象，可以使用多种方式获取页面中的元素节点，例如：</p><ul><li><code>getElementById</code></li><li><code>getElementsByClassName</code></li><li><code>getElementsByTagName</code></li><li><code>querySelector</code> &#x2F; <code>querySelectorAll</code></li></ul><p>这些方法最终都会返回<strong>一个节点或节点集合（元素对象）</strong>。</p><p>每一个元素对象在 DOM 树中都对应一个节点，它既是树结构中的一个成员，也可以作为操作起点，对与之相关的其他节点进行操作。例如，可以获取其父节点、子节点、兄弟节点，也可以在 DOM 树中插入新节点或删除已有节点。</p><p>除了结构操作之外，DOM 还支持对节点内容和表现形式的修改，包括但不限于：</p><ul><li>修改文本内容</li><li>修改属性</li><li>修改样式</li><li>动态增删节点</li></ul><p>其中，<strong>事件机制是 DOM 设计的核心功能之一</strong>。DOM 的设计初衷就是让网页能够与用户产生动态交互，而这种交互正是通过事件系统实现的。通过为元素绑定事件监听器，JavaScript 可以在用户点击、输入、滚动等操作发生时执行相应的逻辑，从而实现页面的动态行为。</p><h3 id="2-JavaScript-Event"><a href="#2-JavaScript-Event" class="headerlink" title="2. JavaScript Event"></a>2. JavaScript Event</h3><p>在 JavaScript 中，事件通过<strong>绑定回调函数</strong>来处理用户的各种操作。当用户在页面上进行点击、输入、移动鼠标等行为时，浏览器会触发相应的事件；一旦事件被触发，与之绑定的<strong>事件监听器</strong>就会调用对应的<strong>回调函数</strong>。因此，事件回调函数也常被称为<strong>事件处理函数或事件响应函数</strong>。</p><h4 id="【事件的绑定方式】"><a href="#【事件的绑定方式】" class="headerlink" title="【事件的绑定方式】"></a>【事件的绑定方式】</h4><p>JavaScript 中常见的事件绑定方式主要有三种：</p><ol><li><p><strong>通过 HTML 标签的事件属性</strong>（不推荐）</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;handleClick()&quot;</span>&gt;点击&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>通过元素对象的事件属性</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">element.onclick</span> = function () &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>通过 <code>addEventListener</code> 绑定事件监听器（推荐）</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">element.addEventListener(<span class="hljs-symbol">&#x27;click</span>&#x27;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;&#125;);<br></code></pre></td></tr></table></figure></li></ol><p>其中，<code>addEventListener</code> 是最灵活、最规范的方式，支持多个监听器、事件捕获与冒泡控制。</p><h4 id="【事件对象（Event-Object）】"><a href="#【事件对象（Event-Object）】" class="headerlink" title="【事件对象（Event Object）】"></a>【事件对象（Event Object）】</h4><p>当事件触发时，浏览器会自动向事件回调函数传入一个参数，这个参数就是<strong>事件对象（event）</strong>。事件对象中包含了与当前事件相关的各种信息。</p><p><code>Event</code> 是所有事件对象的基类，在此基础上派生出多种具体事件类型，例如：</p><ul><li><code>MouseEvent</code>：处理鼠标事件（点击、移动、坐标等）</li><li><code>KeyboardEvent</code>：处理键盘事件（按键、键值等）</li><li><code>InputEvent</code>：处理输入相关事件</li></ul><p>常用的事件对象属性包括：</p><ul><li><code>event.type</code>：事件类型</li><li><code>event.target</code>：触发事件的元素</li><li><code>event.currentTarget</code>：当前绑定事件的元素</li><li><code>event.bubbles</code>：是否支持冒泡</li><li><code>event.cancelable</code>：是否可以取消默认行为</li><li><code>event.timeStamp</code>：事件发生的时间</li></ul><h4 id="【事件传播机制】"><a href="#【事件传播机制】" class="headerlink" title="【事件传播机制】"></a>【事件传播机制】</h4><p>要理解事件冒泡和事件委托，首先需要了解<strong>事件传播的三个阶段</strong>：</p><ol><li><strong>捕获阶段</strong><br>事件从 <code>window</code> 开始，沿着 DOM 树向下传播，直到目标元素。在这一阶段，默认情况下不会触发事件监听器。</li><li><strong>目标阶段</strong><br>事件到达目标元素，在目标元素上触发对应的事件监听器。</li><li><strong>冒泡阶段</strong><br>事件从目标元素开始，沿着 DOM 树向上传播，直到 <code>document</code>，依次触发祖先元素上绑定的事件监听器（如果存在）。</li></ol><p>这是“已确定 target 的情况下”才存在的传播路径，</p><h4 id="【事件冒泡与事件委托】"><a href="#【事件冒泡与事件委托】" class="headerlink" title="【事件冒泡与事件委托】"></a>【事件冒泡与事件委托】</h4><p>事件冒泡的一个重要作用是实现<strong>事件委托</strong>。</p><p>事件委托的核心思想是：</p><blockquote><p>如果父元素和其多个子元素需要处理同一类事件，可以只在父元素上绑定一次事件监听器，利用事件冒泡统一处理。</p></blockquote><p>例如，在一个包含多个子元素的大容器中，如果希望监听鼠标移动事件：</p><ul><li>鼠标移动时，事件会先在目标子元素上触发</li><li>随后通过冒泡传播到父元素</li><li>父元素即可统一处理该事件</li></ul><p>这样做的好处是：</p><ul><li>不需要为每个子元素单独绑定事件</li><li>减少代码量</li><li>降低逻辑复杂度</li><li><strong>对动态新增的子元素同样有效</strong></li></ul><p>当然，并不是所有事件都适合冒泡。如果某些事件<strong>不希望被祖先元素接收到</strong>，可以通过关闭冒泡或阻止传播来控制。</p><h3 id="3-自定义一个JS事件"><a href="#3-自定义一个JS事件" class="headerlink" title="3. 自定义一个JS事件"></a>3. 自定义一个JS事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;outer&quot;</span> style=<span class="hljs-string">&quot;padding:20px;border:2px solid #999;&quot;</span>&gt;<br>  outer<br>  &lt;div id=<span class="hljs-string">&quot;inner&quot;</span> style=<span class="hljs-string">&quot;margin-top:10px;padding:20px;border:2px solid #666;&quot;</span>&gt;<br>    inner<br>    &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;dispatch&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> outer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;outer&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> inner = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;inner&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 打印工具：你能一眼看到 target/currentTarget 以及处于哪个阶段</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">tag</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> phaseMap = &#123; <span class="hljs-number">1</span>: <span class="hljs-string">&quot;capture&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;bubble&quot;</span> &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-string">`[<span class="hljs-subst">$&#123;tag&#125;</span>] phase=<span class="hljs-subst">$&#123;phaseMap[e.eventPhase]&#125;</span> `</span> +</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-string">`target=#<span class="hljs-subst">$&#123;e.target.id&#125;</span> currentTarget=#<span class="hljs-subst">$&#123;e.currentTarget.id&#125;</span> `</span> +</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-string">`detail=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(e.detail)&#125;</span>`</span></span></span><br><span class="language-javascript"><span class="language-xml">      );</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 1) 监听器：捕获阶段</span></span></span><br><span class="language-javascript"><span class="language-xml">  outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer CAPTURE&quot;</span>), <span class="hljs-literal">true</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  inner.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inner CAPTURE&quot;</span>), <span class="hljs-literal">true</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 这里的 true 表示：监听器在「事件捕获阶段」执行。</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 2) 监听器：冒泡阶段（默认 false）</span></span></span><br><span class="language-javascript"><span class="language-xml">  outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer BUBBLE&quot;</span>));</span></span><br><span class="language-javascript"><span class="language-xml">  inner.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inner BUBBLE&quot;</span>));</span></span><br><span class="language-javascript"><span class="language-xml">  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn BUBBLE&quot;</span>));</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 3) 点击按钮：创建并派发自定义事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> ev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">detail</span>: &#123; <span class="hljs-attr">num</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">threshold</span>: <span class="hljs-number">5</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 允许冒泡（否则只有目标阶段）</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 允许 preventDefault（自定义事件通常用不到，但可演示）</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---- dispatch start ----&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    btn.<span class="hljs-title function_">dispatchEvent</span>(ev); <span class="hljs-comment">// 派发到目标：btn</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---- dispatch end ----&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>当你点按钮后，控制台会按顺序输出类似：</p><ol><li><code>outer CAPTURE</code>（捕获，从外到内）</li><li><code>inner CAPTURE</code></li><li><code>btn BUBBLE</code>（目标阶段：监听器会以 target 触发；eventPhase 显示 target）</li><li><code>inner BUBBLE</code>（冒泡，从内到外）</li><li><code>outer BUBBLE</code></li></ol><p>这里最关键的是两点：</p><ul><li><strong><code>event.target</code> 永远是事件真正发生&#x2F;派发的目标（btn）</strong></li><li><strong><code>event.currentTarget</code> 是当前正在执行监听器的那个元素（outer&#x2F;inner&#x2F;btn 会变化）</strong></li></ul><hr><p>把它和“派发&#x2F;监听器过程”对应起来（你要的主线）</p><ol><li>创建事件对象(CustomEvent是DOM Level 3 Events 标准的一部分，就叫自定义事件）</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;num-threshold&quot;</span>, &#123; detail, bubbles &#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>绑定监听器</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addEventListener</span><span class="hljs-params">(<span class="hljs-string">&quot;num-threshold&quot;</span>, handler, useCapture?)</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>派发事件（关键动作）</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">btn.dispatchEvent(<span class="hljs-built_in">ev</span>)<br></code></pre></td></tr></table></figure><p>一旦派发，浏览器就会根据 DOM 树生成路径，并按阶段执行监听器：</p><ul><li><strong>捕获阶段</strong>：window → … → outer → inner</li><li><strong>目标阶段</strong>：btn</li><li><strong>冒泡阶段</strong>：inner → outer → … → document（前提：<code>bubbles: true</code>）</li></ul><h3 id="4-Vue-事件监听机制"><a href="#4-Vue-事件监听机制" class="headerlink" title="4. Vue 事件监听机制"></a>4. Vue 事件监听机制</h3><p>Vue 的事件系统并不是一套“新的事件模型”，而是<strong>对原生 DOM 事件机制的封装与语法抽象</strong>。<br> 其核心目标是：<strong>在不改变事件本质的前提下，降低事件绑定、传播控制和逻辑组织的复杂度</strong>。</p><h4 id="【Vue-中的事件监听方式】"><a href="#【Vue-中的事件监听方式】" class="headerlink" title="【Vue 中的事件监听方式】"></a>【Vue 中的事件监听方式】</h4><p>Vue 使用 <code>v-on</code> 指令（简写为 <code>@</code>）来监听事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button @click=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;点击&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>从本质上看，这一写法等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handleClick);<br></code></pre></td></tr></table></figure><p>不同之处在于：</p><ul><li>事件绑定由 Vue 在 <strong>组件挂载阶段</strong> 自动完成</li><li>回调函数默认绑定到当前组件实例（<code>this</code> 指向组件）</li></ul><h4 id="【Vue-事件与原生-JS-事件】"><a href="#【Vue-事件与原生-JS-事件】" class="headerlink" title="【Vue 事件与原生 JS 事件】"></a>【Vue 事件与原生 JS 事件】</h4><blockquote><p>Vue 事件 ≠ 自定义事件系统</p><p>Vue 事件 &#x3D; 原生 DOM 事件 + 语法层封装</p></blockquote><p>具体体现在：</p><ol><li><p><strong>事件触发来源</strong></p><ul><li>Vue 的 DOM 事件最终仍由浏览器触发</li><li>Vue 不接管浏览器的事件派发过程</li></ul></li><li><p><strong>事件对象</strong></p><ul><li>Vue 事件回调中接收到的 <code>$event</code> 本质就是原生 <code>Event</code> 对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick($event)&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Event</span>); <span class="hljs-comment">// true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>事件传播机制</strong></p><ul><li>捕获 → 目标 → 冒泡</li><li>完全遵循 DOM 标准事件流</li></ul></li></ol><p>从 JS 视角看，Vue 事件修饰符本质是：<strong>把“事件控制逻辑”从回调函数中前移到模板声明层</strong></p><p>对比：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原生 JS</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>();<br>  e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;<br>&lt;!-- <span class="hljs-title class_">Vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>带来的好处：</p><ul><li>事件行为一眼可见</li><li>减少样板代码</li><li>事件控制语义化</li><li>更利于模板阅读与维护</li></ul><p>Vue 事件 vs JS 事件对照总结</p><table><thead><tr><th>对比点</th><th>原生 JS 事件</th><th>Vue DOM 事件</th></tr></thead><tbody><tr><td>触发来源</td><td>浏览器</td><td>浏览器</td></tr><tr><td>事件对象</td><td>Event</td><td>Event（$event）</td></tr><tr><td>传播机制</td><td>捕获&#x2F;冒泡</td><td>完全一致</td></tr><tr><td>绑定方式</td><td>addEventListener</td><td>v-on &#x2F; @</td></tr><tr><td>事件控制</td><td>手动调用 API</td><td>修饰符声明</td></tr><tr><td>组件通信</td><td>不支持</td><td><code>$emit</code></td></tr></tbody></table><h4 id="【Vue-事件修饰符】"><a href="#【Vue-事件修饰符】" class="headerlink" title="【Vue 事件修饰符】"></a>【Vue 事件修饰符】</h4><p>事件修饰符是 Vue 对<strong>事件传播控制与默认行为控制</strong>的语法级抽象。</p><p> <code>.stop</code> —— 阻止冒泡</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;button @click.stop=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;点击&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>等价原生写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>.prevent</code> —— 阻止默认行为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;#&quot;</span> @click.<span class="hljs-attribute">prevent</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;链接&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>等价原生写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">e.<span class="hljs-title function_">preventDefault</span>();<br></code></pre></td></tr></table></figure><p><code>.stop.prevent</code> —— 组合修饰符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;form @submit.<span class="hljs-property">stop</span>.<span class="hljs-property">prevent</span>=<span class="hljs-string">&quot;submitForm&quot;</span>&gt;&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">e.<span class="hljs-title function_">stopPropagation</span>();<br>e.<span class="hljs-title function_">preventDefault</span>();<br></code></pre></td></tr></table></figure><p><code>.capture</code> —— 捕获阶段监听</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> @click.capture=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handler, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>这与 JS 中 <code>addEventListener(type, handler, true)</code> 的含义完全一致。</p><p><code>.once</code> —— 只执行一次</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>等价原生写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handler, &#123; <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><p><code>.self</code> —— 只响应自身触发</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">&lt;<span class="hljs-keyword">div</span> @click.<span class="hljs-symbol">self</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>逻辑等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> === e.<span class="hljs-property">currentTarget</span>) &#123;<br>  <span class="hljs-title function_">handleClick</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>常用于防止事件委托误触。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.JS的函数问题</title>
    <link href="/2025/12/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/6-JS%E7%9A%84%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2025/12/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/6-JS%E7%9A%84%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是立即执行函数？</li><li>什么是闭包？</li><li>函数中的<code>this</code>指向？</li></ol><span id="more"></span><h2 id="JS的函数问题"><a href="#JS的函数问题" class="headerlink" title="JS的函数问题"></a>JS的函数问题</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#JavaScript%E5%87%BD%E6%95%B0">JavaScript基础 - 相</a></p></blockquote><h3 id="1-立即执行函数（IIFE）"><a href="#1-立即执行函数（IIFE）" class="headerlink" title="1.立即执行函数（IIFE）"></a>1.立即执行函数（IIFE）</h3><p>在 JavaScript 模块化机制尚未完善之前，<strong>立即执行函数</strong>是一种常用的封装手段，用来避免变量污染全局作用域。其核心思想是：<strong>创建一个只执行一次的私有作用域，把变量和方法包裹在里面</strong>。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;&#125;)();<br></code></pre></td></tr></table></figure><p>立即执行函数（Immediately Invoked Function Expression，IIFE）本质上是一个<strong>函数表达式</strong>。通过外层括号将函数声明转换为表达式后，紧随其后的 <code>()</code> 会使其在定义后立刻执行。由于它是表达式，因此<strong>可以有返回值</strong>，并将结果赋给变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;,<br>    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>      count = <span class="hljs-number">0</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reset&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这段代码中，IIFE 只执行一次，创建了一个私有作用域，变量 <code>count</code> 只存在于该作用域内部。函数执行完成后返回一个对象，并赋值给 <code>Counter</code>。从外部只能通过 <code>increment</code> 和 <code>reset</code> 这两个方法操作 <code>count</code>，而无法直接访问或修改它，从而实现了<strong>模块化封装</strong>。</p><p>这种写法在行为上与使用 <code>class</code> 封装私有状态非常相似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  #count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#count);<br>  &#125;<br><br>  <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#count = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reset&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br></code></pre></td></tr></table></figure><p>二者都实现了“内部状态私有、对外只暴露接口”的效果，只是 IIFE 依赖函数作用域，而 <code>class</code> 由语言层面提供私有字段支持。</p><h3 id="2-闭包（Closure）"><a href="#2-闭包（Closure）" class="headerlink" title="2.闭包（Closure）"></a>2.闭包（Closure）</h3><p>在上述例子中，<code>count</code> 并没有随着 IIFE 的执行结束而被销毁，<code>increment</code> 和 <code>reset</code> 仍然可以持续访问它。这正是<strong>闭包</strong>的体现。</p><p>闭包的本质是：<strong>函数可以访问其定义时的词法作用域，即使该函数在其定义作用域之外被调用</strong>。只要某个内部变量仍然被外部函数引用，JavaScript 引擎就不会回收对应的作用域。</p><p>在 <code>Counter</code> 示例中，<code>increment</code> 和 <code>reset</code> 方法都引用了 <code>count</code>，因此该变量会被长期保留在内存中，但对外部代码不可见。这使得 <code>count</code> 成为一种“私有状态”，只能通过受控的方式被修改。</p><p>如果从类的角度类比理解，可以认为：<strong>类的方法可以访问私有字段，而实例对象本身不能直接访问这些字段</strong>。闭包在函数层面实现了类似的封装能力，是 JavaScript 早期实现私有变量和模块化的核心机制。</p><blockquote><p>立即执行函数用于<strong>创建独立作用域并封装模块</strong>，而闭包则保证了<strong>该作用域在函数执行结束后仍能被安全地访问和维护</strong>。二者结合，构成了 JavaScript 在模块化与私有变量出现之前最重要的设计模式之一。</p></blockquote><h3 id="3-this"><a href="#3-this" class="headerlink" title="3.this"></a>3.<code>this</code></h3><p><code>this</code> 并不是 JavaScript 的语法关键字参数，而是<strong>函数在执行时由调用方式动态确定的隐含参数</strong>。理解 <code>this</code> 的关键，不在于“它是什么”，而在于<strong>函数是“如何被调用的”</strong>。</p><p>（1）普通函数与箭头函数中的 <code>this</code></p><p>对于<strong>普通函数</strong>来说，<code>this</code> 的指向取决于调用者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-title function_">fn</span>();   <span class="hljs-comment">// this 指向 obj</span><br><span class="hljs-title function_">fn</span>();       <span class="hljs-comment">// this 指向全局对象（或 strict mode 下为 undefined）</span><br></code></pre></td></tr></table></figure><p>可以理解为：</p><p>普通函数在执行时，会被隐式地传入一个 <code>this</code> 参数。</p><p>而<strong>箭头函数完全不同</strong>：</p><ul><li>箭头函数<strong>没有自己的 <code>this</code></strong></li><li>它的 <code>this</code> 在<strong>定义时就已经确定</strong></li><li>永远指向<strong>定义时所在词法作用域的 <code>this</code></strong></li><li>之后<strong>无法再被改变</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的 <code>this</code> **不指向 <code>obj</code>**，而是指向外层作用域的 <code>this</code>。</p><hr><p>（2）箭头函数与 <code>arguments</code> &#x2F; <code>call</code> &#x2F; <code>apply</code> &#x2F; <code>bind</code></p><p>由于箭头函数没有自己的执行上下文，它也自然：</p><ul><li>没有 <code>arguments</code></li><li>不能通过 <code>call</code> &#x2F; <code>apply</code> &#x2F; <code>bind</code> 修改 <code>this</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//  ReferenceError</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而普通函数则可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>（3）<code>call</code>、<code>apply</code>、<code>bind</code> 的作用与区别</p><p><code>call</code>、<code>apply</code>、<code>bind</code> 都用于<strong>显式指定函数执行时的 <code>this</code> 指向</strong>，区别在于<strong>是否立即执行</strong>以及<strong>参数传递方式</strong>。</p><table><thead><tr><th>方法</th><th>作用</th><th>是否立即执行</th><th>参数形式</th></tr></thead><tbody><tr><td><code>call</code></td><td>改变 <code>this</code> 并执行函数</td><td>是</td><td>逐个参数</td></tr><tr><td><code>apply</code></td><td>改变 <code>this</code> 并执行函数</td><td>是</td><td>数组参数</td></tr><tr><td><code>bind</code></td><td>改变 <code>this</code>，返回新函数</td><td>否</td><td>逐个参数</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fn.<span class="hljs-title function_">call</span>(obj, a, b);<br>fn.<span class="hljs-title function_">apply</span>(obj, [a, b]);<br><span class="hljs-keyword">const</span> newFn = fn.<span class="hljs-title function_">bind</span>(obj, a);<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><p><code>apply</code> 中传入的数组，会被<strong>拆解为多个独立参数</strong>，其行为与 ES6 的展开运算符 <code>...arr</code> 等价。</p><hr><p>（4）类中方法、函数表达式与箭头函数的区别</p><p>在 <code>class</code> 中，方法的定义方式会影响它们的存储位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;          <span class="hljs-comment">// 方法</span><br>  bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">// 函数表达式</span><br>  baz = <span class="hljs-function">() =&gt;</span> &#123;&#125;      <span class="hljs-comment">// 箭头函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>foo</code>：定义在 <strong>原型对象（prototype）</strong> 上</li><li><code>bar</code>：作为实例属性存在（每个实例一份）</li><li><code>baz</code>：也是实例属性，且 <strong><code>this</code> 固定为实例</strong></li></ul><p>因此：</p><ul><li><strong>箭头函数不会出现在原型链上</strong></li><li>每个实例都会单独创建一份箭头函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.Vue基本原理</title>
    <link href="/2025/12/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2025/12/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ol><li>如何描述Vue采用的MVVM框架？</li><li>如何描述Vue2的响应式原理 （流程&#x2F;数据劫持原理）？</li><li>如何描述Vue3的响应式原理 （与Vue2差异 &#x2F; Proxy &#x2F; Reflect)？</li><li>数据代理的思想？</li></ol><span id="more"></span><h2 id="Vue的基本原理"><a href="#Vue的基本原理" class="headerlink" title="Vue的基本原理"></a>Vue的基本原理</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=145">145_尚硅谷Vue3技术_回顾Vue2的响应式原理_哔哩哔哩_bilibili</a></p></blockquote><h3 id="1-MVVM框架"><a href="#1-MVVM框架" class="headerlink" title="1.MVVM框架"></a>1.MVVM框架</h3><img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251217223808740.png" class title="image-20251217223808740"><p>根据MVVM库的特点：</p><p>MVVM（Model–View–ViewModel）是一种通过 <strong>ViewModel</strong> 作为中介，实现 <strong>View 与 Model 双向同步</strong> 的设计模式。</p><ul><li><strong>Model</strong>：数据层，负责数据状态与业务逻辑</li><li><strong>View</strong>：视图层，负责页面展示</li><li><strong>ViewModel</strong>：连接 View 和 Model，负责数据同步与视图更新</li></ul><p><strong>在 Vue 中的具体对应</strong></p><ul><li><strong>View</strong>：HTML 模板（如 <code>&lt;input&gt;</code>、<code>&#123;&#123; value &#125;&#125;</code>）</li><li><strong>Model</strong>：<code>data</code> 中定义的数据对象</li><li><strong>ViewModel</strong>：<code>vm = new Vue(&#123;...&#125;)</code> 创建的 Vue 实例</li></ul><p>先举一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div id=&#x27;root&#x27;&gt;<br>        &lt;input v-model=&quot;value&quot;&gt;<br>        &lt;p&gt;value的值为 &#123;&#123;value&#125;&#125; &lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el:&quot;#root&quot;,<br>        data:&#123;<br>            value:123<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在上面这个示例中，当我们在浏览器浏览器输入框修改value的值时，data中的value会同步修改。这是从<code>view-&gt;model</code>的过程。当data的value一旦被修改，页面就要重新渲染，那么<code>&lt;p&gt;</code>中的模板语句被修改。这是<code>model-&gt;view</code>的过程。</p><h4 id="【view-model】"><a href="#【view-model】" class="headerlink" title="【view-&gt;model】"></a>【<code>view-&gt;model</code>】</h4><p>当用户在输入框中输入内容时：</p><ol><li>用户操作视图（View）</li><li><strong>DOM 事件触发</strong>（如 <code>input</code> 事件）</li><li>事件回调中修改 <code>data.value</code></li><li>数据更新完成（Model 被修改）</li></ol><p>关键结论</p><ul><li>这一过程本质是 <strong>DOM 事件监听 + 回调赋值</strong></li><li>属于 <strong>浏览器 + JavaScript 的原生机制</strong></li><li><strong>不是 Vue 响应式原理的内容</strong></li></ul><p>Vue 在这里只是：</p><ul><li>通过<font color="#409eff"><strong>数据绑定</strong></font><code>Data Bingdings</code>，自动绑定了事件，省去了手写监听与赋值的代码</li></ul><h4 id="【model-view】"><a href="#【model-view】" class="headerlink" title="【model-&gt;view】"></a>【<code>model-&gt;view</code>】</h4><p>当 <code>data.value</code> 被修改后，页面中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>value 的值为 &#123;&#123; value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>能够自动更新，这一过程才是 <strong>Vue 响应式系统真正解决的问题</strong>。</p><ul><li>Vue 在初始化时，对 <code>data</code> 中的数据进行了 <strong><font color="#409eff">数据劫持</font></strong></li><li>每个被使用到的数据，都通过 <font color="#409eff"><strong>发布者–订阅者模式</strong></font> 与对应的视图更新逻辑建立了关联</li><li>当数据发生变化时：<ul><li>Vue 内部触发对应的 <strong>更新通知</strong></li><li>相关的视图更新函数被执行</li><li>页面完成重新渲染</li></ul></li></ul><p><strong>用一句话高度总结</strong></p><p>Vue 的双向数据绑定并不是一个统一机制，而是：</p><ul><li><strong>view → model</strong>：通过 DOM 事件监听实现（JS 原生机制）</li><li><strong>model → view</strong>：通过数据劫持 + 发布订阅机制实现（Vue 响应式系统核心）</li></ul><h3 id="2-Vue的响应式原理"><a href="#2-Vue的响应式原理" class="headerlink" title="2.Vue的响应式原理"></a>2.Vue的响应式原理</h3><p>Vue 的响应式原理，本质上是：<strong>数据劫持负责“感知变化”，发布–订阅机制负责“通知变化”</strong>两者配合，实现 <code>model → view</code> 的自动更新。</p><ul><li>数据劫持是指：通过拦截数据的读取（get）和修改（set）操作，使系统在数据被访问或变更时能够感知到这一行为，并触发相应的依赖收集或更新逻辑。</li><li>发布者–订阅者模式： 简单来说，就是发布者发布信号（数据变化），订阅者当信号绑定到自己的方法上。当信号被触发，所有绑定了信号的订阅者都执行，和Qt中的信号与槽机制很像。</li></ul><p>当响应式数据发生变化时，数据修改行为会被拦截并感知，随后由依赖系统通知所有依赖该数据的订阅者，订阅者执行各自的更新函数，从而驱动相关视图重新渲染。</p><p>Vue2响应式原理的流程图如下：</p><img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251218021138928.png" class title="image-20251218021138928"><p>核心代码(先不看，直接看流程)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-title function_">defineReactive</span>(obj, key, obj[key]));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Observer: 负责把对象的属性转为 getter/setter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(val); <span class="hljs-comment">// 递归处理嵌套对象</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        dep.<span class="hljs-title function_">depend</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>        val = newVal;<br>        <span class="hljs-title function_">observe</span>(newVal); <span class="hljs-comment">// 如果赋值对象，继续劫持</span><br>        <span class="hljs-comment">// 通知更新</span><br>        dep.<span class="hljs-title function_">notify</span>();<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// Dep: 管理依赖的容器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">watcher</span> =&gt;</span> watcher.<span class="hljs-title function_">update</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Watcher: 观察者，依赖更新时执行回调</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 设置当前 watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);  <span class="hljs-comment">// 执行取值，会触发数据的 getter</span><br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空，防止污染</span><br>  &#125;<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上述例子为示例，完整流程如下：</p><h4 id="【第一阶段：初始化】"><a href="#【第一阶段：初始化】" class="headerlink" title="【第一阶段：初始化】"></a>【第一阶段：初始化】</h4><p>第 0 步：在页面渲染之前初始化数据劫持</p><p>在实例化 Vue 时，Vue 会遍历 <code>data</code> 对象中的所有属性，并使用 <code>Object.defineProperty</code> 给每个属性添加 getter 和 setter，当属性被访问，调用<code>getter</code>方法， 当属性被修改，调用<code>setter</code>方法， 具体细节见下一节。</p><p>第 1 步：Compile 解析模板</p><p>以模板为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Compile 在解析模板时，会分别处理不同类型的绑定。</p><hr><p>第 2 步：处理 <code>v-model</code>（双通道中的 view → model）</p><p>Compile 遇到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它会做两件事，这就使<strong>数据绑定</strong>，也是<code>v-model</code>的原理。</p><p>（1）初始化视图（数据 → 视图）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-property">value</span> = vm.<span class="hljs-property">msg</span>;<br></code></pre></td></tr></table></figure><p>（2）绑定 DOM 事件（视图 → 数据）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  vm.<span class="hljs-property">msg</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这一过程的性质：</p><ul><li>属于 DOM 事件监听</li><li>属于 JavaScript 原生机制</li><li><strong>不属于 Vue 响应式核心</strong></li></ul><p>到此为止：</p><ul><li>view → model 的通道已建立</li><li>只是“赋值”，还没有响应式更新</li></ul><hr><p>第 3 步：Compile 处理插值表达式</p><p>Compile 遇到：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>此时 Compile 明确两件事：</p><ol><li>这个 DOM 节点 <strong>依赖 <code>msg</code></strong></li><li>当 <code>msg</code> 变化时，<strong>应该如何更新 DOM</strong></li></ol><p>于是 Compile 生成一个<strong>更新函数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateText</span>(<span class="hljs-params"></span>) &#123;<br>  node.<span class="hljs-property">textContent</span> = vm.<span class="hljs-property">msg</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>这是一个普通的 JS 函数</li><li>它不是 DOM 事件</li><li>它只是“更新逻辑的描述”</li></ul><hr><p>第 4 步：Compile 创建 Watcher</p><p>Compile 将更新函数交给 Watcher：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, <span class="hljs-string">&#x27;msg&#x27;</span>, updateText);<br></code></pre></td></tr></table></figure><p>此时：</p><ul><li>Watcher 内部保存了更新函数</li><li>Watcher 尚未执行更新</li><li>Watcher 需要和数据建立关系</li></ul><hr><p>第 5 步：Watcher 实例化时完成依赖收集</p><p>在 Watcher 构造过程中，会发生一次关键操作，参考<strong>核心代码</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher;<br>vm.<span class="hljs-property">msg</span>;        <span class="hljs-comment">// 触发 getter</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>结果是：</p><ul><li><code>msg</code> 的 getter 被触发</li><li><code>msg</code> 对应的 Dep 发现当前存在 Dep.target</li><li>Dep 将该 Watcher 收集为自己的订阅者</li></ul><p>到此为止：</p><ul><li>数据知道“谁依赖我”</li><li>Watcher 知道“我依赖哪个数据”</li><li>依赖关系建立完成</li><li>页面尚未发生变化</li></ul><p>注意：</p><ul><li>每个数据都有一个Dep容器</li><li>Dep容器存储所有以该数据相关的Watcher</li><li>一个DOM节点 * 一个数据 &#x3D;  一个Watcher， DOM节点是订阅者，<code>msg</code>是发布者， <code>msg</code>修改触发信号， 也就是发布者-订阅者机制已经建立。</li></ul><h4 id="【第二阶段：运行时】"><a href="#【第二阶段：运行时】" class="headerlink" title="【第二阶段：运行时】"></a>【第二阶段：运行时】</h4><p>第 6 步：数据发生变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;world&#x27;</span>;<br></code></pre></td></tr></table></figure><p>触发 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>  dep.<span class="hljs-title function_">notify</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>第 7 步：Dep 通知所有 Watcher</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">dep.<span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>  watchers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.<span class="hljs-title function_">update</span>());<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>第 8 步：Watcher 执行更新逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>();   <span class="hljs-comment">// 执行 Compile 创建的更新函数</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>第 9 步：视图更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-property">textContent</span> = vm.<span class="hljs-property">msg</span>;<br></code></pre></td></tr></table></figure><p>视图更新会重新触发属性的<code>getter</code>方法，检测 Watcher 是否已经在 dep 中不会重复添加。</p><p>完整流程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">【初始化阶段】<br>Compile<br>  ↓<br>生成 DOM 更新函数<br>  ↓<br>创建 Watcher<br>  ↓<br>Watcher 读取数据<br>  ↓<br>数据 <span class="hljs-keyword">getter</span> 收集 Watcher 到 Dep<br><br>【运行阶段】<br>数据被修改<br>  ↓<br><span class="hljs-keyword">setter</span> 触发<br>  ↓<br>dep.notify()<br>  ↓<br>watcher.update()<br>  ↓<br>执行更新函数<br>  ↓<br>视图更新<br></code></pre></td></tr></table></figure><h4 id="【数据劫持】"><a href="#【数据劫持】" class="headerlink" title="【数据劫持】"></a>【数据劫持】</h4><p>我们分析Vue2中数据劫持的机制。</p><p><strong><code>Object.defineProperty</code></strong></p><p>在了解数据响应式的原理之前，我们先熟悉<code>Object.defineProperty</code>方法。</p><p><code>Object.defineProperty(obj, prop, descriptor)</code>是JS中用于为对象添加属性的方法。</p><ul><li><strong>obj</strong>：要定义属性的对象</li><li><strong>prop</strong>：要定义的属性名</li><li><strong>descriptor</strong>：属性描述符（决定属性的行为）</li></ul><p><strong>属性描述符分类两大类</strong></p><ol><li>数据描述符</li></ol><p>用于直接定义一个普通属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 是否可以修改</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 是否可以枚举（for...in / Object.keys）</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 是否可以删除或重新定义</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>value</code>：属性值</li><li><code>writable</code>：能否修改</li><li><code>enumerable</code>：能否枚举</li><li><code>configurable</code>：能否删除或重新定义属性</li></ul><ol start="2"><li>存取描述符</li></ol><p>通过 getter 和 setter 控制属性访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;&#125;;<br><span class="hljs-keyword">let</span> ageValue = <span class="hljs-number">20</span>;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&quot;age&quot;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getter 被调用&quot;</span>);<br>    <span class="hljs-keyword">return</span> ageValue;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setter 被调用:&quot;</span>, newVal);<br>    ageValue = newVal;<br>  &#125;,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// getter 被调用 -&gt; 20</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;         <span class="hljs-comment">// setter 被调用: 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// getter 被调用 -&gt; 30</span><br></code></pre></td></tr></table></figure><p>对于Vue的<code>data</code>对象，创建一个Observe对象，<code>data</code>中的所有属性都会在Observe上创建，并且有<code>getter</code>和<code>setter</code>方法。将<code>vm._data = obs</code>，这样当数据修改时，调用的是<code>observe</code>的方法，由<code>observe</code>修改<code>data</code>的属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, key, obj[key]));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Observer: 负责把对象的属性转为 getter/setter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(val); <span class="hljs-comment">// 递归处理嵌套对象</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>        val = newVal;<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br><br>obs = <span class="hljs-keyword">new</span> <span class="hljs-title function_">observe</span>(data)<br><span class="hljs-keyword">let</span> vm = &#123;&#125;<br>vm.<span class="hljs-property">_data</span> = data = obs<br></code></pre></td></tr></table></figure><h4 id="【局限性】"><a href="#【局限性】" class="headerlink" title="【局限性】"></a>【局限性】</h4><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=34">034_尚硅谷Vue技术_Vue监测数据的原理_对象_哔哩哔哩_bilibili</a></p></blockquote><ol><li><p><strong>不能监听对象属性的新增&#x2F;删除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;);<br>obj.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 没有劫持到</span><br></code></pre></td></tr></table></figure><p>需要 <code>Vue.set(obj, &#39;b&#39;, 2)</code> 来实现。</p></li><li><p><strong>不能监听数组下标变化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;  <span class="hljs-comment">// Vue2 监听不到</span><br></code></pre></td></tr></table></figure><p>两者都是由于没有<code>setter</code>和<code>getter</code>方法，无法进行数据劫持。通过以下方式可以解决</p><ul><li><code>this.$set() / Vue.set()</code></li><li><code>this.$delete() / Vue.delete()</code></li><li>使用<code>push, pop, shift, unshift, splice</code></li></ul></li><li><p><strong>初始化时需要递归遍历</strong></p></li></ol><ul><li>Vue2 会在初始化时递归调用 <code>defineProperty</code> 劫持所有属性，这对深层嵌套对象性能不好。</li></ul><h3 id="3-Vue3的响应式原理"><a href="#3-Vue3的响应式原理" class="headerlink" title="3.Vue3的响应式原理"></a>3.Vue3的响应式原理</h3><p>首先明确 Vue3 和 Vue2 在<strong>思想层面完全一致</strong>：</p><ul><li>数据劫持（拦截 get &#x2F; set）</li><li>依赖收集</li><li>依赖触发更新（发布–订阅思想）</li></ul><p>但是调用的方法和API不同。但不再有 <strong>Observer &#x2F; Dep &#x2F; Watcher</strong> 这些类名；它们被 <strong>Proxy + Map&#x2F;Set + effect 函数</strong> 替代</p><p>Vue 3 使用 Proxy 对对象进行代理拦截：在读取属性时通过 track 完成依赖收集；在修改属性时通过 trigger 触发依赖更新。与 Vue 2 逐属性 defineProperty 不同，Proxy 天然支持新增&#x2F;删除属性以及更多操作类型，并可采用惰性代理降低初始化成本。</p><h4 id="【第一阶段：初始化】-1"><a href="#【第一阶段：初始化】-1" class="headerlink" title="【第一阶段：初始化】"></a>【第一阶段：初始化】</h4><p>第 0 步：在首次渲染之前完成“响应式包装”（Proxy）</p><p>Vue 3 中不再是“遍历 data 每个属性 defineProperty”，而是：</p><ul><li><code>reactive(data)</code> 返回一个 Proxy</li><li>Proxy 在 <strong>get &#x2F; set</strong> 时拦截并执行 <code>track / trigger</code>， <code>track</code>是依赖收集，<code>trigger</code>是依赖触发。</li></ul><p>示意：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>这一步一定发生在首次渲染之前，否则 render 读取数据时无法 track 依赖。</p><hr><p>第 1 步：模板被编译为 render（概念上对应 Compile 解析）</p><p>Vue 3 的 render 大致可以抽象成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 读取 state.msg（会触发 Proxy.get -&gt; track）</span><br>  input.<span class="hljs-property">value</span> = state.<span class="hljs-property">msg</span>;<br>  p.<span class="hljs-property">textContent</span> = state.<span class="hljs-property">msg</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>真实 Vue 会生成 VNode 并 patch，但不影响响应式因果链。</p><hr><p>第 2 步：处理 <code>v-model</code>（view → model 仍然是 DOM 事件）</p><ul><li>DOM 事件监听属于 JS 原生机制</li><li>Vue 只是在框架层帮你组织好“监听 + 赋值”</li></ul><p>等价示意：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  state.<span class="hljs-property">msg</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">// Proxy.set -&gt; trigger</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>到此为止：</p><ul><li>view → model 通道建立</li><li>但响应式更新链路要靠下面的 effect 才能自动跑起来</li></ul><hr><p>第 3 步：创建渲染 effect（等价于 Vue 2 的“创建渲染 Watcher”）</p><p>Vue 3 中对应的是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 首次执行：读取 state.msg -&gt; track 收集依赖</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>这一句是 Vue 3 运行时的关键点：</p><ul><li>effect 首次执行 render</li><li>render 内部读取 <code>state.msg</code></li><li>触发 <code>Proxy.get</code> → <code>track(target, &#39;msg&#39;)</code></li><li>把当前 effect 记录到依赖图 <code>targetMap</code> 的对应集合里</li></ul><p>到此为止：</p><ul><li>依赖关系已建立</li><li><strong>effect 是“订阅者&#x2F;更新单元”</strong></li><li><code>state.msg</code> 的依赖集合里已经有这个 effect</li></ul><hr><h4 id="【第二阶段：运行时】-1"><a href="#【第二阶段：运行时】-1" class="headerlink" title="【第二阶段：运行时】"></a>【第二阶段：运行时】</h4><p>第 4 步：数据发生变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">state.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;world&#x27;</span>;<br></code></pre></td></tr></table></figure><p>触发：</p><ul><li><code>Proxy.set</code></li><li>进而 <code>trigger(target, &#39;msg&#39;)</code></li></ul><hr><p>第 5 步：trigger 通知所有依赖该属性的 effect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dep.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">eff</span> =&gt;</span> <span class="hljs-title function_">eff</span>());<br></code></pre></td></tr></table></figure><p>这一步等价于 Vue 2 的：</p><ul><li><code>dep.notify() -&gt; watcher.update()</code></li></ul><hr><p>第 6 步：effect 重新执行 render，完成视图更新</p><p>effect 再次执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 再次读取 state.msg</span><br></code></pre></td></tr></table></figure><p>因此：</p><ul><li>视图更新会再次触发 <code>Proxy.get</code></li><li>会再次走到 <code>track</code></li><li>但依赖集合是 <code>Set</code>，不会重复添加同一个 effect</li></ul><p>结论：</p><ul><li><strong>getter（Proxy.get）会重复触发</strong></li><li><strong>effect 不会重新创建，只会重复执行</strong></li><li><strong>依赖不会重复收集（Set 去重）</strong></li></ul><hr><p>完整流程（Vue 3 文字版固化）</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf">【初始化阶段】<br>reactive(data) 创建 Proxy<br>  ↓<br>编译得到 render（概念上）<br>  ↓<br>effect(() =&gt; render())  首次执行 render<br>  ↓<br>render 读取 <span class="hljs-keyword">state</span>.msg<br>  ↓<br>Proxy.get -&gt; track 收集 effect 到依赖图<br><br>【运行阶段】<br><span class="hljs-keyword">state</span>.msg 被修改<br>  ↓<br>Proxy.<span class="hljs-built_in">set</span> -&gt; trigger<br>  ↓<br>trigger 找到依赖该 key 的 effects<br>  ↓<br>重新执行 effect（不会重新创建）<br>  ↓<br>render 再次执行 -&gt; 视图更新<br></code></pre></td></tr></table></figure><h4 id="【Proxy和Reflect】"><a href="#【Proxy和Reflect】" class="headerlink" title="【Proxy和Reflect】"></a>【<code>Proxy</code>和<code>Reflect</code>】</h4><p><code>Proxy</code>和<code>Reflect</code>是ES6新增的属性。</p><p>调用 <code>reactive(state)</code>时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> &#125; &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>此时发生的事情是：</p><ul><li>创建了 <strong>state 的 Proxy</strong></li><li>内部对象 <code>a</code>、<code>b</code>、<code>c</code> 还是普通对象</li></ul><p>Vue 3 不会在创建 <code>reactive</code> 时就递归地把所有嵌套对象都变成响应式，而是在“第一次访问某个嵌套对象时”，才对它进行 <code>reactive</code> 包装。</p><p><strong>Proxy</strong> 用来创建对象的代理，可以拦截对对象的各种操作。</p><p>基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><ul><li><strong>target</strong>：原始对象</li><li><strong>handler</strong>：一个对象，定义拦截操作（trap）</li></ul><p>常用 trap：</p><table><thead><tr><th>trap</th><th>作用</th></tr></thead><tbody><tr><td>get</td><td>读取属性时触发</td></tr><tr><td>set</td><td>修改属性时触发</td></tr><tr><td>deleteProperty</td><td>删除属性时触发</td></tr><tr><td>has</td><td><code>key in obj</code> 时触发</td></tr><tr><td>ownKeys</td><td><code>Object.keys</code> &#x2F; <code>for...in</code> 时触发</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取属性 <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置属性 <span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    target[key] = value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;);<br><br>proxyObj.<span class="hljs-property">a</span>;      <span class="hljs-comment">// 读取属性 a</span><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">20</span>; <span class="hljs-comment">// 设置属性 a = 20</span><br></code></pre></td></tr></table></figure><p><strong>Reflect</strong> 提供与对象操作对应的方法，是一种原生的操作封装。它的目的是 <strong>用函数形式实现对象的默认行为</strong>，可以和 Proxy 的 handler 配合使用。</p><p>常用方法</p><table><thead><tr><th>方法</th><th>对应操作</th></tr></thead><tbody><tr><td>Reflect.get(target, key, receiver)</td><td>对象读取属性</td></tr><tr><td>Reflect.set(target, key, value, receiver)</td><td>对象设置属性</td></tr><tr><td>Reflect.deleteProperty(target, key)</td><td>删除属性</td></tr><tr><td>Reflect.has(target, key)</td><td><code>key in obj</code></td></tr><tr><td>Reflect.ownKeys(target)</td><td><code>Object.keys</code> &#x2F; <code>Object.getOwnPropertyNames</code></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取 <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver); <span class="hljs-comment">// 默认行为</span><br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`修改 <span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver); <span class="hljs-comment">// 默认行为</span><br>  &#125;<br>&#125;);<br><br>proxyObj.<span class="hljs-property">a</span>;      <span class="hljs-comment">// 读取 a</span><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 修改 a = 100</span><br></code></pre></td></tr></table></figure><p>使用 Reflect 的好处：将Object,Function所有的操作<strong>统一到了一个对象下面</strong> ，<strong>也统一了操作方式</strong> 。 优化了一些报错，相比于Object代码健壮性更强。</p><blockquote><p><strong>整体描述</strong></p></blockquote><p>Vue 是基于 MVVM 架构实现的渐进式前端框架，其中 Model 负责保存数据和业务状态，View 是模板和最终的 DOM，ViewModel 即 Vue 实例负责把二者连接起来并实现数据与视图的双向绑定。框架通过响应式系统把数据的读写和视图更新耦合起来：在 Vue2 中，框架在初始化时会递归遍历 <code>data</code>，对每个属性使用 <code>Object.defineProperty</code> 设置 getter 和 setter；在组件渲染阶段执行渲染函数时，读取响应式属性会触发 getter，getter 中利用一个全局指针（<code>Dep.target</code>）将当前正在执行的 Watcher（渲染 Watcher、computed 的惰性 Watcher，或用户通过 <code>watch</code>&#x2F;<code>$watch</code> 创建的 Watcher）加入该属性对应的依赖管理器 Dep，从而建立“属性 → 订阅者（Watcher）”的关系；当属性被修改时，setter 被触发，调用 Dep.notify 通知所有依赖该属性的 Watcher 去更新。视图到数据的反向链路由模板编译时产生的指令完成，例如 <code>v-model</code> 实际上会编译为 <code>:value=&quot;xxx&quot;</code> 与 <code>@input=&quot;xxx = $event.target.value&quot;</code>，用户输入触发事件处理器写回数据，写回数据触发 setter，再通过依赖链更新视图。Vue2 中对数组采用覆盖变异方法（如重写 <code>push</code>、<code>splice</code>）来拦截变更，但不能检测通过下标直接赋值或新增&#x2F;删除对象属性（需要 <code>Vue.set</code>&#x2F;<code>Vue.delete</code>），且初始化时对深层对象的递归劫持开销较大。</p><p>为了解决这些局限，Vue3 将响应式内核替换为 <code>Proxy</code> + <code>Reflect</code> 的实现：<code>reactive</code> 返回一个 Proxy，<code>get</code>&#x2F;<code>set</code>&#x2F;<code>deleteProperty</code> 等拦截器配合 <code>track</code>&#x2F;<code>trigger</code> 在内部维护依赖映射结构 <code>targetMap</code>（WeakMap → Map（key → Set(effects)））；当一个 effect（等价于 Vue2 的 Watcher）在执行时读取属性会被 <code>track</code> 收集为依赖，写操作或删除操作会通过 <code>trigger</code> 找到相关 effect 并重新执行。Proxy 的优点是能拦截属性新增与删除、数组下标与长度变化，并且采用按需（懒）代理嵌套对象以减少初始化开销，从而使得对数组和新增属性的监测更自然、性能更优。</p><p>视图更新层面，模板在构建阶段被编译为渲染函数（render），渲染函数执行生成虚拟 DOM（VNode）；响应式变化触发渲染 Watcher &#x2F; effect 重新执行渲染函数产生新的 VNode，框架通过虚拟 DOM 的 diff 算法比较新旧 VNode 并以最小化的方式 patch 到真实 DOM。为了提高并发修改的性能，Vue 会把多个同步的数据修改合并为一次异步批量更新（维护更新队列并使用微任务&#x2F;<code>nextTick</code> 调度），Vue3 在 diff 的子节点重排上用 keyed 优化和最长递增子序列（LIS）等策略进一步减少 DOM 移动。</p><p>总之，Vue 的关键是把数据变动的“通知”链和视图的“渲染”链通过依赖收集连接起来：Vue2 用 <code>Object.defineProperty</code> + Dep&#x2F;Watcher 实现，存在新增&#x2F;数组索引检测等局限；Vue3 用 <code>Proxy</code> + <code>track/trigger</code>（基于 WeakMap→Map→Set 的依赖表）解决这些问题并带来性能与语义上的改进；而 <code>v-model</code>、computed、watch、渲染队列与虚拟 DOM 则是建立在这套响应式核心之上的常用抽象。</p><h3 id="4-数据代理"><a href="#4-数据代理" class="headerlink" title="4.数据代理"></a>4.数据代理</h3><p>创建一个简单的vue实例时：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>初识Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入Vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示。</span></span><br><span class="language-javascript"><span class="hljs-comment">//创建Vue实例</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#demo&#x27;</span>, <span class="hljs-comment">//el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。</span></span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123; <span class="hljs-comment">//data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。</span></span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;atguigu&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;北京&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在命令行终端中，可以通过<code>vm.name</code>和<code>vm.address</code>来访问数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">name</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">name</span><br>vm.<span class="hljs-property">address</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">address</span><br></code></pre></td></tr></table></figure><ul><li>当修改<code>vm.name</code>时，<code>vm._data.name</code>会同步修改。</li></ul><h4 id="理解数据代理"><a href="#理解数据代理" class="headerlink" title="理解数据代理"></a>理解数据代理</h4><p>在前面我们说VMMV的 Model 实际上就是<code>data</code>属性中是数据，当我们创建一个vue的实例对象的时候。Vue会帮我们将数据进行一些处理。</p><ul><li>首先将数据从<code>data</code>中取出放到<code>_data</code>中，并进行数据劫持的相关操作（后面提到）</li><li>将数据从<code>_data</code>中复制了一份在<code>vm</code>实例对象上，对 <code>vm</code> 实例的属性访问，转发到 <code>vm._data</code> 上。<strong>（数据代理）</strong></li></ul><img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20250903140313714.png" class title="image-20250903140313714"><blockquote><p>要注意的是，数据代理的作用是减少代码量，让开发体验更好。与响应式没有关系。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">addr</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">addr</span> === vm.<span class="hljs-property">data</span>.<span class="hljs-property">addr</span> ( === vm.<span class="hljs-property">observe</span>.<span class="hljs-property">addr</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3快速上手</title>
    <link href="/2025/12/17/Vue/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <url>/2025/12/17/Vue/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>在尚硅谷Vue3学习笔记基础上整理，核心语法 &#x2F; 路由 &#x2F; pinia &#x2F; 组件通信</p><span id="more"></span><blockquote><p>TS教程：<a href="https://www.tslang.cn/docs/home.html">文档简介 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><p>Vite教程：<a href="https://cn.vitejs.dev/config/">配置 Vite | Vite 官方中文文档 (vitejs.dev)</a></p><p>Vue教程：<a href="https://cn.vuejs.org/api/">API 参考 | Vue.js (vuejs.org)</a></p><p>Vue-Route教程：<a href="https://router.vuejs.org/zh/">Vue Router | Vue.js 的官方路由 (vuejs.org)</a></p><p><a href="https://www.bilibili.com/video/BV1Za4y1r7KE?spm_id_from=333.788.recommend_more_video.0&trackid=web_related_0.router-related-2206146-7vfnq.1765979057313.173&vd_source=ff414aaf189e3a685358d2a984fd4742">尚硅谷Vue3入门到实战，最新版vue3+TypeScript前端开发教程_哔哩哔哩_bilibili</a></p></blockquote><h1 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1. Vue3简介"></a>1. Vue3简介</h1><ul><li><p>2020年9月18日，<code>Vue.js</code>发布版<code>3.0</code>版本，代号：<code>One Piece</code>（n</p></li><li><p>经历了：<a href="https://github.com/vuejs/core/commits/main">4800+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">40+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/core/graphs/contributors">300+贡献者</a></p></li><li><p>官方发版地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs&#x2F;core</a></p></li><li><p>截止2023年10月，最新的公开版本为：<code>3.3.4</code></p><img src="/2025/12/17/Vue/Vue3快速上手/1695089947298-161c1b47-eb86-42fb-b1f8-d6a4fcab8ee2-1765979249041-3.png" alt="image.png" style="zoom:30%;"></li></ul><h2 id="1-1-【性能的提升】"><a href="#1-1-【性能的提升】" class="headerlink" title="1.1. 【性能的提升】"></a>1.1. 【性能的提升】</h2><ul><li>打包大小减少<code>41%</code>。</li><li>初次渲染快<code>55%</code>, 更新渲染快<code>133%</code>。</li><li>内存减少<code>54%</code>。</li></ul><h2 id="1-2-【-源码的升级】"><a href="#1-2-【-源码的升级】" class="headerlink" title="1.2.【 源码的升级】"></a>1.2.【 源码的升级】</h2><ul><li><p>使用<code>Proxy</code>代替<code>defineProperty</code>实现响应式。</p></li><li><p>重写虚拟<code>DOM</code>的实现和<code>Tree-Shaking</code>。</p></li></ul><h2 id="1-3-【拥抱TypeScript】"><a href="#1-3-【拥抱TypeScript】" class="headerlink" title="1.3. 【拥抱TypeScript】"></a>1.3. 【拥抱TypeScript】</h2><ul><li><code>Vue3</code>可以更好的支持<code>TypeScript</code>。</li></ul><h2 id="1-4-【新的特性】"><a href="#1-4-【新的特性】" class="headerlink" title="1.4. 【新的特性】"></a>1.4. 【新的特性】</h2><ol><li><p><code>Composition API</code>（组合<code>API</code>）：</p><ul><li><p><code>setup</code></p></li><li><p><code>ref</code>与<code>reactive</code></p></li><li><p><code>computed</code>与<code>watch</code></p><p>……</p></li></ul></li><li><p>新的内置组件：</p><ul><li><p><code>Fragment</code></p></li><li><p><code>Teleport</code></p></li><li><p><code>Suspense</code></p><p>……</p></li></ul></li><li><p>其他改变：</p><ul><li><p>新的生命周期钩子</p></li><li><p><code>data</code> 选项应始终被声明为一个函数</p></li><li><p>移除<code>keyCode</code>支持作为<code> v-on</code> 的修饰符</p><p>……</p></li></ul></li></ol><h1 id="2-创建Vue3工程"><a href="#2-创建Vue3工程" class="headerlink" title="2. 创建Vue3工程"></a>2. 创建Vue3工程</h1><h2 id="2-1-【基于-vue-cli-创建】"><a href="#2-1-【基于-vue-cli-创建】" class="headerlink" title="2.1. 【基于 vue-cli 创建】"></a>2.1. 【基于 vue-cli 创建】</h2><p>点击查看<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">官方文档</a></p><blockquote><p>备注：目前<code>vue-cli</code>已处于维护模式，官方推荐基于 <code>Vite</code> 创建项目。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue <span class="hljs-literal">--version</span><br><br><span class="hljs-comment">## 安装或者升级你的@vue/cli </span><br>npm install <span class="hljs-literal">-g</span> @vue/<span class="hljs-built_in">cli</span><br><br><span class="hljs-comment">## 执行创建命令</span><br>vue create vue_test<br><br><span class="hljs-comment">##  随后选择3.x</span><br><span class="hljs-comment">##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)</span><br><span class="hljs-comment">##  &gt; 3.x</span><br><span class="hljs-comment">##    2.x</span><br><br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><hr><h2 id="2-2-【基于-vite-创建】-推荐"><a href="#2-2-【基于-vite-创建】-推荐" class="headerlink" title="2.2. 【基于 vite 创建】(推荐)"></a>2.2. 【基于 vite 创建】(推荐)</h2><p><code>vite</code> 是新一代前端构建工具，官网地址：<a href="https://vitejs.cn/">https://vitejs.cn</a>，<code>vite</code>的优势如下：</p><ul><li>轻量快速的热重载（<code>HMR</code>），能实现极速的服务启动。</li><li>对 <code>TypeScript</code>、<code>JSX</code>、<code>CSS</code> 等支持开箱即用。</li><li>真正的按需编译，不再等待整个应用编译完成。</li><li><code>webpack</code>构建 与 <code>vite</code>构建对比图如下：<br><img src="/2025/12/17/Vue/Vue3快速上手/.." alt="webpack构建" title="webpack构建" style="zoom:20%;box-shadow:0 0 10px black"><img src="/2025/12/17/Vue/Vue3快速上手/1683167204081-582dc237-72bc-499e-9589-2cdfd452e62f-1765979249041-4.png" alt="vite构建" title="vite构建" style="zoom: 20%;box-shadow:0 0 10px black"></li></ul><ul><li>具体操作如下（点击查看<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">官方文档</a>）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">## 1.创建命令</span><br>npm create vue@latest<br><br><span class="hljs-comment">## 2.具体配置</span><br><span class="hljs-comment">## 配置项目名称</span><br>√ Project name: vue3_test<br><span class="hljs-comment">## 是否添加TypeScript支持</span><br>√ Add TypeScript?  Yes<br><span class="hljs-comment">## 是否添加JSX支持</span><br>√ Add JSX Support?  No<br><span class="hljs-comment">## 是否添加路由环境</span><br>√ Add Vue Router <span class="hljs-keyword">for</span> Single Page Application development?  No<br><span class="hljs-comment">## 是否添加pinia环境</span><br>√ Add Pinia <span class="hljs-keyword">for</span> state management?  No<br><span class="hljs-comment">## 是否添加单元测试</span><br>√ Add Vitest <span class="hljs-keyword">for</span> Unit Testing?  No<br><span class="hljs-comment">## 是否添加端到端测试方案</span><br>√ Add an <span class="hljs-keyword">End</span><span class="hljs-literal">-to-End</span> Testing Solution? » No<br><span class="hljs-comment">## 是否添加ESLint语法检查</span><br>√ Add ESLint <span class="hljs-keyword">for</span> code quality?  Yes<br><span class="hljs-comment">## 是否添加Prettiert代码格式化</span><br>√ Add Prettier <span class="hljs-keyword">for</span> code formatting?  No<br></code></pre></td></tr></table></figure><p>自己动手编写一个App组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;app&quot;&gt;<br>    &lt;h1&gt;你好啊！&lt;/h1&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;App&#x27; //组件名<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>  .app &#123;<br>    background-color: #ddd;<br>    box-shadow: 0 0 10px;<br>    border-radius: 10px;<br>    padding: 20px;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>安装官方推荐的<code>vscode</code>插件：</p><img src="/2025/12/17/Vue/Vue3快速上手/volar-1765979249041-6.png" alt="Snipaste_2023-10-08_20-46-34" style="zoom:50%;"> <img src="/2025/12/17/Vue/Vue3快速上手/image-20231218085906380-1765979249041-8.png" alt="image-20231218085906380" style="zoom:42%;"> <p>总结：</p><ul><li><code>Vite</code> 项目中，<code>index.html</code> 是项目的入口文件，在项目最外层。</li><li>加载<code>index.html</code>后，<code>Vite</code> 解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;</code> 指向的<code>JavaScript</code>。</li><li><code>Vue3</code>**中是通过 **<code>createApp</code> 函数创建一个应用实例。</li></ul><h2 id="2-3-【一个简单的效果】"><a href="#2-3-【一个简单的效果】" class="headerlink" title="2.3. 【一个简单的效果】"></a>2.3. 【一个简单的效果】</h2><p><code>Vue3</code>向下兼容<code>Vue2</code>语法，且<code>Vue3</code>中的模板中可以没有根标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;App&#x27;,<br>    data() &#123;<br>      return &#123;<br>        name:&#x27;张三&#x27;,<br>        age:18,<br>        tel:&#x27;13888888888&#x27;<br>      &#125;<br>    &#125;,<br>    methods:&#123;<br>      changeName()&#123;<br>        this.name = &#x27;zhang-san&#x27;<br>      &#125;,<br>      changeAge()&#123;<br>        this.age += 1<br>      &#125;,<br>      showTel()&#123;<br>        alert(this.tel)<br>      &#125;<br>    &#125;,<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h1 id="3-Vue3核心语法"><a href="#3-Vue3核心语法" class="headerlink" title="3. Vue3核心语法"></a>3. Vue3核心语法</h1><h2 id="3-1-【OptionsAPI-与-CompositionAPI】"><a href="#3-1-【OptionsAPI-与-CompositionAPI】" class="headerlink" title="3.1.  【OptionsAPI 与 CompositionAPI】"></a>3.1.  【OptionsAPI 与 CompositionAPI】</h2><ul><li><code>Vue2</code>的<code>API</code>设计是<code>Options</code>（配置）风格的。</li><li><code>Vue3</code>的<code>API</code>设计是<code>Composition</code>（组合）风格的。</li></ul><h3 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h3><p><code>Options</code>类型的 <code>API</code>，数据、方法、计算属性等，是分散在：<code>data</code>、<code>methods</code>、<code>computed</code>中的，若想新增或者修改一个需求，就需要分别修改：<code>data</code>、<code>methods</code>、<code>computed</code>，不便于维护和复用。</p><p><img src="/2025/12/17/Vue/Vue3快速上手/.." alt="1.gif" style="zoom:70%;border-radius:20px"><img src="/2025/12/17/Vue/Vue3快速上手/1696662200734-1bad8249-d7a2-423e-a3c3-ab4c110628be-1765979249041-9.gif" alt="2.gif" style="zoom:70%;border-radius:20px"></p><h3 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h3><p>可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。</p><p><img src="/2025/12/17/Vue/Vue3快速上手/1696662249851-db6403a1-acb5-481a-88e0-e1e34d2ef53a-1765979249041-10.gif" alt="3.gif" style="height:300px;border-radius:10px"><img src="/2025/12/17/Vue/Vue3快速上手/.." alt="4.gif" style="height:300px;border-radius:10px"></p><blockquote><p>说明：以上四张动图原创作者：大帅老猿</p></blockquote><h2 id="3-2-【拉开序幕的-setup】"><a href="#3-2-【拉开序幕的-setup】" class="headerlink" title="3.2. 【拉开序幕的 setup】"></a>3.2. 【拉开序幕的 setup】</h2><h3 id="setup-概述"><a href="#setup-概述" class="headerlink" title="setup 概述"></a>setup 概述</h3><p><code>setup</code>是<code>Vue3</code>中一个新的配置项，值是一个函数，它是 <code>Composition API</code> <strong>“表演的舞台</strong>_<strong>”</strong>_，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在<code>setup</code>中。</p><p>特点如下：</p><ul><li><code>setup</code>函数返回的对象中的内容，可直接在模板中使用。</li><li><code>setup</code>中访问<code>this</code>是<code>undefined</code>。</li><li><code>setup</code>函数会在<code>beforeCreate</code>之前调用，它是“领先”所有钩子执行的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;Person&#x27;,<br>    setup()&#123;<br>      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）<br>      let name = &#x27;张三&#x27;<br>      let age = 18<br>      let tel = &#x27;13888888888&#x27;<br><br>      // 方法，原来写在methods中<br>      function changeName()&#123;<br>        name = &#x27;zhang-san&#x27; //注意：此时这么修改name页面是不变化的<br>        console.log(name)<br>      &#125;<br>      function changeAge()&#123;<br>        age += 1 //注意：此时这么修改age页面是不变化的<br>        console.log(age)<br>      &#125;<br>      function showTel()&#123;<br>        alert(tel)<br>      &#125;<br><br>      // 返回一个对象，对象中的内容，模板中可以直接使用<br>      return &#123;name,age,tel,changeName,changeAge,showTel&#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="setup-的返回值"><a href="#setup-的返回值" class="headerlink" title="setup 的返回值"></a>setup 的返回值</h3><ul><li>若返回一个<strong>对象</strong>：则对象中的：属性、方法等，在模板中均可以直接使用<strong>（重点关注）。</strong></li><li>若返回一个<strong>函数</strong>：则可以自定义渲染内容（基本不用），代码如下：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span> <span class="hljs-string">&#x27;你好啊！&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="setup-与-Options-API-的关系"><a href="#setup-与-Options-API-的关系" class="headerlink" title="setup 与 Options API 的关系"></a>setup 与 Options API 的关系</h3><ul><li><code>Vue2</code> 的配置（<code>data</code>、<code>methos</code>……）中<strong>可以访问到</strong> <code>setup</code>中的属性、方法。</li><li>但在<code>setup</code>中<strong>不能访问到</strong><code>Vue2</code>的配置（<code>data</code>、<code>methos</code>……）。</li><li>如果与<code>Vue2</code>冲突，则<code>setup</code>优先。</li></ul><h3 id="setup-语法糖"><a href="#setup-语法糖" class="headerlink" title="setup 语法糖"></a>setup 语法糖</h3><p><code>setup</code>函数有一个语法糖，这个语法糖，可以让我们把<code>setup</code>独立出去，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;Person&#x27;,<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;!-- 下面的写法是setup语法糖 --&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  console.log(this) //undefined<br>  <br>  // 数据（注意：此时的name、age、tel都不是响应式数据）<br>  let name = &#x27;张三&#x27;<br>  let age = 18<br>  let tel = &#x27;13888888888&#x27;<br><br>  // 方法<br>  function changName()&#123;<br>    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的<br>  &#125;<br>  function changAge()&#123;<br>    console.log(age)<br>    age += 1 //注意：此时这么修改age页面是不变化的<br>  &#125;<br>  function showTel()&#123;<br>    alert(tel)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>扩展：上述代码，还需要编写一个不写<code>setup</code>的<code>script</code>标签，去指定组件名字，比较麻烦，我们可以借助<code>vite</code>中的插件简化</p><ol><li>第一步：<code>npm i vite-plugin- vue-setup-extend -D</code></li><li>第二步：<code>vite.config.ts</code></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueSetupExtend</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-vue-setup-extend&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [ <span class="hljs-title class_">VueSetupExtend</span>() ]<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>第三步：<code>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</code></li></ol><h2 id="3-3-【ref-创建：基本类型的响应式数据】"><a href="#3-3-【ref-创建：基本类型的响应式数据】" class="headerlink" title="3.3. 【ref 创建：基本类型的响应式数据】"></a>3.3. 【ref 创建：基本类型的响应式数据】</h2><ul><li><strong>作用：</strong>定义响应式变量。</li><li><strong>语法：</strong><code>let xxx = ref(初始值)</code>。</li><li><strong>返回值：</strong>一个<code>RefImpl</code>的实例对象，简称<code>ref对象</code>或<code>ref</code>，<code>ref</code>对象的<code>value</code><strong>属性是响应式的</strong>。</li><li><strong>注意点：</strong><ul><li><code>JS</code>中操作数据需要：<code>xxx.value</code>，但模板中不需要<code>.value</code>，直接使用即可。</li><li>对于<code>let name = ref(&#39;张三&#39;)</code>来说，<code>name</code>不是响应式的，<code>name.value</code>是响应式的。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;<br>  import &#123;ref&#125; from &#x27;vue&#x27;<br>  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。<br>  let name = ref(&#x27;张三&#x27;)<br>  let age = ref(18)<br>  // tel就是一个普通的字符串，不是响应式的<br>  let tel = &#x27;13888888888&#x27;<br><br>  function changeName()&#123;<br>    // JS中操作ref对象时候需要.value<br>    name.value = &#x27;李四&#x27;<br>    console.log(name.value)<br><br>    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。<br>    // name = ref(&#x27;zhang-san&#x27;)<br>  &#125;<br>  function changeAge()&#123;<br>    // JS中操作ref对象时候需要.value<br>    age.value += 1 <br>    console.log(age.value)<br>  &#125;<br>  function showTel()&#123;<br>    alert(tel)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-4-【reactive-创建：对象类型的响应式数据】"><a href="#3-4-【reactive-创建：对象类型的响应式数据】" class="headerlink" title="3.4. 【reactive 创建：对象类型的响应式数据】"></a>3.4. 【reactive 创建：对象类型的响应式数据】</h2><ul><li><strong>作用：</strong>定义一个<strong>响应式对象</strong>（基本类型不要用它，要用<code>ref</code>，否则报错）</li><li><strong>语法：</strong><code>let 响应式对象= reactive(源对象)</code>。</li><li><strong>返回值：</strong>一个<code>Proxy</code>的实例对象，简称：响应式对象。</li><li><strong>注意点：</strong><code>reactive</code>定义的响应式数据是“深层次”的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;<br>    &lt;h2&gt;游戏列表：&lt;/h2&gt;<br>    &lt;ul&gt;<br>      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;<br>    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;<br>    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>import &#123; reactive &#125; from &#x27;vue&#x27;<br><br>// 数据<br>let car = reactive(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)<br>let games = reactive([<br>  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;<br>])<br>let obj = reactive(&#123;<br>  a:&#123;<br>    b:&#123;<br>      c:&#123;<br>        d:666<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br>function changeCarPrice() &#123;<br>  car.price += 10<br>&#125;<br>function changeFirstGame() &#123;<br>  games[0].name = &#x27;流星蝴蝶剑&#x27;<br>&#125;<br>function test()&#123;<br>  obj.a.b.c.d = 999<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-5-【ref-创建：对象类型的响应式数据】"><a href="#3-5-【ref-创建：对象类型的响应式数据】" class="headerlink" title="3.5. 【ref 创建：对象类型的响应式数据】"></a>3.5. 【ref 创建：对象类型的响应式数据】</h2><ul><li>其实<code>ref</code>接收的数据可以是：<strong>基本类型</strong>、<strong>对象类型</strong>。</li><li>若<code>ref</code>接收的是对象类型，内部其实也是调用了<code>reactive</code>函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;<br>    &lt;h2&gt;游戏列表：&lt;/h2&gt;<br>    &lt;ul&gt;<br>      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;<br>    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;<br>    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>  <br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>// 数据<br>let car = ref(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)<br>let games = ref([<br>  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;<br>])<br>let obj = ref(&#123;<br>  a:&#123;<br>    b:&#123;<br>      c:&#123;<br>        d:666<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br>console.log(car)<br><br>function changeCarPrice() &#123;<br>  car.value.price += 10<br>&#125;<br>function changeFirstGame() &#123;<br>  games.value[0].name = &#x27;流星蝴蝶剑&#x27;<br>&#125;<br>function test()&#123;<br>  obj.value.a.b.c.d = 999<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-6-【ref-对比-reactive】"><a href="#3-6-【ref-对比-reactive】" class="headerlink" title="3.6. 【ref 对比 reactive】"></a>3.6. 【ref 对比 reactive】</h2><p>宏观角度看：</p><blockquote><ol><li><p><code>ref</code>用来定义：<strong>基本类型数据</strong>、<strong>对象类型数据</strong>；</p></li><li><p><code>reactive</code>用来定义：<strong>对象类型数据</strong>。</p></li></ol></blockquote><ul><li>区别：</li></ul><blockquote><ol><li><p><code>ref</code>创建的变量必须使用<code>.value</code>（可以使用<code>volar</code>插件自动添加<code>.value</code>）。</p><img src="/2025/12/17/Vue/Vue3快速上手/自动补充value-1765979249042-12.png" alt="自动补充value" style="zoom:50%;border-radius:20px"> </li><li><p><code>reactive</code>重新分配一个新对象，会<strong>失去</strong>响应式（可以使用<code>Object.assign</code>去整体替换）。 </p></li><li><p><code>ref</code>可以给value直接分配一个新对象。</p></li></ol></blockquote><ul><li>使用原则：</li></ul><blockquote><ol><li>若需要一个基本类型的响应式数据，必须使用<code>ref</code>。</li><li>若需要一个响应式对象，层级不深，<code>ref</code>、<code>reactive</code>都可以。</li><li>若需要一个响应式对象，且层级较深，推荐使用<code>reactive</code>。</li></ol></blockquote><h2 id="3-7-【toRefs-与-toRef】"><a href="#3-7-【toRefs-与-toRef】" class="headerlink" title="3.7. 【toRefs 与 toRef】"></a>3.7. 【toRefs 与 toRef】</h2><ul><li>作用：将一个响应式对象中的每一个属性，转换为<code>ref</code>对象。</li><li>备注：<code>toRefs</code>与<code>toRef</code>功能一致，但<code>toRefs</code>可以批量转换。</li><li>语法如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;性别：&#123;&#123;person.gender&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changeGender&quot;&gt;修改性别&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,reactive,toRefs,toRef&#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let person = reactive(&#123;name:&#x27;张三&#x27;, age:18, gender:&#x27;男&#x27;&#125;)<br><br>  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力<br>  let &#123;name,gender&#125; =  toRefs(person)<br><br>  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力<br>  let age = toRef(person,&#x27;age&#x27;)<br><br>  // 方法<br>  function changeName()&#123;<br>    name.value += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    age.value += 1<br>  &#125;<br>  function changeGender()&#123;<br>    gender.value = &#x27;女&#x27;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-8-【computed】"><a href="#3-8-【computed】" class="headerlink" title="3.8. 【computed】"></a>3.8. 【computed】</h2><p>作用：根据已有数据计算出新数据（和<code>Vue2</code>中的<code>computed</code>作用一致）。</p><img src="/2025/12/17/Vue/Vue3快速上手/computed-1765979249042-13.gif" style="zoom:20%;">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;<br>    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;<br>    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;<br>    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;<br>  import &#123;ref,computed&#125; from &#x27;vue&#x27;<br><br>  let firstName = ref(&#x27;zhang&#x27;)<br>  let lastName = ref(&#x27;san&#x27;)<br><br>  // 计算属性——只读取，不修改<br>  /* let fullName = computed(()=&gt;&#123;<br>    return firstName.value + &#x27;-&#x27; + lastName.value<br>  &#125;) */<br><br><br>  // 计算属性——既读取又修改<br>  let fullName = computed(&#123;<br>    // 读取<br>    get()&#123;<br>      return firstName.value + &#x27;-&#x27; + lastName.value<br>    &#125;,<br>    // 修改<br>    set(val)&#123;<br>      console.log(&#x27;有人修改了fullName&#x27;,val)<br>      firstName.value = val.split(&#x27;-&#x27;)[0]<br>      lastName.value = val.split(&#x27;-&#x27;)[1]<br>    &#125;<br>  &#125;)<br><br>  function changeFullName()&#123;<br>    fullName.value = &#x27;li-si&#x27;<br>  &#125; <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-9-【watch】"><a href="#3-9-【watch】" class="headerlink" title="3.9.【watch】"></a>3.9.【watch】</h2><ul><li>作用：监视数据的变化（和<code>Vue2</code>中的<code>watch</code>作用一致）</li><li>特点：<code>Vue3</code>中的<code>watch</code>只能监视以下<strong>四种数据</strong>：</li></ul><blockquote><ol><li><code>ref</code>定义的数据。</li><li><code>reactive</code>定义的数据。</li><li>函数返回一个值（<code>getter</code>函数）。</li><li>一个包含上述内容的数组。</li></ol></blockquote><p>我们在<code>Vue3</code>中使用<code>watch</code>的时候，通常会遇到以下几种情况：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="* 情况一"></a>* 情况一</h3><p>监视<code>ref</code>定义的【基本类型】数据：直接写数据名即可，监视的是其<code>value</code>值的改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况一：监视【ref】定义的【基本类型】数据&lt;/h1&gt;<br>    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,watch&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let sum = ref(0)<br>  // 方法<br>  function changeSum()&#123;<br>    sum.value += 1<br>  &#125;<br>  // 监视，情况一：监视【ref】定义的【基本类型】数据<br>  const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)<br>    if(newValue &gt;= 10)&#123;<br>      stopWatch()<br>    &#125;<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>water</code>的返回值是用于<strong>结束监视</strong>的函数。</p><h3 id="情况二"><a href="#情况二" class="headerlink" title="* 情况二"></a>* 情况二</h3><p>监视<code>ref</code>定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p><blockquote><p>注意：</p><ul><li><p>若修改的是<code>ref</code>定义的对象中的属性，<code>newValue</code> 和 <code>oldValue</code> 都是新值，因为它们是同一个对象。</p></li><li><p>若修改整个<code>ref</code>定义的对象，<code>newValue</code> 是新值， <code>oldValue</code> 是旧值，因为不是同一个对象了。</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况二：监视【ref】定义的【对象类型】数据&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,watch&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let person = ref(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.value.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.value.age += 1<br>  &#125;<br>  function changePerson()&#123;<br>    person.value = &#123;name:&#x27;李四&#x27;,age:90&#125;<br>  &#125;<br>  /* <br>    监视，情况二：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视<br>    watch的第一个参数是：被监视的数据<br>    watch的第二个参数是：监视的回调<br>    watch的第三个参数是：配置对象（deep、immediate等等.....） <br>  */<br>  watch(person,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person变化了&#x27;,newValue,oldValue)<br>  &#125;,&#123;deep:true&#125;)<br>  <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="情况三"><a href="#情况三" class="headerlink" title="*  情况三"></a>*  情况三</h3><p>监视<code>reactive</code>定义的【对象类型】数据，且默认开启了深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况三：监视【reactive】定义的【对象类型】数据&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;<br>    &lt;hr&gt;<br>    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;test&quot;&gt;修改obj.a.b.c&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;reactive,watch&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let person = reactive(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18<br>  &#125;)<br>  let obj = reactive(&#123;<br>    a:&#123;<br>      b:&#123;<br>        c:666<br>      &#125;<br>    &#125;<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.age += 1<br>  &#125;<br>  function changePerson()&#123;<br>    Object.assign(person,&#123;name:&#x27;李四&#x27;,age:80&#125;)<br>  &#125;<br>  function test()&#123;<br>    obj.a.b.c = 888<br>  &#125;<br><br>  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的<br>  watch(person,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person变化了&#x27;,newValue,oldValue)<br>  &#125;)<br>  watch(obj,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;Obj变化了&#x27;,newValue,oldValue)<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="情况四"><a href="#情况四" class="headerlink" title="* 情况四"></a>* 情况四</h3><p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p><ol><li>若该属性值<strong>不是</strong>【对象类型】，需要写成函数形式。</li><li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，建议写成函数。</li></ol><p><strong>结论</strong>：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;reactive,watch&#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let person = reactive(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18,<br>    car:&#123;<br>      c1:&#x27;奔驰&#x27;,<br>      c2:&#x27;宝马&#x27;<br>    &#125;<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.age += 1<br>  &#125;<br>  function changeC1()&#123;<br>    person.car.c1 = &#x27;奥迪&#x27;<br>  &#125;<br>  function changeC2()&#123;<br>    person.car.c2 = &#x27;大众&#x27;<br>  &#125;<br>  function changeCar()&#123;<br>    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;<br>  &#125;<br><br>  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式<br>  /* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)<br>  &#125;) */<br><br>  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数<br>  watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)<br>  &#125;,&#123;deep:true&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="情况五"><a href="#情况五" class="headerlink" title="* 情况五"></a>* 情况五</h3><p>监视上述的多个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况五：监视上述的多个数据&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;reactive,watch&#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let person = reactive(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18,<br>    car:&#123;<br>      c1:&#x27;奔驰&#x27;,<br>      c2:&#x27;宝马&#x27;<br>    &#125;<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.age += 1<br>  &#125;<br>  function changeC1()&#123;<br>    person.car.c1 = &#x27;奥迪&#x27;<br>  &#125;<br>  function changeC2()&#123;<br>    person.car.c2 = &#x27;大众&#x27;<br>  &#125;<br>  function changeCar()&#123;<br>    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;<br>  &#125;<br><br>  // 监视，情况五：监视上述的多个数据<br>  watch([()=&gt;person.name,person.car],(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)<br>  &#125;,&#123;deep:true&#125;)<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-10-【watchEffect】"><a href="#3-10-【watchEffect】" class="headerlink" title="3.10. 【watchEffect】"></a>3.10. 【watchEffect】</h2><ul><li><p>官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</p></li><li><p><code>watch</code>对比<code>watchEffect</code></p><blockquote><ol><li><p>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</p></li><li><p><code>watch</code>：要明确指出监视的数据</p></li><li><p><code>watchEffect</code>：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。</p></li></ol></blockquote></li><li><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;需求：水温达到50℃，或水位达到20cm，则联系服务器&lt;/h1&gt;<br>    &lt;h2 id=&quot;demo&quot;&gt;水温：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;水位：&#123;&#123;height&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changePrice&quot;&gt;水温+1&lt;/button&gt;<br>    &lt;button @click=&quot;changeSum&quot;&gt;水位+10&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,watch,watchEffect&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let temp = ref(0)<br>  let height = ref(0)<br><br>  // 方法<br>  function changePrice()&#123;<br>    temp.value += 10<br>  &#125;<br>  function changeSum()&#123;<br>    height.value += 1<br>  &#125;<br><br>  // 用watch实现，需要明确的指出要监视：temp、height<br>  watch([temp,height],(value)=&gt;&#123;<br>    // 从value中获取最新的temp值、height值<br>    const [newTemp,newHeight] = value<br>    // 室温达到50℃，或水位达到20cm，立刻联系服务器<br>    if(newTemp &gt;= 50 || newHeight &gt;= 20)&#123;<br>      console.log(&#x27;联系服务器&#x27;)<br>    &#125;<br>  &#125;)<br><br>  // 用watchEffect实现，不用<br>  const stopWtach = watchEffect(()=&gt;&#123;<br>    // 室温达到50℃，或水位达到20cm，立刻联系服务器<br>    if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;<br>      console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)<br>      console.log(&#x27;联系服务器&#x27;)<br>    &#125;<br>    // 水温达到100，或水位达到50，取消监视<br>    if(temp.value === 100 || height.value === 50)&#123;<br>      console.log(&#x27;清理了&#x27;)<br>      stopWtach()<br>    &#125;<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-11-【标签的-ref-属性】"><a href="#3-11-【标签的-ref-属性】" class="headerlink" title="3.11. 【标签的 ref 属性】"></a>3.11. 【标签的 ref 属性】</h2><p>作用：用于注册模板引用。</p><blockquote><ul><li><p>用在普通<code>DOM</code>标签上，获取的是<code>DOM</code>节点。</p></li><li><p>用在组件标签上，获取的是组件实例对象。</p></li></ul></blockquote><p>用在普通<code>DOM</code>标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1 ref=&quot;title1&quot;&gt;尚硅谷&lt;/h1&gt;<br>    &lt;h2 ref=&quot;title2&quot;&gt;前端&lt;/h2&gt;<br>    &lt;h3 ref=&quot;title3&quot;&gt;Vue&lt;/h3&gt;<br>    &lt;input type=&quot;text&quot; ref=&quot;inpt&quot;&gt; &lt;br&gt;&lt;br&gt;<br>    &lt;button @click=&quot;showLog&quot;&gt;点我打印内容&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref&#125; from &#x27;vue&#x27;<br><br>  let title1 = ref()<br>  let title2 = ref()<br>  let title3 = ref()<br><br>  function showLog()&#123;<br>    // 通过id获取元素<br>    const t1 = document.getElementById(&#x27;title1&#x27;)<br>    // 打印内容<br>    console.log((t1 as HTMLElement).innerText)<br>    console.log((&lt;HTMLElement&gt;t1).innerText)<br>    console.log(t1?.innerText)<br>    <br>/************************************/<br><br>    // 通过ref获取元素<br>    console.log(title1.value)<br>    console.log(title2.value)<br>    console.log(title3.value)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>用在组件标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 父组件App.vue --&gt;<br>&lt;template&gt;<br>  &lt;Person ref=&quot;ren&quot;/&gt;<br>  &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;<br>  import Person from &#x27;./components/Person.vue&#x27;<br>  import &#123;ref&#125; from &#x27;vue&#x27;<br><br>  let ren = ref()<br><br>  function test()&#123;<br>    console.log(ren.value.name)<br>    console.log(ren.value.age)<br>  &#125;<br>&lt;/script&gt;<br><br><br>&lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --&gt;<br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,defineExpose&#125; from &#x27;vue&#x27;<br>// 数据<br>  let name = ref(&#x27;张三&#x27;)<br>  let age = ref(18)<br>  /****************************/<br>  /****************************/<br>  // 使用defineExpose将组件中的数据交给外部<br>  defineExpose(&#123;name,age&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-12-【props】"><a href="#3-12-【props】" class="headerlink" title="3.12. 【props】"></a>3.12. 【props】</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个接口，限制每个Person对象的格式</span><br><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">PersonInter</span> &#123;<br><span class="hljs-attr">id</span>:string,<br><span class="hljs-attr">name</span>:string,<br><span class="hljs-attr">age</span>:number<br>&#125;<br><br><span class="hljs-comment">// 定义一个自定义类型Persons</span><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">Persons</span> = <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">PersonInter</span>&gt;<br></code></pre></td></tr></table></figure><p><code>App.vue</code>中代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;Person :list=&quot;persons&quot;/&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;<br>import Person from &#x27;./components/Person.vue&#x27;<br>import &#123;reactive&#125; from &#x27;vue&#x27;<br>import &#123;type Persons&#125; from &#x27;./types&#x27;<br><br>let person:PersonInter = &#123;<br>  id:&#x27;e98219e11&#x27;, name:&#x27;qq&#x27;, age:17 <br>&#125;<br>let persons = reactive&lt;Persons&gt;([<br>&#123;id:&#x27;e98219e12&#x27;,name:&#x27;张三&#x27;,age:18&#125;,<br>&#123;id:&#x27;e98219e13&#x27;,name:&#x27;李四&#x27;,age:19&#125;,<br> &#123;id:&#x27;e98219e14&#x27;,name:&#x27;王五&#x27;,age:20&#125;<br>])<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p><code>Person.vue</code>中代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>&lt;div class=&quot;person&quot;&gt;<br>&lt;ul&gt;<br>&lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;<br>  &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>import &#123;defineProps&#125; from &#x27;vue&#x27;<br>import &#123;type PersonInter&#125; from &#x27;@/types&#x27;<br><br>// 第一种写法：仅接收<br>// const props = defineProps([&#x27;list&#x27;])<br><br>// 第二种写法：接收+限制类型<br>// defineProps&lt;&#123;list:Persons&#125;&gt;()<br><br>// 第三种写法：接收+限制类型+指定默认值+限制必要性<br>let props = withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;<br>list:()=&gt;[&#123;id:&#x27;asdasg01&#x27;,name:&#x27;小猪佩奇&#x27;,age:18&#125;]<br>&#125;)<br>console.log(props)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-13-【生命周期】"><a href="#3-13-【生命周期】" class="headerlink" title="3.13. 【生命周期】"></a>3.13. 【生命周期】</h2><ul><li><p>概念：<code>Vue</code>组件实例在创建时要经历一系列的初始化步骤，在此过程中<code>Vue</code>会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子</p></li><li><p>规律：</p><blockquote><p>生命周期整体分为四个阶段，分别是：<strong>创建、挂载、更新、销毁</strong>，每个阶段都有两个钩子，一前一后。</p></blockquote></li><li><p><code>Vue2</code>的生命周期</p><blockquote><p>创建阶段：<code>beforeCreate</code>、<code>created</code></p><p>挂载阶段：<code>beforeMount</code>、<code>mounted</code></p><p>更新阶段：<code>beforeUpdate</code>、<code>updated</code></p><p>销毁阶段：<code>beforeDestroy</code>、<code>destroyed</code></p></blockquote></li><li><p><code>Vue3</code>的生命周期</p><blockquote><p>创建阶段：<code>setup</code></p><p>挂载阶段：<code>onBeforeMount</code>、<code>onMounted</code></p><p>更新阶段：<code>onBeforeUpdate</code>、<code>onUpdated</code></p><p>卸载阶段：<code>onBeforeUnmount</code>、<code>onUnmounted</code></p></blockquote></li><li><p>常用的钩子：<code>onMounted</code>(挂载完毕)、<code>onUpdated</code>(更新完毕)、<code>onBeforeUnmount</code>(卸载之前)</p></li><li><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;!-- vue3写法 --&gt;<br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123; <br>    ref, <br>    onBeforeMount, <br>    onMounted, <br>    onBeforeUpdate, <br>    onUpdated, <br>    onBeforeUnmount, <br>    onUnmounted <br>  &#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let sum = ref(0)<br>  // 方法<br>  function changeSum() &#123;<br>    sum.value += 1<br>  &#125;<br>  console.log(&#x27;setup&#x27;)<br>  // 生命周期钩子<br>  onBeforeMount(()=&gt;&#123;<br>    console.log(&#x27;挂载之前&#x27;)<br>  &#125;)<br>  onMounted(()=&gt;&#123;<br>    console.log(&#x27;挂载完毕&#x27;)<br>  &#125;)<br>  onBeforeUpdate(()=&gt;&#123;<br>    console.log(&#x27;更新之前&#x27;)<br>  &#125;)<br>  onUpdated(()=&gt;&#123;<br>    console.log(&#x27;更新完毕&#x27;)<br>  &#125;)<br>  onBeforeUnmount(()=&gt;&#123;<br>    console.log(&#x27;卸载之前&#x27;)<br>  &#125;)<br>  onUnmounted(()=&gt;&#123;<br>    console.log(&#x27;卸载完毕&#x27;)<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-14-【自定义hook】"><a href="#3-14-【自定义hook】" class="headerlink" title="3.14. 【自定义hook】"></a>3.14. 【自定义hook】</h2><ul><li><p>什么是<code>hook</code>？—— 本质是一个函数，把<code>setup</code>函数中使用的<code>Composition API</code>进行了封装，类似于<code>vue2.x</code>中的<code>mixin</code>。</p></li><li><p>自定义<code>hook</code>的优势：复用代码, 让<code>setup</code>中的逻辑更清楚易懂。</p></li></ul><p>示例代码：</p><ul><li><p><code>useSum.ts</code>中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;ref,onMounted&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    sum.<span class="hljs-property">value</span> += <span class="hljs-number">1</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">decrement</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    sum.<span class="hljs-property">value</span> -= <span class="hljs-number">1</span><br>  &#125;<br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">increment</span>()<br>  &#125;)<br><br>  <span class="hljs-comment">//向外部暴露数据</span><br>  <span class="hljs-keyword">return</span> &#123;sum,increment,decrement&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>useDog.ts</code>中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;reactive,onMounted&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> axios,&#123;<span class="hljs-title class_">AxiosError</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> dogList = reactive&lt;string[]&gt;([])<br><br>  <span class="hljs-comment">// 方法</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDog</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 发请求</span><br>      <span class="hljs-keyword">let</span> &#123;data&#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;</span>)<br>      <span class="hljs-comment">// 维护数据</span><br>      dogList.<span class="hljs-title function_">push</span>(data.<span class="hljs-property">message</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-comment">// 处理错误</span><br>      <span class="hljs-keyword">const</span> err = &lt;<span class="hljs-title class_">AxiosError</span>&gt;error<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 挂载钩子</span><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">getDog</span>()<br>  &#125;)<br><br>  <span class="hljs-comment">//向外部暴露数据</span><br>  <span class="hljs-keyword">return</span> &#123;dogList,getDog&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>组件中具体使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;点我+1&lt;/button&gt;<br>  &lt;button @click=&quot;decrement&quot;&gt;点我-1&lt;/button&gt;<br>  &lt;hr&gt;<br>  &lt;img v-for=&quot;(u,index) in dogList.urlList&quot; :key=&quot;index&quot; :src=&quot;(u as string)&quot;&gt; <br>  &lt;span v-show=&quot;dogList.isLoading&quot;&gt;加载中......&lt;/span&gt;&lt;br&gt;<br>  &lt;button @click=&quot;getDog&quot;&gt;再来一只狗&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  import &#123;defineComponent&#125; from &#x27;vue&#x27;<br><br>  export default defineComponent(&#123;<br>    name:&#x27;App&#x27;,<br>  &#125;)<br>&lt;/script&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import useSum from &#x27;./hooks/useSum&#x27;<br>  import useDog from &#x27;./hooks/useDog&#x27;<br><br>  let &#123;sum,increment,decrement&#125; = useSum()<br>  let &#123;dogList,getDog&#125; = useDog()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h1><h2 id="4-1-【对路由的理解】"><a href="#4-1-【对路由的理解】" class="headerlink" title="4.1. 【对路由的理解】"></a>4.1. 【对路由的理解】</h2><img src="/2025/12/17/Vue/Vue3快速上手/image-20231018144351536-1765979249042-14.png" alt="image-20231018144351536" style="zoom:20%;border-radius:40px"> <h2 id="4-2-【基本切换效果】"><a href="#4-2-【基本切换效果】" class="headerlink" title="4.2. 【基本切换效果】"></a>4.2. 【基本切换效果】</h2><ul><li><p><code>Vue3</code>中要使用<code>vue-router</code>的最新版本，目前是<code>4</code>版本。</p></li><li><p>路由配置文件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">News</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/News.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/About.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>&#125;<br>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>main.ts</code>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index&#x27;</span><br>app.<span class="hljs-title function_">use</span>(router)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>App.vue</code>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;app&quot;&gt;<br>    &lt;h2 class=&quot;title&quot;&gt;Vue路由测试&lt;/h2&gt;<br>    &lt;!-- 导航区 --&gt;<br>    &lt;div class=&quot;navigate&quot;&gt;<br>      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;<br>      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt;<br>      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt;<br>    &lt;/div&gt;<br>    &lt;!-- 展示区 --&gt;<br>    &lt;div class=&quot;main-content&quot;&gt;<br>      &lt;RouterView&gt;&lt;/RouterView&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;<br>  import &#123;RouterLink,RouterView&#125; from &#x27;vue-router&#x27;  <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-3-【两个注意点】"><a href="#4-3-【两个注意点】" class="headerlink" title="4.3. 【两个注意点】"></a>4.3. 【两个注意点】</h2><blockquote><ol><li><p>路由组件通常存放在<code>pages</code> 或 <code>views</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p></li><li><p>通过点击导航，视觉效果上“消失” 了的路由组件，默认是被<strong>卸载</strong>掉的，需要的时候再去<strong>挂载</strong>。</p></li></ol></blockquote><h2 id="4-4-【路由器工作模式】"><a href="#4-4-【路由器工作模式】" class="headerlink" title="4.4.【路由器工作模式】"></a>4.4.【路由器工作模式】</h2><ol><li><p><code>history</code>模式</p><blockquote><p>优点：<code>URL</code>更加美观，不带有<code>#</code>，更接近传统的网站<code>URL</code>。</p><p>缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有<code>404</code>错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(), <span class="hljs-comment">//history模式</span><br><span class="hljs-comment">/******/</span><br>&#125;)<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>hash</code>模式</p><blockquote><p>优点：兼容性更好，因为不需要服务器端处理路径。</p><p>缺点：<code>URL</code>带有<code>#</code>不太美观，且在<code>SEO</code>优化方面相对较差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHashHistory</span>(), <span class="hljs-comment">//hash模式</span><br><span class="hljs-comment">/******/</span><br>&#125;)<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="4-5-【to的两种写法】"><a href="#4-5-【to的两种写法】" class="headerlink" title="4.5. 【to的两种写法】"></a>4.5. 【to的两种写法】</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 第一种：to的字符串写法 --&gt;<br>&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;<br><br>&lt;!-- 第二种：to的对象写法 --&gt;<br>&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><h2 id="4-6-【命名路由】"><a href="#4-6-【命名路由】" class="headerlink" title="4.6. 【命名路由】"></a>4.6. 【命名路由】</h2><p>作用：可以简化路由跳转及传参（后面就讲）。</p><p>给路由规则命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>:[<br>  &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zhuye&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xinwen&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/news&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;guanyu&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>跳转路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;<br>&lt;router-link to=&quot;/news/detail&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;<br>&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><h2 id="4-7-【嵌套路由】"><a href="#4-7-【嵌套路由】" class="headerlink" title="4.7. 【嵌套路由】"></a>4.7. 【嵌套路由】</h2><ol><li><p>编写<code>News</code>的子路由：<code>Detail.vue</code></p></li><li><p>配置路由规则，使用<code>children</code>配置项：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zhuye&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xinwen&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/news&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiang&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span><br>&#125;<br>]<br>&#125;,<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;guanyu&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>&#125;<br>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li><li><p>跳转路由（记得要加完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to=&quot;/news/detail&quot;&gt;xxxx&lt;/router-link&gt;<br>&lt;!-- 或 --&gt;<br>&lt;router-link :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;xxxx&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li><li><p>记得去<code>Home</code>组件中预留一个<code>&lt;router-view&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;news&quot;&gt;<br>    &lt;nav class=&quot;news-list&quot;&gt;<br>      &lt;RouterLink v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot; :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;<br>        &#123;&#123;news.name&#125;&#125;<br>      &lt;/RouterLink&gt;<br>    &lt;/nav&gt;<br>    &lt;div class=&quot;news-detail&quot;&gt;<br>      &lt;RouterView/&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-8-【路由传参】"><a href="#4-8-【路由传参】" class="headerlink" title="4.8. 【路由传参】"></a>4.8. 【路由传参】</h2><h3 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;<br>&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;<br>跳转<br>&lt;/router-link&gt;<br><br>&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;<br>&lt;RouterLink <br>  :to=&quot;&#123;<br>    //name:&#x27;xiang&#x27;, //用name也可以跳转<br>    path:&#x27;/news/detail&#x27;,<br>    query:&#123;<br>      id:news.id,<br>      title:news.title,<br>      content:news.content<br>    &#125;<br>  &#125;&quot;<br>&gt;<br>  &#123;&#123;news.title&#125;&#125;<br>&lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useRoute&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-comment">// 打印query参数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">query</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;<br>&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;<br><br>&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;<br>&lt;RouterLink <br>  :to=&quot;&#123;<br>    name:&#x27;xiang&#x27;, //用name跳转<br>    params:&#123;<br>      id:news.id,<br>      title:news.title,<br>      content:news.title<br>    &#125;<br>  &#125;&quot;<br>&gt;<br>  &#123;&#123;news.title&#125;&#125;<br>&lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useRoute&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-comment">// 打印params参数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>)<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>备注1：传递<code>params</code>参数时，若使用<code>to</code>的对象写法，必须使用<code>name</code>配置项，不能用<code>path</code>。</p><p>备注2：传递<code>params</code>参数时，需要提前在规则中占位。</p></blockquote><h2 id="4-9-【路由的props配置】"><a href="#4-9-【路由的props配置】" class="headerlink" title="4.9. 【路由的props配置】"></a>4.9. 【路由的props配置】</h2><p>作用：让路由组件更方便的收到参数（可以将路由参数作为<code>props</code>传给组件）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiang&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id/:title/:content&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><br>  <span class="hljs-comment">// props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件</span><br>  <span class="hljs-comment">// props:&#123;a:1,b:2,c:3&#125;, </span><br><br>  <span class="hljs-comment">// props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件</span><br>  <span class="hljs-comment">// props:true</span><br>  <br>  <span class="hljs-comment">// props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件</span><br><span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br>  <span class="hljs-keyword">return</span> route.<span class="hljs-property">query</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-【-replace属性】"><a href="#4-10-【-replace属性】" class="headerlink" title="4.10. 【 replace属性】"></a>4.10. 【 replace属性】</h2><ol><li><p>作用：控制路由跳转时操作浏览器历史记录的模式。</p></li><li><p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>：</p><ul><li><code>push</code>是追加历史记录（默认值）。</li><li><code>replace</code>是替换当前记录。</li></ul></li><li><p>开启<code>replace</code>模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink replace .......&gt;News&lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-11-【编程式导航】"><a href="#4-11-【编程式导航】" class="headerlink" title="4.11. 【编程式导航】"></a>4.11. 【编程式导航】</h2><p>路由组件的两个重要的属性：<code>$route</code>和<code>$router</code>变成了两个<code>hooks</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useRoute,useRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">query</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">parmas</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(router.<span class="hljs-property">push</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(router.<span class="hljs-property">replace</span>)<br></code></pre></td></tr></table></figure><h2 id="4-12-【重定向】"><a href="#4-12-【重定向】" class="headerlink" title="4.12. 【重定向】"></a>4.12. 【重定向】</h2><ol><li><p>作用：将特定的路径，重新定向到已有路由。</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/about&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="5-pinia"><a href="#5-pinia" class="headerlink" title="5. pinia"></a>5. pinia</h1><h2 id="5-1【准备一个效果】"><a href="#5-1【准备一个效果】" class="headerlink" title="5.1【准备一个效果】"></a>5.1【准备一个效果】</h2><img src="/2025/12/17/Vue/Vue3快速上手/pinia_example-1765979249042-15.gif" alt="pinia_example" style="zoom:30%;border:3px solid"> <h2 id="5-2【搭建-pinia-环境】"><a href="#5-2【搭建-pinia-环境】" class="headerlink" title="5.2【搭建 pinia 环境】"></a>5.2【搭建 pinia 环境】</h2><p>第一步：<code>npm install pinia</code></p><p>第二步：操作<code>src/main.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">/* 引入createPinia，用于创建pinia */</span><br><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">/* 创建pinia */</span><br><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">/* 使用插件 */</span>&#123;&#125;<br>app.<span class="hljs-title function_">use</span>(pinia)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>此时开发者工具中已经有了<code>pinia</code>选项</p><img src="/2025/12/17/Vue/Vue3快速上手/1684309952481-c67f67f9-d1a3-4d69-8bd6-2b381e003f31.png" style="zoom:80%;border:1px solid black;border-radius:10px"><h2 id="5-3【存储-读取数据】"><a href="#5-3【存储-读取数据】" class="headerlink" title="5.3【存储+读取数据】"></a>5.3【存储+读取数据】</h2><ol><li><p><code>Store</code>是一个保存：<strong>状态</strong>、<strong>业务逻辑</strong> 的实体，每个组件都可以<strong>读取</strong>、<strong>写入</strong>它。</p></li><li><p>它有三个概念：<code>state</code>、<code>getter</code>、<code>action</code>，相当于组件中的： <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</p></li><li><p>具体编码：<code>src/store/count.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 引入defineStore用于创建store</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">// 定义并暴露一个store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCountStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;count&#x27;</span>,&#123;<br>  <span class="hljs-comment">// 动作</span><br>  <span class="hljs-attr">actions</span>:&#123;&#125;,<br>  <span class="hljs-comment">// 状态</span><br>  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">sum</span>:<span class="hljs-number">6</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-attr">getters</span>:&#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>具体编码：<code>src/store/talk.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入defineStore用于创建store</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">// 定义并暴露一个store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTalkStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;talk&#x27;</span>,&#123;<br>  <span class="hljs-comment">// 动作</span><br>  <span class="hljs-attr">actions</span>:&#123;&#125;,<br>  <span class="hljs-comment">// 状态</span><br>  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">talkList</span>:[<br>        &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;yuysada01&#x27;</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span>&#125;,<br>     &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;yuysada02&#x27;</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span>&#125;,<br>        &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;yuysada03&#x27;</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span>&#125;<br>      ]<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-attr">getters</span>:&#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中使用<code>state</code>中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;当前求和为：&#123;&#123; sumStore.sum &#125;&#125;&lt;/h2&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;<br>  // 引入对应的useXxxxxStore<br>  import &#123;useSumStore&#125; from &#x27;@/store/sum&#x27;<br>  <br>  // 调用useXxxxxStore得到对应的store<br>  const sumStore = useSumStore()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;ul&gt;<br>    &lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&gt;<br>      &#123;&#123; talk.content &#125;&#125;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;<br>  import axios from &#x27;axios&#x27;<br>  import &#123;useTalkStore&#125; from &#x27;@/store/talk&#x27;<br><br>  const talkStore = useTalkStore()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-4-【修改数据】-三种方式"><a href="#5-4-【修改数据】-三种方式" class="headerlink" title="5.4.【修改数据】(三种方式)"></a>5.4.【修改数据】(三种方式)</h2><ol><li><p>第一种修改方式，直接修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">countStore.<span class="hljs-property">sum</span> = <span class="hljs-number">666</span><br></code></pre></td></tr></table></figure></li><li><p>第二种修改方式：批量修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts">countStore.$patch(&#123;<br>  <span class="hljs-attr">sum</span>:<span class="hljs-number">999</span>,<br>  <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;atguigu&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>第三种修改方式：借助<code>action</code>修改（<code>action</code>中可以编写一些业务逻辑）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCountStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>  <span class="hljs-comment">/*************/</span><br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-comment">//加</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">value:number</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> &lt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-comment">//操作countStore中的sum</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> += value<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">//减</span><br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params">value:number</span>)&#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> -= value<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">/*************/</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中调用<code>action</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用countStore</span><br><span class="hljs-keyword">const</span> countStore = <span class="hljs-title function_">useCountStore</span>()<br><br><span class="hljs-comment">// 调用对应action</span><br>countStore.<span class="hljs-title function_">incrementOdd</span>(n.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-5-【storeToRefs】"><a href="#5-5-【storeToRefs】" class="headerlink" title="5.5.【storeToRefs】"></a>5.5.【storeToRefs】</h2><ul><li>借助<code>storeToRefs</code>将<code>store</code>中的数据转为<code>ref</code>对象，方便在模板中使用。</li><li>注意：<code>pinia</code>提供的<code>storeToRefs</code>只会将数据做转换，而<code>Vue</code>的<code>toRefs</code>会转换<code>store</code>中数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;count&quot;&gt;<br>&lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;<br>  import &#123; useCountStore &#125; from &#x27;@/store/count&#x27;<br>  /* 引入storeToRefs */<br>  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;<br><br>/* 得到countStore */<br>  const countStore = useCountStore()<br>  /* 使用storeToRefs转换countStore，随后解构 */<br>  const &#123;sum&#125; = storeToRefs(countStore)<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h2 id="5-6-【getters】"><a href="#5-6-【getters】" class="headerlink" title="5.6.【getters】"></a>5.6.【getters】</h2><ol><li><p>概念：当<code>state</code>中的数据，需要经过处理后再使用时，可以使用<code>getters</code>配置。</p></li><li><p>追加<code>getters</code>配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入defineStore用于创建store</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">// 定义并暴露一个store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCountStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;count&#x27;</span>,&#123;<br>  <span class="hljs-comment">// 动作</span><br>  <span class="hljs-attr">actions</span>:&#123;<br>    <span class="hljs-comment">/************/</span><br>  &#125;,<br>  <span class="hljs-comment">// 状态</span><br>  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">sum</span>:<span class="hljs-number">1</span>,<br>      <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;atguigu&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-attr">getters</span>:&#123;<br>    <span class="hljs-attr">bigSum</span>:(state):<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> state.<span class="hljs-property">sum</span> *<span class="hljs-number">10</span>,<br>    <span class="hljs-title function_">upperSchool</span>():string&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>. school.<span class="hljs-title function_">toUpperCase</span>()<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中读取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;increment,decrement&#125; = countStore<br><span class="hljs-keyword">let</span> &#123;sum,school,bigSum,upperSchool&#125; = <span class="hljs-title function_">storeToRefs</span>(countStore)<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-7-【-subscribe】"><a href="#5-7-【-subscribe】" class="headerlink" title="5.7.【$subscribe】"></a>5.7.【$subscribe】</h2><p>通过 store 的 <code>$subscribe()</code> 方法侦听 <code>state</code> 及其变化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts">talkStore.$subscribe(<span class="hljs-function">(<span class="hljs-params">mutate,state</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LoveTalk&#x27;</span>,mutate,state)<br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;talk&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(talkList.<span class="hljs-property">value</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="5-8-【store组合式写法】"><a href="#5-8-【store组合式写法】" class="headerlink" title="5.8. 【store组合式写法】"></a>5.8. 【store组合式写法】</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> &#123;nanoid&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nanoid&#x27;</span><br><span class="hljs-keyword">import</span> &#123;reactive&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTalkStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;talk&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// talkList就是state</span><br>  <span class="hljs-keyword">const</span> talkList = <span class="hljs-title function_">reactive</span>(<br>    <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;talkList&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>) || []<br>  )<br><br>  <span class="hljs-comment">// getATalk函数相当于action</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getATalk</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 发请求，下面这行的写法是：连续解构赋值+重命名</span><br>    <span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">data</span>:&#123;<span class="hljs-attr">content</span>:title&#125;&#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;</span>)<br>    <span class="hljs-comment">// 把请求回来的字符串，包装成一个对象</span><br>    <span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">id</span>:<span class="hljs-title function_">nanoid</span>(),title&#125;<br>    <span class="hljs-comment">// 放到数组中</span><br>    talkList.<span class="hljs-title function_">unshift</span>(obj)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;talkList,getATalk&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="6-组件通信"><a href="#6-组件通信" class="headerlink" title="6. 组件通信"></a>6. 组件通信</h1><p><strong><code>Vue3</code>组件通信和<code>Vue2</code>的区别：</strong></p><ul><li>移出事件总线，使用<code>mitt</code>代替。</li></ul><ul><li><code>vuex</code>换成了<code>pinia</code>。</li><li>把<code>.sync</code>优化到了<code>v-model</code>里面了。</li><li>把<code>$listeners</code>所有的东西，合并到<code>$attrs</code>中了。</li><li><code>$children</code>被砍掉了。</li></ul><p><strong>常见搭配形式：</strong></p><img src="/2025/12/17/Vue/Vue3快速上手/image-20231119185900990-1765979249042-16.png" alt="image-20231119185900990" style="zoom:60%;"> <h2 id="6-1-【props】"><a href="#6-1-【props】" class="headerlink" title="6.1. 【props】"></a>6.1. 【props】</h2><p>概述：<code>props</code>是使用频率最高的一种通信方式，常用与 ：<strong>父 ↔ 子</strong>。</p><ul><li>若 <strong>父传子</strong>：属性值是<strong>非函数</strong>。</li><li>若 <strong>子传父</strong>：属性值是<strong>函数</strong>。</li></ul><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    &lt;h3&gt;父组件，&lt;/h3&gt;<br>&lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;<br>&lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot;/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;<br>import Child from &#x27;./Child.vue&#x27;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>// 数据<br>const car = ref(&#x27;奔驰&#x27;)<br>const toy = ref()<br>// 方法<br>function getToy(value:string)&#123;<br>toy.value = value<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child&quot;&gt;<br>    &lt;h3&gt;子组件&lt;/h3&gt;<br>&lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>&lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>const toy = ref(&#x27;奥特曼&#x27;)<br><br>defineProps([&#x27;car&#x27;,&#x27;getToy&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="6-2-【自定义事件】"><a href="#6-2-【自定义事件】" class="headerlink" title="6.2. 【自定义事件】"></a>6.2. 【自定义事件】</h2><ol><li>概述：自定义事件常用于：<strong>子 &#x3D;&gt; 父。</strong></li><li>注意区分好：原生事件、自定义事件。</li></ol><ul><li>原生事件：<ul><li>事件名是特定的（<code>click</code>、<code>mosueenter</code>等等）</li><li>事件对象<code>$event</code>: 是包含事件相关信息的对象（<code>pageX</code>、<code>pageY</code>、<code>target</code>、<code>keyCode</code>）</li></ul></li><li>自定义事件：<ul><li>事件名是任意名称</li><li><strong style="color:red">事件对象<code>$event</code>: 是调用<code>emit</code>时所提供的数据，可以是任意类型！！！</strong></li></ul></li></ul><ol start="3"><li><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> @<span class="hljs-attr">send-toy</span>=<span class="hljs-string">&quot;toy = $event&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toy = $event&quot;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子组件中，触发事件：</span><br><span class="hljs-keyword">let</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;send-toy&#x27;</span>])<br><span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>, value)<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-3-【mitt】"><a href="#6-3-【mitt】" class="headerlink" title="6.3. 【mitt】"></a>6.3. 【mitt】</h2><p>概述：与消息订阅与发布（<code>pubsub</code>）功能类似，可以实现任意组件间通信。</p><p>安装<code>mitt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i mitt<br></code></pre></td></tr></table></figure><p>新建文件：<code>src\utils\emitter.ts</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入mitt </span><br><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mitt&quot;</span>;<br><br><span class="hljs-comment">// 创建emitter</span><br><span class="hljs-keyword">const</span> emitter = <span class="hljs-title function_">mitt</span>()<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  // 绑定事件</span><br><span class="hljs-comment">  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;</span><br><span class="hljs-comment">    console.log(&#x27;abc事件被触发&#x27;,value)</span><br><span class="hljs-comment">  &#125;)</span><br><span class="hljs-comment">  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;</span><br><span class="hljs-comment">    console.log(&#x27;xyz事件被触发&#x27;,value)</span><br><span class="hljs-comment">  &#125;)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  setInterval(() =&gt; &#123;</span><br><span class="hljs-comment">    // 触发事件</span><br><span class="hljs-comment">    emitter.emit(&#x27;abc&#x27;,666)</span><br><span class="hljs-comment">    emitter.emit(&#x27;xyz&#x27;,777)</span><br><span class="hljs-comment">  &#125;, 1000);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  setTimeout(() =&gt; &#123;</span><br><span class="hljs-comment">    // 清理事件</span><br><span class="hljs-comment">    emitter.all.clear()</span><br><span class="hljs-comment">  &#125;, 3000); </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 创建并暴露mitt</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> emitter<br></code></pre></td></tr></table></figure><p>接收数据的组件中：绑定事件、同时在销毁前解绑事件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/emitter&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-comment">// 绑定事件</span><br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;send-toy事件被触发&#x27;</span>,value)<br>&#125;)<br><br><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// 解绑事件</span><br>  emitter.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>【第三步】：提供数据的组件，在合适的时候触发事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/emitter&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendToy</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 触发事件</span><br>  emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>,toy.<span class="hljs-property">value</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意这个重要的内置关系，总线依赖着这个内置关系</strong></p><h2 id="6-4-【v-model】"><a href="#6-4-【v-model】" class="headerlink" title="6.4.【v-model】"></a>6.4.【v-model】</h2><ol><li><p>概述：实现 <strong>父↔子</strong> 之间相互通信。</p></li><li><p>前序知识 —— <code>v-model</code>的本质</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 使用v-model指令 --&gt;<br>&lt;input type=&quot;text&quot; v-model=&quot;userName&quot;&gt;<br><br>&lt;!-- v-model的本质是下面这行代码 --&gt;<br>&lt;input <br>  type=&quot;text&quot; <br>  :value=&quot;userName&quot; <br>  @input=&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;<br>&gt;<br></code></pre></td></tr></table></figure></li><li><p>组件标签上的<code>v-model</code>的本质：<code>:moldeValue</code> ＋ <code>update:modelValue</code>事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 组件标签上使用v-model指令 --&gt;<br>&lt;AtguiguInput v-model=&quot;userName&quot;/&gt;<br><br>&lt;!-- 组件标签上v-model的本质 --&gt;<br>&lt;AtguiguInput :modelValue=&quot;userName&quot; @update:model-value=&quot;userName = $event&quot;/&gt;<br></code></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;box&quot;&gt;<br>    &lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;<br>&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;<br>    &lt;input <br>       type=&quot;text&quot; <br>       :value=&quot;modelValue&quot; <br>       @input=&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;<br>    &gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;<br>  // 接收props<br>  defineProps([&#x27;modelValue&#x27;])<br>  // 声明事件<br>  const emit = defineEmits([&#x27;update:model-value&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>也可以更换<code>value</code>，例如改成<code>abc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 也可以更换value，例如改成abc--&gt;<br>&lt;AtguiguInput v-model:abc=&quot;userName&quot;/&gt;<br><br>&lt;!-- 上面代码的本质如下 --&gt;<br>&lt;AtguiguInput :abc=&quot;userName&quot; @update:abc=&quot;userName = $event&quot;/&gt;<br></code></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;box&quot;&gt;<br>    &lt;input <br>       type=&quot;text&quot; <br>       :value=&quot;abc&quot; <br>       @input=&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;<br>    &gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;<br>  // 接收props<br>  defineProps([&#x27;abc&#x27;])<br>  // 声明事件<br>  const emit = defineEmits([&#x27;update:abc&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>如果<code>value</code>可以更换，那么就可以在组件标签上多次使用<code>v-model</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;AtguiguInput v-model:abc=&quot;userName&quot; v-model:xyz=&quot;password&quot;/&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-5-【-attrs-】"><a href="#6-5-【-attrs-】" class="headerlink" title="6.5.【$attrs 】"></a>6.5.【$attrs 】</h2><ol><li><p>概述：<code>$attrs</code>用于实现<strong>当前组件的父组件</strong>，向<strong>当前组件的子组件</strong>通信（<strong>祖→孙</strong>）。</p></li><li><p>具体说明：<code>$attrs</code>是一个对象，包含所有父组件传入的标签属性。</p><blockquote><p> 注意：<code>$attrs</code>会自动排除<code>props</code>中声明的属性(可以认为声明过的 <code>props</code> 被子组件自己“消费”了)</p></blockquote></li></ol><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    &lt;h3&gt;父组件&lt;/h3&gt;<br>&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot; :updateA=&quot;updateA&quot;/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;<br>import Child from &#x27;./Child.vue&#x27;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>let a = ref(1)<br>let b = ref(2)<br>let c = ref(3)<br>let d = ref(4)<br><br>function updateA(value)&#123;<br>a.value = value<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;child&quot;&gt;<br>&lt;h3&gt;子组件&lt;/h3&gt;<br>&lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;<br>import GrandChild from &#x27;./GrandChild.vue&#x27;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>孙组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;grand-child&quot;&gt;<br>&lt;h3&gt;孙组件&lt;/h3&gt;<br>&lt;h4&gt;a：&#123;&#123; a &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;b：&#123;&#123; b &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;c：&#123;&#123; c &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;d：&#123;&#123; d &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;x：&#123;&#123; x &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;y：&#123;&#123; y &#125;&#125;&lt;/h4&gt;<br>&lt;button @click=&quot;updateA(666)&quot;&gt;点我更新A&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;<br>defineProps([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;updateA&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="6-6-【-refs、-parent】"><a href="#6-6-【-refs、-parent】" class="headerlink" title="6.6. 【$refs、$parent】"></a>6.6. 【$refs、$parent】</h2><ol><li><p>概述：</p><ul><li><code>$refs</code>用于 ：<strong>父→子。</strong></li><li><code>$parent</code>用于：<strong>子→父。</strong></li></ul></li><li><p>原理如下：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>$refs</code></td><td>值为对象，包含所有被<code>ref</code>属性标识的<code>DOM</code>元素或组件实例。</td></tr><tr><td><code>$parent</code></td><td>值为对象，当前组件的父组件实例对象。</td></tr></tbody></table></li></ol><p>比如:在父组件挂载完毕获取组件实例</p><p>父组件内部代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h1&gt;ref与$parent&lt;/h1&gt;<br>    &lt;Son ref=&quot;son&quot;&gt;&lt;/Son&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import Son from &quot;./Son.vue&quot;;<br>import &#123; onMounted, ref &#125; from &quot;vue&quot;;<br>const son = ref();<br>onMounted(() =&gt; &#123;<br>  console.log(son.value);<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>但是需要注意，如果想让父组件获取子组件的数据或者方法需要通过defineExpose对外暴露,因为vue3中组件内部的数据对外“关闭的”，外部不能访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>//数据<br>let money = ref(1000);<br>//方法<br>const handler = ()=&gt;&#123;<br>&#125;<br>defineExpose(&#123;<br>  money,<br>   handler<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>$parent可以获取某一个组件的父组件实例VC,因此可以使用父组件内部的数据与方法。必须子组件内部拥有一个按钮点击时候获取父组件实例，当然父组件的数据与方法需要通过defineExpose方法对外暴露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;handler($parent)&quot;&gt;点击我获取父组件实例&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="6-7-【provide、inject】"><a href="#6-7-【provide、inject】" class="headerlink" title="6.7. 【provide、inject】"></a>6.7. 【provide、inject】</h2><ol><li><p>概述：实现<strong>祖孙组件</strong>直接通信</p></li><li><p>具体使用：</p><ul><li>在祖先组件中通过<code>provide</code>配置向后代组件提供数据</li><li>在后代组件中通过<code>inject</code>配置来声明接收数据</li></ul></li><li><p>具体编码：</p><p>【第一步】父组件中，使用<code>provide</code>提供数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    &lt;h3&gt;父组件&lt;/h3&gt;<br>    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;<br>    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt;<br>    &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt;<br>    &lt;Child/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;<br>  import Child from &#x27;./Child.vue&#x27;<br>  import &#123; ref,reactive,provide &#125; from &quot;vue&quot;;<br>  // 数据<br>  let money = ref(100)<br>  let car = reactive(&#123;<br>    brand:&#x27;奔驰&#x27;,<br>    price:100<br>  &#125;)<br>  // 用于更新money的方法<br>  function updateMoney(value:number)&#123;<br>    money.value += value<br>  &#125;<br>  // 提供数据<br>  provide(&#x27;moneyContext&#x27;,&#123;money,updateMoney&#125;)<br>  provide(&#x27;car&#x27;,car)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注意：子组件中不用编写任何东西，是不受到任何打扰的</p></blockquote><p>【第二步】孙组件中使用<code>inject</code>配置项接受数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;grand-child&quot;&gt;<br>    &lt;h3&gt;我是孙组件&lt;/h3&gt;<br>    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;<br>    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;<br>  import &#123; inject &#125; from &#x27;vue&#x27;;<br>  // 注入数据<br> let &#123;money,updateMoney&#125; = inject(&#x27;moneyContext&#x27;,&#123;money:0,updateMoney:(x:number)=&gt;&#123;&#125;&#125;)<br>  let car = inject(&#x27;car&#x27;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-8-【pinia】"><a href="#6-8-【pinia】" class="headerlink" title="6.8. 【pinia】"></a>6.8. 【pinia】</h2><p>参考之前<code>pinia</code>部分的讲解</p><h2 id="6-9-【slot】"><a href="#6-9-【slot】" class="headerlink" title="6.9. 【slot】"></a>6.9. 【slot】</h2><h3 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="1. 默认插槽"></a>1. 默认插槽</h3><img src="/2025/12/17/Vue/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/default_slot.png" class title="img"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category title=&quot;今日热门游戏&quot;&gt;<br>          &lt;ul&gt;<br>            &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>          &lt;/ul&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>          &lt;div class=&quot;item&quot;&gt;<br>            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;<br>            &lt;!-- 默认插槽 --&gt;<br>            &lt;slot&gt;&lt;/slot&gt;<br>          &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category title=&quot;今日热门游戏&quot;&gt;<br>          &lt;template v-slot:s1&gt;<br>            &lt;ul&gt;<br>              &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>            &lt;/ul&gt;<br>          &lt;/template&gt;<br>          &lt;template #s2&gt;<br>            &lt;a href=&quot;&quot;&gt;更多&lt;/a&gt;<br>          &lt;/template&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>          &lt;div class=&quot;item&quot;&gt;<br>            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;<br>            &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;<br>            &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;<br>          &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h3><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（新闻数据在<code>News</code>组件中，但使用数据所遍历出来的结构由<code>App</code>组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>      &lt;Game v-slot=&quot;params&quot;&gt;<br>      &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt;<br>      &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;<br>        &lt;ul&gt;<br>          &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>        &lt;/ul&gt;<br>      &lt;/Game&gt;<br><br>子组件中：<br>      &lt;template&gt;<br>        &lt;div class=&quot;category&quot;&gt;<br>          &lt;h2&gt;今日游戏榜单&lt;/h2&gt;<br>          &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot;&gt;&lt;/slot&gt;<br>        &lt;/div&gt;<br>      &lt;/template&gt;<br><br>      &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt;<br>        import &#123;reactive&#125; from &#x27;vue&#x27;<br>        let games = reactive([<br>          &#123;id:&#x27;asgdytsa01&#x27;,name:&#x27;英雄联盟&#x27;&#125;,<br>          &#123;id:&#x27;asgdytsa02&#x27;,name:&#x27;王者荣耀&#x27;&#125;,<br>          &#123;id:&#x27;asgdytsa03&#x27;,name:&#x27;红色警戒&#x27;&#125;,<br>          &#123;id:&#x27;asgdytsa04&#x27;,name:&#x27;斗罗大陆&#x27;&#125;<br>        ])<br>      &lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h1 id="7-其它-API"><a href="#7-其它-API" class="headerlink" title="7. 其它 API"></a>7. 其它 API</h1><h2 id="7-1-【shallowRef-与-shallowReactive-】"><a href="#7-1-【shallowRef-与-shallowReactive-】" class="headerlink" title="7.1.【shallowRef 与 shallowReactive 】"></a>7.1.【shallowRef 与 shallowReactive 】</h2><h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a><code>shallowRef</code></h3><ol><li><p>作用：创建一个响应式数据，但只对顶层属性进行响应式处理。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myVar = <span class="hljs-title function_">shallowRef</span>(initialValue);<br></code></pre></td></tr></table></figure></li><li><p>特点：只跟踪引用值的变化，不关心值内部的属性变化。</p></li></ol><h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a><code>shallowReactive</code></h3><ol><li><p>作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myObj = <span class="hljs-title function_">shallowReactive</span>(&#123; ... &#125;);<br></code></pre></td></tr></table></figure></li><li><p>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>通过使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowref"><code>shallowRef()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 来绕开深度响应。浅层式 <code>API</code> 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。</p></blockquote><h2 id="7-2-【readonly-与-shallowReadonly】"><a href="#7-2-【readonly-与-shallowReadonly】" class="headerlink" title="7.2.【readonly 与 shallowReadonly】"></a>7.2.【readonly 与 shallowReadonly】</h2><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><strong><code>readonly</code></strong></h3><ol><li><p>作用：用于创建一个对象的深只读副本。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> original = <span class="hljs-title function_">reactive</span>(&#123; ... &#125;);<br><span class="hljs-keyword">const</span> readOnlyCopy = <span class="hljs-title function_">readonly</span>(original);<br></code></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li>对象的所有嵌套属性都将变为只读。</li><li>任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。</li></ul></li><li><p>应用场景：</p><ul><li>创建不可变的状态快照。</li><li>保护全局状态或配置不被修改。</li></ul></li></ol><h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a><strong><code>shallowReadonly</code></strong></h3><ol><li><p>作用：与 <code>readonly</code> 类似，但只作用于对象的顶层属性。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> original = <span class="hljs-title function_">reactive</span>(&#123; ... &#125;);<br><span class="hljs-keyword">const</span> shallowReadOnlyCopy = <span class="hljs-title function_">shallowReadonly</span>(original);<br></code></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li><p>只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。</p></li><li><p>适用于只需保护对象顶层属性的场景。</p></li></ul></li></ol><h2 id="7-3-【toRaw-与-markRaw】"><a href="#7-3-【toRaw-与-markRaw】" class="headerlink" title="7.3.【toRaw 与 markRaw】"></a>7.3.【toRaw 与 markRaw】</h2><h3 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a><code>toRaw</code></h3><ol><li><p>作用：用于获取一个响应式对象的原始对象， <code>toRaw</code> 返回的对象不再是响应式的，不会触发视图更新。</p><blockquote><p>官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。</p></blockquote><blockquote><p>何时使用？ —— 在需要将响应式对象传递给非 <code>Vue</code> 的库或外部系统时，使用 <code>toRaw</code> 可以确保它们收到的是普通对象</p></blockquote></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive,toRaw,markRaw,isReactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-comment">/* toRaw */</span><br><span class="hljs-comment">// 响应式对象</span><br><span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tony&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;)<br><span class="hljs-comment">// 原始对象</span><br><span class="hljs-keyword">let</span> rawPerson = <span class="hljs-title function_">toRaw</span>(person)<br><br><br><span class="hljs-comment">/* markRaw */</span><br><span class="hljs-keyword">let</span> citysd = <span class="hljs-title function_">markRaw</span>([<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda01&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;北京&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda02&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;上海&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda03&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;天津&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda04&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;重庆&#x27;</span>&#125;<br>])<br><span class="hljs-comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span><br><span class="hljs-keyword">let</span> citys2 = <span class="hljs-title function_">reactive</span>(citys)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(person))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(rawPerson))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(citys))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(citys2))<br></code></pre></td></tr></table></figure></li></ol><h3 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a><code>markRaw</code></h3><ol><li><p>作用：标记一个对象，使其<strong>永远不会</strong>变成响应式的。</p><blockquote><p>例如使用<code>mockjs</code>时，为了防止误把<code>mockjs</code>变为响应式对象，可以使用 <code>markRaw</code> 去标记<code>mockjs</code></p></blockquote></li><li><p>编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* markRaw */</span><br><span class="hljs-keyword">let</span> citys = <span class="hljs-title function_">markRaw</span>([<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda01&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;北京&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda02&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;上海&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda03&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;天津&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda04&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;重庆&#x27;</span>&#125;<br>])<br><span class="hljs-comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span><br><span class="hljs-keyword">let</span> citys2 = <span class="hljs-title function_">reactive</span>(citys)<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-4-【customRef】"><a href="#7-4-【customRef】" class="headerlink" title="7.4.【customRef】"></a>7.4.【customRef】</h2><p>作用：创建一个自定义的<code>ref</code>，并对其依赖项跟踪和更新触发进行逻辑控制。</p><p>实现防抖效果（<code>useSumRef.ts</code>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;customRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">initValue</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">delay</span>:<span class="hljs-built_in">number</span></span>)&#123;<br>  <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track,trigger</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">timer</span>:<span class="hljs-built_in">number</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">track</span>() <span class="hljs-comment">// 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新</span><br>        <span class="hljs-keyword">return</span> initValue<br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          initValue = value<br>          <span class="hljs-title function_">trigger</span>() <span class="hljs-comment">//通知Vue数据msg变化了</span><br>        &#125;, delay);<br>      &#125;<br>    &#125;<br>  &#125;) <br>  <span class="hljs-keyword">return</span> &#123;msg&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组件中使用：</p><h1 id="8-Vue3新组件"><a href="#8-Vue3新组件" class="headerlink" title="8. Vue3新组件"></a>8. Vue3新组件</h1><h2 id="8-1-【Teleport】"><a href="#8-1-【Teleport】" class="headerlink" title="8.1. 【Teleport】"></a>8.1. 【Teleport】</h2><ul><li>什么是Teleport？—— Teleport 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;body&#x27;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是一个弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是弹窗中的一些内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-2-【Suspense】"><a href="#8-2-【Suspense】" class="headerlink" title="8.2. 【Suspense】"></a>8.2. 【Suspense】</h2><ul><li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验 </li><li>使用步骤： <ul><li>异步引入组件</li><li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li></ul></li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent,<span class="hljs-title class_">Suspense</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;app&quot;&gt;<br>        &lt;h3&gt;我是App组件&lt;/h3&gt;<br>        &lt;Suspense&gt;<br>          &lt;template v-slot:default&gt;<br>            &lt;Child/&gt;<br>          &lt;/template&gt;<br>          &lt;template v-slot:fallback&gt;<br>            &lt;h3&gt;加载中.......&lt;/h3&gt;<br>          &lt;/template&gt;<br>        &lt;/Suspense&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="8-3-【全局API转移到应用对象】"><a href="#8-3-【全局API转移到应用对象】" class="headerlink" title="8.3.【全局API转移到应用对象】"></a>8.3.【全局API转移到应用对象】</h2><ul><li><code>app.component</code></li><li><code>app.config</code></li><li><code>app.directive</code></li><li><code>app.mount</code></li><li><code>app.unmount</code></li><li><code>app.use</code></li></ul><h2 id="8-4-【其他】"><a href="#8-4-【其他】" class="headerlink" title="8.4.【其他】"></a>8.4.【其他】</h2><ul><li><p>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</p></li><li><p><code>keyCode</code> 作为 <code>v-on</code> 修饰符的支持。</p></li><li><p><code>v-model</code> 指令在组件上的使用已经被重新设计，替换掉了 <code>v-bind.sync。</code></p></li><li><p><code>v-if</code> 和 <code>v-for</code> 在同一个元素身上使用时的优先级发生了变化。</p></li><li><p>移除了<code>$on</code>、<code>$off</code> 和 <code>$once</code> 实例方法。</p></li><li><p>移除了过滤器 <code>filter</code>。</p></li><li><p>移除了<code>$children</code> 实例 <code>propert</code>。</p><p>……</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Promise与JS异步</title>
    <link href="/2025/12/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/4-Promise%E4%B8%8EJS%E5%BC%82%E6%AD%A5/"/>
    <url>/2025/12/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/4-Promise%E4%B8%8EJS%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<ol><li>为什么要引入Promise？</li><li>如何理解Promise？</li><li>什么是微任务与宏任务？</li><li>async 和 await 的原理和作用是什么？</li></ol><span id="more"></span><h2 id="Promise-与-JS异步-微任务与宏任务-async-与-await"><a href="#Promise-与-JS异步-微任务与宏任务-async-与-await" class="headerlink" title="Promise 与 JS异步 &#x2F; 微任务与宏任务 &#x2F; async 与 await"></a>Promise 与 JS异步 &#x2F; 微任务与宏任务 &#x2F; async 与 await</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#Promise%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93">NodeJS核心总结 - 相</a></p><p><a href="https://lilichao.com/?p=6460">异步编程 – 李立超 | lilichao.com</a></p><p><a href="https://www.bilibili.com/video/BV1qN4y1A7jM?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=3">03_Promise介绍_哔哩哔哩_bilibili</a></p></blockquote><p>推荐B站李立超老师的教学视频和笔记，重点突出且内容精简，已针对老师视频和资料做了详细的总结。</p><hr><p><font color="#409eff">面试模板：</font></p><p><strong>Promise 是 ES6 引入的一个构造函数，用来解决传统异步编程中回调地狱、回调嵌套等问题。</strong>它本质上是一个对象，用来<strong>存储异步操作的结果</strong>，并提供链式调用和统一的错误处理能力。在传统回调方式中，如果多个异步操作相互依赖，我们需要层层嵌套回调，代码结构混乱，可读性差，异常处理也分散，不易维护。而 Promise 的出现就是为了解决这些问题。</p><p>存储数据时，在Promise中维护着两个隐藏的值PromiseResult和PromiseState，PromiseResult是Promise中真正存储值的地方，在Promise中无论是通过resolve、reject还是报错时的异常信息都会存储到PromiseResult中。PromiseState用来表示Promise中值的状态，Promise一共有三种状态：pending、fulfilled、rejected。pending是Promise的初始化状态，此时Promise中没有任何值。fulfilled是Promise的完成状态，此时表示值已经正常存储到了Promise中（通过resolve）。rejected表示拒绝，此时表示值是通过reject存储的或是执行时出现了错误。<font color="#409eff">异步任务完成后，通过调用 <code>resolve</code> 或 <code>reject</code> 将结果“写入” Promise 对象，而不是通过回调函数“传出”。</font></p><p>调用数据时，使用 <code>.then()</code> 可以注册回调函数，用于处理 <code>resolve</code> 或 <code>reject</code> 的结果。每次调用 <code>.then()</code> 都会返回一个<strong>新的 Promise</strong>，并把上一个回调的返回结果继续向下传递，实现<strong>链式调用</strong>，避免了回调嵌套。<code>.catch()</code> 方法用于统一捕获 Promise 中的异常，不再需要在每一步都处理错误。当我们调用Promise的then方法时，相当于为Promise设置了一个回调函数，换句话说，<font color="#409eff">then中的回调函数不会立即执行，而是在Promise的PromiseState发生变化时才会执行</font>。如果PromiseState从pending变成了fulfilled则then的第一个回调函数执行，且PromiseResult的值作为参数传递给回调函数。如果PromiseState从pending变成了rejected则then的第二个回调函数执行，且PromiseResult的值作为参数传递给回调函数。</p><p>最终解决问题：</p><ul><li><strong>回调地狱</strong> → 通过链式调用让逻辑扁平化</li><li><strong>错误分散</strong> → 通过 <code>.catch()</code> 实现集中错误处理</li><li><strong>结果不可直接返回</strong> → 通过 <code>resolve()</code> 封装返回值，延迟处理</li><li><strong>可组合性差</strong> → Promise 提供 <code>Promise.all()</code>、<code>Promise.race()</code> 等组合方法来管理多个异步任务</li></ul><hr><h3 id="1-Promise的引入"><a href="#1-Promise的引入" class="headerlink" title="1.Promise的引入"></a>1.Promise的引入</h3><p><strong>Promise 在 JavaScript 中用于实现异步编程？</strong></p><p>在 JavaScript 中，<strong>异步编程</strong>是为了解决<strong>单线程模型下的耗时操作阻塞主线程</strong>的问题。</p><p>JavaScript 本身是<strong>单线程执行</strong>的，所有代码默认是同步执行的。如果将网络请求、文件读取、定时器等<strong>耗时操作</strong>都以同步方式执行，会直接阻塞主线程，导致页面卡顿甚至失去响应。</p><p>与JAVA等语言通过多线程的方式不同，为了解决这个问题，JavaScript 采用了<strong>异步机制</strong>：</p><ul><li>将耗时任务<strong>交给宿主环境（如浏览器或 Node.js）中的异步 API 执行</strong></li><li>当异步操作完成后，宿主环境会把对应的回调任务<strong>以事件的形式放入任务队列</strong></li><li>JavaScript 主线程通过事件循环机制，在合适的时机取出这些任务并执行回调函数</li></ul><p>这就是 JavaScript 异步执行的基本原理，例如：<code>setTimeout</code> 的异步任务由<strong>宿主环境执行</strong>，计时完成后，宿主环境将<strong>回调函数作为一个宏任务放入任务队列</strong>；当 JS 主线程空闲时，事件循环机制会将该回调函数取出并压入调用栈执行。</p><p><strong>最早的异步方案：回调函数</strong></p><p>JavaScript 最早通过<strong>回调函数（callback）</strong>来处理异步操作：在发起异步任务时传入一个回调函数，等任务完成后再调用该回调处理结果。</p><p>但回调方式存在明显缺陷：</p><ol><li>多层异步嵌套会形成“<strong>回调地狱</strong>”，代码结构混乱、可读性差</li><li>错误处理分散在各个回调中，难以统一管理</li><li>异步流程不直观，不利于维护和扩展</li></ol><p><strong>Promise 的作用</strong></p><p>为了解决回调函数的问题，ES6 引入了 <strong>Promise</strong>。</p><p><strong>Promise 本质上是一个用于描述“异步操作最终结果”的对象</strong>，它有三种状态：</p><ul><li><code>pending</code>（进行中）</li><li><code>fulfilled</code>（已成功）</li><li><code>rejected</code>（已失败）</li></ul><p>Promise 的核心价值在于：</p><ol><li><strong>支持链式调用</strong>（<code>then</code> &#x2F; <code>catch</code>），避免回调地狱</li><li><strong>统一错误处理</strong>，异常可以沿链向下传递</li><li><strong>使异步流程更清晰</strong>，逻辑结构更接近同步代码</li><li>为 <code>async / await</code> 提供了基础能力</li></ol><p><strong>总结一句话</strong></p><p>JavaScript 的异步编程是通过将耗时任务交给宿主环境执行、再通过事件机制回到主线程完成的；Promise 通过<font color="#409eff">状态管理</font>和<font color="#409eff">链式调用</font>，解决了回调函数在可读性、错误处理和维护性上的问题，是现代 JavaScript 异步编程的核心基础。</p><h3 id="2-Promise介绍"><a href="#2-Promise介绍" class="headerlink" title="2.Promise介绍"></a>2.Promise介绍</h3><h4 id="【状态管理】"><a href="#【状态管理】" class="headerlink" title="【状态管理】"></a>【状态管理】</h4><p>首先要明确一点：<strong>Promise 本质上也是一个对象</strong>，它的作用是用来“保存数据”。<br> 那它和普通对象（比如 <code>&#123;&#125;</code>、<code>Map</code>）有什么本质区别？</p><p>区别不在于“能不能存数据”，而在于——<strong>Promise 专门用来存储「异步任务的结果」</strong>。</p><p><strong>异步任务有一个天然的问题：结果不是立即产生的，而是在未来某个时间点才会出现。</strong>因此，异步任务在设计上必须依赖<strong>回调函数</strong>来“通知结果已经产生”。</p><p>这样的回调函数再Promise中有两个，<code>resolve</code>表示任务成功时的回调，<code>reject</code> 表示失败时的回调，最原始的异步模型大致是这样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AsynchronousFunction</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-title class_">AsynchronousFunction</span>(<span class="hljs-function">(<span class="hljs-params">args</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">args</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里的 <code>AsynchronousFunction</code> 并不是返回结果，而是<strong>在未来的某个时间点主动调用回调函数</strong>。</p><p>在 Promise 中，<code>resolve</code> 和 <code>reject</code> <strong>不再负责“打印结果”或“立刻处理结果”</strong>，<br> 而是负责——<strong>把结果保存到 Promise 对象内部</strong>。</p><p>因此，异步函数不再是我们自己调用的函数，而是作为 <strong>Promise 构造函数的参数</strong>：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这段代码里有两个非常重要的点：</p><ol><li><code>new Promise(...)</code> 会<strong>立刻执行</strong>传入的函数</li><li>异步任务在这个函数内部执行，结果通过 <code>resolve / reject</code> 存入 Promise</li></ol><p>此时，Promise 对象已经创建完成了，但异步任务还没有结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise) <span class="hljs-comment">// PromiseState = &#x27;pending&#x27;, PromiseResult = &#x27;undefined&#x27;</span><br></code></pre></td></tr></table></figure><p>如果我们立刻读取这个 Promise是读不到结果的。原因是数据还没回来。这个时候我们就需要<font color="#409eff">promise告诉我们任务是否结束</font>，也就是当前的状态，这里就引出了 Promise 的第一个核心能力：<strong>状态管理</strong>。</p><p>Promise 内部维护了两个“隐藏属性”：</p><ul><li><code>PromiseState</code>：表示当前状态</li><li><code>PromiseResult</code>：真正存储数据的位置</li></ul><p>Promise 一共有三种状态：</p><ul><li><code>pending</code>：初始状态，异步任务尚未完成</li><li><code>fulfilled</code>：任务成功完成，数据通过 <code>resolve</code> 存入</li><li><code>rejected</code>：任务失败或抛出异常，数据通过 <code>reject</code> 或错误存入</li></ul><p>状态变化只有一种方向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">pending → fulfilled<br>pending → rejected<br></code></pre></td></tr></table></figure><p><strong>一旦状态发生变化，就不可逆转</strong>。<br> 这也意味着：</p><ul><li><code>resolve</code> 和 <code>reject</code> 只能有一个生效</li><li>且只能执行一次</li></ul><p>当异步任务完成后，Promise 内部会变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise)<br>    <span class="hljs-comment">// PromiseState: &quot;fulfilled&quot;</span><br>    <span class="hljs-comment">// PromiseResult: &quot;哈哈&quot;</span><br>&#125;, <span class="hljs-number">11000</span>)<br></code></pre></td></tr></table></figure><p>问题到这里就变成了：</p><p><em><strong>既然不能同步读取 PromiseResult，那怎么才能在“合适的时机”拿到结果？</strong></em></p><p>答案就是：<code>then</code>。</p><p><code>then</code> 是 Promise 的实例方法，用来<strong>注册“当状态发生变化后要执行的回调函数”</strong>。</p><ul><li>当 Promise 变为 <code>fulfilled</code> 时，执行第一个回调</li><li>当 Promise 变为 <code>rejected</code> 时，执行第二个回调</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>这里的关键不是“then 能拿到数据”，而是<strong>then 会被 Promise 主动调用，而不是我们去“轮询”Promise 的状态。</strong></p><p>这也是 Promise 相比定时器、回调嵌套最大的进步。</p><p>在实际开发中，为了让错误处理更集中，通常会使用 <code>catch</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">promise<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>    &#125;)<br></code></pre></td></tr></table></figure><p><code>catch</code> 本质上只关心 <code>rejected</code> 状态。</p><p>此外，Promise 还提供了 <code>finally</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;无论成功还是失败都会执行&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>finally</code> 不接收结果参数，也不区分状态，它只关心一件事：<strong>这个异步任务“结束了”。</strong></p><h4 id="【链式调用】"><a href="#【链式调用】" class="headerlink" title="【链式调用】"></a>【链式调用】</h4><p>到这里我们已经知道，Promise 的核心作用是：<br> <strong>通过状态管理，在合适的时间点取到异步任务的结果</strong>。</p><p>但仅仅能“取到结果”还不够。真实开发中，异步任务往往不是一步，而是<strong>多个异步步骤顺序执行</strong>，并且要求：</p><ol><li>上一步的结果作为下一步的输入</li><li>错误能够统一处理</li><li>代码不能层层嵌套形成“回调地狱”</li></ol><p>这正是 Promise 的<strong>链式调用</strong>要解决的问题。</p><p>那么，什么是链式调用？</p><p>从语法角度看，链式调用并不神秘，它只依赖一个条件：<strong>一个对象的方法，返回的还是一个对象，并且这个对象也具有相同的方法。</strong></p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">object.<span class="hljs-title function_">method1</span>().<span class="hljs-title function_">method2</span>().<span class="hljs-title function_">method3</span>()<br></code></pre></td></tr></table></figure><p>只要 <code>method1</code> 的返回值仍然是一个拥有 <code>method2</code> 的对象，这个链条就可以一直写下去。</p><p>如果某个方法返回的还是同一个对象实例，那么形式可能变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">object.<span class="hljs-title function_">method1</span>().<span class="hljs-title function_">method1</span>().<span class="hljs-title function_">method1</span>()<br></code></pre></td></tr></table></figure><p>而 Promise 的 <code>then</code>，正是基于这种思想设计的。</p><p>关键结论是：<strong>每一次 <code>then</code> 执行，都会返回一个全新的 Promise 对象。</strong></p><p>这个新的 Promise 会把 <code>then</code> 回调函数的<strong>返回值</strong>作为自己的结果保存起来：</p><ul><li>如果 <code>then</code> 中 <strong>返回普通值</strong><br> → 这个值会被包装成一个“已成功的 Promise”</li><li>如果 <strong>没有显式 return</strong><br> → 新 Promise 的结果为 <code>undefined</code></li><li>如果 <strong>返回的是一个 Promise</strong><br> → 新 Promise 会“等待”这个 Promise 的结果</li></ul><p>先看一个最直观的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> promise2 = promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> promise3 = promise2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这里并没有发生什么“魔法”，只是：</p><ol><li>第一个 Promise 成功</li><li><code>then</code> 被触发</li><li><code>then</code> 返回一个值</li><li>这个值被存入<strong>新的 Promise</strong></li><li>下一个 <code>then</code> 再从这个新 Promise 中取值</li></ol><p>因为 <code>then</code> 返回的一定是 Promise，所以这段代码完全可以写成链式形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br>promise<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span><br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>这样写的本质是：<strong>把“嵌套的回调结构”，改造成“值的顺序传递模型”。</strong></p><p>也正因为每一步都只是“返回一个值或 Promise”，代码结构从“向右不断缩进”，变成了“从上到下线性展开”，这就从根本上解决了<strong>回调地狱</strong>的问题。</p><p>接下来是另一个关键问题：<strong>错误应该怎么处理？</strong></p><p>如果在每一个 <code>then</code> 中都写错误处理代码，不但冗余，而且很难维护。Promise 提供的做法是：**统一在链条末尾使用 <code>catch</code>**。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哎呀出错了，随便返回一个吧&quot;</span>, <span class="hljs-number">8888</span>)<br>    &#125;)<br></code></pre></td></tr></table></figure><p>这段代码里有一个非常重要但常被忽略的规则：<strong>只要前面的 Promise 链条处于“正常 fulfilled 状态”，<code>catch</code> 就不会执行，将参数不变地封装成一个新的 Promise 并返回。</strong></p><p>也就是说：</p><ul><li><code>catch</code> 只会在<strong>某一步返回 rejected 或抛出异常</strong>时触发</li><li>一旦进入 <code>catch</code>，错误就被“接住”了</li><li>如果错误被处理并返回一个值，链条仍然可以继续</li></ul><p>因此可以这样理解：</p><ul><li><code>then</code> 负责<strong>正常流程的结果传递</strong></li><li><code>catch</code> 负责<strong>异常流程的集中处理</strong></li></ul><p>Promise 的链式调用，本质上并不是“连续调用函数”，而是<strong>用 Promise 对象，把“异步执行过程”拆分成一段一段可组合的状态转换。</strong></p><p>到这里，Promise 的三个核心能力已经完整闭合：</p><ol><li>用状态保存异步结果</li><li>用 <code>then</code> 实现顺序依赖</li><li>用 <code>catch</code> 实现统一错误处理</li></ol><h3 id="3-微任务与宏任务"><a href="#3-微任务与宏任务" class="headerlink" title="3.微任务与宏任务"></a>3.微任务与宏任务</h3><p>在 JavaScript 中，代码的执行并不是“写一行、立刻执行一行”，而是基于<strong>事件循环机制（Event Loop）</strong>来完成的。<br> 为了协调同步代码、异步回调以及 UI 渲染，JavaScript 将任务按照执行优先级划分为两类：<strong>宏任务（MacroTask）</strong> 和 <strong>微任务（MicroTask）</strong>。</p><p>ES 规范中定义了一个内部队列，称为 <strong>PromiseJobs</strong>，用于存放由 Promise 产生的回调任务（如 <code>then</code>、<code>catch</code>、<code>finally</code>）。这个队列在实际开发和学习中通常被称为<strong>微任务队列（microtask queue）</strong>。<br> 与之相对，像 <code>setTimeout</code>、<code>setInterval</code> 等 API 所产生的回调，会被放入<strong>宏任务队列（macrotask queue）</strong>。</p><p>当 JavaScript 引擎开始执行代码时，<strong>整个 <code>script</code> 脚本本身会被视为第一个宏任务</strong>，并进入宏任务队列。此时：</p><ul><li>调用栈（Call Stack）为空</li><li>微任务队列为空</li><li>宏任务队列中包含当前脚本任务</li></ul><p><font color="#409eff">事件循环的整体执行流程可以概括为以下几个步骤：</font></p><ol><li>从宏任务队列中取出一个宏任务（最开始就是 <code>script</code>），放入调用栈中执行</li><li>在宏任务执行过程中，如果产生了微任务（例如 Promise 的 <code>then</code> 回调），就将它们加入微任务队列</li><li>当前宏任务执行完成后，调用栈清空，此时<strong>不会立刻执行下一个宏任务</strong></li><li>引擎会立刻检查微任务队列，并按照先进先出的顺序，将所有微任务依次放入调用栈中执行，直到微任务队列被清空</li><li>微任务全部执行完毕后，事件循环才会继续取出下一个宏任务</li><li>重复上述过程，直到所有任务执行完成</li></ol><p>需要特别强调的是：<br> <strong>在一次宏任务执行结束后，微任务队列一定会被“清空执行”，而不是只执行其中一个微任务。</strong></p><p>正是这种调度策略，使得微任务具有比宏任务更高的执行优先级。<br> 因此在实际表现上：</p><ul><li><code>Promise.then / catch / finally</code> 的回调</li><li>总是会比 <code>setTimeout(fn, 0)</code> 更早执行</li></ul><p>这种设计的好处在于：微任务可以在两个宏任务之间，对程序状态进行快速、连续的补充处理，从而保证 Promise 状态变化和链式调用的<strong>一致性与及时性</strong>，同时也提高了程序的整体响应速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-comment">// 2 , 1 </span><br></code></pre></td></tr></table></figure><p>那么现在对于前面提到的一个例子如下，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>整个执行顺序如下：</strong></p><p><strong>宏任务：script（当前整段代码）</strong></p><ul><li>执行 <code>new Promise(...)</code><ul><li>注册定时器（1s 后才可能入宏任务队列）</li></ul></li><li>执行 <code>.then(...)</code><ul><li>把回调登记到 Promise 上（此时不入微任务队列）</li></ul></li></ul><p>1s 后：</p><ul><li><strong>宏任务：timer 回调入队并被执行</strong><ul><li>执行 <code>resolve(&quot;哈哈&quot;)</code><ul><li>Promise fulfilled</li><li><code>then</code> 回调 <strong>入微任务队列</strong></li></ul></li></ul></li><li>timer 宏任务执行完毕</li><li><strong>立刻清空微任务队列</strong><ul><li>执行 <code>then</code> 回调 → <code>console.log(&quot;哈哈&quot;)</code></li></ul></li></ul><p><strong><code>Promise</code>登记过程</strong></p><p>在规范层面，每一个 Promise 内部至少维护这三类“槽位”：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">Promise &#123;<br>  <span class="hljs-string">[[PromiseState]]</span>: pending | fulfilled | rejected<br>  <span class="hljs-string">[[PromiseResult]]</span>: value | reason<br>  <span class="hljs-string">[[PromiseReactions]]</span>: &#123;<br>      fulfillReactions: [],<br>      rejectReactions: []<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>.then()</code> 做的事情，本质上只有三步，当写：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">promise.then(<span class="hljs-keyword">on</span>Fulfilled, <span class="hljs-keyword">on</span>Rejected)<br></code></pre></td></tr></table></figure><p>JS 引擎内部（逻辑等价，不是源码）会做：</p><p>① 创建一个新的 Promise（这是链式调用的根）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">newPromise</span> <span class="hljs-operator">=</span> new Promise(...)<br></code></pre></td></tr></table></figure><p>这个 Promise 还没有状态，是 <code>pending</code>。</p><p>② 把回调“包装成 reaction 对象”：不是简单存一个函数，而是一个<strong>结构体</strong>，类似这样：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-attr">reaction</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br>  onFulfilled,          <span class="hljs-comment">// 成功回调</span><br>  onRejected,           <span class="hljs-comment">// 失败回调</span><br><span class="hljs-symbol">  capability:</span> <span class="hljs-punctuation">&#123;</span><br>    resolve,            <span class="hljs-comment">// newPromise 的 resolve</span><br>    reject              <span class="hljs-comment">// newPromise 的 reject</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这一步非常关键：<strong>reaction 把“当前 Promise 的回调”和“下一个 Promise 的控制权”绑在了一起</strong></p><p>这就是为什么：<code>then</code> 的返回值会由回调的返回值决定</p><p>③ 根据当前 Promise 状态，决定“登记”还是“立刻调度”</p><p><strong>情况 A：当前 Promise 是 <code>pending</code></strong></p><p>此时引擎会做：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">promise.<span class="hljs-string">[[PromiseReactions]]</span>.fulfillReactions.push(reaction)<br>promise.<span class="hljs-string">[[PromiseReactions]]</span>.rejectReactions.push(reaction)<br></code></pre></td></tr></table></figure><p><strong>只登记，不执行，不入队列</strong></p><p>也就是说：<code>.then()</code> 在 pending 状态下只是“订阅事件”，类似 addEventListener</p><p><strong>情况 B：当前 Promise 已经是 <code>fulfilled</code></strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>(100).the<span class="hljs-meta">n</span>(fn)<br></code></pre></td></tr></table></figure><p>此时不会登记到列表，而是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">把 reaction 立刻封装成一个 microtask<br>推入 PromiseJobs（微任务队列）<br></code></pre></td></tr></table></figure><p>这就是为什么：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>().the<span class="hljs-meta">n</span>(fn)<br></code></pre></td></tr></table></figure><p><strong>一定是异步执行的</strong></p><p>情况 C：当前 Promise 已经是 <code>rejected</code></p><p>逻辑完全对称，只走 reject 分支。</p><p><strong>状态一旦切换，Promise 就“封印”了，取出之前登记的 reactions</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">each</span> <span class="hljs-variable">reaction</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">fulfillReactions</span>:<br>    <span class="hljs-function"><span class="hljs-title">enqueueMicrotask</span>(<span class="hljs-variable">reaction</span>)</span><br></code></pre></td></tr></table></figure><p>注意这句话非常重要：<strong>是 resolve 触发了微任务的创建，而不是 then</strong></p><h3 id="4-async-和-await"><a href="#4-async-和-await" class="headerlink" title="4.async 和 await"></a>4.async 和 await</h3><p><code>async</code> 和 <code>await</code> 是 ES2017 引入的基于 Promise 的语法糖，用来以同步的书写方式处理异步操作。被 <code>async</code> 修饰的函数会始终返回一个 Promise，当函数返回普通值时会被自动包装成一个已完成状态的 Promise，当函数抛出异常时则会返回一个拒绝状态的 Promise。<code>await</code> 只能在 <code>async</code> 函数中使用，它会暂停函数的执行，等待其后表达式返回的 Promise 完成，并将完成的值作为返回结果，如果 Promise 被拒绝则会抛出异常，需要用 <code>try...catch</code> 来捕获。<font color="#409eff">即使 <code>await</code> 后面不是 Promise，也会被转换成一个已完成的 Promise 再处理。</font><code>async/await</code> 的核心优势是让异步代码看起来像同步代码一样直观，减少回调嵌套和链式 then 带来的可读性问题，同时可以通过 <code>try...catch</code> 统一捕获错误，从而让异步逻辑结构更清晰。但它并没有改变 JavaScript 单线程、事件循环的本质，底层依然是通过 Promise 和微任务机制来调度执行的。</p><h4 id="【async函数】"><a href="#【async函数】" class="headerlink" title="【async函数】"></a>【async函数】</h4><p>async是一个加在函数前的修饰符，用来创建一个异步函数，被async定义的函数会默认返回一个Promise对象resolve的值。</p><p>因此对async函数可以直接then，返回值就是then方法传入的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async基础语法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">fun0</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val) <span class="hljs-comment">// 1,1</span><br>&#125;)<br><br><span class="hljs-comment">// ===&gt; 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">fun1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// Promise Promise</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="【await】"><a href="#【await】" class="headerlink" title="【await】"></a>【await】</h4><p>await 也是一个修饰符，只能放在async定义的函数内。可以理解为<strong>等待</strong>。</p><p>await 修饰的如果是Promise对象，可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p><p><code>await expr</code> 的语义近似是<strong>把 <code>expr</code> 先变成 <code>Promise.resolve(expr)</code>，然后在它 fulfilled 之后，用 <code>.then(...)</code> 继续执行后续代码。</strong>即使 <code>expr</code> 是普通值（比如 <code>1</code>），也会走一次“异步恢复”（微任务）。</p><p>注意事项</p><ul><li>await必须写在async函数中，但是async函数中可以没有await</li><li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li><li><font color="#409eff">当我们使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕以后，被放入到微任务队列中。</font></li></ul><h4 id="【面试题】"><a href="#【面试题】" class="headerlink" title="【面试题】"></a>【面试题】</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 非promise的东西当做await表达式的结果</span><br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)  <span class="hljs-comment">// Promise中返回的内容（resolve或reject的参数）</span><br>    &#125;)<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>&#125;<br><span class="hljs-comment">// === &gt; </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a, b, c;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)                 <span class="hljs-comment">// await 1</span><br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>      a = v;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;     <span class="hljs-comment">// await new Promise(...)</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);<br>        &#125;, <span class="hljs-number">3000</span>);<br>      &#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>      b = v;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>((<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// await IIFE</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function&quot;</span>;<br>      &#125;)());<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>      c = v;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c);<br>      <span class="hljs-comment">// async fun 默认返回 Promise&lt;undefined&gt;</span><br>      <span class="hljs-comment">// 这里不 return 等价于 return undefined，链会 resolve(undefined)</span><br>    &#125;);<br>&#125;<br><br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 3秒后输出： 1 &quot;setTimeout&quot; &quot;function&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">aysnc <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn4</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;<br><span class="hljs-title function_">fn4</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// =&gt;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn4</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>        <span class="hljs-title function_">resolve</span>()<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// 1,2,4,3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>)<br>        &#125;, <span class="hljs-number">0</span>)<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>    &#125;)<br><br>&#125;))<br><span class="hljs-title function_">first</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br><span class="hljs-comment">// 3,7,4,1,2,5</span><br></code></pre></td></tr></table></figure><h3 id="5-Promise-的静态方法"><a href="#5-Promise-的静态方法" class="headerlink" title="5. Promise 的静态方法"></a>5. Promise 的静态方法</h3><blockquote><p><a href="https://cxdlogver.github.io/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#%E3%80%90Promise%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%91">NodeJS核心总结 - 相</a></p></blockquote><h4 id="手写-Promise-all"><a href="#手写-Promise-all" class="headerlink" title="手写 Promise.all"></a>手写 <code>Promise.all</code></h4><p><strong>规则</strong>：</p><ul><li>全部成功 → resolve 结果数组（保持顺序）</li><li>任意失败 → 立即 reject</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>([]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>          result[index] = value;<br>          count++;<br>          <span class="hljs-keyword">if</span> (count === len) &#123;<br>            <span class="hljs-title function_">resolve</span>(result);<br>          &#125;<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">reject</span>(err);<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="手写-Promise-race"><a href="#手写-Promise-race" class="headerlink" title="手写 Promise.race"></a>手写 <code>Promise.race</code></h4><p><strong>规则</strong>：</p><ul><li>第一个 settled（resolve 或 reject）的结果直接返回</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseRace</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(resolve, reject);<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(value),<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">reject</span>(error)<br>);<br></code></pre></td></tr></table></figure><p>意思是：</p><ul><li><strong>如果 p 成功</strong> → 尝试 <code>resolve(value)</code></li><li><strong>如果 p 失败</strong> → 尝试 <code>reject(error)</code></li></ul><hr><h4 id="手写-Promise-any"><a href="#手写-Promise-any" class="headerlink" title="手写 Promise.any"></a>手写 <code>Promise.any</code></h4><p><strong>规则</strong>：</p><ul><li>任意一个成功 → resolve</li><li>全部失败 → reject（AggregateError）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseAny</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> errors = [];<br>    <span class="hljs-keyword">let</span> rejectedCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>([], <span class="hljs-string">&quot;All promises were rejected&quot;</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(value);<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>          errors[index] = err;<br>          rejectedCount++;<br>          <span class="hljs-keyword">if</span> (rejectedCount === len) &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(errors, <span class="hljs-string">&quot;All promises were rejected&quot;</span>));<br>          &#125;<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="手写-Promise-allSettled"><a href="#手写-Promise-allSettled" class="headerlink" title="手写 Promise.allSettled"></a>手写 <code>Promise.allSettled</code></h4><p><strong>规则</strong>：</p><ul><li>不关心成功或失败</li><li>全部结束后返回状态数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPromiseAllSettled</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = [];<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">resolve</span>([]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">p, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>          result[index] = &#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;fulfilled&quot;</span>,<br>            value<br>          &#125;;<br>          count++;<br>          <span class="hljs-keyword">if</span> (count === len) <span class="hljs-title function_">resolve</span>(result);<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>          result[index] = &#123;<br>            <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;rejected&quot;</span>,<br>            reason<br>          &#125;;<br>          count++;<br>          <span class="hljs-keyword">if</span> (count === len) <span class="hljs-title function_">resolve</span>(result);<br>        &#125;<br>      );<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS核心总结</title>
    <link href="/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"/>
    <url>/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>NodeJS简介 &#x2F; 包管理器 &#x2F; 计算机网络 &#x2F; Promise &#x2F; Express &#x2F; Buffer &#x2F; Path &#x2F; 会话控制</p><span id="more"></span><h1 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h1><blockquote><p><a href="https://nodejs.org/en">Node.js — Run JavaScript Everywhere</a></p></blockquote><p>Node.js 是一个基于 <strong>Chrome V8 引擎</strong> 构建的 <strong>JavaScript 运行环境</strong>，它让你能够在服务器端运行 JavaScript 代码。</p><ul><li><strong>本质</strong>：Node.js 是一个 JavaScript 运行环境（runtime environment），让 JavaScript 脱离浏览器、在服务器上运行。</li><li><strong>核心引擎</strong>：使用 Google 的 V8 JavaScript 引擎。</li><li><strong>异步 I&#x2F;O</strong>：采用 <strong>事件驱动、非阻塞（non-blocking）I&#x2F;O 模型</strong>，非常适合处理高并发请求。</li></ul><h2 id="Node-js-的特点"><a href="#Node-js-的特点" class="headerlink" title="Node.js 的特点"></a>Node.js 的特点</h2><table><thead><tr><th>特点</th><th>描述</th></tr></thead><tbody><tr><td>非阻塞 I&#x2F;O</td><td>异步处理请求，性能高</td></tr><tr><td>单线程事件循环</td><td>用一个线程处理多个请求，通过事件循环实现并发</td></tr><tr><td>跨平台</td><td>支持 Windows、Linux、macOS 等操作系统</td></tr><tr><td>使用 JavaScript</td><td>前后端统一开发语言（同一API）</td></tr><tr><td>大量模块支持</td><td>拥有丰富的 NPM（Node Package Manager）生态系统</td></tr></tbody></table><h2 id="Node-js-常见用途"><a href="#Node-js-常见用途" class="headerlink" title="Node.js 常见用途"></a>Node.js 常见用途</h2><ol><li><strong>构建 Web 服务器</strong>（如 Express 框架）</li><li><strong>API 接口服务</strong>（RESTful、GraphQL）</li><li><strong>实时通信应用</strong>（如聊天室、Socket.io）</li><li><strong>命令行工具开发</strong></li><li><strong>构建微服务架构</strong></li><li><strong>自动化构建工具</strong>（Webpack、Gulp 等）</li><li><strong>物联网（IoT）项目</strong></li></ol><hr><h2 id="Node-js-的核心模块"><a href="#Node-js-的核心模块" class="headerlink" title="Node.js 的核心模块"></a>Node.js 的核心模块</h2><table><thead><tr><th>模块名</th><th>功能简介</th></tr></thead><tbody><tr><td><code>http</code></td><td>创建 Web 服务器</td></tr><tr><td><code>fs</code></td><td>文件系统操作</td></tr><tr><td><code>path</code></td><td>处理文件路径</td></tr><tr><td><code>events</code></td><td>事件处理</td></tr><tr><td><code>stream</code></td><td>数据流操作</td></tr><tr><td><code>os</code></td><td>系统信息获取</td></tr><tr><td><code>process</code></td><td>创建子进程</td></tr></tbody></table><h2 id="NVM简介"><a href="#NVM简介" class="headerlink" title="NVM简介"></a>NVM简介</h2><p>NVM（Node Version Manager）是 <strong>Node.js 版本管理工具</strong>，可以方便地在同一台机器上安装和切换多个 Node.js 版本。</p><ul><li><strong>全称</strong>：Node Version Manager</li><li><strong>作用</strong>：帮助你在同一系统中安装、管理和切换多个版本的 Node.js。</li><li><strong>使用场景</strong>：<ul><li>不同项目需要不同版本的 Node.js。</li><li>测试代码在不同 Node.js 版本下的兼容性。</li><li>避免全局安装冲突。</li></ul></li></ul><p><strong>NVM 的主要功能</strong></p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>安装 Node.js</td><td><code>nvm install 16.20.2</code></td><td>安装指定版本的 Node</td></tr><tr><td>查看已安装版本</td><td><code>nvm ls</code></td><td>显示当前安装的所有 Node.js 版本</td></tr><tr><td>查看可安装版本</td><td><code>nvm ls-remote</code></td><td>查看远程所有可安装版本</td></tr><tr><td>使用某版本</td><td><code>nvm use 16.20.2</code></td><td>临时切换 Node.js 版本</td></tr><tr><td>设置默认版本</td><td><code>nvm alias default 16.20.2</code></td><td>设置默认使用的版本</td></tr><tr><td>卸载版本</td><td><code>nvm uninstall 14.21.3</code></td><td>删除指定版本的 Node</td></tr></tbody></table><h2 id="Node-js-使用"><a href="#Node-js-使用" class="headerlink" title="Node.js 使用"></a>Node.js 使用</h2><p>和之前学习的JavaScript不同，Node.js需要运行在服务器端，说的直白一些我们需要通过命令行来执行JS代码。通过命令行执行js代码有两种方式：</p><p>第一种直接在命令行中输入node，会进入到node的REPL界面（交互编程环境），在REPL下和浏览器的控制台类似，我们可以直接输入各种JS代码，REPL会立即执行这些代码并输出结果（.exit用来退出REPL）。</p><img src="/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220927094943815.png" class title="img"><p>第二种也是我们最常使用的一种，就是将js代码编写到一个js文件中，然后通过命令行执行js文件</p><img src="/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220927095238144.png" class title="img"><p>Node.js虽然也属于js，但是它和浏览器中js还是有所区别的。对于ECMAScript标准来说，它们是一致的所以像是原始值、流程控制语句、运算符、函数、对象、数组、内建对象这些东西无论是浏览器环境还是node中都是一样的。对于宿主对象来说浏览器和node是截然不同的，像是DOM、BOM这些对象在node中通通是不存在的，但是一些东西在Node中依然得到了保留，比如console对象、比如定时器之类。</p><h2 id="Node-js-的作用"><a href="#Node-js-的作用" class="headerlink" title="Node.js 的作用"></a>Node.js 的作用</h2><ol><li><strong>开发服务器应用</strong> —— 因为 Node.js 提供了服务端能力</li></ol><p><strong>解释：</strong></p><p>JavaScript 原本只运行在浏览器中，不能访问磁盘、网络、数据库等“后端功能”。但通过 <strong>Node.js</strong>，JavaScript 拥有了这些底层访问能力：</p><ul><li>Node.js 提供了 HTTP 模块，可以构建 Web 服务器</li><li>提供文件系统（fs）、网络（net）、数据库连接等 API</li><li>使用异步非阻塞 I&#x2F;O 机制，非常适合处理<strong>高并发请求</strong></li></ul><p><strong>举例场景：</strong></p><table><thead><tr><th>应用类型</th><th>示例</th></tr></thead><tbody><tr><td>API 服务</td><td>RESTful 或 GraphQL 接口</td></tr><tr><td>实时服务</td><td>聊天服务器、在线协作、弹幕系统</td></tr><tr><td>Web 后端</td><td>博客系统、论坛系统、内容管理系统（CMS）</td></tr></tbody></table><p><strong>常用工具</strong>：Express、Koa、NestJS</p><ol start="2"><li><strong>开发工具类应用</strong> —— 因为 Node.js 可直接操作系统资源</li></ol><p><strong>解释：</strong></p><p>Node.js 能读取文件、执行命令、读取环境变量，因此非常适合用来开发 <strong>命令行工具</strong> 或 <strong>项目构建工具</strong>：</p><ul><li>可以写项目脚手架（自动创建目录结构）</li><li>实现自动构建、打包、格式化等工具</li><li>可以发布为 npm 包，方便分发与使用</li></ul><p><strong>举例场景：</strong></p><table><thead><tr><th>工具类型</th><th>示例</th></tr></thead><tbody><tr><td>前端构建工具</td><td>Webpack、Vite、Rollup</td></tr><tr><td>命令行工具</td><td>Vue CLI、create-react-app</td></tr><tr><td>自动化工具</td><td>ESLint、Prettier、Gulp、Husky</td></tr></tbody></table><p><strong>优势：</strong> 使用 JavaScript 写工具，让前端开发流程更统一、可自动化。</p><ol start="3"><li><strong>开发桌面端应用</strong> —— 因为 JavaScript 可借助 <font color="#409eff">Electron </font>实现跨平台桌面程序</li></ol><p><strong>解释：</strong></p><p>通过 <strong>Electron</strong>（基于 Node.js + Chromium），JavaScript 可以构建完整的桌面应用，支持：</p><ul><li>系统窗口管理（打开窗口、菜单栏、托盘图标等）</li><li>访问系统资源（文件读写、系统通知、硬件接口）</li><li>使用 HTML&#x2F;CSS&#x2F;JS 构建 UI，适配所有平台（Windows、macOS、Linux）</li></ul><p><strong>举例场景：</strong></p><table><thead><tr><th>应用类型</th><th>示例</th></tr></thead><tbody><tr><td>编辑器类</td><td>VS Code、Atom</td></tr><tr><td>聊天类</td><td>Slack、Discord（旧版本）</td></tr><tr><td>开发工具</td><td>Postman、Insomnia、Figma 桌面版</td></tr></tbody></table><p><strong>为什么可行？</strong></p><ul><li>Electron 中，<strong>前端页面用浏览器渲染，后端逻辑由 Node.js 支撑</strong></li><li>统一语言栈，开发效率高</li><li>支持跨平台打包</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><font color="#409eff">面试模板：</font></p><p>Node.js 是一个基于 Chrome V8 引擎构建的 JavaScript 运行时环境，它让 JavaScript 不再局限于浏览器中运行，而是可以直接在服务器端执行。Node.js 采用事件驱动、非阻塞 I&#x2F;O 的模型，这种设计使得它在处理高并发、I&#x2F;O 密集型任务时具有非常高的性能和扩展性。所有 I&#x2F;O 操作都通过<strong>事件循环和回调机制</strong>来异步执行，从而避免了线程阻塞的问题。Node.js 提供了丰富的内置模块，比如文件系统、HTTP、网络等，同时也有全球最大的开源包管理生态——npm。总结来说，Node.js 的特点是单线程、事件驱动、异步非阻塞，优势在于高并发处理能力和丰富的生态，缺点是 CPU 密集型任务表现不佳，因为单线程在处理复杂计算时容易阻塞事件循环。</p><p>事件驱动就是程序的执行流程由事件来推动，而不是按顺序一行行地死等结果。在 Node.js 里，有一个事件循环机制，所有任务会被注册成事件，当某个事件发生，比如网络请求完成、文件读取结束，就会触发对应的回调函数执行，这样程序不必在原地等待，而是去忙别的事，等事件通知。</p><p>非阻塞 I&#x2F;O 是指在执行 I&#x2F;O 操作，比如读文件、查数据库、发网络请求时，不会阻塞代码的继续运行。传统的阻塞模式是必须等 I&#x2F;O 完成才继续执行后面的代码，而 Node.js 的非阻塞 I&#x2F;O 会立即返回，先把操作交给系统后台去处理，当处理完成后通过事件和回调通知程序，这样可以同时发起多个 I&#x2F;O 请求，不浪费等待的时间。</p><h1 id="JavaScript模块化"><a href="#JavaScript模块化" class="headerlink" title="JavaScript模块化"></a>JavaScript模块化</h1><blockquote><p>知识点总结：尚硅谷\禹神：一小时速通JavaScript模块化</p></blockquote><p><font color="#409eff">面试模板：</font></p><p>JavaScript 模块化是一种将代码按照功能拆分成独立文件的编程方式，每个模块内部定义自己的作用域和功能，并通过特定的导出与导入机制实现复用。模块化的出现主要是为了解决早期 JavaScript 在全局作用域下编写代码所带来的全局变量污染、依赖顺序混乱以及数据暴露不安全等问题。通过模块化，每个模块都有独立的作用域，避免了不同模块之间的变量和函数相互覆盖；同时模块通过显式的 <code>import</code> 和 <code>export</code> 声明依赖关系，不再依赖于手动调整脚本引入顺序，从而解决依赖混乱的问题；此外，模块内部的数据和实现细节如果不导出，外部是无法访问的，这样就实现了数据的封装与安全。早期的模块化方案包括 IIFE 自执行函数封装、CommonJS（主要用于 Node.js）和 AMD（浏览器端异步加载），现代 JavaScript 则通过 ES Module（<code>import</code>&#x2F;<code>export</code>）在语言层面原生支持模块化，并结合构建工具打包，既解决了全局污染和依赖混乱的问题，也让数据访问更可控、更安全。</p><h1 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h1><h2 id="NPM介绍"><a href="#NPM介绍" class="headerlink" title="NPM介绍"></a>NPM介绍</h2><p>NPM（<strong>Node Package Manager</strong>）是 <strong>Node.js 的包管理工具</strong>，也是<strong>世界上最大的 JavaScript 软件包生态系统</strong>。</p><ul><li><strong>全称</strong>：Node Package Manager</li><li><strong>功能</strong>：用于安装、管理、共享 JavaScript 包（模块&#x2F;库）</li><li><strong>作用对象</strong>：主要配合 Node.js 使用，但也适用于前端项目（如 Vue、React）</li></ul><blockquote><p>安装 Node.js 时通常会自动附带安装 NPM。</p></blockquote><p><strong>三大功能</strong></p><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>安装模块</td><td>安装你项目需要的库（如 <code>express</code>、<code>lodash</code>）</td></tr><tr><td>管理依赖</td><td></td></tr><tr><td>发布包</td><td>将你自己的模块上传到 NPM 仓库，供他人使用</td></tr></tbody></table><p>NPM 常用命令速查表</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm init</code></td><td>初始化项目，创建 <code>package.json</code></td><td>会提示填写信息</td></tr><tr><td><code>npm init -y</code></td><td>快速初始化项目</td><td>使用默认值跳过询问</td></tr></tbody></table><p>安装依赖</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm install</code> 或 <code>npm i</code></td><td>安装所有依赖（根据 <code>package.json</code>）</td><td>生成 <code>node_modules</code> 和 <code>package-lock.json</code></td></tr><tr><td><code>npm install &lt;包名&gt;</code></td><td>安装指定包，添加到 <code>dependencies</code></td><td>默认本地安装</td></tr><tr><td><code>npm install &lt;包名&gt; --save-dev</code> 或 <code>-D</code></td><td>安装为开发依赖</td><td>添加到 <code>devDependencies</code></td></tr><tr><td><code>npm install -g &lt;包名&gt;</code></td><td>全局安装一个包</td><td>多用于 CLI 工具（如 nodemon）</td></tr></tbody></table><p>卸载依赖</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm uninstall &lt;包名&gt;</code></td><td>卸载依赖并从 <code>package.json</code> 中移除</td><td>支持卸载开发依赖</td></tr></tbody></table><p>更新与查看</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm update &lt;包名&gt;</code></td><td>更新某个依赖包</td><td>自动安装符合 semver 的最新版本</td></tr><tr><td><code>npm outdated</code></td><td>查看过时的依赖包</td><td>显示当前版本、最新版本等</td></tr><tr><td><code>npm list</code></td><td>查看当前项目依赖结构</td><td>默认显示完整树</td></tr><tr><td><code>npm list --depth=0</code></td><td>查看顶级依赖</td><td>常用于查看主要依赖版本</td></tr></tbody></table><p>运行脚本</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm start</code></td><td>执行 <code>package.json</code> 中的 <code>start</code> 脚本</td><td>如：<code>&quot;start&quot;: &quot;node index.js&quot;</code></td></tr><tr><td><code>npm run &lt;脚本名&gt;</code></td><td>执行自定义脚本</td><td>如：<code>npm run dev</code></td></tr><tr><td><code>npm test</code></td><td>执行 <code>test</code> 脚本</td><td>一般用于单元测试</td></tr></tbody></table><p> 镜像源设置（加速）</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm config set registry &lt;url&gt;</code></td><td>设置 NPM 镜像地址</td><td>如淘宝源 <code>https://registry.npmmirror.com</code></td></tr><tr><td><code>npm config get registry</code></td><td>查看当前镜像源</td><td>可用于确认是否设置成功</td></tr></tbody></table><p>其他实用命令</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm cache clean --force</code></td><td>清除本地缓存</td><td>修复安装错误时常用</td></tr><tr><td><code>npm doctor</code></td><td>检查 NPM 环境配置</td><td>帮助诊断问题</td></tr><tr><td><code>npm version &lt;type&gt;</code></td><td>自动升级版本号</td><td><code>type</code>为 <code>patch</code>、<code>minor</code>、<code>major</code> 等</td></tr><tr><td><code>npm publish</code></td><td>发布自己的包到 NPM 仓库</td><td>需要先登录账户</td></tr><tr><td><code>npm login</code></td><td>登录到 NPM 账号</td><td>发布包前必须登录</td></tr></tbody></table><h2 id="Yarn和Pnpm"><a href="#Yarn和Pnpm" class="headerlink" title="Yarn和Pnpm"></a>Yarn和Pnpm</h2><p><strong>Yarn</strong></p><ul><li>安装速度快（比 npm 早期版本快很多）</li><li>默认使用 <code>yarn.lock</code> 锁定依赖</li><li>支持 <strong>Plug’n’Play（PnP）</strong>，跳过 <code>node_modules</code></li></ul><p><strong>pnpm</strong></p><ul><li>采用 <strong>符号链接 + 全局内容寻址存储</strong> 节省磁盘空间</li><li>更严格的依赖隔离，防止 <code>npm</code> 和 <code>yarn</code> 容易出现的“幽灵依赖”</li><li>支持 monorepo（内置 workspace）</li></ul><table><thead><tr><th>功能</th><th>npm 命令</th><th>yarn 命令</th><th>pnpm 命令</th></tr></thead><tbody><tr><td>初始化项目</td><td><code>npm init</code>  <code>npm init -y</code></td><td><code>yarn init</code>  <code>yarn init -y</code></td><td><code>pnpm init</code>  <code>pnpm init -y</code></td></tr><tr><td>安装依赖（全部）</td><td><code>npm install</code>  <code>npm i</code></td><td><code>yarn install</code></td><td><code>pnpm install</code></td></tr><tr><td>安装依赖（指定）</td><td><code>npm install 包名</code></td><td><code>yarn add 包名</code></td><td><code>pnpm add 包名</code></td></tr><tr><td>安装开发依赖</td><td><code>npm install 包名 --save-dev</code>  <code>npm i 包名 -D</code></td><td><code>yarn add 包名 --dev</code></td><td><code>pnpm add 包名 -D</code></td></tr><tr><td>安装全局包</td><td><code>npm install -g 包名</code></td><td><code>yarn global add 包名</code></td><td><code>pnpm add -g 包名</code></td></tr><tr><td>移除依赖</td><td><code>npm uninstall 包名</code>  <code>npm rm 包名</code></td><td><code>yarn remove 包名</code></td><td><code>pnpm remove 包名</code></td></tr><tr><td>更新依赖</td><td><code>npm update 包名</code></td><td><code>yarn upgrade 包名</code></td><td><code>pnpm update 包名</code></td></tr><tr><td>查看过期依赖</td><td><code>npm outdated</code></td><td><code>yarn outdated</code></td><td><code>pnpm outdated</code></td></tr><tr><td>运行脚本</td><td><code>npm run 脚本名</code></td><td><code>yarn run 脚本名</code>  <code>yarn 脚本名</code></td><td><code>pnpm run 脚本名</code>  <code>pnpm 脚本名</code></td></tr><tr><td>清缓存</td><td><code>npm cache clean --force</code></td><td><code>yarn cache clean</code></td><td><code>pnpm store prune</code></td></tr><tr><td>查看依赖树</td><td><code>npm list</code></td><td><code>yarn list</code></td><td><code>pnpm list</code></td></tr><tr><td>安装指定版本</td><td><code>npm install 包名@版本</code></td><td><code>yarn add 包名@版本</code></td><td><code>pnpm add 包名@版本</code></td></tr><tr><td>安装本地包</td><td><code>npm install ./路径</code></td><td><code>yarn add ./路径</code></td><td><code>pnpm add ./路径</code></td></tr></tbody></table><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p><code>package.json</code> 是 <strong>Node.js</strong> 和 <strong>前端项目（如使用 npm 或 yarn 管理依赖的项目）</strong> 中的一个核心配置文件。它是一个 <strong>JSON 格式的文件</strong>，主要用来描述项目的基本信息、依赖关系、脚本命令等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your-project-name&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 项目名称</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span>                 <span class="hljs-comment">// 版本号，遵循语义化版本规则</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;A short description of your project&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 项目描述</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span>                 <span class="hljs-comment">// 项目入口文件</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                       <span class="hljs-comment">// 脚本命令，可以用 npm run 命令调用</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 启动项目</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jest&quot;</span>                  <span class="hljs-comment">// 测试命令</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                      <span class="hljs-comment">// 关键词，便于搜索</span><br>    <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;example&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Your Name&quot;</span><span class="hljs-punctuation">,</span>             <span class="hljs-comment">// 作者</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-comment">// 许可证类型</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 生产依赖包</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lodash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.20&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>               <span class="hljs-comment">// 开发依赖包，仅在开发环境需要</span><br>    <span class="hljs-attr">&quot;jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^26.4.2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                   <span class="hljs-comment">// 代码仓库信息</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/yourname/your-repo.git&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;engines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-comment">// 指定 Node.js 或 npm 的版本要求</span><br>    <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=14.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;private&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>                  <span class="hljs-comment">// 是否为私有项目，true 时禁止发布到 npm</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>常见字段作用：</strong></p><ul><li><strong>name</strong>：包的名称。</li><li><strong>version</strong>：版本号。</li><li><strong>description</strong>：项目描述。</li><li><strong>main</strong>：入口文件。</li><li><strong>scripts</strong>：定义脚本命令，如启动、测试、构建等。</li><li><strong>dependencies</strong>：生产环境依赖的包。</li><li><strong>devDependencies</strong>：开发环境依赖的包。</li><li><strong>repository</strong>：仓库地址。</li><li><strong>keywords</strong>：关键字。</li><li><strong>author</strong>：作者。</li><li><strong>license</strong>：开源协议。</li><li><strong>private</strong>：防止发布到 npm（通常私有项目设置为 true）。</li></ul><p><strong>生产依赖包 (<code>dependencies</code>)</strong></p><ul><li><strong>用途</strong>：这些依赖是你的项目在 <strong>运行时（生产环境）</strong> 必须依赖的包。也就是说，当你的应用真正上线、给用户使用时，程序依赖的这些包必须存在。</li></ul><p><strong>开发依赖包 (<code>devDependencies</code>)</strong></p><ul><li><strong>用途</strong>：这些依赖是你在 <strong>开发阶段</strong> 用来辅助开发、测试、构建、代码检查等的工具包，生产环境不需要它们。最终运行的时候不需要打包。</li></ul><p><strong>举例</strong>：</p><ul><li>代码打包工具（如 <code>webpack</code>、<code>rollup</code>）</li><li>测试框架（如 <code>jest</code>、<code>mocha</code>）</li><li>代码格式检查工具（如 <code>eslint</code>、<code>prettier</code>）</li></ul><p><strong><code>package-lock.json</code></strong></p><ul><li><strong>作用</strong>：锁定项目中所有依赖包的<strong>具体版本号</strong>和<strong>依赖树结构</strong>，确保每次安装依赖时，安装的包版本一致，避免因依赖版本变化导致代码不稳定，也不免反复按照多个版本依赖。node自动配置，不需要手动修改。</li></ul><h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p><strong>npx</strong> 是 Node.js 自带的一个命令行工具（从 <strong>npm 5.2.0</strong> 开始内置），它的主要作用是 <strong>执行 Node.js 项目中的可执行包（CLI 工具）</strong>，而不需要你提前全局安装它。</p><h3 id="【为什么有-npx】"><a href="#【为什么有-npx】" class="headerlink" title="【为什么有 npx】"></a>【为什么有 npx】</h3><p>在 npx 出现之前：</p><ul><li>如果想用某个 npm 包的命令行工具（比如 <code>create-react-app</code>），你必须先用 <code>npm install -g create-react-app</code> 全局安装。</li><li>全局安装会导致版本管理困难，不同项目可能需要不同版本。</li></ul><p>npx 解决了这些问题：</p><ul><li>直接运行包的可执行文件，不必全局安装。</li><li>可以运行项目本地 <code>node_modules</code> 里的 CLI 工具。</li><li>支持临时安装一次性运行的工具，执行后自动清除。</li></ul><h3 id="【使用方式】"><a href="#【使用方式】" class="headerlink" title="【使用方式】"></a>【使用方式】</h3><p><strong>运行已安装在项目中的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx eslint src/<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./node_modules/.bin/eslint src/<br></code></pre></td></tr></table></figure><p>（npx 会自动到 <code>node_modules/.bin</code> 找可执行文件）</p><p><strong>运行一次性工具（没安装过）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx cowsay <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>npx 会先下载 <code>cowsay</code>（存在临时目录），执行后删除。</p><p><strong>指定包版本执行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-react-app@4.0.0 my-app<br></code></pre></td></tr></table></figure><p>可以避免全局安装多个版本冲突。</p><p><strong>执行 GitHub &#x2F; Gist 上的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx github:username/repo<br>npx gist:1234567890abcdef<br></code></pre></td></tr></table></figure><h1 id="计算机网络知识"><a href="#计算机网络知识" class="headerlink" title="计算机网络知识"></a>计算机网络知识</h1><blockquote><p><a href="https://www.bilibili.com/video/BV19E411D78Q/?spm_id_from=333.337.search-card.all.click&vd_source=ff414aaf189e3a685358d2a984fd4742">王道计算机考研 计算机网络_哔哩哔哩_bilibili</a> —— 传输层和应用层部分</p><p><a href="./1.6W%E5%AD%97%EF%BC%81%E6%A2%B3%E7%90%8650%E9%81%93%E7%BB%8F%E5%85%B8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E8%97%8F%E7%89%88%EF%BC%89.pdf">1.6W字！梳理50道经典计算机网络面试题（收藏版）</a></p><p><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络——面试题</a></p><p><a href="https://www.yuque.com/cuggz/feplus/cxuwy0">计算机网络——前端充电宝</a></p></blockquote><h2 id="一个最常见的面试题"><a href="#一个最常见的面试题" class="headerlink" title="一个最常见的面试题"></a>一个最常见的面试题</h2><blockquote><p>当浏览器中输入一行地址以后发生了什么？（例如<a href="https://www.baidu.com/">https://www.baidu.com</a>)</p></blockquote><ol><li><strong>URL 解析</strong></li></ol><ul><li>浏览器首先解析你输入的地址 <code>https://www.baidu.com</code></li><li>分解出：<ul><li>协议（<code>https</code>）</li><li>主机名（<code>www.baidu.com</code>）</li><li>端口（<code>https</code> 默认 443）</li><li>路径（<code>/</code>）</li><li>查询参数（如果有）</li></ul></li></ul><hr><ol start="2"><li><strong>检查缓存</strong></li></ol><p>浏览器会先看看本地有没有现成的资源，按顺序查找：</p><ol><li>浏览器缓存（Memory Cache &#x2F; Disk Cache）</li><li>操作系统缓存（DNS 缓存）</li><li>路由器缓存</li><li>ISP DNS 缓存<br>如果缓存命中，就直接用缓存返回数据，不再走后续步骤。</li></ol><hr><ol start="3"><li><strong>DNS 解析</strong></li></ol><p>如果缓存中没找到域名的 IP，需要向 DNS 服务器查询：</p><ol><li>浏览器调用操作系统的 <strong>DNS 解析库</strong></li><li>OS 向本地配置的 DNS 服务器发起请求</li><li>如果是多级域名，DNS 会从根域名服务器开始逐级解析：<ul><li>根 DNS → <code>.com</code> 顶级域 DNS → <code>baidu.com</code> 权威 DNS</li></ul></li><li>最终得到目标服务器的 <strong>IP 地址</strong>（比如 <code>220.181.38.150</code>）</li></ol><hr><ol start="4"><li><strong>浏览器与服务器建立连接（TCP&#x2F;IP）</strong></li></ol><p>浏览器使用 IP 与服务器建立 TCP 连接：</p><ol><li><strong>SYN</strong>（浏览器 → 服务器，请求建立连接）</li><li><strong>SYN-ACK</strong>（服务器 → 浏览器，同意建立连接）</li><li><strong>ACK</strong>（浏览器 → 服务器，确认）<br>连接建立后，浏览器和服务器之间可以可靠地收发数据。</li></ol><p>HTTPS 会在 TCP 基础上进行 <strong>TLS 握手</strong>，确保数据加密传输：</p><ol><li>浏览器发送支持的加密算法和随机数</li><li>服务器返回证书和公钥</li><li>浏览器验证证书合法性</li><li>双方协商会话密钥<br>握手完成后，所有 HTTP 数据会被加密传输。</li></ol><hr><ol start="5"><li><strong>浏览器发送HTTP请求</strong></li></ol><p>浏览器构造请求报文：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">GET / HTTP/1.1<br><span class="hljs-section">Host: www.baidu.com</span><br><span class="hljs-section">User-Agent: ...</span><br><span class="hljs-section">Accept: ...</span><br></code></pre></td></tr></table></figure><p>通过 TCP 连接发送到服务器</p><hr><ol start="6"><li><strong>服务器处理请求</strong></li></ol><p>服务器（比如 Nginx + 应用层）：</p><ol><li>接收请求数据</li><li>根据 URL 路径匹配资源或调用后端程序</li><li>查询数据库 &#x2F; 缓存</li><li>生成 HTTP 响应（包含 HTML &#x2F; JSON &#x2F; 图片等）</li></ol><hr><ol start="7"><li><strong>返回 HTTP 响应</strong></li></ol><ul><li><p>服务器把响应通过 TCP 发送给浏览器</p></li><li><p>响应报文可能是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span><br><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html</span><br><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">1024</span><br><br><span class="hljs-string">&lt;html&gt;...&lt;/html&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>如果有 <strong>压缩（gzip&#x2F;br）</strong>，浏览器需要解压</p></li></ul><hr><ol start="8"><li><strong>浏览器渲染页面</strong></li></ol><p>浏览器渲染引擎（如 Blink &#x2F; WebKit）执行：</p><ol><li><strong>解析 HTML</strong> → 生成 DOM 树</li><li><strong>解析 CSS</strong> → 生成 CSSOM 树</li><li><strong>合并 DOM + CSSOM</strong> → 生成渲染树</li><li><strong>布局（Layout）</strong>：计算元素位置和大小</li><li><strong>绘制（Paint）</strong>：将像素绘制到屏幕</li><li><strong>执行 JavaScript</strong>（如果遇到 <code>&lt;script&gt;</code> 标签，可能阻塞解析）</li><li>如果页面有图片、CSS、JS 等资源，会<strong>并行发起请求</strong>（重复上述流程）</li></ol><hr><ol start="10"><li><strong>连接关闭</strong></li></ol><ul><li>如果使用 HTTP&#x2F;1.1 且有 <code>Connection: keep-alive</code>，TCP 连接会复用</li><li>HTTP&#x2F;2 &#x2F; HTTP&#x2F;3 会多路复用一个连接</li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>客户端与服务器之间进行通信，需要确定三个地址：<code>MAC地址</code>、<code>IP地址</code>、<code>端口号</code>。</p><ul><li><strong>MAC 地址</strong>（物理地址）：定位 <strong>同一局域网中</strong> 的设备</li><li><strong>IP 地址</strong>（网络地址）：在 <strong>整个互联网范围</strong> 唯一定位一台设备（或者网络节点）</li><li><strong>端口号</strong>（进程地址）：在一台设备上区分不同的应用程序</li></ul><p>根据 IP地址 + 端口号， 可以确定整个互联网中唯一一台设备的唯一进程。IP就好比快递传输中的通讯地址，进程好比收件人。那么MAC地址呢？如果需要跨省传输，那么快递会经过中转站，MAC地址也会改变。也就是<font color="#409eff">IP地址不变，MAC地址每跳改变，端口号唯一定位进程</font>。</p><ul><li>源IP和目的IP地址不会变。始终表示【发货地 -&gt; 目的地】</li><li>源MAC地址和目的MAC地址可能改变。【发货地 -&gt; A省中转站】 -&gt; 【A省中转站 -&gt; B省中转站】 -&gt; 【B省中转站 -&gt; 目的地】</li></ul><p>其中</p><ul><li>端口号是默认或者手动配置的，在传输层添加。</li><li>IP地址通过DNS解析域名得到，在网络层添加。</li><li>MAC地址通过ARP协议，利用IP地址获取，在数据链路层添加。</li></ul><blockquote><p>假设客户端向服务器发送一个 HTTP 请求，整个过程从应用层开始，依次经过传输层、网络层、数据链路层，到物理层发送出去，服务器再反向解析，完成通信。</p></blockquote><ol><li>应用层（Application Layer）</li></ol><ul><li><strong>作用</strong>：提供用户直接使用的服务，处理具体应用协议，比如 HTTP、FTP、SMTP、DNS 等。</li><li><strong>过程</strong>：<ul><li>用户在浏览器输入 URL 发起 HTTP 请求。</li><li>应用层生成符合 HTTP 协议格式的数据（请求报文），准备发送。</li><li>调用下一层（传输层）接口发送数据。</li></ul></li></ul><ol start="2"><li>传输层（Transport Layer）</li></ol><ul><li><strong>作用</strong>：实现端到端的通信管理，提供可靠（TCP）或不可靠（UDP）的传输服务，负责分段、重传、流量控制、端口管理。</li><li><strong>过程</strong>：<ul><li>应用层数据被切分成传输层的数据段（TCP 段或 UDP 数据报）。</li><li>为数据段添加<strong>源端口和目的端口号</strong>，确定通信的进程。</li><li>如果是 TCP，会建立连接（三次握手），保证可靠传输。</li><li>数据段传给下一层（网络层）。</li></ul></li></ul><ol start="3"><li>网络层（Network Layer）</li></ol><ul><li><strong>作用</strong>：负责数据包<strong>从源主机到目标主机的路由选择和转发，主要协议是 IP</strong>。</li><li><strong>过程</strong>：<ul><li>传输层传过来的数据段被封装成数据包（IP 包）。</li><li>添加源 IP 和目的 IP 地址。</li><li>网络层根据目标 IP 寻找路由路径，决定发送到哪个下一跳。</li><li>发送给数据链路层。</li></ul></li></ul><ol start="4"><li>数据链路层（Data Link Layer）</li></ol><ul><li><strong>作用</strong>：负责相邻节点之间的可靠传输，处理物理地址（MAC）、帧的封装和差错检测。</li><li><strong>过程</strong>：<ul><li>将网络层传来的数据包封装成帧（Frame）。</li><li><strong>添加源 MAC 和目的 MAC 地址</strong>。</li><li>通过帧校验序列（FCS）实现差错检测。</li><li>发送到物理层。</li></ul></li></ul><ol start="5"><li>物理层（Physical Layer）</li></ol><ul><li><strong>作用</strong>：负责物理传输媒体上的比特流传输，如电信号、光信号等。</li><li><strong>过程</strong>：<ul><li>把数据链路层的帧转化成适合传输的电信号或光信号。</li><li>通过网线、光纤、无线信道等物理媒介发送给目标设备。</li></ul></li></ul><p>传输到目标服务器后，接收端的流程是反向的：</p><ol><li><strong>物理层</strong>接收信号，转成比特流交给数据链路层。</li><li><strong>数据链路层</strong>解析帧，校验数据，提取数据包。</li><li><strong>网络层</strong>检查 IP 地址，进行路由处理，将数据包交给传输层。</li><li><strong>传输层</strong>重组数据段，校验完整性，确认端口，组装成应用层数据。</li><li><strong>应用层</strong>根据协议解析数据，完成请求处理（如 HTTP 请求被 Web 服务器解析），返回响应。</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss">客户端（发送端）<br>应用层 (HTTP请求)<br>    ↓<br>传输层 (TCP段，加端口)<br>    ↓<br>网络层 (IP包，加IP地址)<br>    ↓<br>数据链路层 (帧，加MAC地址)<br>    ↓<br>物理层 (电信号/光信号)<br><br>--------------------网络传输--------------------<br><br>服务器端（接收端）<br>物理层 (接收信号)<br>    ↑<br>数据链路层 (帧解包，MAC地址校验)<br>    ↑<br>网络层 (IP解包，路由处理)<br>    ↑<br>传输层 (TCP重组，端口校验)<br>    ↑<br>应用层 (HTTP请求解析)<br></code></pre></td></tr></table></figure><p><font color="#409eff">为什么同时需要IP地址和MAC地址：</font></p><p><strong>MAC 地址（物理地址 &#x2F; 硬件地址）</strong></p><ul><li><p>作用：<br>用来标识 <strong>同一局域网内</strong> 的网络设备，在数据链路层用于点对点传输。</p></li><li><p>特性：</p><ul><li>唯一性：理论上全球唯一。</li><li>不可更改（可以通过软件伪造）。</li><li>只在局域网范围内有效，跨网络传输时会被替换（由路由器处理）。</li></ul></li></ul><p><strong>IP 地址（逻辑地址）</strong></p><ul><li><p><strong>作用</strong>：<br>用于在 <strong>不同网络之间</strong> 定位主机，实现数据包的路由转发。</p></li><li><p><strong>特性</strong>：</p><ul><li>逻辑性：可以手动配置，也可以自动分配（DHCP）。</li><li>会变化（设备换网络、换运营商，IP就可能变）。</li><li>在跨网通信时必须依赖IP进行寻址。</li></ul><blockquote><p>MAC地址跨网络传输时会被更新，起到中转的作用。</p></blockquote><p>示例：你的电脑（Client）要访问 <strong><code>www.example.com</code></strong> 服务器（Server）。</p></li></ul><p><strong>步骤 1：DNS 解析</strong></p><ol><li>你在浏览器输入 <code>www.example.com</code>。</li><li>浏览器向 <strong>DNS 服务器</strong> 查询，获取目标服务器的 <strong>IP 地址</strong>（假设是 <code>93.184.216.34</code>）。</li><li>现在你的电脑知道了对方的 IP 地址，但还不知道对方的 <strong>MAC 地址</strong>。</li></ol><p><strong>步骤 2：ARP 获取 MAC 地址（局域网内通信）</strong></p><ol><li>如果目标 IP 在<strong>同一个局域网</strong>：<ul><li>电脑发出 <strong>ARP 广播</strong>（”谁是 93.184.216.34，请告诉我你的 MAC 地址”）。</li><li>目标主机返回自己的 MAC 地址。</li></ul></li><li>如果目标 IP 不在同一个局域网（大多数访问互联网的情况）：<ul><li>电脑会先查本地路由表，发现目标 IP 要通过<strong>网关（路由器）</strong>转发。</li><li>电脑用 ARP 请求获取 <strong>网关的 MAC 地址</strong>（因为第一跳是网关，而不是服务器）。</li></ul></li></ol><p><strong>步骤 3：封装并发送数据</strong></p><ol><li>电脑把数据封装成 <strong>IP 包</strong>（源 IP &#x3D; 你的电脑，目标 IP &#x3D; 服务器）。</li><li>在 IP 包外面再封装一层 <strong>以太网帧</strong>（源 MAC &#x3D; 你的电脑，目标 MAC &#x3D; 网关的 MAC）。</li><li>数据从你的电脑发到网关。</li></ol><p><strong>步骤 4：跨网络传输（路由器处理）</strong></p><ol><li>网关收到帧后，解封装，读取 IP 头，发现目标 IP 在外网。</li><li>根据路由表，把数据转发给下一个路由器：<ul><li><font color="#409eff">修改以太网帧的 <strong>源 MAC</strong> &#x3D; 自己的 MAC，<strong>目标 MAC</strong> &#x3D; 下一跳路由器的 MAC。</font></li><li><strong>IP 地址保持不变</strong>（源 IP 依旧是你的电脑，目标 IP 依旧是服务器）。</li></ul></li><li>经过多个路由器，这个过程不断重复。</li></ol><p><strong>步骤 5：目标服务器接收</strong></p><ol><li>数据到达服务器所在的局域网后，最后一个路由器通过 ARP 找到服务器的 MAC 地址。</li><li>以太网帧（目标 MAC &#x3D; 服务器 MAC）送到服务器。</li><li>服务器解封装，以 IP 为依据确认是发给自己的，然后交给 TCP&#x2F;应用层处理。</li></ol><p><strong>核心要点</strong></p><ul><li><strong>IP 地址</strong>：跨网络定位主机（类似全球地址系统）。</li><li><strong>MAC 地址</strong>：在局域网内唯一标识设备（类似局域网内门牌号）。</li><li><strong>ARP 协议</strong>：IP ↔ MAC 之间的翻译员。</li><li>在跨网通信中，<strong>IP 地址不变</strong>，<strong>MAC 地址每一跳都会改变</strong>（因为每一跳的物理链路是不同的）。</li></ul><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h3 id="1-DNS-协议的概念"><a href="#1-DNS-协议的概念" class="headerlink" title="1. DNS 协议的概念"></a>1. DNS 协议的概念</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的IP 地址。</p><h3 id="2-DNS同时使用TCP和UDP协议"><a href="#2-DNS同时使用TCP和UDP协议" class="headerlink" title="2. DNS同时使用TCP和UDP协议"></a>2. DNS同时使用TCP和UDP协议</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p><p>（1）在区域传输的时候使用TCP协议</p><ul><li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li><li>TCP是一种可靠连接，保证了数据的准确性。</li></ul><p>（2）在域名解析的时候使用UDP协议</p><ul><li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li></ul><h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>比如我们如果想要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，我们首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4.迭代查询与递归查询"></a>4.迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p><ul><li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li><li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li></ul><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><p><code>（Name，Value，Type，TTL）</code></p><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p><ol><li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li><li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li><li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li></ol><h2 id="TCP和UDP协议"><a href="#TCP和UDP协议" class="headerlink" title="TCP和UDP协议"></a>TCP和UDP协议</h2><h3 id="【TCP与UDP协议特点】"><a href="#【TCP与UDP协议特点】" class="headerlink" title="【TCP与UDP协议特点】"></a>【TCP与UDP协议特点】</h3><p><strong>TCP 协议特点</strong></p><ul><li><strong>面向连接</strong>：通信前需要建立连接（三次握手）。</li><li><strong>可靠传输</strong>：通过<strong>确认应答、重传机制</strong>保证数据不丢失、不乱序。</li><li><strong>面向字节流</strong>：数据被看作连续的字节流，没有明确边界。</li><li><strong>流量控制</strong>：通过滑动窗口控制发送速率，避免接收方处理不过来。</li><li><strong>拥塞控制</strong>：慢启动、拥塞避免、快速重传等算法，避免网络拥堵。</li><li><strong>开销相对大</strong>：头部20字节起。</li></ul><p><strong>UDP 协议特点</strong></p><ul><li><strong>无连接</strong>：发送数据前不建立连接，直接发送。</li><li><strong>不保证可靠性</strong>：不确认、不重传，可能丢包、乱序。</li><li><strong>面向报文</strong>：发送方一次发送的数据作为一个整体接收，保留数据边界。</li><li><strong>速度快</strong>：无握手和复杂控制，延迟低。</li><li><strong>开销小</strong>：头部只有8字节。</li><li><strong>常用于</strong>：实时通信（视频、语音）、广播、多播、DNS查询等。</li></ul><p><strong>TCP vs UDP 对比表</strong></p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>数据顺序</td><td>保证顺序</td><td>不保证</td></tr><tr><td>传输形式</td><td>字节流</td><td>报文</td></tr><tr><td>速度</td><td>较慢</td><td>快</td></tr><tr><td>开销</td><td>大（20字节以上）</td><td>小（8字节）</td></tr><tr><td>场景</td><td>HTTP、FTP、SMTP</td><td>视频、语音、DNS</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li><strong>TCP</strong>：需要可靠性和顺序的传输（如网页、文件、邮件）。</li><li><strong>UDP</strong>：追求速度、容忍少量丢包的应用（如直播、游戏、DNS）。</li></ul><h3 id="【面试考点】"><a href="#【面试考点】" class="headerlink" title="【面试考点】"></a>【面试考点】</h3><ul><li>UDP协议特点</li><li>TPC协议特点</li><li>TPC三次握手（为什么不采用二次握手）</li><li>TPC四次挥手（为什么不采用三次挥手）</li><li>TPC拥塞控制（慢开始，拥塞控制，快开始，快重传）</li><li>TPC流量控制（根据返回窗口和拥塞窗口计算）</li><li>TPC可靠传输（校验（不是重点）—— 序号 —— 确认 —— 重传（超时重传和快重传）</li></ul><p><font color="#409eff">具体内容见标题下方PDF笔记链接</font></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="【HTTP协议概述】"><a href="#【HTTP协议概述】" class="headerlink" title="【HTTP协议概述】"></a>【HTTP协议概述】</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p><p>HTTP协议具有以下<strong>优点</strong>：</p><ul><li>支持客户端&#x2F;服务器模式</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li><strong>无连接</strong>：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li><li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li></ul><p>HTTP协议具有以下<strong>缺点</strong>：</p><ul><li><strong>无状态：</strong>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li><li><strong>明文传输：</strong>协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li><li><strong>不安全</strong></li></ul><p>（1）通信使用明文（不加密），内容可能会被窃听</p><p>（2）不验证通信方的身份，因此有可能遭遇伪装</p><p>（3）无法证明报文的完整性，所以有可能已遭篡改</p><h3 id="【HTTP连接方式】"><a href="#【HTTP连接方式】" class="headerlink" title="【HTTP连接方式】"></a>【HTTP连接方式】</h3><p>HTTP 协议是基于 TCP&#x2F;IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p><ul><li><strong>长连接</strong></li></ul><p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。</p><p>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。</p><p>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p><p>对于不同版本的采用不同的连接方式：</p><ul><li><p>在HTTP&#x2F;1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</p></li><li><p>在HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</p></li><li><p><strong>管道网络传输</strong></p></li></ul><p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。<font color="#409eff">也就是流水线式连接</font>。</p><h3 id="【HTTP无连接含义】"><a href="#【HTTP无连接含义】" class="headerlink" title="【HTTP无连接含义】"></a>【HTTP无连接含义】</h3><ol><li>“无连接”指的是<strong>应用层的逻辑连接</strong></li></ol><ul><li>HTTP是<strong>应用层协议</strong>，设计时的“无连接”是指：<ul><li><strong>每个请求&#x2F;响应完成后，应用层不会保留连接状态</strong></li><li>一次请求处理完毕，双方不会保存这次会话的信息</li></ul></li><li>换句话说，HTTP协议本身不管理连接的持续，也不维持会话状态</li></ul><ol start="2"><li>HTTP与传输层TCP的关系</li></ol><ul><li>HTTP协议基于<strong>传输层TCP协议</strong></li><li>TCP是<strong>面向连接的协议</strong>，会建立并维护连接（如三次握手、四次挥手）</li><li>但HTTP层面，在一次请求-响应完成后，默认关闭TCP连接（HTTP&#x2F;1.0短连接）</li></ul><ol start="3"><li>什么叫无连接</li></ol><ul><li>请求和响应是<strong>独立的</strong></li><li>不需要也不保持之前请求的状态</li><li>每次请求都必须携带完成该请求所需的全部信息（例如cookies、认证信息等）</li></ul><ol start="4"><li>现代HTTP的持久连接</li></ol><ul><li>HTTP&#x2F;1.1引入持久连接，允许复用底层TCP连接，但仍然保持HTTP层的无状态特性</li><li>即使连接保持，HTTP仍然是无连接协议，因为它不维护会话信息，状态由应用管理</li></ul><p><font color="#409eff">HTTP的无连接也使得HTTP是无状态的</font>。</p><h3 id="【HTTP无状态含义】"><a href="#【HTTP无状态含义】" class="headerlink" title="【HTTP无状态含义】"></a>【HTTP无状态含义】</h3><p><strong>1. 定义</strong></p><ul><li><strong>HTTP是无状态协议</strong>，意味着<strong>服务器不会自动保留客户端之前请求的任何信息</strong>。</li><li>每一次HTTP请求都是<strong>独立的、互不关联</strong>的。</li></ul><ol start="2"><li><strong>具体表现</strong></li></ol><ul><li>当客户端向服务器发送请求时，服务器仅根据当前请求来处理，并不依赖之前的请求。</li><li>请求处理完毕后，服务器不会保存任何会话信息（状态）。</li><li>下一次请求服务器不会“记得”之前的任何事情。</li></ul><ol start="3"><li><strong>举例说明</strong></li></ol><ul><li>你第一次访问一个购物网站，添加商品到购物车后关闭页面。</li><li>第二次访问时，如果没有额外机制，服务器不知道你之前放了什么商品，因为HTTP本身不保存状态。</li></ul><ol start="4"><li><strong>无状态带来的问题</strong></li></ol><ul><li>不能自动跟踪用户会话</li><li>需要通过其他机制实现状态管理（例如：Cookie、Session、Token）</li></ul><ol start="5"><li><strong>如何解决无状态？</strong></li></ol><ul><li><strong>Cookie</strong>：浏览器保存少量信息，随请求发送给服务器</li><li><strong>Session</strong>：服务器存储用户状态，客户端通过Cookie保存会话ID</li><li><strong>Token</strong>：如JWT，包含用户身份信息，客户端每次请求携带</li></ul><ol start="6"><li><strong>为什么设计为无状态？</strong></li></ol><ul><li>简化服务器设计，提高性能和可伸缩性</li><li>服务器无需保存大量状态信息，方便分布式部署</li></ul><h3 id="【HTTP1-1】"><a href="#【HTTP1-1】" class="headerlink" title="【HTTP1.1】"></a>【HTTP1.1】</h3><p><strong>HTTP 1.1版本</strong>较之前的1.0版本又有了更大的更新，它进一步完善了HTTP协议，现在仍然有在使用，它主要有以下更新：</p><ul><li><strong>持久连接（长连接）</strong><br>该版本之前的版本所建立的都是短连接，该版本引入了持久连接的概念，就是TCP连接默认是不关闭的，建立一个TCP连接，就可以发送多个请求，减少了建立和关闭连接的消耗和延迟。<br>在请求头设置一个非标准的Connection字段:<code>Connection: keep-alive</code>就可以进行长连接，这个字段要求服务器不要关闭TCP连接，服务器同样会回应这个字段。如果想要关闭TCP连接，就要在请求中设置字段：<code>Connection: false</code></li><li><strong>管道机制(流水线式）</strong>：该版本还引入了管道机制，即在一个TCP连接里，客户端可以同时发送多个请求，不需要等收到上一个请求回应，就可以发送新的请求，但是请求的响应还是按照请求发送的顺序返回的，这样就进一步提高了HTTP协议的效率</li><li><strong>分块传输编码</strong>：在HTTP1.0版本中，如果在服务器端遇到较为耗费时间的操作，那么需要等到这一操作全部完成后，才会向客户端发送数据，这段等待时间很影响性能和客户体验。多以使用<strong>分块传输编码</strong>，只要请求或者回应的头部信息有<code>Transfer-Encoding</code>字段：<code>Transfer-Encoding: chunked</code>，就表明回应将由数量未定的数据块组成。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了</li><li>加入了新的<strong>请求方法</strong>：<strong>PUT、PATCH、HEAD、 OPTIONS、DELETE</strong></li><li>优化了<strong>缓存机制</strong>：<strong>强缓存</strong>和<strong>协商缓存</strong></li><li>客户端请求的头部信息<strong>加入了</strong><code>Host</code><strong>字段</strong>，用来指定服务器的域名，这样就可以区分同一个物理主机中的不同虚拟主机的域名</li></ul><h3 id="【HTTPS】"><a href="#【HTTPS】" class="headerlink" title="【HTTPS】"></a>【HTTPS】</h3><h4 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h4><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL&#x2F;TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><img src="/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png" class title="img"><p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p><p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p><h4 id="2-TLS-SSL的工作原理"><a href="#2-TLS-SSL的工作原理" class="headerlink" title="2. TLS&#x2F;SSL的工作原理"></a>2. TLS&#x2F;SSL的工作原理</h4><p><strong>TLS&#x2F;SSL</strong>全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p><p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商<img src="/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png" class title="img"></li></ul><p><strong>2.1 散列函数hash</strong></p><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p><p><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p><p><strong>2.2 对称加密</strong></p><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p><p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p><p><strong>特点：</strong> 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p><p><strong>2.3 非对称加密</strong></p><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p><p><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p><p>综合上述算法特点，TLS&#x2F;SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p><h4 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a>3. 数字证书</h4><p>现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。</p><h4 id="4-TLS握手"><a href="#4-TLS握手" class="headerlink" title="4. TLS握手"></a>4. TLS握手</h4><p>HTTPS通信过程</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">浏览器（客户端）<br><span class="hljs-code">     |</span><br><span class="hljs-code">TCP三次握手</span><br><span class="hljs-code">     |</span><br><span class="hljs-code">TLS握手（客户端Hello → 服务器Hello +证书 → 密钥协商）</span><br><span class="hljs-code">     |</span><br><span class="hljs-code">对称加密的HTTP通信</span><br><span class="hljs-code">     |</span><br><span class="hljs-code">连接关闭</span><br></code></pre></td></tr></table></figure><p>假设你用浏览器访问 <code>https://www.example.com</code>，进行TLS握手，具体过程如下：</p><ol><li>客户端发送 ClientHello</li></ol><ul><li>浏览器发送 ClientHello 消息，包含：<ul><li>支持的 TLS 协议版本（比如 TLS 1.2）</li><li>支持的加密套件列表（如 AES256-GCM-SHA384、ECDHE-RSA-AES128-SHA256 等）</li><li>一个随机数（ClientRandom），用于后续生成密钥</li><li>支持的压缩方法等扩展信息</li></ul></li></ul><ol start="2"><li>服务器响应 ServerHello</li></ol><ul><li>服务器选择使用的 TLS 版本和加密套件，比如 TLS 1.2 和 ECDHE-RSA-AES128-SHA256</li><li>服务器生成自己的随机数（ServerRandom）</li><li>发送 ServerHello 消息给客户端，包含：<ul><li>选定的协议版本和加密套件</li><li>ServerRandom</li></ul></li><li><strong>发送服务器数字证书</strong>，证书里包含服务器的公钥（如RSA公钥）和证书链</li><li>服务器可能还会发送 ServerHelloDone，表示握手消息发送完毕</li></ul><ol start="3"><li>客户端验证服务器证书</li></ol><ul><li>客户端验证服务器证书是否合法：<ul><li>是否被受信任的证书颁发机构（CA）签发</li><li>证书是否过期</li><li>证书的域名是否与访问域名匹配</li></ul></li><li>如果证书合法，客户端继续握手；否则，浏览器会提示安全警告</li></ul><ol start="4"><li>客户端生成预主密钥（Pre-Master Secret）</li></ol><ul><li>客户端生成一个随机数，称为 <strong>预主密钥</strong></li><li>使用服务器公钥加密这个预主密钥（保证只有服务器能解密）</li><li>将加密后的预主密钥发送给服务器</li></ul><ol start="5"><li>服务器用私钥解密预主密钥</li></ol><ul><li>服务器用自己的私钥解密出预主密钥</li></ul><ol start="6"><li>双方生成对称加密密钥</li></ol><ul><li>客户端和服务器分别使用<strong>预主密钥</strong>和之前交换的两个随机数（ClientRandom 和 ServerRandom）</li><li>通过预定义的密钥派生函数生成一组对称密钥（用于加密和MAC验证）</li></ul><ol start="7"><li>握手完成（ChangeCipherSpec &amp; Finished）</li></ol><ul><li>客户端发送 ChangeCipherSpec 消息，告诉服务器后续消息将用协商好的密钥加密</li><li>客户端发送 Finished 消息，内容被加密，包含之前所有握手消息的摘要，用于验证握手完整性</li><li>服务器响应 ChangeCipherSpec 和 Finished 消息，完成握手</li></ul><ol start="8"><li>加密通信开始</li></ol><ul><li>后续客户端和服务器之间的HTTP数据都用对称密钥加密传输，保证机密性和完整性</li></ul><p><strong>随机数保证每次会话密钥唯一，确保每次密钥都独特且不可预测，随机数是明文传输。</strong></p><ul><li>随机数（ClientRandom 和 ServerRandom）与预主密钥一起参与<strong>会话密钥的生成</strong></li><li>通过这两个随机数，即使预主密钥相同，每次生成的对称密钥也会不同</li><li>避免重放攻击和密钥重复使用，提高安全性</li></ul><h3 id="【HTTP状态码】"><a href="#【HTTP状态码】" class="headerlink" title="【HTTP状态码】"></a>【HTTP状态码】</h3><p>应用通常就是客户端向服务器发出请求，服务器做出响应。状态码就是让我们知道 HTTP 请求是成功、失败还是其他。HTTP状态码通常分为五类：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>定义</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接受的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作来完成请求</td></tr><tr><td>4xx</td><td>Client Error (客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>常见状态码介绍</strong></p><ul><li><strong>200 OK</strong>：请求成功，服务器返回请求的数据。</li><li><strong>301 Moved Permanently</strong>：资源已被永久移动到新地址，客户端应更新请求链接。</li><li><strong>302 Found</strong>：资源临时移动，客户端应继续使用原地址。</li><li><strong>304 Not Modified</strong>：资源未修改，客户端可使用缓存，节省带宽。</li><li><strong>400 Bad Request</strong>：请求参数错误，服务器无法理解请求。</li><li><strong>401 Unauthorized</strong>：请求未经授权，需进行身份验证。</li><li><strong>403 Forbidden</strong>：服务器拒绝访问，权限不足。</li><li><strong>404 Not Found</strong>：请求资源不存在。</li><li><strong>500 Internal Server Error</strong>：服务器内部错误，无法完成请求。</li><li><strong>503 Service Unavailable</strong>：服务器暂时不可用，可能过载或维护。</li></ul><p>更详细的 <strong>HTTP状态码</strong> 总结：</p><p>1xx - 信息性状态码（暂时响应）</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>100</td><td>Continue（继续）</td><td>服务器已收到请求，客户端继续发送请求的剩余部分</td></tr><tr><td>101</td><td>Switching Protocols（切换协议）</td><td>服务器同意切换协议</td></tr></tbody></table><p>2xx - 成功状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功，服务器返回请求的数据</td></tr><tr><td>201</td><td>Created</td><td>请求成功且服务器创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>请求已接受，但未处理完成</td></tr><tr><td>204</td><td>No Content</td><td>请求成功，但没有内容返回</td></tr></tbody></table><p>3xx - 重定向状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently（永久移动）</td><td>请求的资源已永久移动到新URL</td></tr><tr><td>302</td><td>Found（临时移动）</td><td>请求的资源临时移动</td></tr><tr><td>303</td><td>See Other</td><td>请求的响应可以在另一个URL获得</td></tr><tr><td>304</td><td>Not Modified（未修改）</td><td>资源未修改，客户端可使用缓存内容</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向，方法不变</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>永久重定向，方法不变</td></tr></tbody></table><p>4xx - 客户端错误状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>400</td><td>Bad Request（错误请求）</td><td>请求参数有误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized（未授权）</td><td>需要身份验证，用户未登录或认证失败</td></tr><tr><td>403</td><td>Forbidden（禁止访问）</td><td>服务器拒绝请求，权限不足</td></tr><tr><td>404</td><td>Not Found（未找到）</td><td>请求资源不存在</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求方法不被允许</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时</td></tr><tr><td>429</td><td>Too Many Requests</td><td>请求过多，限流</td></tr></tbody></table><p>5xx - 服务器错误状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error（服务器内部错误）</td><td>服务器发生错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能</td></tr><tr><td>502</td><td>Bad Gateway</td><td>网关错误，服务器作为代理时接收无效响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务器不可用，可能过载或维护</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>网关超时</td></tr></tbody></table><h3 id="【HTTP请求方法】"><a href="#【HTTP请求方法】" class="headerlink" title="【HTTP请求方法】"></a>【HTTP请求方法】</h3><h4 id="1-GET"><a href="#1-GET" class="headerlink" title="1. GET"></a>1. GET</h4><ul><li><strong>作用</strong>：请求访问指定资源，获取资源的表示（数据）。</li><li><strong>特点</strong>：只读操作，不应有副作用，幂等（多次请求结果相同）。</li><li><strong>常用场景</strong>：获取网页内容、查询数据等。</li></ul><h4 id="2-POST"><a href="#2-POST" class="headerlink" title="2. POST"></a>2. POST</h4><ul><li><strong>作用</strong>：向服务器提交数据，用于创建资源或触发操作。</li><li><strong>特点</strong>：非幂等，可能产生副作用（比如新增数据）。</li><li><strong>常用场景</strong>：提交表单、上传文件、创建新资源。</li></ul><h4 id="3-PUT"><a href="#3-PUT" class="headerlink" title="3. PUT"></a>3. PUT</h4><ul><li><strong>作用</strong>：更新指定资源，或者如果资源不存在则创建。</li><li><strong>特点</strong>：幂等（多次执行结果相同）。</li><li><strong>常用场景</strong>：修改用户信息、更新数据。</li></ul><h4 id="4-DELETE"><a href="#4-DELETE" class="headerlink" title="4. DELETE"></a>4. DELETE</h4><ul><li><strong>作用</strong>：删除指定资源。</li><li><strong>特点</strong>：幂等。</li><li><strong>常用场景</strong>：删除数据库中的记录或文件。</li></ul><h4 id="5-HEAD"><a href="#5-HEAD" class="headerlink" title="5. HEAD"></a>5. HEAD</h4><ul><li><strong>作用</strong>：类似GET请求，但只请求响应头，不返回响应体。</li><li><strong>用途</strong>：检测资源是否存在、检查更新、获取元数据。</li></ul><h4 id="6-OPTIONS"><a href="#6-OPTIONS" class="headerlink" title="6. OPTIONS"></a>6. OPTIONS</h4><ul><li><strong>作用</strong>：询问服务器支持的HTTP方法。</li><li><strong>用途</strong>：跨域请求时，浏览器发起预检请求。</li></ul><h4 id="7-PATCH"><a href="#7-PATCH" class="headerlink" title="7. PATCH"></a>7. PATCH</h4><ul><li><strong>作用</strong>：对资源进行部分修改。</li><li><strong>特点</strong>：非幂等，修改部分字段。</li><li><strong>常用场景</strong>：局部更新资源数据。</li></ul><h3 id="【HTTP请求报文结构】"><a href="#【HTTP请求报文结构】" class="headerlink" title="【HTTP请求报文结构】"></a>【HTTP请求报文结构】</h3><p>HTTP请求报文由三部分组成：</p><ol><li><strong>请求行（Request Line）</strong></li><li><strong>请求头部（Request Headers）</strong></li><li>空行</li><li><strong>请求体（Request Body）</strong>（可选）</li></ol><h4 id="请求行（Request-Line）"><a href="#请求行（Request-Line）" class="headerlink" title="请求行（Request Line）"></a><strong>请求行（Request Line）</strong></h4><p>请求行是请求报文的第一行，包含三个部分：<code>方法 请求URL 协议版本</code></p><ul><li><strong>方法（Method）</strong>：表示客户端希望对资源执行的操作，比如：<ul><li>GET（请求资源）</li><li>POST（提交数据）</li><li>PUT（更新资源）</li><li>DELETE（删除资源）</li><li>HEAD、OPTIONS、PATCH等</li></ul></li><li><strong>请求URL（Request-URI）</strong>：请求的资源地址，通常是相对路径，如 <code>/index.html</code>。</li><li><strong>协议版本（HTTP Version）</strong>：一般是 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">GET</span> /index.<span class="hljs-property">html</span> <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span><br></code></pre></td></tr></table></figure><h4 id="请求头部（Request-Headers）"><a href="#请求头部（Request-Headers）" class="headerlink" title="请求头部（Request Headers）"></a>请求头部（Request Headers）</h4><p>请求头部是若干行键值对，用于描述客户端环境、请求特性等信息。格式为：<code>字段名: 字段值</code></p><p>常见请求头字段包括：</p><ul><li><code>Host</code>：请求的主机名和端口（HTTP&#x2F;1.1中必须）</li><li><code>User-Agent</code>：客户端浏览器或工具信息</li><li><code>Accept</code>：客户端可接受的响应内容类型</li><li><code>Accept-Language</code>：客户端可接受的语言</li><li><code>Accept-Encoding</code>：客户端可接受的压缩编码</li><li><code>Connection</code>：是否保持连接（keep-alive）</li><li><code>Cookie</code>：客户端携带的Cookie信息</li><li><code>Content-Type</code>：请求体的数据类型（POST等请求才有）</li><li><code>Content-Length</code>：请求体长度</li></ul><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Host:</span> <span class="hljs-string">www.example.com</span><br><span class="hljs-attr">User-Agent:</span> <span class="hljs-string">Mozilla/5.0</span> <span class="hljs-string">(Windows</span> <span class="hljs-string">NT</span> <span class="hljs-number">10.0</span><span class="hljs-string">;</span> <span class="hljs-string">Win64;</span> <span class="hljs-string">x64)</span><br><span class="hljs-attr">Accept:</span> <span class="hljs-string">text/html,application/xhtml+xml</span><br><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span><br></code></pre></td></tr></table></figure><p><code>Content-Type</code>常用类型：</p><table><thead><tr><th>使用场景</th><th>Content-Type</th></tr></thead><tbody><tr><td>普通文本传输</td><td><code>text/plain; charset=utf-8</code></td></tr><tr><td>浏览器请求网页</td><td><code>text/html; charset=utf-8</code></td></tr><tr><td>AJAX请求JSON数据</td><td><code>application/json</code></td></tr><tr><td>HTML表单提交</td><td><code>application/x-www-form-urlencoded</code></td></tr><tr><td>文件上传</td><td><code>multipart/form-data</code></td></tr><tr><td>图片显示</td><td><code>image/png</code>、<code>image/jpeg</code></td></tr><tr><td>下载二进制文件</td><td><code>application/octet-stream</code></td></tr></tbody></table><h4 id="请求体（Request-Body）"><a href="#请求体（Request-Body）" class="headerlink" title="请求体（Request Body）"></a>请求体（Request Body）</h4><p>请求体是请求的实体内容，只有在某些请求方法中才有（如 POST、PUT）。用于发送提交的数据，比如表单数据、JSON等。</p><h3 id="【HTTP响应报文结构】"><a href="#【HTTP响应报文结构】" class="headerlink" title="【HTTP响应报文结构】"></a>【HTTP响应报文结构】</h3><p>HTTP响应报文由三部分组成：</p><ol><li><strong>响应行（Response Line）</strong></li><li><strong>响应头部（Response Headers）</strong></li><li>空行</li><li><strong>响应体（Response Body）</strong></li></ol><h4 id="响应行（Response-Line）"><a href="#响应行（Response-Line）" class="headerlink" title="响应行（Response Line）"></a>响应行（Response Line）</h4><p>响应行是响应报文的第一行，包含三个部分：<code>协议版本 状态码 状态描述</code></p><ul><li><strong>协议版本</strong>：如 HTTP&#x2F;1.1</li><li><strong>状态码（Status Code）</strong>：三位数字，表示响应状态，如：<ul><li>1xx：信息性状态</li><li>2xx：成功（200 OK）</li><li>3xx：重定向</li><li>4xx：客户端错误（404 Not Found）</li><li>5xx：服务器错误（500 Internal Server Error）</li></ul></li><li><strong>状态描述</strong>：对状态码的简短描述，如 OK、Not Found 等</li></ul><p>示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br></code></pre></td></tr></table></figure><h4 id="响应头部（Response-Headers）"><a href="#响应头部（Response-Headers）" class="headerlink" title="响应头部（Response Headers）"></a>响应头部（Response Headers）</h4><p>响应头部是若干行键值对，描述服务器和响应体的相关信息，格式同请求头：</p><p>常见响应头字段：</p><ul><li><code>Content-Type</code>：响应体的数据类型，如 <code>text/html</code>、<code>application/json</code></li><li><code>Content-Length</code>：响应体的字节长度</li><li><code>Server</code>：服务器软件信息</li><li><code>Set-Cookie</code>：服务器向客户端设置Cookie</li><li><code>Cache-Control</code>：缓存策略</li><li><code>Date</code>：响应时间</li><li><code>Connection</code>：连接状态</li></ul><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=UTF-8</span><br><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">138</span><br><span class="hljs-attr">Server:</span> <span class="hljs-string">Apache/2.4.41</span> <span class="hljs-string">(Ubuntu)</span><br><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span><br></code></pre></td></tr></table></figure><p>响应头部与响应体之间也用空行分隔。</p><h4 id="响应体（Response-Body）"><a href="#响应体（Response-Body）" class="headerlink" title="响应体（Response Body）"></a>响应体（Response Body）</h4><p>响应体包含服务器返回给客户端的具体资源内容，比如HTML页面、图片、JSON数据等。它的格式和内容由 <code>Content-Type</code> 头部决定。</p><h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><h3 id="【缓存基础】"><a href="#【缓存基础】" class="headerlink" title="【缓存基础】"></a>【缓存基础】</h3><p>浏览器缓存分为两大类：</p><ul><li><strong>强缓存（强制缓存，Fresh Cache）</strong>：直接使用缓存，不发请求给服务器。</li><li><strong>协商缓存（协商验证缓存，Conditional Cache）</strong>：先向服务器询问资源是否更新，服务器判断后决定是否返回资源。</li></ul><p>浏览器会先判断是否使用强缓存，强缓存未命中时才发起协商缓存请求。</p><h3 id="【强缓存（强制缓存）】"><a href="#【强缓存（强制缓存）】" class="headerlink" title="【强缓存（强制缓存）】"></a>【强缓存（强制缓存）】</h3><h4 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1. 工作流程"></a>1. 工作流程</h4><p>浏览器访问资源时：</p><ul><li>先检查该资源是否存在且未过期的强缓存。</li><li>如果存在且有效，直接从缓存读取，不发起网络请求。</li><li>如果强缓存失效，浏览器才会发起网络请求。</li></ul><h4 id="2-设置方式（响应头）"><a href="#2-设置方式（响应头）" class="headerlink" title="2. 设置方式（响应头）"></a>2. 设置方式（响应头）</h4><p>服务器通过HTTP响应头告诉浏览器缓存资源的有效时间：</p><ul><li><code>Expires</code>（HTTP&#x2F;1.0，绝对时间，格式固定）</li><li><code>Cache-Control</code>（HTTP&#x2F;1.1，推荐，优先级更高）</li></ul><p><strong>具体说明</strong></p><ul><li><code>Expires: &lt;GMT时间&gt;</code><br>表示资源过期时间，客户端只要在过期时间内，使用缓存。但<code>Expires</code>是绝对时间，可能受客户端和服务器时间不一致影响。</li><li><code>Cache-Control: max-age=&lt;秒&gt;</code><br>指定资源在客户端缓存的最大生命周期（秒）。max-age优先级高于Expires。</li><li>其他 Cache-Control 指令：<ul><li><code>public</code>：所有缓存都可以缓存</li><li><code>private</code>：只有私有缓存可缓存（浏览器）</li><li><code>no-cache</code>：不使用强缓存（需协商缓存）</li><li><code>no-store</code>：不缓存</li></ul></li></ul><h4 id="3-举例"><a href="#3-举例" class="headerlink" title="3. 举例"></a>3. 举例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-string">max-age=3600</span><br><span class="hljs-attr">Expires:</span> <span class="hljs-string">Wed,</span> <span class="hljs-number">11</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2025 12:00:00 </span><span class="hljs-string">GMT</span><br></code></pre></td></tr></table></figure><p>表示缓存1小时有效期，1小时内访问不请求服务器。</p><h3 id="【协商缓存（协商验证缓存）】"><a href="#【协商缓存（协商验证缓存）】" class="headerlink" title="【协商缓存（协商验证缓存）】"></a>【协商缓存（协商验证缓存）】</h3><h4 id="1-工作流程-1"><a href="#1-工作流程-1" class="headerlink" title="1. 工作流程"></a>1. 工作流程</h4><ul><li>当强缓存失效，浏览器会带上上次缓存时服务器返回的<strong>标识</strong>向服务器发起请求，询问资源是否更新。</li><li>服务器根据标识判断资源是否改变：<ul><li>如果未改变，返回 <code>304 Not Modified</code>，浏览器使用缓存资源。</li><li>如果改变，返回新的资源和状态码 <code>200 OK</code>。</li></ul></li></ul><h4 id="2-设置方式（请求头-响应头）"><a href="#2-设置方式（请求头-响应头）" class="headerlink" title="2. 设置方式（请求头 + 响应头）"></a>2. 设置方式（请求头 + 响应头）</h4><p>服务器通过响应头告诉客户端标识，下次请求时客户端会带上验证标识。</p><p><strong>两种常用验证方式</strong></p><table><thead><tr><th>验证方式</th><th>说明</th><th>相关头部</th></tr></thead><tbody><tr><td><strong>Last-Modified &#x2F; If-Modified-Since</strong></td><td>通过最后修改时间比较是否更新</td><td>服务器响应头：<code>Last-Modified</code>   浏览器请求头：<code>If-Modified-Since</code></td></tr><tr><td><strong>ETag &#x2F; If-None-Match</strong></td><td>通过文件的唯一标识（哈希等）比较是否更新</td><td>服务器响应头：<code>ETag</code>   浏览器请求头：<code>If-None-Match</code></td></tr></tbody></table><h4 id="具体过程举例"><a href="#具体过程举例" class="headerlink" title="具体过程举例"></a>具体过程举例</h4><ol><li>服务器返回：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Last-Modified:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">11</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2025 08:00:00 </span><span class="hljs-string">GMT</span><br><span class="hljs-attr">ETag:</span> <span class="hljs-string">&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>浏览器下次请求带：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">If-Modified-Since:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">11</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2025 08:00:00 </span><span class="hljs-string">GMT</span><br><span class="hljs-attr">If-None-Match:</span> <span class="hljs-string">&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>服务器判断资源是否变化：</li></ol><ul><li>没变化，返回状态码 <code>304 Not Modified</code>，无响应体。</li><li>变化，返回状态码 <code>200 OK</code> 和新的资源。</li></ul><h3 id="【对比总结】"><a href="#【对比总结】" class="headerlink" title="【对比总结】"></a>【对比总结】</h3><table><thead><tr><th>方面</th><th>强缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td>作用</td><td>直接使用缓存，完全不请求服务器</td><td>先向服务器询问资源是否改变</td></tr><tr><td>触发条件</td><td>缓存有效期内</td><td>缓存过期或无强缓存时触发</td></tr><tr><td>缓存时间控制</td><td>通过 <code>Cache-Control</code> &#x2F; <code>Expires</code> 设置</td><td>服务器通过<code>Last-Modified</code>&#x2F;<code>ETag</code>提供验证标识</td></tr><tr><td>网络请求</td><td>无</td><td>有请求，但服务器可能返回304</td></tr><tr><td>性能</td><td>更快，不发请求</td><td>需要发请求但节省传输资源</td></tr><tr><td>是否返回响应体</td><td>不返回</td><td>未变时不返回，变时返回</td></tr></tbody></table><h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><p>浏览器从你输入网址开始，到页面呈现在屏幕上，大致经历以下步骤：</p><h4 id="1-解析-HTML-→-生成-DOM-树"><a href="#1-解析-HTML-→-生成-DOM-树" class="headerlink" title="1. 解析 HTML → 生成 DOM 树"></a>1. 解析 HTML → 生成 DOM 树</h4><ul><li>浏览器接收到 HTML 文本后，开始<strong>从上到下解析</strong>HTML标记。</li><li>解析过程中，浏览器会根据标签构建<strong>DOM（Document Object Model）树</strong>，DOM树是页面的结构化内存表示，包含所有元素节点、文本节点等。</li><li>每个 HTML 标签对应 DOM 树中的一个节点。</li><li>注意：如果遇到 <code>&lt;script&gt;</code> 标签，且没有设置 <code>async</code> 或 <code>defer</code>，浏览器会<strong>暂停解析HTML</strong>，先下载并执行脚本，执行完再继续解析。</li></ul><h4 id="2-解析-CSS-→-生成-CSSOM-树"><a href="#2-解析-CSS-→-生成-CSSOM-树" class="headerlink" title="2. 解析 CSS → 生成 CSSOM 树"></a>2. 解析 CSS → 生成 CSSOM 树</h4><ul><li>浏览器在解析HTML的过程中，如果遇到 <code>&lt;style&gt;</code> 标签或者外部CSS文件（<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>），会<strong>同时开始解析 CSS</strong>。</li><li>CSS解析器把 CSS 代码转换成<strong>CSSOM（CSS Object Model）树</strong>，描述所有选择器和样式规则。</li><li>CSSOM树描述了每个元素应该应用的样式。</li></ul><h4 id="3-合并-DOM-CSSOM-→-生成渲染树（Render-Tree）"><a href="#3-合并-DOM-CSSOM-→-生成渲染树（Render-Tree）" class="headerlink" title="3. 合并 DOM + CSSOM → 生成渲染树（Render Tree）"></a>3. 合并 DOM + CSSOM → 生成渲染树（Render Tree）</h4><ul><li>浏览器将 DOM树和 CSSOM树结合，生成<strong>渲染树（Render Tree）</strong>。</li><li>渲染树只包含<strong>需要渲染的节点</strong>（例如 <code>display:none</code> 的节点不会出现在渲染树中）。</li><li>渲染树的每个节点包含元素的几何信息（尺寸、颜色、字体等）以及它们的布局关系。</li></ul><h4 id="4-布局（Layout-或-Reflow）"><a href="#4-布局（Layout-或-Reflow）" class="headerlink" title="4. 布局（Layout 或 Reflow）"></a>4. 布局（Layout 或 Reflow）</h4><ul><li>浏览器根据渲染树计算每个节点的<strong>具体位置和大小</strong>（x、y坐标，宽高）。</li><li>这个过程称为布局或回流（Reflow）。</li><li>布局阶段确定元素在页面上的准确位置，供后续绘制使用。</li><li>布局依赖父元素和兄弟元素的位置关系，可能触发多次回流。</li></ul><h4 id="5-绘制（Paint）"><a href="#5-绘制（Paint）" class="headerlink" title="5. 绘制（Paint）"></a>5. 绘制（Paint）</h4><ul><li>布局完成后，浏览器会遍历渲染树，将每个节点的内容转化为实际的<strong>像素绘制指令</strong>，比如绘制文字、颜色、边框、阴影等。</li><li>绘制会生成<strong>图层</strong>（Layers），之后传递给合成器进行合成。</li></ul><h4 id="6-执行-JavaScript"><a href="#6-执行-JavaScript" class="headerlink" title="6. 执行 JavaScript"></a>6. 执行 JavaScript</h4><ul><li>浏览器遇到 <code>&lt;script&gt;</code> 标签时，如果没有 <code>async</code> 或 <code>defer</code>，会暂停 HTML 解析，<strong>下载并执行 JavaScript</strong>。</li><li>JS 脚本可以操作 DOM 和 CSSOM，改变页面结构和样式。</li><li>可能会导致重新生成渲染树、重新布局和重绘。</li><li>设置 <code>defer</code> 的脚本会延迟到 DOM 解析完成后执行。</li><li>设置 <code>async</code> 的脚本会在下载完成后立即执行，且不会阻塞 HTML 解析。</li></ul><h4 id="7-并行加载资源"><a href="#7-并行加载资源" class="headerlink" title="7. 并行加载资源"></a>7. 并行加载资源</h4><ul><li>页面中存在的资源（图片、CSS文件、JS文件、字体等）会<strong>并行向服务器发起请求</strong>。</li><li>这些资源的加载和解析可能和 HTML 解析并行，也可能会影响渲染流程（例如 CSS 解析阻塞渲染，JS 可能阻塞HTML解析）。</li><li>当这些资源加载完成，会触发对应的渲染更新。</li></ul><h1 id="Promise核心总结"><a href="#Promise核心总结" class="headerlink" title="Promise核心总结"></a>Promise核心总结</h1><h2 id="Promise的引入"><a href="#Promise的引入" class="headerlink" title="Promise的引入"></a>Promise的引入</h2><h3 id="【进程与线程】"><a href="#【进程与线程】" class="headerlink" title="【进程与线程】"></a>【进程与线程】</h3><p>程序执行的基本单位</p><ol><li>进程（Process）</li></ol><ul><li>程序的一次运行实例，拥有独立的资源和内存空间。</li><li>是操作系统分配资源的最小单位。</li><li>可以并发存在多个进程，互相之间相对独立。</li></ul><ol start="2"><li>线程（Thread）</li></ol><ul><li>线程是进程中的一个执行单元，是 CPU 调度的基本单位。</li><li>一个进程中可以有多个线程，这些线程共享该进程的资源。</li><li>多线程的出现使得<strong>并发处理任务</strong>成为可能。</li></ul><ol start="3"><li>JavaScript 的运行环境</li></ol><ul><li>JavaScript 是<strong>单线程语言</strong>，即同一时间只能执行一个任务。</li><li>其运行环境（如浏览器、Node.js）通过<strong>事件循环（Event Loop）</strong>机制，配合<strong>异步 API（如定时器、网络请求）</strong>实现了伪“并发”效果。</li></ul><h3 id="【同步】"><a href="#【同步】" class="headerlink" title="【同步】"></a>【同步】</h3><p>控制执行流程的两种模式</p><p><strong>1. 同步（Synchronous）</strong></p><ul><li>所有操作按顺序执行，当前操作未完成时，程序会阻塞，等待执行完毕后再继续。</li><li>简单、直观，但当某一步操作耗时时，<strong>整个程序都被阻塞</strong>。</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">blockingTask</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">5000</span>) &#123;&#125; <span class="hljs-comment">// 阻塞5秒</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;任务完成&quot;</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始任务&quot;</span>);<br><span class="hljs-title function_">blockingTask</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;后续代码&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出顺序为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">开始任务<br>任务完成<br>后续代码<br></code></pre></td></tr></table></figure><p><strong>2. 为什么不能一直用同步模式？</strong></p><p><font color="#409eff">同步的最大问题是阻塞</font>，所谓阻塞就是一段代码不执行完毕其后的所有代码也不会执行。比如上述的案例中，如果sum()函数执行速度比较慢，由于我们编写的是同步代码，所以在sum()执行完之前其后所有代码都不会执行，也就是它会阻塞后边代码的执行。像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-keyword">let</span> begin = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">while</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - begin &lt; <span class="hljs-number">10000</span>)&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一行打印&quot;</span>)<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二行打印&quot;</span>)<br></code></pre></td></tr></table></figure><p>上例中sum()执行时会停顿10秒，10秒以后才会返回结果，由于是同步执行的代码，所以sum()会阻塞其后所有代码的执行，导致整个程序的执行速度极差。</p><p>在现代应用中，经常需要进行一些<strong>高耗时的操作</strong>，如：</p><ul><li>向服务器请求数据</li><li>读写本地文件</li><li>等待用户输入或响应</li></ul><p>如果这些操作都采用同步模式，将导致：</p><ul><li>用户界面冻结</li><li>网络请求阻塞主线程</li><li>整体程序无响应</li></ul><p>因此，我们需要引入<strong>异步机制</strong>。</p><h3 id="【异步】"><a href="#【异步】" class="headerlink" title="【异步】"></a>【异步】</h3><ol><li><font color="#409eff">异步的基本思路: “耗时任务交给宿主环境，完成后以事件的形式再交还 JS 主线程执行回调。”</font></li></ol><ul><li>将耗时任务“挂起”，不会阻塞主线程。</li><li>当任务完成后，通过某种机制“通知”主程序进行处理。</li><li>异步任务不是 JavaScript 引擎执行的，而是由“宿主环境的底层系统组件”执行的</li></ul><table><thead><tr><th>异步类型</th><th>真正执行者</th></tr></thead><tbody><tr><td>setTimeout</td><td>浏览器 Timer 线程</td></tr><tr><td>fetch &#x2F; xhr</td><td>浏览器 Network 线程 + OS</td></tr><tr><td>DOM 事件</td><td>浏览器 UI 线程</td></tr><tr><td>Promise</td><td>JS 引擎（微任务调度）</td></tr></tbody></table><p><strong>2. JavaScript 的异步实现方式：回调函数</strong></p><p>最早的异步处理方法是使用<strong>回调函数（Callback）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncSum</span>(<span class="hljs-params">a, b, callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">callback</span>(a + b);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">asyncSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;结果是:&quot;</span>, result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">结果是: <span class="hljs-number">3</span> （延迟<span class="hljs-number">1</span>秒后输出）<br></code></pre></td></tr></table></figure><p>对于其他的编程语言，如java，它的处理方式简单且粗暴，即多线程。线程是计算机中运算的执行者，我们代码需要线程来执行，它是一个干活的人。但是对于Node.js来说，它本身就是单线程的，没有创建多个线程的能力（就像人不能影分身一样）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> a + b<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一行打印&quot;</span>)<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二行打印&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述代码，我们将计算操作放入到了setTimeout中，同样是等待10s，但是setTimeout不会阻塞其他代码的执行，而是在10秒后将函数放入到任务队列中，这样一来就可以很好的解决掉阻塞的问题。</p><p>但与此同时也产生了一个问题，函数确实不会阻塞后续代码的执行了，但是由于函数的返回值设置到了setTimeout的回调函数中调用sum时便无法获取到函数的计算结果了，此时我们得到的结果是undefined。这也是异步的一个特点，<font color="#409eff">异步代码的执行结果无法通过返回值获得</font>，返回值只能用来获取同步代码的执行结果。那么如何获取异步代码的执行结果呢？答案只有一个——回调函数，异步代码通常都需要一个回调函数作为参数，当异步代码执行完毕取得结果时便可以将结果作为回调函数的参数进行传递，这样我们便可以在回调函数中来读取结果，并完成后续操作了，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, cb</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">cb</span>(a + b)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一行打印&quot;</span>)<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二行打印&quot;</span>)<br></code></pre></td></tr></table></figure><p>通过这样一个介绍，相信你对异步多少能够了解了一些。在java这种多线程的编程语言中，通常需要一个叫做线程池的东西，在程序中随时要有一些线程在线程池中待命，当有任务时需要调用线程去执行程序以完成功能，当线程池中线程不够使用时还必须要创建新的线程协助完成任务，当线程池中的闲置线程过多时也必须要清理掉一些多余的线程。无论是线程池还是线程的管理程序都需要耗费一定的系统的性能，这就要求像java这种多线程的编程语言，必须要运行在一些性能较好的服务器中。</p><p>而Node.js这种异步的编程语言，由于始终只有一个线程在干活，不需要线程池存储线程，也无需线程的管理调用程序去管理线程，所以它对服务器的要求就比较低，从而也就降低了服务器的使用成本。但是异步的编程的方式也提升了程序的复杂度，使代码变得难以理解，于是如何简化异步代码，让其更容易编写于维护就是我们下一步要面临的问题。</p><p><strong>引入回调函数：异步的初级实现</strong></p><ol><li>回调函数的定义</li></ol><ul><li>回调函数是将一个函数作为参数传入另一个函数，在该函数执行结束后再调用这个“回调函数”。</li><li>适用于处理延迟返回的结果，如网络请求、定时器等。</li></ul><ol start="2"><li>为什么异步需要回调函数？</li></ol><ul><li>因为异步操作不会立即返回结果，所以必须通过某种方式在<strong>任务完成时通知我们</strong>。</li><li>回调函数就是这个“通知机制”的基本实现。</li></ul><ol start="3"><li>回调函数的局限性</li></ol><p>随着异步操作的增多，程序结构容易变得复杂，出现“<font color="#409eff">回调地狱”（Callback Hell）</font>问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">asyncSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">asyncSum</span>(r1, <span class="hljs-number">3</span>, <span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">asyncSum</span>(r2, <span class="hljs-number">4</span>, <span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;最终结果:&quot;</span>, r3);<br>        &#125;);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>问题包括：</p><ul><li>嵌套层级深，可读性差</li><li>错误处理复杂，不易维护</li><li>缺乏统一的流程控制机制</li></ul><p><font color="#409eff">因此Promise就是回调函数的替代方案。</font></p><h3 id="【Promise】"><a href="#【Promise】" class="headerlink" title="【Promise】"></a>【Promise】</h3><p><strong>1. 为什么引入 Promise？</strong></p><p>Promise 的设计目标是：</p><ul><li>提供一种统一的方式来处理异步操作</li><li>改善回调地狱问题</li><li>提供更好的错误处理机制</li><li>支持链式调用，流程清晰</li></ul><p><strong>2. Promise 的本质</strong></p><ul><li>是一个<strong>对象</strong>，用于表示一个异步操作最终的<strong>完成或失败</strong>。</li><li>有三种状态：<ul><li><code>pending</code>：初始状态</li><li><code>fulfilled</code>：操作成功，调用 <code>resolve</code></li><li><code>rejected</code>：操作失败，调用 <code>reject</code></li></ul></li></ul><p><strong>3. 基本语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncSum</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(a + b);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-title function_">asyncSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncSum</span>(result, <span class="hljs-number">3</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncSum</span>(result, <span class="hljs-number">4</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;最终结果:&quot;</span>, result);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;出错了:&quot;</span>, error);<br>    &#125;);<br></code></pre></td></tr></table></figure><p><strong>4. Promise 的优势</strong></p><ul><li><strong>结构清晰</strong>，避免回调嵌套</li><li><strong>链式调用</strong>，流程线性表达</li><li><strong>统一错误处理</strong>，通过 <code>catch</code> 实现异常捕获</li></ul><h3 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h3><table><thead><tr><th>问题</th><th>原始方案</th><th>存在的问题</th><th>改进方案</th></tr></thead><tbody><tr><td>耗时操作阻塞程序</td><td>同步代码执行</td><td>用户体验差，界面卡顿</td><td>异步执行</td></tr><tr><td>异步结果处理机制</td><td>回调函数（callback）</td><td>可读性差，嵌套复杂，难调试</td><td>Promise</td></tr><tr><td>多异步操作流程控制复杂</td><td>多层嵌套</td><td>缺乏统一流程管理</td><td>Promise 链式调用</td></tr><tr><td>异步错误难以处理</td><td>try-catch 无效</td><td>异常不易传播</td><td><code>.catch()</code></td></tr></tbody></table><p><font color="#409eff">面试回答模板：</font></p><p>在 JavaScript 中，由于它是单线程的，所有任务默认是同步执行的。但现实开发中，很多操作是耗时的，比如网络请求、文件读取、定时器等。如果这些都用同步方式处理，就会阻塞主线程，导致页面卡顿甚至无响应。</p><p>为了解决这个问题，JavaScript 引入了异步机制，而最早的异步处理方式就是回调函数。通过给异步操作传入一个回调函数，当操作完成后再调用这个回调来处理结果。</p><p>但回调函数有明显的缺点，尤其是当多个异步操作嵌套调用时，会形成所谓的“回调地狱”，代码层层嵌套、结构混乱、难以维护和调试。同时，错误处理也非常分散，不利于统一管理。</p><p>为了解决这些问题，ES6 引入了 Promise。它本质上是一个用于表示异步操作最终结果的对象。Promise 可以更清晰地组织异步代码，支持链式调用，把异步流程写得像同步代码一样清晰。它还提供统一的错误捕获机制，使得异步代码更加易读、易维护。</p><h2 id="Promise介绍"><a href="#Promise介绍" class="headerlink" title="Promise介绍"></a>Promise介绍</h2><blockquote><p><a href="https://lilichao.com/?p=6460">异步编程 – 李立超 | lilichao.com</a></p></blockquote><p>只要是通过回调函数来获取异步的结果，就一定会遇到回调地狱之类的问题。为了解决这个问题，JS为我们提供一个对象 —— Promise，Promise意为承诺，它可以用来存储一个值，并确保在你需要将这个值返回。这一点听上去似乎也并没有什么新奇的地方，任何一个对象都可以存储值，为什么非得用Promise呢？说到这就必须得看看Promise特别的存取数据的方式了！</p><h3 id="【创建Promise】"><a href="#【创建Promise】" class="headerlink" title="【创建Promise】"></a>【创建Promise】</h3><p>Promise存储值的方式非常的特别，我们先来看看它的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(executor)<br></code></pre></td></tr></table></figure><p>创建Promise时需要一个executor（执行器）为参数，执行器是一个回调函数，进一步调用它大概长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><p>回调函数在执行时会收到两个参数，两个参数都是函数。第一个函数通常命名为resolve，第二个函数通常会命名为reject。向Promise中存储值的关键就在于这两个函数，可以将想要存储到Promise中的值作为函数的参数传递，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样我们就将”哈哈”这个字符串存储到了Promise中，那么问题又来了，为什么需要两个函数存储值呢？很简单，resolve用来存储运行正确时的数据，reject用来存储运行出错时的错误信息。我们在使用Promise时需要根据不同的情况，调用不同的函数来存储不同的数据。</p><p>Promise为什么整了如此复杂的一种方式来存储数据呢？如果仅仅是存储其他的数据，这么做确实有点脱了放。但是Promise是专门为了异步调用而生的，所以Promise中存储的主要是异步调用的数据，也就是那些本来需要通过回调函数来传递的数据。在Promise中，可以直接调用异步代码，在异步代码执行完毕后直接调用resolve或reject来将执行结果存储到Promise中，这就解决了异步代码无法设置返回值的问题。换句话说，异步代码的执行结果可以直接存储到Promise中，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上例中通过setTimeout实现了一个异步调用，定时器会在10秒后执行，并调用resolve将”哈哈”存储到Promise中。现在你应该能够理解为什么Promise有这么一个奇怪的存储值的方式了吧？</p><h3 id="【获取Promise中的数据】"><a href="#【获取Promise中的数据】" class="headerlink" title="【获取Promise中的数据】"></a>【获取Promise中的数据】</h3><p>Promise存储数据的方式奇特，读取方式同样特殊。我们需要通过Promise的实例方法来读取存储到Promise中的数据。现在我们有这样一个Promise，Promise中通过resolve存储了一个数据”哈哈”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then是Promise的实例方法，通过该方法可以获取到Promise中存储的数据。它需要一个回调函数作为参数，Promise中存储的数据会作为回调函数的实参返回给我们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// &quot;哈哈&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>注意：这种方式只适合读取通过resolve存储的数据，如果存储数据时出现了错误，或者是通过reject存储的数据，这种方式是读取不到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;出错了！&quot;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上边的两块代码都是读取不到数据的，而且运行时会在控制台报出错误信息。这是因为，then的第一个参数只负责读取Promise中代码正常执行的结果，也就是只有Promise中数据正常时才会被调用。当Promise中的代码出错，或通过reject来添加数据时，我们还需要为其指定第二个参数来处理错误。</p><p>then的第二个参数同样是一个回调函数，两个回调的函数的结构相同，不同点在于第一个回调函数会在没有异常时被调用。而第二个函数会在出现错误（或通过reject存储数据）时调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;主动抛出错误&quot;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上边两个案例中，then的第二个回调函数会执行。执行时异常信息或时reject中返回的数据会作为参数传递。现实开发中，第二个回调函数通常会用来编写异常处理的代码。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在Promise中维护着两个隐藏的值PromiseResult和PromiseState，PromiseResult是Promise中真正存储值的地方，在Promise中无论是通过resolve、reject还是报错时的异常信息都会存储到PromiseResult中。PromiseState用来表示Promise中值的状态，Promise一共有三种状态：pending、fulfilled、rejected。pending是Promise的初始化状态，此时Promise中没有任何值。fulfilled是Promise的完成状态，此时表示值已经正常存储到了Promise中（通过resolve）。rejected表示拒绝，此时表示值是通过reject存储的或是执行时出现了错误。</p><blockquote><p>状态一旦从 <code>pending</code> 转换为 <code>fulfilled</code> 或 <code>rejected</code>，<strong>就不可逆转</strong>。因此resolve()和reject()函数只能有一个执行且只能执行一次。</p></blockquote><p>当我们调用Promise的then方法时，相当于为Promise设置了一个回调函数，换句话说，<font color="#409eff">then中的回调函数不会立即执行，而是在Promise的PromiseState发生变化时才会执行</font>。如果PromiseState从pending变成了fulfilled则then的第一个回调函数执行，且PromiseResult的值作为参数传递给回调函数。如果PromiseState从pending变成了rejected则then的第二个回调函数执行，且PromiseResult的值作为参数传递给回调函数。</p><img src="/2025/12/17/NodeJS/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20221010132511667-1024x574.png" class title="img"><p><font color="#409eff">then执行后每次总会返回一个新的Promise</font>，并将then中回调函数的返回值存储到这个Promise中，如果没有指定返回值则新Promise中不会存储任何值。如果 <code>.then()</code> 的回调中<strong>返回的不是一个 Promise（而是普通值）</strong>，那它会被自动包装成一个<strong>立即 resolve 的 Promise</strong>，并作为<strong>下一个 <code>.then()</code> 的输入值</strong>继续执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> promise2 = promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> promise3 = promise2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在简化一些可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>第一个then用来读取上边我们创建的Promise中存储的结果，第二个then用来读取第一个then所返回的结果，依此类推我们就可以根据需要一直then下去，如此便解决了“回调地狱”的问题。</p><p>有了Promise后，在异步函数中我们便不再需要通过回调函数来返回结果，取而代之的是返回一个Promise，并将异步执行的结果存储到Promise中，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(a + b)<br>        &#125;, <span class="hljs-number">10000</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于sum的返回值是一个Promise，所以我们不在需要通过回调函数来读取结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;结果为：&quot;</span>, result) <span class="hljs-comment">// 结果为： 579</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>如果需要连续多次调用，也不会在有“回调地狱的问题”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br></code></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>除了then以外，Promise中还有一个catch方法，catch和then使用方式类似，但是catch中只需要一个回调函数作为参数。catch中回调函数的作用等同于then中的第二个回调函数，会在执行出错时被调用。既然有了then的第二个参数，为什么还需要一个catch呢？两个回调函数都写到then中，会导致代码不够清晰，但是多了一个catch后立刻就变的不一样了，开发时通常会在then中编写正常运行时的代码，catch中编写出现异常后要执行的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;出错了&quot;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// 出现异常，then中只传了一个回调函数，无法读取数据</span><br><span class="hljs-comment">// promise.then((data) =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(data)</span><br><span class="hljs-comment">// &#125;) </span><br><br><span class="hljs-comment">// 出现异常，可以通过catch来读取数据</span><br>promise.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>&#125;)<br></code></pre></td></tr></table></figure><p>当Promise中代码执行出错时（或者reject执行时），如果我们调用的是catch来处理数据，则Promise会将错误信息传递给catch的回调函数，我们便可以在catch中处理异常，同时catch回调函数的返回值会作为下一步Promise中的数据向下传递。如果我们调用了then来处理数据，同时没有传递第二个参数，这时then是不会执行的，而是将错误信息直接添加到下一步返回的Promise中，由后续的方法处理。在后续调用中如果有catch或then的第二个参数，则正常处理。如果没有，则报错。</p><p>简言之，处理Promise时，如果没有对Promise中的异常进行处理（无论是then的二参数，还是catch），则异常信息总是会封装到下一步的Promise中进行传递，直到找到异常处理的代码位置，如果一直没有处理，则报错。</p><p>这种设计方式使得我们可以在任意的位置对Promise的异常进行处理，例如有如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.7</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;出错了&quot;</span>)<br>        &#125;<br>        <span class="hljs-title function_">resolve</span>(a + b)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br></code></pre></td></tr></table></figure><p>上例代码中，sum函数有一定的几率会出现异常，但是我们并不确定何时会出现异常，这时有了catch就变的非常的方便，因为在出现异常后所有的then在异常处理前都不会执行，所以我们可以将catch写在调用链的最后，这样无论哪一步出现异常，我们都可以在最后统一处理。像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哎呀出错了，随便返回一个吧&quot;</span>, <span class="hljs-number">8888</span>))<br></code></pre></td></tr></table></figure><p>当然如果我们想在中间处理异常也是没有问题的，只是需要注意在链式调用中间处理异常时，由于后续还有then要执行，所以一定不要忘了考虑是否需要在catch中返回一个结果供后续的Promise使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 也可以在调用链的中间处理异常</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了，我选择忽略这个错误，重新计算&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哎呀出错了，随便返回一个吧&quot;</span>, <span class="hljs-number">8888</span>))<br></code></pre></td></tr></table></figure><p>还有一点要强调一下，<font color="#409eff">在Promise正常执行的情况下如果遇到catch，catch是不会执行的，此时Promise中的结果会自动传递给下一个Promise供后续使用</font>。</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally也是Promise的实例方法之一，和then、catch不同，无论何种情况finally中的回调函数总会执行，通常我们在finally中定义一些无论Promise正确执行与否都需要处理的工作。注意，finally的回调函数不会接收任何参数，同时finally的返回值也不会成为下一步的Promise中的结果。简单说，finally只是编写一些必须要执行的代码，不会对Promise产生任何实质的影响。</p><h3 id="【Promise静态方法】"><a href="#【Promise静态方法】" class="headerlink" title="【Promise静态方法】"></a>【Promise静态方法】</h3><table><thead><tr><th>方法名</th><th>简介</th></tr></thead><tbody><tr><td><code>Promise.resolve(value)</code></td><td>创建一个立即成功（fulfilled）的 Promise，值为 <code>value</code>（可以是普通值或另一个 Promise）</td></tr><tr><td><code>Promise.reject(reason)</code></td><td>创建一个立即失败（rejected）的 Promise，原因为 <code>reason</code></td></tr><tr><td><code>Promise.all(iterable)</code></td><td>所有 Promise 成功，整体才成功；有一个失败就失败（并抛出第一个失败的原因）</td></tr><tr><td><code>Promise.allSettled(iterable)</code></td><td>等待所有 Promise 都完成（无论成功或失败），返回每个结果的状态和对应值</td></tr><tr><td><code>Promise.race(iterable)</code></td><td>只看谁“先完成”（不论成功或失败），第一个 settle 的结果会被采用</td></tr><tr><td><code>Promise.any(iterable)</code></td><td>任意一个成功就整体成功，所有都失败才失败（返回一个 <code>AggregateError</code>）</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Promise.resolve</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// 输出 42</span><br><br><span class="hljs-comment">// Promise.reject</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)); <span class="hljs-comment">// 输出 Error</span><br><br><span class="hljs-comment">// Promise.all</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// Promise.race</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">res</span>(<span class="hljs-string">&#x27;A&#x27;</span>), <span class="hljs-number">100</span>)),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">res</span>(<span class="hljs-string">&#x27;B&#x27;</span>), <span class="hljs-number">200</span>))<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// &#x27;A&#x27;</span><br><br><span class="hljs-comment">// Promise.any</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;fail1&quot;</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;first success&quot;</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;second success&quot;</span>)<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// &#x27;first success&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="【总结】-1"><a href="#【总结】-1" class="headerlink" title="【总结】"></a>【总结】</h3><table><thead><tr><th>问题</th><th>Promise 解决方式</th></tr></thead><tbody><tr><td>回调地狱（嵌套多、难阅读）</td><td>支持链式调用，使逻辑扁平化</td></tr><tr><td>错误分散、难统一处理</td><td>支持 <code>.catch()</code> 集中处理</td></tr><tr><td>同步代码无法获取异步结果</td><td>使用 <code>resolve</code> 显式返回结果</td></tr><tr><td>多个异步任务难以组织</td><td>可以组合 Promise.all、Promise.race 等</td></tr></tbody></table><p><font color="#409eff">面试模板：</font></p><p><strong>Promise 是 ES6 引入的一个构造函数，用来解决传统异步编程中回调地狱、回调嵌套等问题。</strong>它本质上是一个对象，用来<strong>存储异步操作的结果</strong>，并提供链式调用和统一的错误处理能力。在传统回调方式中，如果多个异步操作相互依赖，我们需要层层嵌套回调，代码结构混乱，可读性差，异常处理也分散，不易维护。而 Promise 的出现就是为了解决这些问题。</p><p>存储数据时，在Promise中维护着两个隐藏的值PromiseResult和PromiseState，PromiseResult是Promise中真正存储值的地方，在Promise中无论是通过resolve、reject还是报错时的异常信息都会存储到PromiseResult中。PromiseState用来表示Promise中值的状态，Promise一共有三种状态：pending、fulfilled、rejected。pending是Promise的初始化状态，此时Promise中没有任何值。fulfilled是Promise的完成状态，此时表示值已经正常存储到了Promise中（通过resolve）。rejected表示拒绝，此时表示值是通过reject存储的或是执行时出现了错误。<font color="#409eff">异步任务完成后，通过调用 <code>resolve</code> 或 <code>reject</code> 将结果“写入” Promise 对象，而不是通过回调函数“传出”。</font></p><p>调用数据时，使用 <code>.then()</code> 可以注册回调函数，用于处理 <code>resolve</code> 或 <code>reject</code> 的结果。每次调用 <code>.then()</code> 都会返回一个<strong>新的 Promise</strong>，并把上一个回调的返回结果继续向下传递，实现<strong>链式调用</strong>，避免了回调嵌套。<code>.catch()</code> 方法用于统一捕获 Promise 中的异常，不再需要在每一步都处理错误。当我们调用Promise的then方法时，相当于为Promise设置了一个回调函数，换句话说，<font color="#409eff">then中的回调函数不会立即执行，而是在Promise的PromiseState发生变化时才会执行</font>。如果PromiseState从pending变成了fulfilled则then的第一个回调函数执行，且PromiseResult的值作为参数传递给回调函数。如果PromiseState从pending变成了rejected则then的第二个回调函数执行，且PromiseResult的值作为参数传递给回调函数。</p><p>最终解决问题：</p><ul><li><strong>回调地狱</strong> → 通过链式调用让逻辑扁平化</li><li><strong>错误分散</strong> → 通过 <code>.catch()</code> 实现集中错误处理</li><li><strong>结果不可直接返回</strong> → 通过 <code>resolve()</code> 封装返回值，延迟处理</li><li><strong>可组合性差</strong> → Promise 提供 <code>Promise.all()</code>、<code>Promise.race()</code> 等组合方法来管理多个异步任务</li></ul><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>现在有这样一段代码，你能说出它在控制台中的输出结果吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>要真正的理解这一段代码，我们必须要先搞懂Promise中的实例方法then到底是在做什么？之前在学习Promise时，我们就已经说过了，then相当于为Promise设置了一个回调函数，当Promise中的数据处理完毕时，便会调用then所设置的回调函数来继续后续任务。</p><p>上例中，我们通过Promise.resolve()创建了一个理解完成的Promise，那么按道理讲then中的回调函数应该立刻执行啊？因为Promise已经完成了啊？所以打印的顺序不应该是“1 2 3”吗？如果能想到这些那么证明之前讲解的Promise你已经理解的差不多了，但是还不够准确！</p><p>then中的回调函数会在Promise完成后被调用，但是注意并不是立刻就调用，而是采用一种和定时器类似的处理方式，讲函数放入到一个任务队列中，而队列中的代码会在调用栈中的代码执行完毕后才会执行。也就是说then中的代码总是在当前调用栈中的代码执行完后才执行。所以上边代码的输出结果应该为：“1 3 2”</p><p>那么问题又来了，如果是这样的代码呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>错误的分析：setTimeout是定时器，它会在一段时间后将函数放入到任务队列中，而我们没有指定时间，也就意味着函数会立刻放入到任务队列中。then同样也是将函数放入到任务队列中，并且这个Promise是一个立即完成的Promise所以函数也是立刻进入任务队列。那么按照执行顺序来讲，定时器在前，then在后，所以定时器中的函数应该先进入队列，队列又是先进先出的，所以应该先1后2。</p><p>上边的分析看似合理，实际上是不对的。因为setTimeout和then虽然都将函数放入到队列中，但是却不是同一个队列。为了更合理的处理异步任务，ES标准规定了一个内部的队列“PromiseJobs”，这个队列是专门用来放置由Promise产生的回调函数的（then、catch、finally），这个队列我们通常被称为“微任务队列（microtask queue）”。相对的，setTimeout这些方法是将函数放入到了“宏任务队列（macrotask queue）”。</p><p>简单来说，任务队列有两个，宏任务队列和微任务队列。代码执行时，宏任务进入到宏任务队列，微任务进入到微任务队列。那么哪些任务时微任务，哪些任务是宏任务呢？其实大部分的任务都属于宏任务。而微任务通常在代码运行时产生，通常是由Promise所创建的，Promise的then、catch、finally中的回调函数会作为微任务进入到微任务队列中。</p><p>JS代码执行时，每一个宏任务执行完毕后，JS引擎会立即执行微任务队列中的所有任务，然后才是执行宏任务队列中的任务。换句话中then中的回调函数（微任务）会先于定时器中的回调函数（宏任务）执行。所以上例中代码的执行结果应该为：“2 1”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>))<br></code></pre></td></tr></table></figure><ul><li>将一个任务加入到微任务队列中。</li></ul><h3 id="【总结】-2"><a href="#【总结】-2" class="headerlink" title="【总结】"></a>【总结】</h3><p><font color="#409eff">面试模板：</font></p><p>在 JavaScript 中，代码的执行基于<strong>事件循环机制（Event Loop）</strong>。任务按照优先级分为两类：**宏任务（MacroTask）**和**微任务（MicroTask）**。</p><p>宏任务指的是<strong>每次执行栈运行的整体任务</strong>，执行完一个宏任务后，事件循环会去执行所有当前产生的微任务，然后再进入下一个宏任务。<br> 常见的宏任务包括：<code>script</code> 整体代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node）、<code>I/O</code>、<code>UI 渲染</code> 等。</p><p>微任务的优先级比宏任务高，它会在当前宏任务执行结束后、下一个宏任务开始前立即执行。常见的微任务包括：<code>Promise.then</code>&#x2F;<code>catch</code>&#x2F;<code>finally</code> 的回调、<code>MutationObserver</code>、<code>queueMicrotask</code> 等。</p><p>事件循环的顺序是：</p><ol><li>执行一个宏任务（比如 <code>script</code> 代码）</li><li>执行过程中如果产生微任务，将它们加入微任务队列</li><li>当前宏任务执行完后，立刻执行微任务队列，直到清空</li><li>再去执行下一个宏任务</li></ol><p>这样设计的好处是：微任务可以在宏任务之间进行高优先级的补充执行，提高响应速度，比如 <code>Promise</code> 的回调总是比 <code>setTimeout</code> 更快执行。</p><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>async&#x2F;await 是ES7提出的基于Promise的解决异步的最终方案。</p><h3 id="【async函数】"><a href="#【async函数】" class="headerlink" title="【async函数】"></a>【async函数】</h3><p>async是一个加在函数前的修饰符，用来创建一个异步函数，被async定义的函数会默认返回一个Promise对象resolve的值。</p><p>因此对async函数可以直接then，返回值就是then方法传入的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async基础语法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">fun0</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val) <span class="hljs-comment">// 1,1</span><br>&#125;)<br><br><span class="hljs-comment">// ===&gt; 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">fun1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// Promise Promise</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//声明一个async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async function&#x27;</span>);<br>    <span class="hljs-comment">//情况1：返回非promise对象数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hahaha&#x27;</span>;<br>    <span class="hljs-comment">//情况2：返回是promise对象数据</span><br>    <span class="hljs-comment">/* return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="hljs-comment">// resolve(&#x27;ok&#x27;);</span><br><span class="hljs-comment">reject(&#x27;error&#x27;);</span><br><span class="hljs-comment">&#125;) */</span><br>    <span class="hljs-comment">//情况3：抛出异常</span><br>    <span class="hljs-comment">// throw new Error(&#x27;出错啦!!!&#x27;);</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">main</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h3 id="【await表达式】"><a href="#【await表达式】" class="headerlink" title="【await表达式】"></a>【await表达式】</h3><p>await 也是一个修饰符，只能放在async定义的函数内。可以理解为<strong>等待</strong>。</p><p>await 修饰的如果是Promise对象，可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p><p>注意事项</p><ul><li>await必须写在async函数中，但是async函数中可以没有await</li><li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li><li><font color="#409eff">当我们使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕以后，被放入到微任务队列中。</font></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>&#125;<br><span class="hljs-comment">// === &gt; </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> a,b,c<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        a = <span class="hljs-number">1</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        b = resolve<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        c = resolve<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 3秒后输出： 1 &quot;setTimeout&quot; &quot;function&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">time</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;,time)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">3000</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <br><span class="hljs-comment">// === &gt;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>))<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">log</span>(<span class="hljs-number">3000</span>);)<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br>        <span class="hljs-title function_">log</span>(<span class="hljs-number">2000</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 立即输出 undefined 1</span><br><span class="hljs-comment">// 1秒后输出 1000</span><br><span class="hljs-comment">// 2秒后输出 2000</span><br><span class="hljs-comment">// 3秒后输出 3000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//1、如果await右侧为非promise类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-string">&quot;非常6+7&quot;</span>;<br><br>    <span class="hljs-comment">//2、如果await右侧为promise成功类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125;)<br><br>    <span class="hljs-comment">//3、如果await右侧为promise失败类型数据,需要借助于try...catch捕获</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>        &#125;<br>&#125;<br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用async/await获取成功的结果</span><br><br><span class="hljs-comment">// 定义一个异步函数，3秒后才能获取到值(类似操作数据库)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomeThing</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;获取成功&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomeThing</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 3秒后输出：获取成功</span><br></code></pre></td></tr></table></figure><p>案例：async结合await读取文件内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1、导包</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123;promisify&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-comment">//2、将fs.readFile转化成promise风格的函数</span><br><span class="hljs-keyword">const</span> myreadfile = <span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><span class="hljs-comment">//3、声明async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//4、读取文件</span><br>        <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/4.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>);<br>    <span class="hljs-comment">//5、拼接读取文件内容</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one + two + three);<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//6、调用main函数</span><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><h3 id="【总结】-3"><a href="#【总结】-3" class="headerlink" title="【总结】"></a>【总结】</h3><p><code>async</code> 和 <code>await</code> 是 ES2017 引入的基于 Promise 的语法糖，用来以同步的书写方式处理异步操作。被 <code>async</code> 修饰的函数会始终返回一个 Promise，当函数返回普通值时会被自动包装成一个已完成状态的 Promise，当函数抛出异常时则会返回一个拒绝状态的 Promise。<code>await</code> 只能在 <code>async</code> 函数中使用，它会暂停函数的执行，等待其后表达式返回的 Promise 完成，并将完成的值作为返回结果，如果 Promise 被拒绝则会抛出异常，需要用 <code>try...catch</code> 来捕获。<font color="#409eff">即使 <code>await</code> 后面不是 Promise，也会被转换成一个已完成的 Promise 再处理。</font><code>async/await</code> 的核心优势是让异步代码看起来像同步代码一样直观，减少回调嵌套和链式 then 带来的可读性问题，同时可以通过 <code>try...catch</code> 统一捕获错误，从而让异步逻辑结构更清晰。但它并没有改变 JavaScript 单线程、事件循环的本质，底层依然是通过 Promise 和微任务机制来调度执行的。</p><h2 id="尚硅谷Promise从入门到精通"><a href="#尚硅谷Promise从入门到精通" class="headerlink" title="尚硅谷Promise从入门到精通"></a>尚硅谷Promise从入门到精通</h2><h3 id="一、前言：为什么会出现Promise"><a href="#一、前言：为什么会出现Promise" class="headerlink" title="一、前言：为什么会出现Promise?"></a>一、前言：为什么会出现Promise?</h3><p>Promise的重要性我认为没有必要多讲，概括起来说就是五个字：<strong>必！须！得！掌！握！</strong>。</p><p>而且还要掌握透彻，在实际的使用中，有非常多的应用场景我们不能立即知道应该如何继续往下执行。</p><p>最常见的一个场景就是ajax请求，通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，</p><p>这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://v0.yiketianqi.com/api?unescape=1&amp;version=v61&amp;appid=82294778&amp;appsecret=4PKVFula&amp;city=%E5%8C%97%E4%BA%AC&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到想要的数</p><p>据，之后才能开始处理数据，这样做看上去并没有什么麻烦，但如果这个时候，我们还需要另外一个ajax请求，这</p><p>个新ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就不得不等待上一个接口请求完成之</p><p>后，再请求后一个接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://v0.yiketianqi.com/api?unescape=1&amp;version=v61&amp;appid=82294778&amp;appsecret=4PKVFula&amp;city=%E5%8C%97%E4%BA%AC&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>            <br>            <span class="hljs-comment">//伪代码....</span><br>            <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>            xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;http://www.xx.com?a&#x27;</span>+xhr.<span class="hljs-property">responseText</span>);<br>            xhr.<span class="hljs-title function_">send</span>();<br>            xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span>&gt;=<span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span>&lt;<span class="hljs-number">300</span>)&#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>                        <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当出现第三个ajax(甚至更多)仍然依赖上一个请求时，我们的代码就变成了一场灾难。</p><p>这场灾难，往往也被称为<strong>回调地狱</strong>。</p><p>因此我们需要一个叫做Promise的东西，来解决这个问题，当然，除了回调地狱之外，还有个非常重要的需求就是</p><p><strong>为了代码更加具有可读性和可维护性，我们需要将数据请求与数据处理明确的区分开来</strong>。</p><p>上面的写法，是完全没有区分开，当数据变得复杂时，也许我们自己都无法轻松维护自己的代码了。</p><p>这也是模块化过程中，必须要掌握的一个重要技能，请一定重视。</p><h3 id="二、Promise是什么"><a href="#二、Promise是什么" class="headerlink" title="二、Promise是什么?"></a>二、Promise是什么?</h3><blockquote><p>Promise是异步编程的一种解决方案，比传统的解决方案回调函数更合理、更强大。</p><p>ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><p>指定回调函数的方式也变得更加灵活易懂，也解决了异步<code>回调地狱</code>的问题</p><p>旧方案是单纯使用回调函数，常见的异步操作有：定时器、fs模块、ajax、数据库操作  </p><p>从语法上说，Promise是一个构造函数；</p><p>从功能上说，Promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值。</p></blockquote><h4 id="2-1-Promise的初体验"><a href="#2-1-Promise的初体验" class="headerlink" title="2.1  Promise的初体验"></a>2.1  Promise的初体验</h4><p>创建promise对象（pending状态）</p><p>const p &#x3D; new Promise(executor);</p><p>其中：</p><p>executor函数:  执行器  (resolve, reject) &#x3D;&gt; {}</p><p>resolve函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {}</p><p>reject函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {}</p><p>executor会在Promise内部立即同步调用,异步操作在执行器中执行</p><p>实例对象调用Promise原型中的then方法来完成对结果的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//如果咱们公司今年挣钱了，年底就发奖金，否则不发</span><br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发奖金&#x27;</span>)<br>    &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;不发奖金&#x27;</span>)<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="三、使用Promise的好处"><a href="#三、使用Promise的好处" class="headerlink" title="三、使用Promise的好处?"></a>三、使用Promise的好处?</h3><h4 id="3-1-指定回调函数的方式更加灵活"><a href="#3-1-指定回调函数的方式更加灵活" class="headerlink" title="3.1  指定回调函数的方式更加灵活"></a>3.1  指定回调函数的方式更加灵活</h4><ol><li><p>旧的：必须在启动异步任务前指定</p></li><li><p>promise：启动异步任务-&gt;返回promise对象-&gt;给promise对象绑定回调函数</p><p>(甚至可以在异步任务结束后指定&#x2F;多个)</p></li></ol><h4 id="3-2-可以解决回调地狱问题，支持链式调用"><a href="#3-2-可以解决回调地狱问题，支持链式调用" class="headerlink" title="3.2 可以解决回调地狱问题，支持链式调用"></a>3.2 可以解决回调地狱问题，支持链式调用</h4><ol><li><p>什么是回调地狱？</p><p>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p></li><li><p>回调地狱的缺点?</p><p>不便于阅读</p><p>不便于异常处理</p></li><li><p>解决方案？</p><p>promise链式调用</p></li><li><p>终极解决方案？</p><p>async&#x2F;await</p></li></ol><h3 id="四、Promise实例对象的两个属性"><a href="#四、Promise实例对象的两个属性" class="headerlink" title="四、Promise实例对象的两个属性"></a>四、Promise实例对象的两个属性</h3><ul><li><p>PromiseState</p><p>此属性为promise对象的状态属性。</p><ul><li>fulfilled：成功的状态</li><li>rejected：失败的状态</li><li>pending：初始化的状态</li></ul><p>【注】状态只能由pending-&gt;fulfilled 或者是 pending-&gt;rejected</p></li><li><p>PromiseResult</p><p>此属性为promise对象的结果值（resolve以及reject函数的形参值）</p></li></ul><h3 id="五、resolve函数以及reject函数"><a href="#五、resolve函数以及reject函数" class="headerlink" title="五、resolve函数以及reject函数"></a>五、resolve函数以及reject函数</h3><ul><li>resolve：修改promise对象的状态，由pending修改到fulfilled；将实参设置到这个属性PromiseResult中。</li><li>reject：修改promise对象的状态，由pending修改到rejected；将实参设置到这个属性PromiseResult中。</li></ul><p>案例1：利用promise来进行读取文件操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.普通文件读取方式</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">//2.直接利用readfile来进行读取</span><br><span class="hljs-comment">/* fs.readFile(__dirname + &#x27;/data.txt&#x27;,(err,data)=&gt;&#123;</span><br><span class="hljs-comment">    if(err) throw err;</span><br><span class="hljs-comment">    console.log(data.toString());</span><br><span class="hljs-comment">&#125;) */</span><br><br><span class="hljs-comment">//3.利用promise来实现文件的读取</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(__dirname + <span class="hljs-string">&#x27;/data.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-title function_">reject</span>(err);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(data);<br>        &#125;<br>    &#125;)<br>&#125;); <br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>());<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例2：利用promise进行ajax请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>发送ajax请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//1.获取DOM元素对象</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//2.绑定事件</span></span></span><br><span class="language-javascript"><span class="language-xml">        btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//3.创建promise实例对象</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//4.创建ajax实例对象</span></span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//5.打开请求</span></span></span><br><span class="language-javascript"><span class="language-xml">                xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;https://www.yiketianqi.com/free/day?appid=82294778&amp;appsecret=4PKVFula&amp;unescape=1&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//6.发送请求</span></span></span><br><span class="language-javascript"><span class="language-xml">                xhr.<span class="hljs-title function_">send</span>();</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//7.利用onreadystatechange事件</span></span></span><br><span class="language-javascript"><span class="language-xml">                xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-comment">//8.判断</span></span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                        <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                            <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                        &#125;<span class="hljs-keyword">else</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                            <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">response</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">                    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">            p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(value));</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取信息失败&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>案例3：利用promise进行数据库操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://127.0.0.1/project&#x27;</span>);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">//连接成功的情况</span><br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;);<br><br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">//连接失败的情况</span><br>        <span class="hljs-title function_">reject</span>();<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//创建结构</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoteSchema</span> = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">content</span>: <span class="hljs-title class_">String</span><br>    &#125;)<br>    <span class="hljs-comment">//创建模型</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoteModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, <span class="hljs-title class_">NoteSchema</span>);<br><br>    <span class="hljs-comment">//读取操作</span><br>    <span class="hljs-title class_">NoteModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>    &#125;)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;连接失败&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例4：封装一个函数，作用是读取文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ReadFileFun</span>(<span class="hljs-params">path</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>         fs.<span class="hljs-title function_">readFile</span>(path,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>              <span class="hljs-comment">//判断</span><br>              <span class="hljs-keyword">if</span>(err)&#123;<br>                    <span class="hljs-title function_">reject</span>(err)<br>              &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">resolve</span>(data);<br>              &#125;<br>         &#125;)<br>    &#125;);<br>&#125;<br><br><span class="hljs-title class_">ReadFileFun</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>());<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>node中的promisify</p><ul><li>promisify  (只能在 NodeJS 环境中使用)</li><li>promisify 是 util 模块中的一个方法  util 是 nodeJS 的内置模块</li><li>作用: 返回一个新的函数, 函数的是 promise 风格的.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-comment">//通过 fs.readFile 创建一个新的函数</span><br><span class="hljs-keyword">const</span> mineReadFile = util.<span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><br><span class="hljs-title function_">mineReadFile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>());<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="六、Promise对象的状态"><a href="#六、Promise对象的状态" class="headerlink" title="六、Promise对象的状态"></a>六、Promise对象的状态</h3><p>Promise对象通过自身的状态来控制异步操作，Promise实例具有三种状态.</p><ul><li>异步操作未完成：pending</li><li>异步操作成功：fulfilled</li><li>异步操作失败：rejected</li></ul><p>这三种的状态的变化途径只有两种</p><ul><li>从pending(未完成)到fulfilled(成功)</li><li>从pending(未成功)到rejected(失败)</li></ul><p>一旦状态发生变化，就凝固了，不会再有新的状态变化，这也是Promise这个名字的由来，它的英语意思”承诺”，</p><p>一旦承诺生效，就不得再改变了，这也意味着Promise实例的状态变化只可能发生一次。</p><p>在Promise对象的构造函数中，将一个函数作为第一个参数。而这个函数，就是用来处理Promise的状态变化。</p><p>上面的resolve和reject都为一个函数，他们的作用分别是将状态修改为resolved和rejected。</p><p>因此，Promise的最终结果只有两种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">异步操作成功，<span class="hljs-title class_">Promise</span>实例传回一个值(value)，状态变为fulfilled.<br>异步操作失败，<span class="hljs-title class_">Promise</span>实例抛出一个错误(error),状态变为rejected<br></code></pre></td></tr></table></figure><h3 id="七、Promise的then方法"><a href="#七、Promise的then方法" class="headerlink" title="七、Promise的then方法"></a>七、Promise的then方法</h3><p>then：指定用于得到成功value的成功回调和用于得到失败reason的失败回调，<code>返回一个新的promise对象</code></p><ul><li>成功的状态：执行第一个回调函数</li><li>失败的状态：执行第二个回调函数</li></ul><p>promise.then()返回的新promise的结果状态由什么决定?</p><p>(1) 简单表达: 由then()指定的回调函数执行的结果决定</p><p>(2) 详细表达:</p><p>① 如果抛出异常, 新promise变为rejected, reason为抛出的异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>     <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;错误&#x27;</span>;<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>② 如果返回的是非promise的任意值, 新promise变为fulfilled, PromiseResult为返回的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>③ 如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//resolve(&#x27;111&#x27;);</span><br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;)<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h3 id="八、Promise的链式调用"><a href="#八、Promise的链式调用" class="headerlink" title="八、Promise的链式调用"></a>八、Promise的链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//resolve(&#x27;ok&#x27;);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例：通过promise的链式调用来读取文件</p><p>回调地狱的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data1</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data2</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data3</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1 + data2 + data3);<br>&#125;)<br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>Promise的形式：</p><p>需求：读取resource下三个文件内容，并在控制台合并输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br> <span class="hljs-comment">//如果失败 则修改promise对象状态为失败</span><br>        <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-comment">//如果成功 则修改promise对象状态为成功</span><br>        <span class="hljs-title function_">resolve</span>(data);<br>&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>             <span class="hljs-comment">//失败</span><br>            <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err);<br>            <span class="hljs-comment">//成功</span><br>            <span class="hljs-title function_">resolve</span>([value,data]);<br>        &#125;)<br>&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>             <span class="hljs-comment">//失败</span><br>            <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err);<br>            value.<span class="hljs-title function_">push</span>(data);<br>            <span class="hljs-comment">//成功</span><br>            <span class="hljs-title function_">resolve</span>(value);<br>        &#125;)<br>&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>));<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="九、Promise下的几种方法"><a href="#九、Promise下的几种方法" class="headerlink" title="九、Promise下的几种方法"></a>九、Promise下的几种方法</h3><h4 id="9-1-Promise-resolve"><a href="#9-1-Promise-resolve" class="headerlink" title="9.1 Promise.resolve()"></a>9.1 Promise.resolve()</h4><p>将一个普通值转化为promise类型的数据</p><ul><li>若参数为非promise对象，则返回的结果为成功状态的promise对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">undefined</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><ul><li>若参数为promise对象，参数的状态决定返回结果的状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3);<br><br><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;OK&quot;</span>)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p4);<br></code></pre></td></tr></table></figure><h4 id="9-2-Promise-reject"><a href="#9-2-Promise-reject" class="headerlink" title="9.2 Promise.reject()"></a>9.2 Promise.reject()</h4><p>返回的结果<code>始终为失败的Promise对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">123</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)));<br></code></pre></td></tr></table></figure><h4 id="9-3-Promise-catch"><a href="#9-3-Promise-catch" class="headerlink" title="9.3 Promise.catch()"></a>9.3 Promise.catch()</h4><p>功能是用来指定失败的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//resolve(&#x27;success&#x27;);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br><br>p.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-comment">//then方法中不是必须传入两个参数，可以只传递成功时的回调函数</span><br><span class="hljs-comment">//也可以单独使用catch来指定失败的回调函数</span><br><br><span class="hljs-comment">//异常（错误）穿透</span><br><span class="hljs-comment">//当如果有多个需要执行的成功时的回调函数，可以不需要每一次都写失败回调，可以统一最后利用catch</span><br><span class="hljs-comment">//当如果promise对象的状态为reject的话，会一直向下穿透直到catch方法</span><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="9-4-Promise-all"><a href="#9-4-Promise-all" class="headerlink" title="9.4 Promise.all()"></a>9.4 Promise.all()</h4><p>作用：针对于多个Promise的异步任务进行处理</p><p>接收的参数：promise数组</p><p>返回值：promise对象，状态由<code>promise数组中的对象状态</code>决定</p><ul><li>若每个对象状态<code>都为</code>成功，则返回的promise对象状态为成功，</li></ul><p>​ 成功的结果值为<code>每个promise对象成功结构值组成的数组</code></p><ul><li>若<code>其中一个对象</code>状态为失败，则返回的promise对象状态为失败，</li></ul><p>​    失败的结果值为<code>失败的promise对象的结果值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;oh yeah&#x27;</span>);<br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，</p><p>那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</p><p>Promise.all接收一个Promise对象组成的数组作为参数，</p><p>当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//ES6中对Promise.all()的理解以及应用场景</span><br><span class="hljs-comment">//用于将多个Promise实例，包装成一个新的Promise实例</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>   <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功01&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功02&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason));<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功03&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">//参数可以不是数组，但必须是iterator接口</span><br><span class="hljs-keyword">let</span> pAll = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p2,p3]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pAll)<br><span class="hljs-comment">//pAll的状态是由p1,p2,p3来决定，只有当这三个都为成功，pAll才会为成功,反之，但凡其中一个失败结果就是失败</span><br><span class="hljs-comment">//这个时候第一个失败的实力的返回值会传递给pAll的回调函数，如果作为参数的实例，自己定义了catch方法，那么它一旦为rejected，是不会触碰到pAll中的catch方法</span><br>pAll.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例1：模拟请求三个接口中的数据，全部请求成功后获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUsersList</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//模拟请求用户列表数据</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;用户列表的数据&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBannersList</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//模拟请求用户列表数据</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;轮播图的数据&#x27;</span>);<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getVideoList</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//模拟请求用户列表数据</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;视频列表的数据&#x27;</span>);<br>        &#125;, <span class="hljs-number">3000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-comment">//初始加载的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initLoad</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> all = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">getUsersList</span>(), <span class="hljs-title function_">getBannersList</span>(), <span class="hljs-title function_">getVideoList</span>()]);<br>    <span class="hljs-comment">//获取成功请求的结果值</span><br>    all.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">initLoad</span>();<br></code></pre></td></tr></table></figure><p>案例2：修改多文件读取代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-keyword">const</span> mywriteFile = util.<span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><span class="hljs-keyword">let</span> one = <span class="hljs-title function_">mywriteFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>);<br><span class="hljs-keyword">let</span> two = <span class="hljs-title function_">mywriteFile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>);<br><span class="hljs-keyword">let</span> three = <span class="hljs-title function_">mywriteFile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>);<br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([one,two,three]);<br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="9-5-Promise-race"><a href="#9-5-Promise-race" class="headerlink" title="9.5 Promise.race()"></a>9.5 Promise.race()</h4><p>Promise.race  race 赛跑的意思</p><p>参数: promise 数组</p><p>返回结果: promise 对象</p><p>状态由『最先改变状态的 promise对象』决定 </p><p>结果值由 『最先改变状态的 promise对象』决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>            &#125;, <span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;oh hou&#x27;</span>);<br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2, p3]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数。</p><p>不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。</p><p>而传递给then方法的值也会有所不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">//ES6中Promise.race的用法以及使用场景</span><br>    <span class="hljs-comment">//将多个Promise实例包装成一个新的Promise实例</span><br>    <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejct</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p1成功&#x27;</span>)<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;)<br>    <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejct</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p2成功&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">//调用</span><br>    <span class="hljs-keyword">const</span> prace = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]);<br>    <span class="hljs-comment">//Promise.race区别于Promise.all：</span><br>    <span class="hljs-comment">//只要是实例中有一个先改变状态，就会把这个实例的返回值传递给prace的回调函数</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用场景：请求超时提示</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>);<br>        &#125;, <span class="hljs-number">4000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;网络不畅,请求超时&#x27;</span>);<br>        &#125;, <span class="hljs-number">3000</span>);<br>    &#125;);<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">request</span>(), <span class="hljs-title function_">timeout</span>()]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="9-6-Promise-allSettled"><a href="#9-6-Promise-allSettled" class="headerlink" title="9.6 Promise.allSettled()"></a>9.6 Promise.allSettled()</h4><p>Promise.allSettled()方法，用来确定要一组异步操作是否都结束了(不管成功或失败)。</p><p>所以，它的名字叫”Settled”，包含了”fufilled”和”rejected”两种情况.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, url, <span class="hljs-literal">true</span>);<br>        xhr.<span class="hljs-title function_">send</span>();<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">responseText</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br><br>&#125;<br><span class="hljs-comment">//类比Promise下的all方法和allSettled</span><br><span class="hljs-comment">// Promise.all([ajax(&#x27;http://www.xiongmaoyouxuan.com/api/tabs&#x27;),</span><br><span class="hljs-comment">// ajax(&#x27;https://m.maizuo.com/gateway?cityId=110100&amp;k=4770248&#x27;)</span><br><span class="hljs-comment">// ]).then(value =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(value)</span><br><span class="hljs-comment">// &#125;).catch(error =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(error);</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://www.xiongmaoyouxuan.com/api/tabs&#x27;</span>),<br>                    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;https://m.maizuo.com/gateway?cityId=110100&amp;k=4770248&#x27;</span>)<br>                   ]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// console.log(value)</span><br>    <span class="hljs-keyword">let</span> successList = value.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(successList)<br><br>    <span class="hljs-keyword">let</span> errorList = value.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errorList)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="9-7-Promise-any"><a href="#9-7-Promise-any" class="headerlink" title="9.7 Promise.any()"></a>9.7 Promise.any()</h4><p>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfiilled状态；</p><p>如果所有参数实例都变成rejected，包装实例就会变成rejected状态。</p><blockquote><p>Promise.any()跟Promise.race()方法很像，但是有一点不同，</p><p>就是Promise.any()不会因为某个Promise变成rejected状态而结束，</p><p>必须等到所有参数Promise变成rejected状态才会结束。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;okk&#x27;</span>);<br>        &#125;, <span class="hljs-number">2000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;, <span class="hljs-number">3000</span>)<br>    &#125;)<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="9-8-Promise-finally"><a href="#9-8-Promise-finally" class="headerlink" title="9.8 Promise.finally()"></a>9.8 Promise.finally()</h4><p>finally是在ES9(ES2018)中新增的一个特性：表示无论Promise对象变成fufilled还是rejected状态，最终都会被执行。</p><p>finally方法中的<code>回调函数</code>是不接受参数的，因为无论前面是fulfilled状态还是rejected状态， 它都是执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// resolve(&#x27;ok&#x27;);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="十、终止Promise链条"><a href="#十、终止Promise链条" class="headerlink" title="十、终止Promise链条"></a>十、终止Promise链条</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// return false;</span><br>    <span class="hljs-comment">// throw &#x27;出错啦&#x27;;</span><br>    <span class="hljs-comment">//有且只有一种方式 返回一个pending状态的promise对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;&#125;);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="十一、几个关键问题"><a href="#十一、几个关键问题" class="headerlink" title="十一、几个关键问题"></a>十一、几个关键问题</h3><h4 id="11-1-如何修改-promise-对象状态"><a href="#11-1-如何修改-promise-对象状态" class="headerlink" title="11.1 如何修改 promise 对象状态"></a>11.1 如何修改 promise 对象状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">//如何修改 promise 对象状态</span><br>    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//1. resolve</span><br>        <span class="hljs-comment">// resolve(&#x27;success&#x27;);</span><br>        <span class="hljs-comment">//2. reject</span><br>        <span class="hljs-comment">// reject(&#x27;error&#x27;);</span><br>        <span class="hljs-comment">//3. 抛出错误 异常</span><br>        <span class="hljs-comment">// throw &#x27;出问题啦! 你说出这样的话  你没有良心!!&#x27;;</span><br>        <span class="hljs-comment">// 状态的改变只有一次 </span><br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>    &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="11-2-指定多个回调执行情况"><a href="#11-2-指定多个回调执行情况" class="headerlink" title="11.2 指定多个回调执行情况"></a>11.2 指定多个回调执行情况</h4><p>问题：一个promise指定多个成功&#x2F;失败回调函数，都会调用吗？</p><p>答：会，但是前提是当promise对象的状态改变(fulfilled&#x2F;rejected)时才会调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">//promise对象是可以多次调用then方法完成多个成功/失败回调函数</span><br>            <span class="hljs-comment">//但是使用的前提是这个promise对象的状态必须要么是fulfilled或者是rejected</span><br>            <span class="hljs-comment">//不能是pending</span><br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;OK&#x27;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">//第一次指定回调</span><br>        p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>        &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>        &#125;);<br><br>        p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(value);<br>        &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(reason);<br>        &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="11-3-指定回调与改变状态先后顺序问题"><a href="#11-3-指定回调与改变状态先后顺序问题" class="headerlink" title="11.3 指定回调与改变状态先后顺序问题"></a>11.3 指定回调与改变状态先后顺序问题</h4><p>改变promise状态和指定回调函数执行谁先谁后？</p><ul><li><p>都有可能，正常情况下是先指定回调再改变状态，但也可以先改变状态在指定回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//若执行器函数中是异步任务, 则先指定回调, 然后再改变状态  更为常见</span><br><span class="hljs-comment">//若执行器函数中是同步任务, 则先改变状态, 然后再指定回调</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//同步任务</span><br>    <span class="hljs-comment">//resolve(&#x27;ok&#x27;);</span><br>    <span class="hljs-comment">//异步任务</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>如何先改状态再指定回调？</p><ul><li>在执行器中直接调用resolve()&#x2F;reject()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">//resolve(&#x27;ok&#x27;);</span><br><span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>延迟更长时间才调用then()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>)<br><br>&#125;)<br><span class="hljs-comment">//then方法使用定时器延迟更久的时间</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>    &#125;)<br><br>&#125;, <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure></li><li><p>什么时候才能得到数据？</p><ul><li>如果是先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据</li><li>如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li></ul></li></ul><h4 id="11-4-promise-then-返回的新promise的结果状态由什么决定？"><a href="#11-4-promise-then-返回的新promise的结果状态由什么决定？" class="headerlink" title="11.4 promise.then()返回的新promise的结果状态由什么决定？"></a>11.4 promise.then()返回的新promise的结果状态由什么决定？</h4><ul><li>简单表达：由then指定的回调函数执行的结果决定</li><li>详细表达：<ul><li>如果抛出异常：新promise对象状态变成rejected，reason为抛出的异常</li><li>如果返回的是是非promise的任意值，新promise对象状态变成fulfilled，value为返回的值</li><li>如果返回的是另一个新的promise对象，此promise的结果就会称为新promise的结果</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//return value;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;okk&#x27;</span>);<br>    &#125;)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h4 id="11-5-promise如何串联多个操作任务"><a href="#11-5-promise如何串联多个操作任务" class="headerlink" title="11.5 promise如何串联多个操作任务?"></a>11.5 promise如何串联多个操作任务?</h4><ul><li>promise的then()返回一个新的promise对象，可以写成then()方法的链式调用</li><li>通过then()的链式调用串联多个同步&#x2F;异步任务</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>            <span class="hljs-title function_">reject</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>    &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>    &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="11-6-promise的异常穿透"><a href="#11-6-promise的异常穿透" class="headerlink" title="11.6 promise的异常穿透"></a>11.6 promise的异常穿透</h4><ul><li>当使用promise的then链式调用时, 可以在最后指定失败的回调,</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="11-7-中断promise链"><a href="#11-7-中断promise链" class="headerlink" title="11.7 中断promise链"></a>11.7 中断promise链</h4><ul><li>当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数</li><li>办法: 在回调函数中返回一个pending状态的promise对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123; &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="十二、async和await"><a href="#十二、async和await" class="headerlink" title="十二、async和await"></a>十二、async和await</h3><p>async&#x2F;await 是ES7提出的基于Promise的解决异步的最终方案。</p><h4 id="12-1-async函数"><a href="#12-1-async函数" class="headerlink" title="12.1  async函数"></a>12.1  async函数</h4><p>async是一个加在函数前的修饰符，用来创建一个异步函数，被async定义的函数会默认返回一个Promise对象resolve的值。</p><p>因此对async函数可以直接then，返回值就是then方法传入的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async基础语法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">fun0</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val) <span class="hljs-comment">// 1,1</span><br>&#125;)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">fun1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// Promise Promise</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//声明一个async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async function&#x27;</span>);<br>    <span class="hljs-comment">//情况1：返回非promise对象数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hahaha&#x27;</span>;<br>    <span class="hljs-comment">//情况2：返回是promise对象数据</span><br>    <span class="hljs-comment">/* return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="hljs-comment">// resolve(&#x27;ok&#x27;);</span><br><span class="hljs-comment">reject(&#x27;error&#x27;);</span><br><span class="hljs-comment">&#125;) */</span><br>    <span class="hljs-comment">//情况3：抛出异常</span><br>    <span class="hljs-comment">// throw new Error(&#x27;出错啦!!!&#x27;);</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">main</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h4 id="12-2-await表达式"><a href="#12-2-await表达式" class="headerlink" title="12.2  await表达式"></a>12.2  await表达式</h4><p>await 也是一个修饰符，只能放在async定义的函数内。可以理解为<strong>等待</strong>。</p><p>await 修饰的如果是Promise对象，可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p><p>注意事项</p><ul><li>await必须写在async函数中，但是async函数中可以没有await</li><li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 3秒后输出： 1 &quot;setTimeout&quot; &quot;function&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">time</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;,time)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-title function_">log</span>(<span class="hljs-number">2000</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <br><br><span class="hljs-comment">// 立即输出 undefined 1</span><br><span class="hljs-comment">// 1秒后输出 1000</span><br><span class="hljs-comment">// 2秒后输出 2000</span><br><span class="hljs-comment">// 3秒后输出 3000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//1、如果await右侧为非promise类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-string">&quot;非常6+7&quot;</span>;<br><br>    <span class="hljs-comment">//2、如果await右侧为promise成功类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125;)<br><br>    <span class="hljs-comment">//3、如果await右侧为promise失败类型数据,需要借助于try...catch捕获</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>        &#125;<br>&#125;<br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用async/await获取成功的结果</span><br><br><span class="hljs-comment">// 定义一个异步函数，3秒后才能获取到值(类似操作数据库)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomeThing</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;获取成功&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomeThing</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 3秒后输出：获取成功</span><br></code></pre></td></tr></table></figure><p>案例：async结合await读取文件内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1、导包</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123;promisify&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-comment">//2、将fs.readFile转化成promise风格的函数</span><br><span class="hljs-keyword">const</span> myreadfile = <span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><span class="hljs-comment">//3、声明async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//4、读取文件</span><br>        <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/4.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>);<br>    <span class="hljs-comment">//5、拼接读取文件内容</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one + two + three);<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//6、调用main函数</span><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><h3 id="十三、JS中的宏队列与微队列"><a href="#十三、JS中的宏队列与微队列" class="headerlink" title="十三、JS中的宏队列与微队列"></a>十三、JS中的宏队列与微队列</h3><ul><li>说明<ul><li>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</li><li>宏列队: 用来保存待执行的宏任务(回调), 比如: 定时器回调&#x2F;DOM事件回调&#x2F;ajax回调</li><li>微列队: 用来保存待执行的微任务(回调), 比如: promise的回调&#x2F;MutationObserver的回调</li><li>JS执行时会区别这2个队列<ul><li>JS引擎首先必须先执行所有的初始化同步任务代码</li><li>每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>();<br>    <span class="hljs-comment">//return ;throw</span><br>    <span class="hljs-title function_">reject</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);<br></code></pre></td></tr></table></figure><h3 id="十四、Promise常见面试题"><a href="#十四、Promise常见面试题" class="headerlink" title="十四、Promise常见面试题"></a>十四、Promise常见面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>)<br>        &#125;, <span class="hljs-number">0</span>)<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>    &#125;)<br><br>&#125;))<br><span class="hljs-title function_">first</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;0&quot;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>)<br>        <span class="hljs-title function_">resolve</span>()<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4&quot;</span>)<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;5&quot;</span>)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;6&quot;</span>);<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;7&quot;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;8&quot;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="十五、手写promise自定义基础结构的搭建"><a href="#十五、手写promise自定义基础结构的搭建" class="headerlink" title="十五、手写promise自定义基础结构的搭建"></a>十五、手写promise自定义基础结构的搭建</h3><h4 id="15-1-Promise-的基本结构"><a href="#15-1-Promise-的基本结构" class="headerlink" title="15.1   Promise 的基本结构"></a>15.1   Promise 的基本结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1- Promise 是一个构造函数</span><br><span class="hljs-comment"> * 2- Promise 接收一个参数，该参数的类型是函数（执行器函数executor）</span><br><span class="hljs-comment"> * 3- executor接收两个参数（resolve,reject）,参数的类型是函数</span><br><span class="hljs-comment"> * 4- 执行器函数会同步执行。</span><br><span class="hljs-comment"> * 5- then方法在其显式原型属性上</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br>    <span class="hljs-comment">// executor是执行器函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br>        <span class="hljs-title function_">executor</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>        &#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>        &#125;);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是我的执行器函数&quot;</span>,resolve,reject)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;over&quot;</span>,<span class="hljs-title class_">Promise</span>);<br></code></pre></td></tr></table></figure><h4 id="15-2-Promise实例拥有两个实例属性"><a href="#15-2-Promise实例拥有两个实例属性" class="headerlink" title="15.2  Promise实例拥有两个实例属性"></a>15.2  Promise实例拥有两个实例属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1- Promise实例拥有两个实例属性：</span><br><span class="hljs-comment"> * 状态（[[PromiseState]]），初始状态为pending</span><br><span class="hljs-comment"> * 值（[[PromiseResult]]）,初始值为undefined</span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-title function_">executor</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;);<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是我的执行器函数&quot;</span>,resolve,reject)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-3-更改状态三种方式-方法未抽离"><a href="#15-3-更改状态三种方式-方法未抽离" class="headerlink" title="15.3 更改状态三种方式-方法未抽离"></a>15.3 更改状态三种方式-方法未抽离</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 更改状态三种方式</span><br><span class="hljs-comment"> * 1- 通过调用resolve将状态更改为成功（fulfilled），接收的值为成功值</span><br><span class="hljs-comment"> * 2- 通过调用reject将状态更改为失败(rejected)，接收的值为失败值</span><br><span class="hljs-comment"> * 3- 抛出异常将状态更改为失败(rejected)，失败的值为异常信息。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将异常信息作为失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = err;<br>&#125;<br><br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-4-更改状态三种方式-抽离为普通函数"><a href="#15-4-更改状态三种方式-抽离为普通函数" class="headerlink" title="15.4  更改状态三种方式-抽离为普通函数"></a>15.4  更改状态三种方式-抽离为普通函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> _resolve = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> _reject = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将异常信息作为失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = err;<br>&#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-5-更改状态三种方式-抽离为箭头函数"><a href="#15-5-更改状态三种方式-抽离为箭头函数" class="headerlink" title="15.5   更改状态三种方式-抽离为箭头函数"></a>15.5   更改状态三种方式-抽离为箭头函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将异常信息作为失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = err;<br>&#125;<br><br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-6-状态只允许更改一次"><a href="#15-6-状态只允许更改一次" class="headerlink" title="15.6   状态只允许更改一次"></a>15.6   状态只允许更改一次</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * pending-&gt; fulfilled</span><br><span class="hljs-comment"> * pending-&gt; rejected</span><br><span class="hljs-comment"> * 改变状态只有这两种，且一个promise对象只能改变一次，，无论变成成功还是失败，都会有一个结果值</span><br><span class="hljs-comment"> * 成功的结果数据一般称为value，失败的结果值一般称为reason</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-7-then函数调用成功或失败回调函数"><a href="#15-7-then函数调用成功或失败回调函数" class="headerlink" title="15.7  then函数调用成功或失败回调函数"></a>15.7  then函数调用成功或失败回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1- then是Promise中的原型方法</span><br><span class="hljs-comment"> * 2- then函数接收两个参数（成功回调，失败回调）</span><br><span class="hljs-comment"> * 3- 如果p1状态为成功执行成功回调，失败执行失败回调。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;<br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><h4 id="15-8-then函数中的回调函数是异步调用的"><a href="#15-8-then函数中的回调函数是异步调用的" class="headerlink" title="15.8  then函数中的回调函数是异步调用的"></a>15.8  then函数中的回调函数是异步调用的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br>&#125;<br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功回调&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败回调&quot;</span>,reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;over&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="15-9-then函数返回的是一个Promise实例"><a href="#15-9-then函数返回的是一个Promise实例" class="headerlink" title="15.9  then函数返回的是一个Promise实例"></a>15.9  then函数返回的是一个Promise实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功回调&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败回调&quot;</span>,reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-10-then函数返回的Promise实例状态以及值-未优化"><a href="#15-10-then函数返回的Promise实例状态以及值-未优化" class="headerlink" title="15.10  then函数返回的Promise实例状态以及值-未优化"></a>15.10  then函数返回的Promise实例状态以及值-未优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * then返回的Promise实例受成功或失败回调函数返回值的影响</span><br><span class="hljs-comment"> * 1- 如果返回的是非Promise,那么p2状态为成功，值为返回值</span><br><span class="hljs-comment"> * 2- 如果返回的是Promise,那么p2状态以及值与返回的状态，值相同。</span><br><span class="hljs-comment"> * 3- 如果出现异常，那么p2状态为失败，值为异常信息。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-comment">// value.then(v=&gt;&#123;</span><br><span class="hljs-comment">// // 将返回的Promise实例设置为成功，值为v</span><br><span class="hljs-comment">// resolve(v);</span><br><span class="hljs-comment">// &#125;,s=&gt;&#123;</span><br><span class="hljs-comment">// // 将返回的Promise实例设置为失败，值为s</span><br><span class="hljs-comment">// reject(s);</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// 简化：</span><br>value.<span class="hljs-title function_">then</span>(resolve,reject)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是失败回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// value是否为Promise实例</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-comment">// 将返回Promise设置为与value相同的结果</span><br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 返回成功promise,值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 返回失败promise,值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// resolve(100)</span><br>        <span class="hljs-comment">// reject(200)</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常2&quot;</span><br>    &#125;)<br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;成功回调&quot;,value);</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// resolve(100);</span><br>        <span class="hljs-comment">// reject(2)</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常3&quot;</span><br>    &#125;)<br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;失败回调&quot;,reason);</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-11-then函数返回的Promise实例状态以及值-优化封装函数-common"><a href="#15-11-then函数返回的Promise实例状态以及值-优化封装函数-common" class="headerlink" title="15.11   then函数返回的Promise实例状态以及值-优化封装函数_common"></a>15.11   then函数返回的Promise实例状态以及值-优化封装函数_common</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">// return new Promise((resolve,reject)=&gt;&#123;</span><br>    <span class="hljs-comment">// // resolve(100)</span><br>    <span class="hljs-comment">// // reject(200)</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常2&quot;</span><br>    <span class="hljs-comment">// &#125;)</span><br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;成功回调&quot;,value);</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">// return new Promise((resolve,reject)=&gt;&#123;</span><br>    <span class="hljs-comment">// // resolve(100);</span><br>    <span class="hljs-comment">// // reject(2)</span><br>    <span class="hljs-comment">// throw &quot;异常3&quot;</span><br>    <span class="hljs-comment">// &#125;)</span><br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;失败回调&quot;,reason);</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-12-增加成功与失败回调函数的默认值"><a href="#15-12-增加成功与失败回调函数的默认值" class="headerlink" title="15.12  增加成功与失败回调函数的默认值"></a>15.12  增加成功与失败回调函数的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1- then如果省略成功回调，默认成功回调为 value=&gt;value;</span><br><span class="hljs-comment"> * 2- then如果省略失败回调，默认失败回调为 reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// reject(2);</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-14-执行器函数常用于处理异步行为"><a href="#15-14-执行器函数常用于处理异步行为" class="headerlink" title="15.14   执行器函数常用于处理异步行为"></a>15.14   执行器函数常用于处理异步行为</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = &#123;&#125;;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-property">onResolved</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">onResolved</span>();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-property">onRejected</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">onRejected</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = &#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">100</span>);<br>    &#125;)<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败&quot;</span>,reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-15-可以指定多个成功或失败的回调"><a href="#15-15-可以指定多个成功或失败的回调" class="headerlink" title="15.15  可以指定多个成功或失败的回调"></a>15.15  可以指定多个成功或失败的回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以指定多个成功或失败的回调</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">100</span>);<br>    &#125;)<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功1&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败1&quot;</span>,reason);<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功2&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败2&quot;</span>,reason);<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功3&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败3&quot;</span>,reason);<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功4&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败4&quot;</span>,reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-16-catch"><a href="#15-16-catch" class="headerlink" title="15.16  catch"></a>15.16  catch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以指定多个成功或失败的回调</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">100</span>);<br>    &#125;)<br>&#125;)<br><span class="hljs-comment">// p1.then(undefined,reason=&gt;&#123;</span><br><span class="hljs-comment">// console.log(reason);</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// catch的返回值是Promise实例,实例的属性与值取决于回调函数的返回值</span><br><span class="hljs-comment">// 返回值为非Promise实例，那么得到的状态为成功，值为返回值</span><br><span class="hljs-comment">// 返回值为Promise实例，那么得到的结果与返回的结果相同。</span><br><span class="hljs-comment">// 有异常，那么得到的状态为失败，值为异常信息。</span><br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">// console.log(reason);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>    &#125;)<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-17-链式调用支持"><a href="#15-17-链式调用支持" class="headerlink" title="15.17  链式调用支持"></a>15.17  链式调用支持</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-18-异常穿透支持"><a href="#15-18-异常穿透支持" class="headerlink" title="15.18   异常穿透支持"></a>15.18   异常穿透支持</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>,reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-19-中断Promise链"><a href="#15-19-中断Promise链" class="headerlink" title="15.19   中断Promise链"></a>15.19   中断Promise链</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">// 在回调函数中返回一个`pendding`状态的promise对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// undefined</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-20-resolve"><a href="#15-20-resolve" class="headerlink" title="15.20  resolve"></a>15.20  resolve</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<span class="hljs-comment">// 如果是Promise实例直接返回</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是Promise实例，那么返回的状态为成功，值为value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// const p1 = Promise.resolve(1);</span><br><span class="hljs-comment">// console.log(p1);</span><br><br><span class="hljs-comment">// const p1 = Promise.resolve(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="hljs-comment">// resolve(2);</span><br><span class="hljs-comment">// &#125;));</span><br><span class="hljs-comment">// console.log(p1);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// const p1 = Promise.resolve(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="hljs-comment">// reject(2);</span><br><span class="hljs-comment">// &#125;));</span><br><span class="hljs-comment">// console.log(p1);</span><br><br><br><span class="hljs-keyword">const</span> p =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>&#125;)<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1===p);<br></code></pre></td></tr></table></figure><h4 id="15-21-reject"><a href="#15-21-reject" class="headerlink" title="15.21  reject"></a>15.21  reject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<span class="hljs-comment">// 如果是Promise实例直接返回</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是Promise实例，那么返回的状态为成功，值为value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">reject</span>(value);<br>&#125;)<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3);<br></code></pre></td></tr></table></figure><h4 id="15-22-完成all"><a href="#15-22-完成all" class="headerlink" title="15.22 完成all"></a>15.22 完成all</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br><span class="hljs-comment">// 接收执行器函数(executor)，执行器函数会同步执行（立即执行）。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-comment">// 初始状态</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 初始值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// _resolve函数将状态更新为成功，成功值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-comment">// 状态更新为成功</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新成功值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>();<br>&#125;)<br>&#125;<br><span class="hljs-comment">// _reject函数将状态更新为失败，失败值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 状态更新为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>();<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-title function_">executor</span>(_resolve, _reject);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-comment">// 如果有异常，将状态更新为失败，失败的值为异常信息</span><br><span class="hljs-title function_">_reject</span>(err);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 将第二个参数（对象）合并至Promise.prototype对象中。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br><span class="hljs-comment">// 1- 接收成功与失败回调函数</span><br><span class="hljs-comment">// 2- 返回的是一个Promise实例</span><br><span class="hljs-comment">// 3- onResolved成功回调，默认值为value=&gt;value;</span><br><span class="hljs-comment">// 4- onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br><span class="hljs-comment">// onResolved成功回调，默认值为value=&gt;value;</span><br><span class="hljs-keyword">if</span> (!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br><span class="hljs-comment">//onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-keyword">if</span> (!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br><span class="hljs-keyword">throw</span> reason<br>&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// callback是成功或失败回调</span><br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// value是成功回调返回结果</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断是否为Promise实例</span><br><span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>value.<span class="hljs-title function_">then</span>(resolve, reject);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 非Promise实例</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br>&#125;)<br><br>&#125;<br><span class="hljs-comment">// 判断状态为成功，调用成功回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onResolved);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onRejected);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onResolved),<br><span class="hljs-attr">onRejected</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected);<br>&#125;<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 判断接收的参数是否为Promise实例，如果是直接返回</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是，创建一个新的Promise,状态为成功，值为value;</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 返回失败的Promise,失败值为接收的value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">reject</span>(value);<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 1- 接收的是数组，返回的是Promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>)&#123;<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> successArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseArr.<span class="hljs-property">length</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,i</span>)=&gt;</span>&#123;<br>value.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>index++;<br>successArr[i] = v;<br><span class="hljs-keyword">if</span>(index === promiseArr.<span class="hljs-property">length</span>)&#123;<br><span class="hljs-title function_">resolve</span>(successArr);<br>&#125;<br>&#125;,<span class="hljs-function"><span class="hljs-params">s</span>=&gt;</span>&#123;<br><span class="hljs-comment">// 返回Promise的状态设置失败</span><br><span class="hljs-title function_">reject</span>(s);<br>&#125;)<br>&#125;)<br>&#125;)<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">200</span>)<br>    &#125;,<span class="hljs-number">50</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">300</span>)<br>    &#125;,<span class="hljs-number">200</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-comment">// all接收的数组中的元素是Promise实例。</span><br><span class="hljs-comment">// 元素中的Promise实例都成功，p的状态为成功，值为数组，数组的元素为成功值</span><br><span class="hljs-comment">// 元素中有一个失败，那么p的状态为失败，值为失败值</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p2,p3,p4]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><h4 id="15-23-完成race"><a href="#15-23-完成race" class="headerlink" title="15.23 完成race"></a>15.23 完成race</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br>    <span class="hljs-comment">// 接收执行器函数(executor)，执行器函数会同步执行（立即执行）。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-comment">// 初始状态</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 初始值</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br>        <span class="hljs-comment">// _resolve函数将状态更新为成功，成功值为接收的value</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value =&gt; &#123;<br>            <span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-comment">// 状态更新为成功</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新成功值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>                item.<span class="hljs-title function_">onResolved</span>();<br>            &#125;)<br>        &#125;<br>        <span class="hljs-comment">// _reject函数将状态更新为失败，失败值为接收的value</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value =&gt; &#123;<br>            <span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 状态更新为失败</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新失败值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>                item.<span class="hljs-title function_">onRejected</span>();<br>            &#125;)<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-title function_">executor</span>(_resolve, _reject);<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>            <span class="hljs-comment">// 如果有异常，将状态更新为失败，失败的值为异常信息</span><br>            <span class="hljs-title function_">_reject</span>(err);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将第二个参数（对象）合并至Promise.prototype对象中。</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>        <span class="hljs-comment">// 1- 接收成功与失败回调函数</span><br>        <span class="hljs-comment">// 2- 返回的是一个Promise实例</span><br>        <span class="hljs-comment">// 3- onResolved成功回调，默认值为value=&gt;value;</span><br>        <span class="hljs-comment">// 4- onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br>        <span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>            <span class="hljs-comment">// onResolved成功回调，默认值为value=&gt;value;</span><br>            <span class="hljs-keyword">if</span> (!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>            <span class="hljs-comment">//onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br>            <span class="hljs-keyword">if</span> (!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">throw</span> reason<br>            &#125;;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-comment">// callback是成功或失败回调</span><br>                <span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// value是成功回调返回结果</span><br>                            <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>                            <span class="hljs-comment">// 判断是否为Promise实例</span><br>                            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                                value.<span class="hljs-title function_">then</span>(resolve, reject);<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-comment">// 非Promise实例</span><br>                                <span class="hljs-title function_">resolve</span>(value);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                            <span class="hljs-title function_">reject</span>(err);<br>                        &#125;<br>                    &#125;)<br><br>                &#125;<br>                <span class="hljs-comment">// 判断状态为成功，调用成功回调</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onResolved);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onRejected);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br>                        <span class="hljs-attr">onResolved</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onResolved),<br>                        <span class="hljs-attr">onRejected</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onRejected)<br>                    &#125;)<br>                &#125;<br>            &#125;)<br>        &#125;,<br>        <span class="hljs-keyword">catch</span>(onRejected)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected);<br>        &#125;<br>    &#125;)<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-comment">// 判断接收的参数是否为Promise实例，如果是直接返回</span><br>        <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 如果不是，创建一个新的Promise,状态为成功，值为value;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(value);<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-comment">// 返回失败的Promise,失败值为接收的value</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-title function_">reject</span>(value);<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 1- 接收的是数组，返回的是Promise</span><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>)&#123;<br>        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> successArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseArr.<span class="hljs-property">length</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,i</span>)=&gt;</span>&#123;<br>                value.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>                    index++;<br>                    successArr[i] = v;<br>                    <span class="hljs-keyword">if</span>(index === promiseArr.<span class="hljs-property">length</span>)&#123;<br>                        <span class="hljs-title function_">resolve</span>(successArr);<br>                    &#125;<br>                &#125;,<span class="hljs-function"><span class="hljs-params">s</span>=&gt;</span>&#123;<br>                    <span class="hljs-comment">// 返回Promise的状态设置失败</span><br>                    <span class="hljs-title function_">reject</span>(s);<br>                &#125;)<br>            &#125;)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>                <span class="hljs-comment">// value.then(v=&gt;&#123;</span><br>                <span class="hljs-comment">// resolve(v);</span><br>                <span class="hljs-comment">// &#125;,s=&gt;&#123;</span><br>                <span class="hljs-comment">// reject(s);</span><br>                <span class="hljs-comment">// &#125;)</span><br>                value.<span class="hljs-title function_">then</span>(resolve,reject);<br>            &#125;)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">200</span>)<br>    &#125;,<span class="hljs-number">50</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">300</span>)<br>    &#125;,<span class="hljs-number">200</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-comment">// race:返回的是Promise实例，谁先执行完就与谁的状态以及值相同。</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1,p2,p3,p4]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><h4 id="15-24-class版本实现Promise"><a href="#15-24-class版本实现Promise" class="headerlink" title="15.24 class版本实现Promise"></a>15.24 class版本实现Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br><span class="hljs-comment">// 1-将之前构造函数体内的语句放置到constructor函数中</span><br><span class="hljs-comment">// 2-将之前prototype的属性直接放置到Promise中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 判断接收的参数是否为Promise实例，如果是直接返回</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是，创建一个新的Promise,状态为成功，值为value;</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 返回失败的Promise,失败值为接收的value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">reject</span>(value);<br>&#125;)<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promiseArr</span>)&#123;<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> successArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseArr.<span class="hljs-property">length</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,i</span>)=&gt;</span>&#123;<br>value.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>index++;<br>successArr[i] = v;<br><span class="hljs-keyword">if</span>(index === promiseArr.<span class="hljs-property">length</span>)&#123;<br><span class="hljs-title function_">resolve</span>(successArr);<br>&#125;<br>&#125;,<span class="hljs-function"><span class="hljs-params">s</span>=&gt;</span>&#123;<br><span class="hljs-comment">// 返回Promise的状态设置失败</span><br><span class="hljs-title function_">reject</span>(s);<br>&#125;)<br>&#125;)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promiseArr</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-comment">// value.then(v=&gt;&#123;</span><br><span class="hljs-comment">// resolve(v);</span><br><span class="hljs-comment">// &#125;,s=&gt;&#123;</span><br><span class="hljs-comment">// reject(s);</span><br><span class="hljs-comment">// &#125;)</span><br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;)<br>&#125;)<br>&#125;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-comment">// 初始状态</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 初始值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// _resolve函数将状态更新为成功，成功值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-comment">// 状态更新为成功</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新成功值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>();<br>&#125;)<br>&#125;<br><span class="hljs-comment">// _reject函数将状态更新为失败，失败值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 状态更新为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>();<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-title function_">executor</span>(_resolve, _reject);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-comment">// 如果有异常，将状态更新为失败，失败的值为异常信息</span><br><span class="hljs-title function_">_reject</span>(err);<br>&#125;<br>&#125;<br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br><span class="hljs-comment">// onResolved成功回调，默认值为value=&gt;value;</span><br><span class="hljs-keyword">if</span> (!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br><span class="hljs-comment">//onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-keyword">if</span> (!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br><span class="hljs-keyword">throw</span> reason<br>&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// callback是成功或失败回调</span><br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// value是成功回调返回结果</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断是否为Promise实例</span><br><span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>value.<span class="hljs-title function_">then</span>(resolve, reject);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 非Promise实例</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br>&#125;)<br><br>&#125;<br><span class="hljs-comment">// 判断状态为成功，调用成功回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onResolved);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onRejected);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onResolved),<br><span class="hljs-attr">onRejected</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br>&#125;<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected);<br>&#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">200</span>)<br>    &#125;,<span class="hljs-number">50</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">300</span>)<br>    &#125;,<span class="hljs-number">200</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-comment">// race:返回的是Promise实例，谁先执行完就与谁的状态以及值相同。</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1,p2,p3,p4]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><h1 id="Express-Web服务"><a href="#Express-Web服务" class="headerlink" title="Express(Web服务)"></a>Express(Web服务)</h1><blockquote><p><a href="https://express.js.cn/">Express - Node.js Web 应用程序框架 - Express.js 框架</a></p></blockquote><h2 id="什么是Express"><a href="#什么是Express" class="headerlink" title="什么是Express"></a>什么是Express</h2><p><strong>Express</strong> 是一个基于 <strong>Node.js</strong> 的轻量级 Web 应用框架，用于构建 Web 服务和 API。</p><p>它提供了一个简单而灵活的方式来：</p><ul><li>处理 HTTP 请求和响应</li><li>定义路由规则</li><li>使用中间件进行功能扩展</li></ul><p>Node.js 负责运行 JavaScript 并处理底层 HTTP，而Express在http模块上封装一层API，使得Web服务和处理 HTTP 请求更加高效。</p><h3 id="【核心特点】"><a href="#【核心特点】" class="headerlink" title="【核心特点】"></a>【核心特点】</h3><ol><li><strong>轻量 &amp; 灵活</strong><ul><li>不像 Django、Rails 那样自带庞大功能，只提供核心 Web 处理能力</li><li>想要什么功能用中间件扩展即可</li></ul></li><li><strong>路由系统强大</strong><ul><li>方便定义不同 URL 对应的处理逻辑</li><li>支持 RESTful API 风格</li></ul></li><li><strong>中间件机制</strong><ul><li>核心思想：请求进来时可以经过一系列处理器（中间件），每个处理器做自己的事</li><li>比如日志记录、解析 JSON、权限校验、错误处理等</li></ul></li><li><strong>支持多种模板引擎</strong><ul><li>例如 EJS、Pug（原 Jade）、Handlebars 等</li></ul></li><li><strong>与 Node.js 原生 HTTP 完全兼容</strong><ul><li>底层还是 Node.js 的 <code>http</code> 模块</li></ul></li></ol><h2 id="Express-基础用法"><a href="#Express-基础用法" class="headerlink" title="Express 基础用法"></a>Express 基础用法</h2><p><strong>安装：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install express<br></code></pre></td></tr></table></figure><p><strong>最小示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 定义一个 GET 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Express!&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running on http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后在浏览器就可以访问 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">&lt;文件名&gt;</span><br><span class="hljs-title"># 或者</span><br><span class="hljs-title">nodemon</span> <span class="hljs-tag">&lt;文件名&gt;</span><br></code></pre></td></tr></table></figure><h3 id="【Express-的运行流程】"><a href="#【Express-的运行流程】" class="headerlink" title="【Express 的运行流程】"></a>【Express 的运行流程】</h3><ol><li><strong>客户端发送请求</strong>（浏览器、Postman、其他服务）</li><li><strong>Express 应用接收请求</strong></li><li><strong>依次执行匹配的中间件</strong></li><li><strong>路由匹配</strong></li><li><strong>执行对应的处理函数</strong></li><li><strong>返回响应给客户端</strong></li></ol><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a><strong>Express</strong> <strong>路由</strong></h2><blockquote><p>官方定义： 路由确定了应用程序如何响应客户端对特定端点的请求</p></blockquote><h3 id="【路由的使用】"><a href="#【路由的使用】" class="headerlink" title="【路由的使用】"></a>【路由的使用】</h3><p>一个路由由 <strong>请求方法</strong>、<strong>路径</strong> 和 <strong>回调函数</strong> 三部分组成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.&lt;method&gt;(path, callback)<br></code></pre></td></tr></table></figure><ul><li><strong>method</strong>：HTTP 方法（<code>get</code>、<code>post</code>、<code>all</code> 等）</li><li><strong>path</strong>：URL 路径</li><li><strong>callback</strong>：处理请求的函数 <code>(req, res) =&gt; &#123; ... &#125;</code></li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">// 创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// GET 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;网站首页&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 首页路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我才是真正的首页&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// POST 路由</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 匹配所有请求方法</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;1 秒钟为您找到相关结果约 100,000,000 个&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口监听为 3000...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【获取请求参数】"><a href="#【获取请求参数】" class="headerlink" title="【获取请求参数】"></a>【获取请求参数】</h3><p>Express 提供了便捷的 API 获取请求报文中的数据，同时兼容原生 HTTP 获取方式。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 原生 HTTP 获取方式</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">method</span>);       <span class="hljs-comment">// 请求方法</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">url</span>);          <span class="hljs-comment">// URL</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">httpVersion</span>);  <span class="hljs-comment">// HTTP 协议版本</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>);      <span class="hljs-comment">// 请求头对象</span><br><br>  <span class="hljs-comment">// Express 独有方式</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>);        <span class="hljs-comment">// 查询字符串对象（重要）</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;host&#x27;</span>));  <span class="hljs-comment">// 获取指定请求头</span><br><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求报文的获取&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><table><thead><tr><th>API</th><th>类型</th><th>说明</th><th>示例值</th></tr></thead><tbody><tr><td><strong>req.method</strong></td><td>属性</td><td>获取请求方法（大写）</td><td><code>&quot;GET&quot;</code></td></tr><tr><td><strong>req.url</strong></td><td>属性</td><td>获取请求路径和查询字符串（原始）</td><td><code>&quot;/user?id=1&quot;</code></td></tr><tr><td><strong>req.httpVersion</strong></td><td>属性</td><td>获取 HTTP 协议版本</td><td><code>&quot;1.1&quot;</code></td></tr><tr><td><strong>req.headers</strong></td><td>对象</td><td>获取所有请求头</td><td><code>&#123; host: &#39;localhost:3000&#39;, ... &#125;</code></td></tr><tr><td><strong>req.get(name)</strong></td><td>方法</td><td>获取指定请求头（不区分大小写）</td><td><code>req.get(&#39;Host&#39;)</code> → <code>&quot;localhost:3000&quot;</code></td></tr><tr><td><strong>req.query</strong></td><td>对象</td><td>获取查询字符串参数（URL <code>?</code> 之后的部分）</td><td><code>/search?key=abc</code> → <code>&#123; key: &quot;abc&quot; &#125;</code></td></tr><tr><td><strong>req.params</strong></td><td>对象</td><td>获取路由参数（路径中声明的 <code>:name</code>）</td><td><code>/user/:id</code> 访问 <code>/user/100</code> → <code>&#123; id: &quot;100&quot; &#125;</code></td></tr><tr><td><strong>req.body</strong></td><td>对象</td><td>获取请求体数据（需配合 <code>express.json()</code> 或 <code>express.urlencoded()</code> 中间件）</td><td><code>&#123; username: &quot;tom&quot;, password: &quot;123&quot; &#125;</code></td></tr><tr><td><strong>req.path</strong></td><td>属性</td><td>获取 URL 路径（不含查询字符串）</td><td><code>&quot;/user&quot;</code></td></tr><tr><td><strong>req.hostname</strong></td><td>属性</td><td>获取主机名（不包含端口）</td><td><code>&quot;localhost&quot;</code></td></tr><tr><td><strong>req.ip</strong></td><td>属性</td><td>获取客户端 IP 地址</td><td><code>&quot;127.0.0.1&quot;</code></td></tr><tr><td><strong>req.protocol</strong></td><td>属性</td><td>获取协议</td><td><code>&quot;http&quot;</code></td></tr><tr><td><strong>req.secure</strong></td><td>属性</td><td>判断是否为 HTTPS 请求</td><td><code>false</code></td></tr></tbody></table><h3 id="【获取路由参数】"><a href="#【获取路由参数】" class="headerlink" title="【获取路由参数】"></a>【获取路由参数】</h3><p>路由参数是 URL 路径中以冒号（<code>:</code>）声明的部分，用来传递数据。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/:id.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;商品详情, 商品 id 为 &#x27;</span> + req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【响应设置】"><a href="#【响应设置】" class="headerlink" title="【响应设置】"></a>【响应设置】</h3><p>express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 1. 基本文本响应</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;这是一个普通的文本响应&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 2. JSON 响应</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/json&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 3. 设置状态码 + 发送内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/status&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;页面未找到&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 4. 设置响应头</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/header&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Custom-Header&#x27;</span>, <span class="hljs-string">&#x27;HelloHeader&#x27;</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;已设置自定义响应头&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 5. 链式调用（状态码 + 响应头 + 内容）</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/chain&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">201</span>)<br>     .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;X-Powered-By&#x27;</span>, <span class="hljs-string">&#x27;Express&#x27;</span>)<br>     .<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;链式调用响应成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 6. 重定向</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/redirect&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 7. 文件下载</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/download&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">download</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;package.json&#x27;</span>)); <br>&#125;);<br><br><span class="hljs-comment">// 8. 发送文件内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/file&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">sendFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;home.html&#x27;</span>));<br>&#125;);<br><br><span class="hljs-comment">// 9. 自定义 404 响应（放在最后）</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器已启动：http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td><code>res.send()</code></td><td>发送文本 &#x2F; HTML &#x2F; Buffer &#x2F; JSON（自动识别类型）</td></tr><tr><td><code>res.json()</code></td><td>发送 JSON 数据</td></tr><tr><td><code>res.status(code)</code></td><td>设置 HTTP 状态码</td></tr><tr><td><code>res.set(header, value)</code></td><td>设置响应头</td></tr><tr><td><code>res.redirect(url)</code></td><td>重定向到新 URL</td></tr><tr><td><code>res.download(filePath)</code></td><td>提示客户端下载文件</td></tr><tr><td><code>res.sendFile(filePath)</code></td><td>直接返回文件内容</td></tr><tr><td><code>res.redirect(path)</code></td><td>路由重定向</td></tr></tbody></table><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><h3 id="【什么是中间件？】"><a href="#【什么是中间件？】" class="headerlink" title="【什么是中间件？】"></a>【什么是中间件？】</h3><p><strong>中间件（Middleware）</strong> 是 Express 中处理请求和响应过程的函数。<br> 它本质上就是一个函数，可以：</p><ul><li>访问 <code>req</code>（请求对象）</li><li>访问 <code>res</code>（响应对象）</li><li>调用 <code>next()</code> 把控制权交给下一个中间件</li><li>结束请求-响应流程</li></ul><p><strong>基本格式</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-comment">// 执行一些操作...</span><br>  <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 交给下一个中间件</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【中间件分类】"><a href="#【中间件分类】" class="headerlink" title="【中间件分类】"></a>【中间件分类】</h3><table><thead><tr><th>类型</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td><strong>应用级中间件</strong></td><td>绑定到 <code>app</code> 实例，处理所有或特定路由的请求</td><td>用 <code>app.use()</code> 或 <code>app.METHOD()</code> 定义</td></tr><tr><td><strong>路由级中间件</strong></td><td>绑定到 <code>express.Router()</code> 实例，只作用于该路由</td><td>用 <code>router.use()</code> 或 <code>router.METHOD()</code> 定义</td></tr><tr><td><strong>内置中间件</strong></td><td>Express 内置的功能（解析 JSON、静态资源等）</td><td>不需要额外安装</td></tr><tr><td><strong>第三方中间件</strong></td><td>由社区提供，增强功能</td><td>需要 <code>npm install</code> 安装</td></tr><tr><td><strong>错误处理中间件</strong></td><td>捕获和处理错误</td><td>格式特殊：有 <strong>4 个参数</strong> <code>(err, req, res, next)</code></td></tr></tbody></table><h3 id="【常见中间件用法】"><a href="#【常见中间件用法】" class="headerlink" title="【常见中间件用法】"></a>【常见中间件用法】</h3><h4 id="1-应用级中间件"><a href="#1-应用级中间件" class="headerlink" title="1.应用级中间件"></a>1.应用级中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 全局中间件（所有请求都会经过）</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;全局中间件：&#x27;</span>, req.<span class="hljs-property">method</span>, req.<span class="hljs-property">url</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// 针对特定路由的中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问了 /user 路由&#x27;</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>));<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;用户中心&#x27;</span>));<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h4 id="2-路由级中间件"><a href="#2-路由级中间件" class="headerlink" title="2.路由级中间件"></a>2.路由级中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// 路由专用中间件</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;进入路由模块&#x27;</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;用户列表&#x27;</span>));<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/detail&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;用户详情&#x27;</span>));<br><br><span class="hljs-comment">// 挂载到 app</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, router);<br></code></pre></td></tr></table></figure><ul><li>实际路由为<code>/user/list</code>和<code>/user/detail</code>，中间件也只以<code>/use</code>为根路由下的子路由生效。</li></ul><h4 id="3-内置中间件"><a href="#3-内置中间件" class="headerlink" title="3.内置中间件"></a>3.内置中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 解析 JSON 请求体</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br><br><span class="hljs-comment">// 解析 URL-encoded 表单数据</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> &#125;));<br><br><span class="hljs-comment">// 托管静态资源</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));<br></code></pre></td></tr></table></figure><ul><li><code>express.urlencoded()</code>：解析 URL-encoded 表单数据，没解析<code>res.body</code>返回为空。</li><li><code>express.static()</code>：托管静态资源。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入express框架</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建服务对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./public&#x27;</span>)); <span class="hljs-comment">//当然这个目录中都是一些静态资源</span><br><span class="hljs-comment">//如果访问的内容经常变化，还是需要设置路由</span><br><span class="hljs-comment">//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，</span><br><span class="hljs-comment">//则谁书写在前，优先执行谁</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/index.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br>    respsonse.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//监听端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3000 端口启动....&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意事项:</p><ol><li><code>index.html</code> 文件为默认打开的资源</li><li>如果静态资源与路由规则同时匹配，谁先匹配谁就响应</li><li>路由响应动态资源，静态资源中间件响应静态资源</li></ol><h4 id="4-第三方中间件"><a href="#4-第三方中间件" class="headerlink" title="4.第三方中间件"></a>4.第三方中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> morgan = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;morgan&#x27;</span>); <span class="hljs-comment">// 日志中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">morgan</span>(<span class="hljs-string">&#x27;dev&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="5-错误处理中间件"><a href="#5-错误处理中间件" class="headerlink" title="5.错误处理中间件"></a>5.错误处理中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;出错了：&#x27;</span>, err.<span class="hljs-property">message</span>);<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;服务器错误&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>注意：必须放在所有路由之后，且有 <code>(err, req, res, next)</code> 四个参数。</p></blockquote><h3 id="【中间件执行顺序】"><a href="#【中间件执行顺序】" class="headerlink" title="【中间件执行顺序】"></a>【中间件执行顺序】</h3><ol><li>按定义顺序依次执行</li><li>同一路径匹配多个中间件时，需调用 <code>next()</code> 才会继续执行</li><li>如果某个中间件没有调用 <code>next()</code> 且没有结束响应，客户端会卡住</li><li><font color="#409eff"><code>res.send()</code>和<code>next()</code>不能同时使用。</font><ul><li><strong><code>res.send()</code><strong>直接</strong>结束响应</strong>，把数据发送给客户端,一旦调用，HTTP 响应就结束了，<strong>不能再发送数据或进入下一个中间件</strong></li><li>**<code>next()</code>**把控制权交给下一个匹配的中间件或路由处理函数，不会自动结束响应。</li></ul></li></ol><h3 id="【Router】"><a href="#【Router】" class="headerlink" title="【Router】"></a>【Router】</h3><p><strong>Express Router</strong> 是 Express 提供的<strong>路由模块化机制</strong>，用来把不同功能的路由拆分到单独文件，避免所有路由都堆在 <code>app.js</code> 里。</p><h4 id="创建Router"><a href="#创建Router" class="headerlink" title="创建Router"></a>创建Router</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// productRouter.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// 路由专属中间件</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问了商品路由：&#x27;</span>, req.<span class="hljs-property">method</span>, req.<span class="hljs-property">url</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;商品列表&#x27;</span>);<br>&#125;);<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/detail/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`商品详情 ID：<span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><h4 id="在-app-js-中挂载"><a href="#在-app-js-中挂载" class="headerlink" title="在 app.js 中挂载"></a>在 app.js 中挂载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 导入路由模块</span><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./userRouter&#x27;</span>);<br><br><span class="hljs-comment">// 挂载到 /user 前缀</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, userRouter);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器已启动 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>router.use([path], middleware)</code></td><td>挂载中间件（可选路径前缀）</td></tr><tr><td><code>router.METHOD(path, handler)</code></td><td>定义路由（METHOD 如 <code>get</code>, <code>post</code> 等）</td></tr><tr><td><code>router.route(path)</code></td><td>链式定义同一路径的多个方法</td></tr><tr><td><code>module.exports = router</code></td><td>导出路由</td></tr></tbody></table><p><strong>链式写法示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/article&#x27;</span>)<br>  .<span class="hljs-title function_">get</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;获取文章&#x27;</span>))<br>  .<span class="hljs-title function_">post</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;新增文章&#x27;</span>))<br>  .<span class="hljs-title function_">put</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;更新文章&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="多模块结构"><a href="#多模块结构" class="headerlink" title="多模块结构"></a>多模块结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">project/<br>│── app.<span class="hljs-property">js</span><br>│── routes/<br>│    ├── user.<span class="hljs-property">js</span><br>│    ├── product.<span class="hljs-property">js</span><br>│    └── article.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/user&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/product&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/product&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/article&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/article&#x27;</span>));<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="EJS模板"><a href="#EJS模板" class="headerlink" title="EJS模板"></a>EJS模板</h2><blockquote><p>官网: <strong><a href="https://ejs.co/">https://ejs.co/</a></strong></p><p>中文站：<strong><a href="https://ejs.bootcss.com/">https://ejs.bootcss.com/</a></strong></p></blockquote><p><strong>EJS (Embedded JavaScript templates)</strong> 是一个轻量级的 JavaScript 模板引擎，用来在 HTML 中嵌入 JavaScript 代码。<br> 它的作用：将 <strong>数据</strong> 和 <strong>模板</strong> 结合，生成最终 HTML</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install ejs<br></code></pre></td></tr></table></figure><h3 id="【Express-中使用-EJS】"><a href="#【Express-中使用-EJS】" class="headerlink" title="【Express 中使用 EJS】"></a>【Express 中使用 EJS】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 1. 设置模板引擎</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>);<br><br><span class="hljs-comment">// 2. 设置模板文件夹（可选，默认 views 文件夹）</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, __dirname + <span class="hljs-string">&#x27;/views&#x27;</span>);<br><br><span class="hljs-comment">// 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;;<br>  <span class="hljs-comment">// 3. 渲染模板</span><br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; user &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="【EJS-模板语法】"><a href="#【EJS-模板语法】" class="headerlink" title="【EJS 模板语法】"></a>【EJS 模板语法】</h3><p>假设 <code>views/index.ejs</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>EJS 示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎 &lt;%= user.name %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：&lt;%= user.age %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- for 循环 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    &lt;% for(let i=1; i&lt;=3; i++)&#123; %&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项目 &lt;%= i %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    &lt;% &#125; %&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- if 判断 --&gt;</span></span><br><span class="language-xml">  &lt;% if(user.age &gt;= 18) &#123; %&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>已成年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  &lt;% &#125; else &#123; %&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>未成年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  &lt;% &#125; %&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="【EJS-语法规则】"><a href="#【EJS-语法规则】" class="headerlink" title="【EJS 语法规则】"></a>【EJS 语法规则】</h3><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;%= 变量 %&gt;</code></td><td>输出转义后的内容（防 XSS）</td></tr><tr><td><code>&lt;%- 变量 %&gt;</code></td><td>输出原始 HTML（不转义）</td></tr><tr><td><code>&lt;% JS代码 %&gt;</code></td><td>执行 JavaScript 代码，不输出</td></tr><tr><td><code>&lt;% include(&#39;file&#39;) %&gt;</code></td><td>引入子模板</td></tr><tr><td><code>&lt;% for()&#123;&#125; %&gt;</code></td><td>循环</td></tr><tr><td><code>&lt;% if()&#123;&#125; %&gt;</code></td><td>条件判断</td></tr></tbody></table><h3 id="【独立渲染-EJS（不依赖-Express）】"><a href="#【独立渲染-EJS（不依赖-Express）】" class="headerlink" title="【独立渲染 EJS（不依赖 Express）】"></a>【独立渲染 EJS（不依赖 Express）】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ejs&#x27;</span>);<br><br>ejs.<span class="hljs-title function_">renderFile</span>(<span class="hljs-string">&#x27;./views/index.ejs&#x27;</span>, &#123; <span class="hljs-attr">user</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125; &#125;, <span class="hljs-function">(<span class="hljs-params">err, str</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 输出 HTML</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="FS模块总结"><a href="#FS模块总结" class="headerlink" title="FS模块总结"></a>FS模块总结</h1><p><code>fs</code> (<strong>File System</strong>) 是 Node.js 内置的文件系统模块</p><ul><li>用于 <strong>文件读写</strong>、<strong>目录操作</strong>、<strong>文件状态查看</strong> 等</li><li>提供 <strong>同步</strong>（<code>xxxSync</code>）和 <strong>异步</strong>（回调&#x2F;Promise）两种 API</li><li>异步版本<strong>不会阻塞</strong>线程，性能更好</li></ul><p>导入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用API总表"><a href="#常用API总表" class="headerlink" title="常用API总表"></a>常用API总表</h2><table><thead><tr><th>类别</th><th>异步方法</th><th>同步方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>读取文件</strong></td><td><code>fs.readFile(path, [options], callback)</code></td><td><code>fs.readFileSync(path, [options])</code></td><td>读取整个文件内容</td></tr><tr><td><strong>写入文件</strong></td><td><code>fs.writeFile(path, data, [options], callback)</code></td><td><code>fs.writeFileSync(...)</code></td><td>覆盖写入文件</td></tr><tr><td><strong>追加写入</strong></td><td><code>fs.appendFile(...)</code></td><td><code>fs.appendFileSync(...)</code></td><td>追加内容到文件末尾</td></tr><tr><td><strong>删除文件</strong></td><td><code>fs.unlink(...)</code></td><td><code>fs.unlinkSync(...)</code></td><td>删除文件</td></tr><tr><td><strong>重命名&#x2F;移动</strong></td><td><code>fs.rename(...)</code></td><td><code>fs.renameSync(...)</code></td><td>重命名文件或移动位置</td></tr><tr><td><strong>检测文件状态</strong></td><td><code>fs.stat(...)</code></td><td><code>fs.statSync(...)</code></td><td>查看文件&#x2F;目录信息</td></tr><tr><td><strong>判断存在</strong></td><td><code>fs.exists(path）</code></td><td><code>fs.existsSync(path)</code></td><td>判断路径是否存在</td></tr><tr><td><strong>创建目录</strong></td><td><code>fs.mkdir(...)</code></td><td><code>fs.mkdirSync(...)</code></td><td>创建文件夹</td></tr><tr><td><strong>读取目录</strong></td><td><code>fs.readdir(...)</code></td><td><code>fs.readdirSync(...)</code></td><td>获取目录内容</td></tr><tr><td><strong>删除目录</strong></td><td><code>fs.rmdir(...)</code></td><td><code>fs.rmdirSync(...)</code></td><td>删除文件夹（空）</td></tr><tr><td><strong>流式读取</strong></td><td><code>fs.createReadStream(path)</code></td><td>-</td><td>创建可读流</td></tr><tr><td><strong>流式写入</strong></td><td><code>fs.createWriteStream(path)</code></td><td>-</td><td>创建可写流</td></tr></tbody></table><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><h3 id="【读取文件】"><a href="#【读取文件】" class="headerlink" title="【读取文件】"></a>【读取文件】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件内容:&#x27;</span>, data);<br>&#125;);<br><br><span class="hljs-comment">// 同步</span><br><span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><h3 id="【写入-追加】"><a href="#【写入-追加】" class="headerlink" title="【写入&#x2F;追加】"></a>【写入&#x2F;追加】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 覆盖写入</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;Hello World&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 追加写入</span><br>fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;\n追加内容&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【删除-重命名】"><a href="#【删除-重命名】" class="headerlink" title="【删除&#x2F;重命名】"></a>【删除&#x2F;重命名】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br><br>fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./old.txt&#x27;</span>, <span class="hljs-string">&#x27;./new.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;重命名成功&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【目录操作】"><a href="#【目录操作】" class="headerlink" title="【目录操作】"></a>【目录操作】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建目录</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./demo&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录创建成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 读取目录</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./demo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录内容:&#x27;</span>, files);<br>&#125;);<br><br><span class="hljs-comment">// 删除目录（空目录）</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./demo&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录删除成功&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【文件状态】"><a href="#【文件状态】" class="headerlink" title="【文件状态】"></a>【文件状态】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stats.<span class="hljs-title function_">isFile</span>()); <span class="hljs-comment">// true</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stats.<span class="hljs-title function_">isDirectory</span>()); <span class="hljs-comment">// false</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【流式读写】"><a href="#【流式读写】" class="headerlink" title="【流式读写】"></a>【流式读写】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./input.txt&#x27;</span>);<br><span class="hljs-keyword">const</span> ws = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./output.txt&#x27;</span>);<br><br>rs.<span class="hljs-title function_">pipe</span>(ws); <span class="hljs-comment">// 直接管道传输</span><br></code></pre></td></tr></table></figure><ul><li><code>createReadStream</code> 会分块读取文件，读到一块就触发数据事件</li><li><code>pipe</code> 方法自动把读到的数据传给写入流</li><li>这样不用把整个文件一次加载进内存，适合大文件处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建读取流对象</span><br><span class="hljs-keyword">let</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br><span class="hljs-comment">//每次取出 64k 数据后执行一次 data 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;);<br><span class="hljs-comment">//读取完毕后, 执行 end 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取完成&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h2><ul><li><strong>同步</strong>：代码会阻塞等待文件操作完成</li><li><strong>异步</strong>：文件操作在后台进行，主线程可以继续执行其他任务</li><li>建议在高并发服务中<strong>优先使用异步</strong>版本</li></ul><h1 id="Buffer总结"><a href="#Buffer总结" class="headerlink" title="Buffer总结"></a>Buffer总结</h1><h2 id="Buffer是什么？"><a href="#Buffer是什么？" class="headerlink" title="Buffer是什么？"></a>Buffer是什么？</h2><ul><li>Buffer 是 Node.js 提供的 <strong>用于处理二进制数据的类数组对象</strong>。</li><li>它的出现解决了 JavaScript 语言本身不支持直接操作二进制数据的问题。</li><li>Buffer 常用于处理文件、网络通信等二进制数据流。</li></ul><h2 id="Buffer的创建"><a href="#Buffer的创建" class="headerlink" title="Buffer的创建"></a>Buffer的创建</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个长度为10的Buffer，内容未初始化（可能包含旧数据）</span><br><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个长度为10的Buffer，内容全部初始化为0</span><br><span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 通过数组创建Buffer</span><br><span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br><span class="hljs-comment">// 通过字符串创建Buffer，默认utf8编码</span><br><span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br><span class="hljs-comment">// 通过字符串创建Buffer，指定编码</span><br><span class="hljs-keyword">const</span> buf5 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;ascii&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th>操作</th><th>方法&#x2F;属性</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>获取长度</td><td><code>buf.length</code></td><td>Buffer字节长度</td><td><code>buf.length</code></td></tr><tr><td>写入字符串</td><td><code>buf.write(string, [offset], [length], [encoding])</code></td><td>写入内容</td><td><code>buf.write(&#39;abc&#39;)</code></td></tr><tr><td>读取字符串</td><td><code>buf.toString([encoding], [start], [end])</code></td><td>转为字符串</td><td><code>buf.toString(&#39;utf8&#39;, 0, 5)</code></td></tr><tr><td>合并 Buffer</td><td><code>Buffer.concat([buf1, buf2, ...])</code></td><td>合并多个Buffer</td><td><code>Buffer.concat([buf1, buf2])</code></td></tr><tr><td>拷贝数据</td><td><code>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</code></td><td>复制内容</td><td><code>buf1.copy(buf2)</code></td></tr><tr><td>截取子Buffer</td><td><code>buf.slice(start, end)</code></td><td>获取Buffer子区间</td><td><code>buf.slice(0, 3)</code></td></tr></tbody></table><h2 id="Buffer-与字符串的转换"><a href="#Buffer-与字符串的转换" class="headerlink" title="Buffer 与字符串的转换"></a>Buffer 与字符串的转换</h2><ul><li><p>Buffer → 字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>字符串 → Buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;字符串&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>编码支持</p><ul><li>支持多种编码格式：<code>utf8</code>（默认）、<code>ascii</code>、<code>base64</code>、<code>hex</code>、<code>latin1</code> 等。</li></ul><h2 id="示例：写入与读取"><a href="#示例：写入与读取" class="headerlink" title="示例：写入与读取"></a>示例：写入与读取</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);<br>buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 hello</span><br></code></pre></td></tr></table></figure><ul><li>通过 <code>Buffer.alloc(10)</code> 申请 10 字节空间；</li><li>用 <code>write</code> 写入字符串到 Buffer；</li><li>用 <code>toString</code> 读取指定范围的字节转换成字符串。</li><li>这样你就可以把字符串转换成二进制存储，也能从二进制读取对应字符串。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>Buffer 大小固定，创建后不可动态扩容</li><li>使用 <code>Buffer.allocUnsafe</code> 可能包含旧数据，慎用</li><li>操作二进制数据时，注意编码和字节偏移</li></ul><h1 id="Path模块总结"><a href="#Path模块总结" class="headerlink" title="Path模块总结"></a>Path模块总结</h1><h2 id="Path模块简介"><a href="#Path模块简介" class="headerlink" title="Path模块简介"></a>Path模块简介</h2><ul><li><code>path</code> 是 Node.js 的核心模块，用于处理和转换文件路径。</li><li>解决不同操作系统（Windows、Linux、macOS）路径分隔符不同的问题。</li><li>提供了许多实用的方法来解析、拼接、格式化路径。</li></ul><h2 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用-API-及说明"><a href="#常用-API-及说明" class="headerlink" title="常用 API 及说明"></a>常用 API 及说明</h2><table><thead><tr><th>方法</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>path.basename(path, [ext])</code></td><td>返回路径中的文件名部分，可去除指定扩展名</td><td><code>path.basename(&#39;/foo/bar/baz.txt&#39;) // &#39;baz.txt&#39;</code></td></tr><tr><td><code>path.dirname(path)</code></td><td>返回路径中的目录部分</td><td><code>path.dirname(&#39;/foo/bar/baz.txt&#39;) // &#39;/foo/bar&#39;</code></td></tr><tr><td><code>path.extname(path)</code></td><td>返回路径中的扩展名</td><td><code>path.extname(&#39;index.html&#39;) // &#39;.html&#39;</code></td></tr><tr><td><code>path.parse(path)</code></td><td>解析路径为对象，包含 root、dir、base、ext、name</td><td><code>path.parse(&#39;/foo/bar/baz.txt&#39;)</code> 返回 <code>&#123; root: &#39;/&#39;, dir: &#39;/foo/bar&#39;, base: &#39;baz.txt&#39;, ext: &#39;.txt&#39;, name: &#39;baz&#39; &#125;</code></td></tr><tr><td><code>path.format(pathObject)</code></td><td>把路径对象转换回路径字符串</td><td><code>path.format(&#123; root: &#39;/&#39;, dir: &#39;/foo/bar&#39;, base: &#39;baz.txt&#39; &#125;)</code> 返回 <code>/foo/bar/baz.txt</code></td></tr><tr><td><code>path.isAbsolute(path)</code></td><td>判断路径是否为绝对路径</td><td><code>path.isAbsolute(&#39;/foo/bar&#39;) // true</code></td></tr><tr><td><code>path.join([...paths])</code></td><td>拼接路径，自动处理分隔符</td><td><code>path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz&#39;) // &#39;/foo/bar/baz&#39;</code></td></tr><tr><td><code>path.resolve([...paths])</code></td><td>解析为绝对路径，基于当前工作目录</td><td><code>path.resolve(&#39;foo&#39;, &#39;/bar&#39;, &#39;baz&#39;)</code> 返回绝对路径</td></tr><tr><td><code>path.relative(from, to)</code></td><td>计算从 <code>from</code> 到 <code>to</code> 的相对路径</td><td><code>path.relative(&#39;/data/orandea/test/aaa&#39;, &#39;/data/orandea/impl/bbb&#39;)</code> 返回 <code>../../impl/bbb</code></td></tr><tr><td><code>path.sep</code></td><td>当前操作系统的路径分隔符</td><td><code>&#39;\\&#39;</code>（Windows）或 <code>&#39;/&#39;</code>（Linux&#x2F;macOS）</td></tr><tr><td><code>path.delimiter</code></td><td>当前操作系统的环境变量分隔符</td><td><code>&#39;;&#39;</code>（Windows）或 <code>&#39;:&#39;</code>（Linux&#x2F;macOS）</td></tr></tbody></table><ul><li><code>__dirname</code> 与 <code>require</code> 类似，都是 Node.js 环境中的全局变量。<code>__dirname</code> 保存着 当前文件所在目录的绝对路径 ，可以使用 <code>__dirname</code> 与文件名拼接成绝对路径</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制编辑<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> filePath = <span class="hljs-string">&#x27;/foo/bar/baz.txt&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件名:&#x27;</span>, path.<span class="hljs-title function_">basename</span>(filePath)); <span class="hljs-comment">// baz.txt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录名:&#x27;</span>, path.<span class="hljs-title function_">dirname</span>(filePath)); <span class="hljs-comment">// /foo/bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;扩展名:&#x27;</span>, path.<span class="hljs-title function_">extname</span>(filePath)); <span class="hljs-comment">// .txt</span><br><br><span class="hljs-keyword">const</span> parsed = path.<span class="hljs-title function_">parse</span>(filePath);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed);<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//   root: &#x27;/&#x27;,</span><br><span class="hljs-comment">//   dir: &#x27;/foo/bar&#x27;,</span><br><span class="hljs-comment">//   base: &#x27;baz.txt&#x27;,</span><br><span class="hljs-comment">//   ext: &#x27;.txt&#x27;,</span><br><span class="hljs-comment">//   name: &#x27;baz&#x27;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> joinedPath = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;拼接路径:&#x27;</span>, joinedPath); <span class="hljs-comment">// /foo/bar/baz</span><br><br><span class="hljs-keyword">const</span> resolvedPath = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;/bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;绝对路径:&#x27;</span>, resolvedPath); <span class="hljs-comment">// 取决于当前工作目录</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;是否绝对路径:&#x27;</span>, path.<span class="hljs-title function_">isAbsolute</span>(filePath)); <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(<span class="hljs-string">&#x27;/foo/bar&#x27;</span>, <span class="hljs-string">&#x27;/foo/baz/file.txt&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;相对路径:&#x27;</span>, relativePath); <span class="hljs-comment">// ../../baz/file.txt</span><br></code></pre></td></tr></table></figure><h1 id="Mongodb数据库"><a href="#Mongodb数据库" class="headerlink" title="Mongodb数据库"></a>Mongodb数据库</h1><p>MongoDB 是一个基于 <strong>文档（Document）</strong> 的 NoSQL 数据库。它使用类似 JSON 的 BSON 格式存储数据，支持灵活的结构。</p><p>数据库就是管理数据的应用软件，对数据进行 增（c）、删（d）、改（u）、查（r）</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="【基础概念】"><a href="#【基础概念】" class="headerlink" title="【基础概念】"></a>【基础概念】</h3><ul><li><p><strong>数据库（Database）</strong><br>包含多个集合</p></li><li><p><strong>集合（Collection）</strong><br>类似于关系数据库的表，存储一组文档</p></li><li><p><strong>文档（Document）</strong><br>BSON 格式的数据结构，类似 JSON 对象<br>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-title class_">ObjectId</span>(<span class="hljs-string">&quot;...&quot;</span>),<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-string">&quot;skills&quot;</span>: [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;MongoDB&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>字段（Field）</strong><br>文档中的键值对，可以嵌套、数组等</p></li></ul><h3 id="【MongoDB-和-关系数据库】"><a href="#【MongoDB-和-关系数据库】" class="headerlink" title="【MongoDB 和 关系数据库】"></a>【MongoDB 和 关系数据库】</h3><ol><li><strong>数据怎么存</strong>？</li></ol><ul><li><strong>MongoDB</strong>：像存 JSON（一种写数据的格式），灵活，字段不固定，能直接嵌套数组和对象。</li><li><strong>关系数据库</strong>：数据存表里，行和列固定，必须先定义好表结构。</li></ul><ol start="2"><li><strong>怎么查数据</strong>？</li></ol><ul><li><strong>MongoDB</strong>：用 JSON 风格的语句查数据，比较像写对象。</li><li><strong>关系数据库</strong>：用 SQL 语句查数据，要写 <code>SELECT</code>、<code>JOIN</code> 等。</li></ul><ol start="3"><li><strong>数据关系和事务</strong></li></ol><ul><li><strong>MongoDB</strong>：适合关系不复杂的数据，也支持事务，但不如关系数据库成熟。</li><li><strong>关系数据库</strong>：关系复杂（比如多个表之间关联），事务支持特别好，保证数据准确。</li></ul><ol start="4"><li><strong>扩展和性能</strong></li></ol><ul><li><strong>MongoDB</strong>：很容易增加服务器横向扩展，适合海量数据和高并发。</li><li><strong>关系数据库</strong>：通常是往服务器加配置（纵向扩展），横向扩展比较难。</li></ul><p><strong>MongoDB 更灵活，适合大数据和变化快的应用；关系数据库更严谨，适合传统业务和复杂数据关联。</strong></p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><blockquote><p>参考文档： <a href="./mongodb.pdf">mongodb.pdf</a> </p></blockquote><h1 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h1><blockquote><p><a href="https://www.yuque.com/cuggz/interview/browser">前端面试题之浏览器原理篇</a></p></blockquote><h2 id="会话概念"><a href="#会话概念" class="headerlink" title="会话概念"></a>会话概念</h2><p><strong>会话（Session）</strong>，在网络通信里，指的是<strong>客户端与服务器之间，从建立连接开始，到连接关闭为止的一段连续交互过程</strong>。有两层含义。</p><ul><li>底层通信会话：从TCP连接建立到TCP连接断开的通信过程。</li><li>应用层逻辑会话：用 Session ID 等机制，从用户首次登录创建Session ID到超时或者登出，Session ID过期属于同一个“会话”</li></ul><p><strong>会话的本质</strong></p><ul><li>是一段有<strong>起点</strong>和<strong>终点</strong>的、有状态的通信过程</li><li>用来维持用户和服务器之间的<strong>上下文</strong>（Context）</li><li>可以跨多次请求，让服务端“记住”客户端。</li></ul><p>HTTP 是一种无状态的协议，它没有办法区分多次的请求是否来自于同一个客户端， 无法区分用户，因此需要过程<code>会话控制</code>来解决该问题。</p><p>常见的会话控制技术有三种：</p><ul><li>cookie</li><li>session</li><li>token</li></ul><h2 id="会话控制技术"><a href="#会话控制技术" class="headerlink" title="会话控制技术"></a>会话控制技术</h2><h3 id="【Cookie-会话控制】"><a href="#【Cookie-会话控制】" class="headerlink" title="【Cookie 会话控制】"></a>【Cookie 会话控制】</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><ul><li><strong>Cookie</strong> 是 <strong>浏览器端的一种存储机制</strong>，它本质上就是浏览器保存的一小段键值对数据。</li><li>浏览器会在后续请求中<strong>自动携带对应域名的 Cookie</strong> 发送给服务器。</li><li>服务器根据 Cookie 中的内容（比如用户 ID、Session ID）来识别用户。</li></ul><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a><strong>实现流程</strong></h4><ol><li><p><strong>第一次请求</strong></p><ul><li><p>客户端访问服务器，没有 Cookie</p></li><li><p>服务器响应中返回 <code>Set-Cookie</code> 头：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: userid=<span class="hljs-number">12345</span>; <span class="hljs-title class_">Expires</span>=<span class="hljs-title class_">Wed</span>, <span class="hljs-number">14</span> <span class="hljs-title class_">Aug</span> <span class="hljs-number">2025</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">GMT</span>; <span class="hljs-title class_">Path</span>=/<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>浏览器存储 Cookie</strong>（内存或硬盘）</p></li><li><p><strong>后续请求自动附带 Cookie</strong></p><ul><li><p>浏览器向同域名发请求时，自动在请求头中加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Cookie</span>: userid=<span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>服务器读取 Cookie 内容</strong>，执行逻辑</p></li></ol><p><strong>浏览器关闭时 Cookie “过期”的原理</strong></p><ul><li><strong>会话 Cookie</strong><ul><li>存在内存里（浏览器进程内存空间）</li><li>浏览器退出 → 进程销毁 → 内存释放 → Cookie 消失</li><li>下次启动浏览器，内存是空的，自然就“过期”了</li></ul></li><li><strong>持久 Cookie</strong><ul><li>存在硬盘文件</li><li>浏览器启动时会读取文件并加载还没过期的 Cookie</li><li>只有到 <code>Expires</code> &#x2F; <code>Max-Age</code> 到期，或用户手动删除时才会失效</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 启用 cookie 解析中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cookieParser</span>());<br><br><span class="hljs-comment">// 设置 Cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/set-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 不带时效性（会话 cookie，浏览器关闭即失效）</span><br>  res.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>);<br>  <span class="hljs-comment">// 带时效性（持久 cookie）</span><br>  res.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;email&#x27;</span>, <span class="hljs-string">&#x27;23123456@qq.com&#x27;</span>, &#123; <span class="hljs-attr">maxAge</span>: <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> &#125;);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Cookie 已设置&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 读取 Cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/get-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">cookies</span>); <span class="hljs-comment">// &#123; username: &#x27;wangwu&#x27;, email: &#x27;...&#x27; &#125;</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`当前 Cookie: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(req.cookies)&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 删除 Cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/delete-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">clearCookie</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Cookie 已删除&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已启动，端口 3000&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>自动化：浏览器帮你存储和发送，开发方便</li><li>兼容性好：几乎所有浏览器支持</li><li>可以存储少量信息（4KB 左右）</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li>容量小</li><li>每次请求都会带上 Cookie，增加流量</li><li>明文存储，容易被窃取（可配合 <code>Secure</code>、<code>HttpOnly</code>）</li><li>不适合存储敏感信息（应存 ID 而非用户密码）</li></ul><h3 id="【Session-会话控制】"><a href="#【Session-会话控制】" class="headerlink" title="【Session 会话控制】"></a>【Session 会话控制】</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>Session</strong> 是服务器端维护的会话状态信息。</li><li>客户端只存一个<strong>Session ID</strong>（通常在 Cookie 中），具体的会话数据保存在服务器内存、数据库或缓存中。</li><li>每次请求时，客户端带上 Session ID，服务器根据这个 ID 找到之前的会话数据。</li></ul><h4 id="实现流程-1"><a href="#实现流程-1" class="headerlink" title="实现流程"></a>实现流程</h4><ol><li><strong>第一次请求</strong><ul><li>客户端访问服务器，没有 Session ID</li><li>服务器生成一个唯一的 Session ID（比如 <code>abc123</code>）</li><li>在服务器端开辟存储空间，保存用户状态（如登录信息）</li><li>通过 <code>Set-Cookie</code> 把 Session ID 发给客户端</li></ul></li><li><strong>后续请求</strong><ul><li>浏览器带上 Cookie 中的 Session ID</li><li>服务器用这个 ID 找到对应会话数据</li></ul></li><li><strong>会话结束</strong><ul><li>Session 过期时间到 &#x2F; 用户登出 &#x2F; 服务器重启（如果没持久化）</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">// 1. 安装包：npm i express-session connect-mongo</span><br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MongoStore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;connect-mongo&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 2. 设置 session 中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sid&#x27;</span>,                 <span class="hljs-comment">// Cookie 名称，默认 connect.sid</span><br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;atguigu&#x27;</span>,           <span class="hljs-comment">// 签名，用于加密 session ID</span><br>  <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 是否保存未初始化的 session</span><br>  <span class="hljs-attr">resave</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 是否每次请求都重新保存 session</span><br>  <span class="hljs-attr">store</span>: <span class="hljs-title class_">MongoStore</span>.<span class="hljs-title function_">create</span>(&#123;   <span class="hljs-comment">// 存储到 MongoDB</span><br>    <span class="hljs-attr">mongoUrl</span>: <span class="hljs-string">&#x27;mongodb://127.0.0.1:27017/project&#x27;</span><br>  &#125;),<br>  <span class="hljs-attr">cookie</span>: &#123;<br>    <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 前端 JS 无法操作</span><br>    <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">300</span>         <span class="hljs-comment">// Session ID 过期时间（毫秒）</span><br>  &#125;<br>&#125;));<br><br><span class="hljs-comment">// 3. 创建 Session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;zhangsan&#x27;</span>;<br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">email</span> = <span class="hljs-string">&#x27;zhangsan@qq.com&#x27;</span>;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录成功，Session 已创建&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 4. 获取 Session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;session 信息:&#x27;</span>, req.<span class="hljs-property">session</span>);<br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span>) &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`你好 <span class="hljs-subst">$&#123;req.session.username&#125;</span>`</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请登录或注册&#x27;</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 5. 销毁 Session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/logout&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;成功退出&#x27;</span>);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 6. 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已启动，端口 3000 监听中...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>安全性较高：敏感数据存在服务器，不暴露给客户端</li><li>容量大：不受 Cookie 4KB 限制</li><li>可以存复杂结构（对象、列表）</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>占用服务器资源（内存、数据库）</li><li>多服务器环境需要 Session 共享（Redis、数据库同步）</li><li>默认依赖 Cookie 存 Session ID（禁用 Cookie 时要用 URL 重写）</li></ul><h3 id="【Token-会话控制】"><a href="#【Token-会话控制】" class="headerlink" title="【Token 会话控制】"></a>【Token 会话控制】</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>Token</strong> 是由服务器签发给客户端的加密字符串，通常包含用户信息和签名。</li><li>客户端持有 Token，后续请求时手动带上（通常放在 <code>Authorization</code> 头中）。</li><li>服务器<strong>不存储 Token 状态</strong>，而是通过解密&#x2F;验证签名来判断 Token 是否有效（JWT 就是这种无状态 Token 的典型实现）。</li><li>服务器验证 <strong>Token 签名</strong> 的核心原理，就是<strong>用同一密钥和相同算法重新生成签名，然后和 Token 里自带的签名比对</strong>，如果一致就说明 Token 没被篡改。</li><li><strong>Token 被截取</strong>，那么在它的有效期内，截取者就可以冒充你发起请求，从而导致<strong>权限丢失</strong>或<strong>数据泄露</strong>。</li></ul><h4 id="实现流程（JWT-为例）"><a href="#实现流程（JWT-为例）" class="headerlink" title="实现流程（JWT 为例）"></a>实现流程（JWT 为例）</h4><ol><li><p><strong>用户登录</strong></p><ul><li>客户端发送账号密码到服务器</li><li>服务器验证成功后，生成 Token（Base64 编码 + 签名）</li><li>返回 Token 给客户端</li></ul></li><li><p><strong>客户端存储 Token</strong></p><ul><li>存在 LocalStorage &#x2F; SessionStorage</li></ul></li><li><p><strong>后续请求</strong></p><ul><li><p>客户端在请求头加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Authorization</span>: <span class="hljs-title class_">Bearer</span> &lt;token&gt;<br></code></pre></td></tr></table></figure></li><li><p>服务器验证签名和过期时间，直接解析出用户信息</p></li></ul></li><li><p><strong>过期或刷新</strong></p><ul><li>Token 一旦签发无法撤回（除非维护黑名单）</li><li>常配合 Refresh Token 实现续期</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// jwt-demo.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SECRET_KEY</span> = <span class="hljs-string">&#x27;my_secret_key&#x27;</span>;<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 模拟用户验证</span><br>  <span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;alice&#x27;</span> &#125;;<br>  <span class="hljs-keyword">const</span> token = jwt.<span class="hljs-title function_">sign</span>(user, <span class="hljs-variable constant_">SECRET_KEY</span>, &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;1m&#x27;</span> &#125;); <br>  <span class="hljs-comment">// 负载（Payload） 秘钥（Secret Key） 配置对象，过期时间 60 秒</span><br>  res.<span class="hljs-title function_">json</span>(&#123; token &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/profile&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> authHeader = req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;authorization&#x27;</span>];<br>  <span class="hljs-keyword">if</span> (!authHeader) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">401</span>);<br><br>  <span class="hljs-keyword">const</span> token = authHeader.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>];<br>  jwt.<span class="hljs-title function_">verify</span>(token, <span class="hljs-variable constant_">SECRET_KEY</span>, <span class="hljs-function">(<span class="hljs-params">err, user</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">403</span>);<br>    res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">`欢迎你，<span class="hljs-subst">$&#123;user.username&#125;</span>`</span> &#125;);<br>  &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3002</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JWT 示例运行在 http://localhost:3002&#x27;</span>));<br><br></code></pre></td></tr></table></figure><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>无状态：服务器不存会话，易于扩展</li><li>跨平台：适合 Web、移动端、第三方 API</li><li>传输灵活：可放在 URL、Header、Cookie</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法主动让 Token 失效（除非加黑名单）</li><li>Token 长度比 Session ID 大（增加流量）</li><li>安全性依赖加密与签名算法</li></ul><h2 id="两种网络攻击"><a href="#两种网络攻击" class="headerlink" title="两种网络攻击"></a>两种网络攻击</h2><h3 id="【CSRF-攻击（Cross-Site-Request-Forgery）】"><a href="#【CSRF-攻击（Cross-Site-Request-Forgery）】" class="headerlink" title="【CSRF 攻击（Cross-Site Request Forgery）】"></a>【CSRF 攻击（Cross-Site Request Forgery）】</h3><p><strong>概念</strong></p><ul><li>攻击者诱导已登录用户在浏览器中发送<strong>伪造请求</strong>到受信任网站，执行用户权限内的操作。</li><li>核心是利用用户已经登录的状态（Cookie、Session、Token）。</li></ul><p><strong>原理</strong></p><ol><li>用户登录网站 A，Cookie 已认证</li><li>用户访问攻击者网站 B</li><li>B 页面发起请求到 A（GET&#x2F;POST），浏览器会自动携带 A 的 Cookie</li><li>A 接收到请求，误以为是用户本人操作 → 执行敏感操作</li></ol><p><strong>举例</strong></p><ul><li>用户已登录银行网站，攻击页面发起：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bank.com/transfer?to=attacker&amp;amount=1000&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>浏览器携带银行 Cookie → 转账成功</li></ul><p><strong>防护方法</strong></p><ol><li><strong>CSRF Token</strong><ul><li>服务器生成随机 Token，绑定用户 Session</li><li>请求中必须携带 Token，服务器校验一致才执行操作</li></ul></li><li>验证 Referer&#x2F;Origin 请求头<ul><li>检查请求来源是否可信</li></ul></li><li>使用验证<ul><li>验证码</li><li>人机验证</li></ul></li></ol><h3 id="【XSS-攻击（Cross-Site-Scripting）】"><a href="#【XSS-攻击（Cross-Site-Scripting）】" class="headerlink" title="【XSS 攻击（Cross-Site Scripting）】"></a>【XSS 攻击（Cross-Site Scripting）】</h3><p><strong>概念</strong></p><ul><li>攻击者在网页中注入恶意脚本（通常是 JavaScript），当用户浏览网页时，脚本在用户浏览器执行。</li><li>目标：<strong>窃取用户信息、篡改页面、执行恶意操作</strong>。</li></ul><p><strong>分类</strong></p><ol><li><strong>存储型 XSS</strong><ul><li>恶意脚本存储在服务器数据库或文件中</li><li>用户访问页面时，脚本被加载执行</li><li>例：留言板、评论区注入 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li></ul></li><li><strong>反射型 XSS</strong><ul><li>恶意脚本随 URL 或表单提交被反射回页面</li><li>用户点击链接就触发</li><li>例：<code>http://example.com/search?q=&lt;script&gt;alert(1)&lt;/script&gt;</code></li></ul></li><li><strong>DOM 型 XSS</strong><ul><li>恶意脚本只在浏览器端操作 DOM 执行</li><li>不经过服务器直接通过前端 JS 执行</li></ul></li></ol><p><strong>危害</strong></p><ul><li>窃取 Cookie、Token、Session 信息</li><li>劫持用户操作</li><li>页面篡改、钓鱼攻击</li></ul><p><strong>防护方法</strong></p><ul><li><p>对用户输入进行 <strong>HTML 转义</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> -&gt; <span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span></span></span><br></code></pre></td></tr></table></figure></li></ul><h1 id="接口请求处理"><a href="#接口请求处理" class="headerlink" title="接口请求处理"></a>接口请求处理</h1><h2 id="RESTFul风格设计"><a href="#RESTFul风格设计" class="headerlink" title="RESTFul风格设计"></a>RESTFul风格设计</h2><blockquote><p><a href="https://restfulapi.net/">https://restfulapi.net/</a></p></blockquote><h3 id="【接口设计】"><a href="#【接口设计】" class="headerlink" title="【接口设计】"></a>【接口设计】</h3><p>在Http协议传递过程中，URL可以选择param\json\path形式。**<font color="#FF774B">RestFul是一套HTTP协议的标准使用方案和风格，帮助用户完成设计：</font>**</p><ul><li>如何设计路径？</li><li>如何设计参数传递？</li><li>如何选择请求方式？</li></ul><ol><li><p><strong>接口设计</strong></p><table><thead><tr><th>功能</th><th>接口和请求方式</th><th>请求参数</th><th>返回值</th></tr></thead><tbody><tr><td>分页查询</td><td>GET  &#x2F;user</td><td>page&#x3D;1&amp;size&#x3D;10</td><td>{ 响应数据 }</td></tr><tr><td>用户添加</td><td>POST &#x2F;user</td><td>{ user 数据 }</td><td>{响应数据}</td></tr><tr><td>用户详情</td><td>GET &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>用户更新</td><td>PUT &#x2F;user</td><td>{ user 更新数据}</td><td>{响应数据}</td></tr><tr><td>用户删除</td><td>DELETE &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>条件模糊</td><td>GET &#x2F;user&#x2F;search</td><td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td><td>{响应数据}</td></tr></tbody></table></li><li><p><strong>问题讨论</strong></p><p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p><p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p><p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p><ul><li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li><li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。<br>此外，还有一些通用的原则可以遵循：</li><li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li><li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li><li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li></ul></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * projectName: com.atguigu.controller</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * description: 用户模块的控制器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟分页查询业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="hljs-type">int</span> page,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="hljs-type">int</span> size)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;page = &quot;</span> + page + <span class="hljs-string">&quot;, size = &quot;</span> + size);<br>        System.out.println(<span class="hljs-string">&quot;分页查询业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟用户保存业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">saveUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>        System.out.println(<span class="hljs-string">&quot;用户保存业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟用户详情业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">detailUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);<br>        System.out.println(<span class="hljs-string">&quot;用户详情业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟用户更新业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>        System.out.println(<span class="hljs-string">&quot;用户更新业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟条件分页查询业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;search&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="hljs-type">int</span> page,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="hljs-type">int</span> size,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(name = &quot;keyword&quot;,required= false)</span>String keyword)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;page = &quot;</span> + page + <span class="hljs-string">&quot;, size = &quot;</span> + size + <span class="hljs-string">&quot;, keyword = &quot;</span> + keyword);<br>        System.out.println(<span class="hljs-string">&quot;条件分页查询业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><font color="#FF774B">GET和DELETE没有请求体，如果参数只有一个例如id，使用路径传递参数。如果参数有多个，使用param传参；POST和PUT有请求体，直接使用请求体传递json。</font></strong></p><h3 id="【响应代码规范】"><a href="#【响应代码规范】" class="headerlink" title="【响应代码规范】"></a>【响应代码规范】</h3><p>HTTP 定义了这些标准状态代码，可用于传达客户端请求的结果。状态代码分为五类。</p><ul><li><strong><a href="https://restfulapi.net/http-status-codes/#1xx">1xx：信息性</a></strong> – 传达传输协议级信息。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#2xx">2xx：成功</a></strong> – 表示客户端的请求已成功接受。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#3xx">3xx：重定向</a></strong> – 表示客户端必须执行一些额外的作才能完成其请求。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#4xx">4xx：客户端错误</a></strong> – 此类错误状态代码将矛头指向客户端。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#5xx">5xx：服务器错误</a></strong> – 服务器对这些错误状态代码负责。</li></ul><h3 id="【Swagger】"><a href="#【Swagger】" class="headerlink" title="【Swagger】"></a>【Swagger】</h3><p>Swagger是一套基于 OpenAPI 规范（OAS）构建的开源工具，主要用于**<font color="#FF774B">生成、描述、调用和可视化RESTful风格的Web API</font>**。</p><h3 id="【Postman】"><a href="#【Postman】" class="headerlink" title="【Postman】"></a>【Postman】</h3><p>接口测试工具，可以模仿客户端向服务器发送接口请求，测试服务器接口的效果。</p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="【什么是-AJAX】"><a href="#【什么是-AJAX】" class="headerlink" title="【什么是 AJAX】"></a>【什么是 AJAX】</h3><p>AJAX（Asynchronous JavaScript and XML）是一种在<strong>不重新加载整个页面</strong>的情况下，从服务器获取数据并更新网页部分内容的技术。它不是一种新的编程语言，而是一种利用现有技术组合的交互方式。核心技术包括 JavaScript、HTML DOM、CSS，以及用于异步数据传输的 <code>XMLHttpRequest</code> 或 <code>Fetch</code> API。</p><p>AJAX 的出现，使得网页在用户操作时可以做到<strong>局部刷新</strong>，提升用户体验。例如，搜索引擎的搜索建议、社交平台的动态加载、地图应用的平滑拖动等，都是 AJAX 的典型应用。</p><h3 id="【AJAX-的特点】"><a href="#【AJAX-的特点】" class="headerlink" title="【AJAX 的特点】"></a>【AJAX 的特点】</h3><ul><li>异步通信：无需刷新整个页面即可与服务器交换数据</li><li>提高用户体验：局部更新页面，减少延迟感</li><li>数据格式多样：不仅可以使用 XML，还可以使用 JSON、HTML、纯文本等</li><li>基于已有标准：HTML、CSS、JavaScript、DOM、XMLHttpRequest</li><li>与服务器交互更灵活：支持 GET、POST 等多种 HTTP 方法</li></ul><h3 id="【AJAX-的工作原理】"><a href="#【AJAX-的工作原理】" class="headerlink" title="【AJAX 的工作原理】"></a>【AJAX 的工作原理】</h3><ol><li>用户在浏览器上触发事件（如点击按钮）</li><li>JavaScript 创建 AJAX 请求对象（XMLHttpRequest 或 Fetch）</li><li>浏览器向服务器发送 HTTP 请求（异步，不阻塞页面）</li><li>服务器接收请求并返回数据（JSON、XML、HTML 等）</li><li>浏览器接收响应数据，并由 JavaScript 更新 DOM 内容</li><li>页面局部刷新，而不是整个重新加载</li></ol><p>数据交互过程可简化为：浏览器事件 → 发送请求 → 服务器响应 → 前端更新</p><h3 id="【AJAX-的实现方法】"><a href="#【AJAX-的实现方法】" class="headerlink" title="【AJAX 的实现方法】"></a>【AJAX 的实现方法】</h3><ul><li><strong>XMLHttpRequest</strong>：早期的 AJAX 核心实现方式，功能全面但语法相对繁琐</li><li><strong>Fetch API</strong>：现代浏览器原生提供的异步请求方式，基于 Promise，更加简洁</li><li><strong>Axios</strong>：第三方 HTTP 库，支持 Promise，功能丰富，兼容性好，支持请求&#x2F;响应拦截等高级特性</li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><h3 id="【什么是跨域】"><a href="#【什么是跨域】" class="headerlink" title="【什么是跨域】"></a>【什么是跨域】</h3><p>跨域是指浏览器出于安全策略（同源策略，Same-Origin Policy）的限制，阻止网页向不同域名、协议或端口的服务器发送 AJAX 请求。</p><p>例如：</p><ul><li>页面地址：<a href="http://example.com/">http://example.com</a></li><li>请求地址：<a href="http://api.example.com/">http://api.example.com</a><br>因为域名不同，会触发跨域限制。</li></ul><p>常见的跨域解决方法：</p><ul><li><strong>CORS（跨域资源共享）</strong>：服务器在响应头中设置 <code>Access-Control-Allow-Origin</code> 来允许特定来源访问</li><li><strong>JSONP</strong>：利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性进行跨域（仅支持 GET 请求，已较少使用）</li><li><strong>服务器代理</strong>：通过服务器代理转发请求，前端请求同源服务器，由该服务器再访问目标接口</li><li><strong>WebSocket</strong>：双向通信协议，可绕过部分跨域限制</li></ul><blockquote><p><a href="https://www.yuque.com/tianyu-coder/openshare/aksmvpbebgw7savk">跨域问题梳理</a></p><p><a href="https://www.bilibili.com/video/BV1pT421k7yz/?spm_id_from=333.337.search-card.all.click&vd_source=ff414aaf189e3a685358d2a984fd4742">禹神：一小时彻底搞懂跨域&amp;解决方案_哔哩哔哩_bilibili</a></p></blockquote><p>跨域问题导致会话控制种的cookie和session都无法使用，因此目前最常用的会话控制都是token。</p><h3 id="【cookie跨域问题】"><a href="#【cookie跨域问题】" class="headerlink" title="【cookie跨域问题】"></a>【cookie跨域问题】</h3><ol><li>浏览器的同源策略限制</li></ol><ul><li><strong>同源策略（Same-Origin Policy）</strong> 要求：协议、域名、端口三者必须一致，Cookie 才会被浏览器自动携带给服务器。</li><li>如果前端页面是 <code>https://a.com</code>，而你请求的 API 是 <code>https://api.b.com</code>，即便两者都是你的服务，浏览器也<strong>不会</strong>自动把 <code>a.com</code> 的 Cookie 发给 <code>b.com</code>。</li></ul><ol start="2"><li>Cookie 的作用域由 <code>Domain</code> 决定</li></ol><ul><li><p>服务器在响应头中设置 Cookie 时，可以指定 <code>Domain</code>，它定义了 Cookie 属于哪个域。</p></li><li><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: sessionId=abc123; <span class="hljs-title class_">Domain</span>=a.<span class="hljs-property">com</span>; <span class="hljs-title class_">Path</span>=/<br></code></pre></td></tr></table></figure><p>这样设置的 Cookie 只会发送给 <code>a.com</code> 及其子域（<code>sub.a.com</code>），<strong>不会</strong>被发送给 <code>b.com</code>。</p></li><li><p>Cookie 无法直接跨顶级域（如 <code>.com</code> 和 <code>.cn</code>），因为浏览器会拒绝这样的设置以防信息泄露。</p></li></ul><ol start="3"><li><strong>安全策略（防止 CSRF）</strong></li></ol><ul><li><p>浏览器在跨域请求中默认 <strong>不发送 Cookie</strong>，除非你在 AJAX 请求中显式开启：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.b.com/data&#x27;</span>, &#123;<br>  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>即便这样做，后端还必须在响应中添加 CORS 允许携带凭证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Credentials</span>: <span class="hljs-literal">true</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//a.com</span><br></code></pre></td></tr></table></figure></li><li><p>这种额外的安全验证，就是为了防止第三方网站利用 Cookie 自动登录或冒充用户（CSRF 攻击）。</p></li></ul><h2 id="三种请求方法"><a href="#三种请求方法" class="headerlink" title="三种请求方法"></a>三种请求方法</h2><blockquote><p><a href="https://www.yuque.com/cuggz/feplus/ouwmxw3uk0vdnz8p#jYHEA">Fetch、Axios、Ajax、XHR</a></p></blockquote><h3 id="XMLHttpRequest（XHR）"><a href="#XMLHttpRequest（XHR）" class="headerlink" title="XMLHttpRequest（XHR）"></a>XMLHttpRequest（XHR）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 配置请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/api/user&#x27;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置请求头</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br><br><span class="hljs-comment">// 携带跨域凭据</span><br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 上传进度</span><br>xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`上传进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 下载进度</span><br>xhr.<span class="hljs-property">onprogress</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`下载进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 响应类型</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;json&#x27;</span>;<br><br><span class="hljs-comment">// 超时设置</span><br>xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">5000</span>;<br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求超时&#x27;</span>);<br><br><span class="hljs-comment">// 成功回调</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;响应数据:&#x27;</span>, xhr.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败:&#x27;</span>, xhr.<span class="hljs-property">status</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 错误回调</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;网络错误&#x27;</span>);<br><br><span class="hljs-comment">// 发送数据</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;));<br></code></pre></td></tr></table></figure><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// GET 请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 错误: <span class="hljs-subst">$&#123;res.status&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err));<br><br><span class="hljs-comment">// POST JSON 数据</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;)<br>&#125;);<br><br><span class="hljs-comment">// 携带跨域凭据</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>, &#123; <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 取消请求（AbortController）</span><br><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/longtask&#x27;</span>, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求被取消:&#x27;</span>, err.<span class="hljs-property">name</span>));<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(), <span class="hljs-number">3000</span>);<br><br><span class="hljs-comment">// 流式读取下载数据</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/bigfile&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">reader</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> reader.<span class="hljs-title function_">read</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">&#123; done, value &#125;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;下载完成&#x27;</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;接收数据块大小:&#x27;</span>, value.<span class="hljs-property">length</span>);<br>      <span class="hljs-keyword">return</span> reader.<span class="hljs-title function_">read</span>().<span class="hljs-title function_">then</span>(process);<br>    &#125;);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><blockquote><p><a href="https://axios.nodejs.cn/docs/intro">立即开始 | Axios 文档</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建实例</span><br><span class="hljs-keyword">const</span> api = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;/api&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>&#125;);<br><br><span class="hljs-comment">// 请求拦截器</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">&#x27;Bearer token&#x27;</span>;<br>  <span class="hljs-keyword">return</span> config;<br>&#125;);<br><br><span class="hljs-comment">// 响应拦截器</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>,<br>  <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>);<br><br><span class="hljs-comment">// GET 请求</span><br>api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br><br><span class="hljs-comment">// POST 请求</span><br>api.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 上传文件并监听进度</span><br><span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]);<br>api.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, formData, &#123;<br>  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">total</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`上传进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 下载文件并监听进度</span><br>api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/download&#x27;</span>, &#123;<br>  <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;blob&#x27;</span>,<br>  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">total</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`下载进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 取消请求</span><br><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/longtask&#x27;</span>, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br>controller.<span class="hljs-title function_">abort</span>();<br></code></pre></td></tr></table></figure><h4 id="Axios-配置项-请求报文对应关系"><a href="#Axios-配置项-请求报文对应关系" class="headerlink" title="Axios 配置项 &amp; 请求报文对应关系"></a>Axios 配置项 &amp; 请求报文对应关系</h4><table><thead><tr><th>Axios 配置项</th><th>作用位置</th><th>最终在 HTTP 请求中的表现</th><th>Node.js (Express) 里 <code>req</code> 的对应字段</th></tr></thead><tbody><tr><td><code>url</code></td><td>请求行</td><td><code>POST /user HTTP/1.1</code></td><td><code>req.url</code>、<code>req.path</code>、<code>req.query</code></td></tr><tr><td><code>method</code></td><td>请求行</td><td><code>POST /user HTTP/1.1</code></td><td><code>req.method</code></td></tr><tr><td><code>baseURL</code>+<code>url</code></td><td>请求行</td><td><code>http://localhost:3000/user</code></td><td><code>req.hostname</code>、<code>req.originalUrl</code></td></tr><tr><td><code>params</code></td><td>URL 查询</td><td><code>/user?id=123&amp;type=admin</code></td><td><code>req.query</code></td></tr><tr><td><code>data</code></td><td>请求体</td><td>JSON、form-data、x-www-form-urlencoded</td><td><code>req.body</code>（需 <code>body-parser</code>&#x2F;<code>express.json()</code> 中间件）</td></tr><tr><td><code>headers</code></td><td>请求头</td><td><code>Content-Type: application/json</code></td><td><code>req.headers</code></td></tr><tr><td><code>timeout</code></td><td>Axios 内部</td><td>不影响 HTTP 报文</td><td>不存在于 <code>req</code>，是 Axios 客户端行为</td></tr><tr><td><code>withCredentials</code></td><td>请求头</td><td><code>Cookie: ...</code></td><td><code>req.headers.cookie</code>、<code>req.cookies</code>（需 cookie-parser）</td></tr><tr><td><code>auth</code></td><td>请求头</td><td><code>Authorization: Basic xxx</code></td><td><code>req.headers.authorization</code></td></tr><tr><td><code>responseType</code></td><td>响应处理</td><td>不影响请求，只影响客户端解析</td><td>和 <code>req</code> 无关，是 Axios 客户端行为</td></tr></tbody></table><h4 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-comment">// 请求方法 (GET、POST、PUT、DELETE、PATCH...)</span><br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br><br>  <span class="hljs-comment">// 请求 URL</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br><br>  <span class="hljs-comment">// baseURL 会自动拼接在 url 前面</span><br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>,<br><br>  <span class="hljs-comment">// 请求参数（拼接到 URL 上，GET 常用）</span><br>  <span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">123</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;admin&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求体数据（POST/PUT 常用）</span><br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;tom&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求头</span><br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer token123&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求超时时间（ms）</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br><br>  <span class="hljs-comment">// 跨域是否携带 Cookie</span><br>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>,<br><br>  <span class="hljs-comment">// 响应数据格式（默认 json，可选 text, blob, arraybuffer, stream 等）</span><br>  <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br><br>  <span class="hljs-comment">// 自定义状态码校验规则（默认 200–299 为成功）</span><br>  <span class="hljs-attr">validateStatus</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">400</span> <span class="hljs-comment">// 200~399 认为成功</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求进度（上传/下载）</span><br>  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;上传进度:&#x27;</span>, progressEvent.<span class="hljs-property">loaded</span> / progressEvent.<span class="hljs-property">total</span>)<br>  &#125;,<br>  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;下载进度:&#x27;</span>, progressEvent.<span class="hljs-property">loaded</span> / progressEvent.<span class="hljs-property">total</span>)<br>  &#125;,<br><br>  <span class="hljs-comment">// 取消请求</span><br>  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> axios.<span class="hljs-title class_">CancelToken</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) &#123;<br>    <span class="hljs-comment">// 调用 cancel() 可取消请求</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 发起请求</span><br><span class="hljs-title function_">axios</span>(config).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="功能对比表"><a href="#功能对比表" class="headerlink" title="功能对比表"></a>功能对比表</h3><table><thead><tr><th>功能</th><th>XHR</th><th>Fetch</th><th>Axios</th></tr></thead><tbody><tr><td>GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 支持</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>自定义请求头</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>跨域携带 Cookie</td><td>✔（withCredentials）</td><td>✔（credentials）</td><td>✔（withCredentials）</td></tr><tr><td>上传进度监听</td><td>✔</td><td>✘</td><td>✔</td></tr><tr><td>下载进度监听</td><td>✔</td><td>流式读取</td><td>✔</td></tr><tr><td>超时设置</td><td>✔</td><td>✘（需手动）</td><td>✔</td></tr><tr><td>取消请求</td><td>✘</td><td>✔（AbortController）</td><td>✔</td></tr><tr><td>JSON 自动解析</td><td>✘（需手动）</td><td>✘（需手动）</td><td>✔</td></tr><tr><td>请求拦截器</td><td>✘</td><td>✘</td><td>✔</td></tr><tr><td>响应拦截器</td><td>✘</td><td>✘</td><td>✔</td></tr><tr><td>API 简洁度</td><td>较低</td><td>中等</td><td>高</td></tr><tr><td>兼容性</td><td>极佳（IE5+）</td><td>现代浏览器</td><td>现代浏览器 + Node</td></tr></tbody></table><h2 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h2><table><thead><tr><th>特性</th><th>XMLHttpRequest</th><th>Fetch</th><th>Axios</th></tr></thead><tbody><tr><td>语法简洁性</td><td>较繁琐，需要手动监听状态</td><td>简洁，基于 Promise</td><td>简洁，基于 Promise</td></tr><tr><td>兼容性</td><td>广泛支持（IE5+）</td><td>现代浏览器（需 polyfill 兼容 IE）</td><td>广泛支持（含 Node.js）</td></tr><tr><td>错误处理</td><td>需检查 readyState 和 status</td><td>需手动检查 response.ok</td><td>自动抛出 HTTP 错误</td></tr><tr><td>请求&#x2F;响应拦截</td><td>不支持</td><td>不支持（需手动封装）</td><td>支持</td></tr><tr><td>自动 JSON 解析</td><td>不支持（需手动 JSON.parse）</td><td>不支持（需调用 response.json）</td><td>支持</td></tr><tr><td>取消请求</td><td>复杂</td><td>支持 AbortController</td><td>原生支持 cancel token</td></tr><tr><td>上传进度</td><td>支持</td><td>不直接支持</td><td>支持（需配置）</td></tr></tbody></table><p>总结：</p><ul><li>对于简单项目：推荐使用 Fetch（现代浏览器环境）</li><li>对于需要兼容性、丰富功能的项目：推荐使用 Axios</li><li>在老旧浏览器环境且无库支持：只能使用 XMLHttpRequest</li></ul><h1 id="前端打包工具"><a href="#前端打包工具" class="headerlink" title="前端打包工具"></a>前端打包工具</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1Kd4y147gg?spm_id_from=333.788.player.switch&vd_source=ff414aaf189e3a685358d2a984fd4742&p=6">06_loader_哔哩哔哩_bilibili</a></p><p><a href="https://www.yuque.com/cuggz/interview/hx0sf2#Tztcn">前端面试题之前端工程化篇</a></p></blockquote><h2 id="什么是前端打包工具"><a href="#什么是前端打包工具" class="headerlink" title="什么是前端打包工具"></a>什么是前端打包工具</h2><p>前端打包工具（Bundler &#x2F; Build Tool）的核心目标是：</p><p><strong>将分散的源代码与资源，转换、整合并输出为浏览器或运行环境可理解的高性能生产代码。</strong></p><p>打包工具到底“打包”了什么</p><p>打包工具处理的不是只有 JS，而是整个前端工程的所有输入：</p><ul><li>JavaScript &#x2F; TypeScript</li><li>CSS &#x2F; SCSS &#x2F; Less</li><li>图片 &#x2F; 字体 &#x2F; SVG</li><li>JSON &#x2F; WASM</li><li>环境变量 &#x2F; 配置文件</li></ul><p>最终目标只有一个：</p><blockquote><p> <strong>生成一组浏览器能够高效加载、稳定运行、长期缓存的静态资源。</strong></p></blockquote><h3 id="【打包工具解决的问题】"><a href="#【打包工具解决的问题】" class="headerlink" title="【打包工具解决的问题】"></a>【打包工具解决的问题】</h3><p>本质解决三类问题：</p><ul><li><strong>工程化问题</strong>：模块拆分、依赖管理、开发规范</li><li><strong>兼容性问题</strong>：语法降级、Polyfill、浏览器差异</li><li><strong>性能问题</strong>：减少体积、减少请求、提升加载速度</li></ul><h4 id="工程化问题：代码如何从“可维护”变成“可执行”"><a href="#工程化问题：代码如何从“可维护”变成“可执行”" class="headerlink" title="工程化问题：代码如何从“可维护”变成“可执行”"></a>工程化问题：代码如何从“可维护”变成“可执行”</h4><ol><li>工程化问题到底指什么</li></ol><p>现代前端项目几乎都采用<strong>模块化工程设计</strong>：</p><ul><li>一个系统会被拆分成多个功能模块</li><li>每个模块只关注自己的职责</li><li>模块之间通过 <code>import / export</code> 建立依赖关系</li></ul><p>这种方式<strong>对人非常友好</strong>，但对浏览器并不友好。</p><hr><ol start="2"><li>浏览器面临的根本问题</li></ol><p>浏览器本身存在三个限制：</p><ul><li>它并不关心“工程结构”</li><li>它不会帮你分析模块依赖关系</li><li>它只会按资源加载顺序执行脚本</li></ul><p>也就是说，浏览器无法自动完成：</p><ul><li>哪个模块应该先执行</li><li>模块之间是否存在循环依赖</li><li>多个模块如何组合成一个整体应用</li></ul><hr><ol start="3"><li>打包工具在工程化问题中的作用</li></ol><p>打包工具在这里扮演的是一个<strong>“工程解释器”</strong>：</p><ul><li>分析所有模块之间的依赖关系</li><li>构建完整的依赖关系图</li><li>根据依赖关系，重新组织代码的加载和执行顺序</li><li>将“工程化拆分的代码”整合为“浏览器可执行的结构”</li></ul><p>换句话说：</p><blockquote><p><strong>工程化让代码更容易被人理解，打包工具让代码重新变得可被浏览器理解。</strong></p></blockquote><hr><h4 id="兼容性问题：浏览器不认识你的“工程语言”"><a href="#兼容性问题：浏览器不认识你的“工程语言”" class="headerlink" title="兼容性问题：浏览器不认识你的“工程语言”"></a>兼容性问题：浏览器不认识你的“工程语言”</h4><ol><li>为什么会出现兼容性问题</li></ol><p>现代前端工程中，开发者大量使用：</p><ul><li>TypeScript</li><li>SCSS &#x2F; Less</li><li>JSX</li><li>新版本 JavaScript 语法</li></ul><p>这些语言和语法的共同特点是：</p><ul><li><strong>浏览器无法直接识别</strong></li><li>它们是“工程阶段语言”，不是“运行阶段语言”</li></ul><hr><ol start="2"><li>不同浏览器之间的现实差异</li></ol><p>即使是标准 JavaScript，不同浏览器之间仍然存在：</p><ul><li>语法支持差异</li><li>API 支持差异</li><li>行为细节差异</li></ul><p>如果直接将源码交给浏览器执行，就会出现：</p><ul><li>某些浏览器报错</li><li>某些功能不可用</li><li>行为不一致</li></ul><hr><ol start="3"><li>打包工具如何解决兼容性问题</li></ol><p>打包工具在构建阶段会：</p><ul><li>将工程语言转换为浏览器通用的 JavaScript &#x2F; CSS</li><li>对新语法进行降级处理</li><li>按目标浏览器环境生成对应的代码形式</li></ul><p>这一步的本质是：</p><blockquote><p><strong>把“开发时的高级表达”，翻译成“运行时的通用表达”。</strong></p></blockquote><p>兼容性问题并不是浏览器运行时才解决的，而是<strong>在打包阶段被提前消化掉的</strong>。</p><hr><h4 id="性能问题：工程化代码如何高效加载"><a href="#性能问题：工程化代码如何高效加载" class="headerlink" title="性能问题：工程化代码如何高效加载"></a>性能问题：工程化代码如何高效加载</h4><ol><li>工程化本身会带来性能风险</li></ol><p>模块化拆分虽然利于开发，但会导致：</p><ul><li>文件数量急剧增加</li><li>重复代码增多</li><li>请求次数变多</li><li>首屏加载成本变高</li></ul><p>如果直接让浏览器加载这些工程化文件，性能会迅速恶化。</p><hr><ol start="2"><li>打包工具如何从构建阶段解决性能问题</li></ol><p>打包工具在性能层面主要做三类事情：</p><p>第一，减少体积</p><ul><li>删除未使用代码</li><li>压缩代码体积</li><li>合并重复逻辑</li></ul><p>第二，减少请求数量</p><ul><li>将多个模块合并成一个或几个必要的文件</li><li>避免浏览器发起大量零散请求</li></ul><p>第三，重新组织加载方式</p><ul><li>将代码拆分为多个块（Chunk）</li><li>首屏只加载必要代码</li><li>非关键功能按需加载</li></ul><hr><ol start="3"><li>性能优化的核心思想</li></ol><p>打包工具并不是简单地“把代码全部合成一个文件”，而是：</p><blockquote><p><strong>在“加载成本”和“执行效率”之间做结构性权衡。</strong></p></blockquote><ul><li>小项目：可能合并成一个文件更快</li><li>大项目：必须拆分、按需加载</li></ul><p>这些决策<strong>只能在打包阶段完成</strong>，浏览器无法自动完成。</p><h3 id="【常见的前端打包工具】"><a href="#【常见的前端打包工具】" class="headerlink" title="【常见的前端打包工具】"></a>【常见的前端打包工具】</h3><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p><strong>定位</strong>：通用型、全功能前端打包工具</p><p>Webpack 是目前应用最广、生态最成熟的前端打包工具，核心思想是<strong>以模块为中心构建依赖图</strong>。</p><p><strong>特点</strong>：</p><ul><li>支持 JS、CSS、图片等一切资源的模块化</li><li>Loader 负责模块内容转换</li><li>Plugin 负责构建流程扩展</li><li>功能全面、可定制性极强</li></ul><p><strong>适用场景</strong>：</p><ul><li>中大型前端项目</li><li>对构建流程和优化策略有高度控制需求的工程</li><li>历史项目或复杂企业级项目</li></ul><hr><h4 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h4><p><strong>定位</strong>：现代前端开发工具，强调开发体验</p><p>Vite 的核心创新在于：<strong>开发阶段不打包，直接基于浏览器原生 ESM 运行</strong>。</p><p><strong>特点</strong>：</p><ul><li>开发阶段启动极快</li><li>按需编译模块</li><li>生产环境使用 Rollup 打包</li><li>配置轻量，默认即最佳实践</li></ul><p><strong>适用场景</strong>：</p><ul><li>Vue &#x2F; React 等现代前端项目</li><li>中小型到中大型应用</li><li>追求开发效率和现代工程体验的项目</li></ul><hr><h4 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h4><p><strong>定位</strong>：专注于“干净输出”的打包工具</p><p>Rollup 更关注<strong>输出代码质量</strong>，而非开发阶段体验。</p><p><strong>特点</strong>：</p><ul><li>天然支持 ES Module</li><li>Tree Shaking 能力非常强</li><li>输出结果结构清晰、体积小</li><li>配置偏向构建产物而非开发服务器</li></ul><p><strong>适用场景</strong>：</p><ul><li>类库、SDK、工具函数库</li><li>对输出体积和结构要求极高的项目</li><li>作为 Vite 的生产环境打包底层工具</li></ul><hr><h4 id="esbuild"><a href="#esbuild" class="headerlink" title="esbuild"></a>esbuild</h4><p><strong>定位</strong>：高性能构建引擎</p><p>esbuild 使用 Go 编写，核心目标是<strong>极致构建速度</strong>。</p><p><strong>特点</strong>：</p><ul><li>构建速度非常快</li><li>支持 TS、JSX 等常见语法</li><li>功能相对精简</li><li>多作为底层构建能力使用</li></ul><p><strong>适用场景</strong>：</p><ul><li>构建工具的底层依赖</li><li>对构建速度要求极高的场景</li><li>不需要复杂插件体系的项目</li></ul><hr><h4 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h4><p><strong>定位</strong>：零配置打包工具</p><p>Parcel 强调“开箱即用”，目标是降低前端工程化的使用门槛。</p><p><strong>特点</strong>：</p><ul><li>几乎不需要配置</li><li>自动处理常见资源类型</li><li>学习成本低</li><li>可控性相对较弱</li></ul><p><strong>适用场景</strong>：</p><ul><li>小型项目</li><li>快速原型开发</li><li>初学者或对构建细节要求不高的项目</li></ul><h2 id="Webpack-1"><a href="#Webpack-1" class="headerlink" title="Webpack"></a>Webpack</h2><p><a href="https://www.webpackjs.com/concepts/">概念 | webpack 中文文档 | webpack中文文档 | webpack中文网</a></p><h3 id="【Webpack-是什么】"><a href="#【Webpack-是什么】" class="headerlink" title="【Webpack 是什么】"></a>【Webpack 是什么】</h3><p>Webpack 是一个<strong>以模块为核心</strong>的前端构建工具，其本质是：</p><blockquote><p><strong>从一个或多个入口文件出发，构建整个应用的依赖图（Dependency Graph），并将其打包为若干个可部署的静态资源。</strong></p></blockquote><hr><p>Webpack 的核心思想</p><ul><li>一切皆模块 JS&#x2F;CSS&#x2F;图片&#x2F;字体&#x2F;JSON</li><li>模块之间通过 <code>import / require</code> 建立依赖</li><li>Webpack 递归分析依赖，最终形成资源图</li></ul><h3 id="【Webpack-核心概念】"><a href="#【Webpack-核心概念】" class="headerlink" title="【Webpack 核心概念】"></a>【Webpack 核心概念】</h3><h4 id="Entry（入口）"><a href="#Entry（入口）" class="headerlink" title="Entry（入口）"></a>Entry（入口）</h4><p>入口决定了<strong>依赖分析的起点</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>单入口：适合 SPA</li><li>多入口：适合多页面应用（MPA）</li></ul><hr><h4 id="Output（输出）"><a href="#Output（输出）" class="headerlink" title="Output（输出）"></a>Output（输出）</h4><p>输出定义了<strong>打包结果的结构与位置</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">output</span>: &#123;<br>  <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>常见关注点：</p><ul><li>输出目录</li><li>文件名规则</li><li>hash &#x2F; chunkhash &#x2F; contenthash</li></ul><hr><h4 id="Loader（加载器）"><a href="#Loader（加载器）" class="headerlink" title="Loader（加载器）"></a>Loader（加载器）</h4><p>Loader 的本质是：</p><blockquote><p><strong>将非 JS 资源转换为 Webpack 能理解的模块</strong></p></blockquote><p>常见 Loader 分类</p><ul><li>语法转换<ul><li><code>babel-loader</code></li><li><code>ts-loader</code></li></ul></li><li>样式处理<ul><li><code>css-loader</code></li><li><code>style-loader</code></li><li><code>sass-loader</code></li></ul></li><li>资源处理<ul><li><code>file-loader</code></li><li><code>url-loader</code></li><li><code>asset module</code></li></ul></li></ul><h4 id="Loader-执行特点"><a href="#Loader-执行特点" class="headerlink" title="Loader 执行特点"></a>Loader 执行特点</h4><ul><li>从右到左（或从下到上）</li><li>纯函数</li><li>单一职责</li></ul><hr><h4 id="Plugin（插件）"><a href="#Plugin（插件）" class="headerlink" title="Plugin（插件）"></a>Plugin（插件）</h4><p>Plugin 解决的是：</p><blockquote><p><strong>Loader 无法处理的构建阶段问题</strong></p></blockquote><p>Plugin 的能力范围</p><ul><li>构建流程控制</li><li>资源优化</li><li>注入环境变量</li><li>生成 HTML</li><li>压缩与分析</li></ul><p>常见插件</p><ul><li><code>HtmlWebpackPlugin</code></li><li><code>DefinePlugin</code></li><li><code>MiniCssExtractPlugin</code></li><li><code>CleanWebpackPlugin</code></li><li><code>CopyWebpackPlugin</code></li></ul><h3 id="【Webpack基本配置】"><a href="#【Webpack基本配置】" class="headerlink" title="【Webpack基本配置】"></a>【Webpack基本配置】</h3><h4 id="一、配套依赖（最小集合）"><a href="#一、配套依赖（最小集合）" class="headerlink" title="一、配套依赖（最小集合）"></a>一、配套依赖（最小集合）</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">npm</span> install -D <span class="hljs-string">\</span><br>webpack webpack-cli webpack-dev-server <span class="hljs-string">\</span><br>html-webpack-plugin <span class="hljs-string">\</span><br>babel-loader @babel/core @babel/preset-env <span class="hljs-string">\</span><br>css-loader style-loader <span class="hljs-string">\</span><br>mini-css-extract-plugin<br></code></pre></td></tr></table></figure><p><code>babel.config.js</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  presets: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="二、推荐项目结构"><a href="#二、推荐项目结构" class="headerlink" title="二、推荐项目结构"></a>二、推荐项目结构</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project<br>├─ public<br>│  └─ index<span class="hljs-selector-class">.html</span><br>├─ <span class="hljs-attribute">src</span><br>│  ├─ index<span class="hljs-selector-class">.js</span><br>│  ├─ index<span class="hljs-selector-class">.css</span><br>│  └─ assets<br>├─ dist<br>├─ babel<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span><br>└─ webpack<span class="hljs-selector-class">.config</span>.js<br></code></pre></td></tr></table></figure><h4 id="三、基本配置项"><a href="#三、基本配置项" class="headerlink" title="三、基本配置项"></a>三、基本配置项</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>)<br><br><span class="hljs-keyword">const</span> isProd = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 构建模式</span><br>  <span class="hljs-attr">mode</span>: isProd ? <span class="hljs-string">&#x27;production&#x27;</span> : <span class="hljs-string">&#x27;development&#x27;</span>,<br><br>  <span class="hljs-comment">// 入口</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br><br>  <span class="hljs-comment">// 输出</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: isProd<br>      ? <span class="hljs-string">&#x27;js/[name].[contenthash:8].js&#x27;</span><br>      : <span class="hljs-string">&#x27;js/[name].js&#x27;</span>,<br>    <span class="hljs-attr">assetModuleFilename</span>: <span class="hljs-string">&#x27;assets/[hash][ext][query]&#x27;</span>,<br>    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 模块解析规则</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      <span class="hljs-comment">// JS / ES6+</span><br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>      &#125;,<br><br>      <span class="hljs-comment">// CSS</span><br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          isProd ? <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span> : <span class="hljs-string">&#x27;style-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span><br>        ]<br>      &#125;,<br><br>      <span class="hljs-comment">// 图片 / 字体 / 媒体资源（Webpack 5 内置）</span><br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg|woff2?|eot|ttf)$/i</span>,<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;asset&#x27;</span>,<br>        <span class="hljs-attr">parser</span>: &#123;<br>          <span class="hljs-attr">dataUrlCondition</span>: &#123;<br>            <span class="hljs-attr">maxSize</span>: <span class="hljs-number">8</span> * <span class="hljs-number">1024</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;,<br><br>  <span class="hljs-comment">// 插件</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./public/index.html&#x27;</span>,<br>      <span class="hljs-attr">inject</span>: <span class="hljs-string">&#x27;body&#x27;</span><br>    &#125;),<br><br>    isProd &amp;&amp;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;css/[name].[contenthash:8].css&#x27;</span><br>      &#125;)<br>  ].<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>),<br><br>  <span class="hljs-comment">// 模块解析配置</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>],<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// Source Map</span><br>  <span class="hljs-attr">devtool</span>: isProd ? <span class="hljs-string">&#x27;source-map&#x27;</span> : <span class="hljs-string">&#x27;eval-cheap-module-source-map&#x27;</span>,<br><br>  <span class="hljs-comment">// 开发服务器</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,<br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 性能与拆包优化（基础）</span><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">splitChunks</span>: &#123;<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">runtimeChunk</span>: <span class="hljs-string">&#x27;single&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>作用</th></tr></thead><tbody><tr><td>mode</td><td>控制构建优化策略</td></tr><tr><td>entry</td><td>依赖分析起点</td></tr><tr><td>output</td><td>打包结果规则</td></tr><tr><td>module.rules</td><td>各类资源处理</td></tr><tr><td>plugins</td><td>构建生命周期增强</td></tr><tr><td>resolve</td><td>模块解析与别名</td></tr><tr><td>devtool</td><td>源码映射</td></tr><tr><td>devServer</td><td>本地开发体验</td></tr><tr><td>optimization</td><td>拆包与缓存</td></tr></tbody></table><h3 id="【Webpack基本指令】"><a href="#【Webpack基本指令】" class="headerlink" title="【Webpack基本指令】"></a>【Webpack基本指令】</h3><ul><li><p><code>npx webpack</code><br> 执行一次构建，读取默认 <code>webpack.config.js</code></p></li><li><p><code>npx webpack build</code><br> 等价于 <code>webpack</code>，显式表示“构建”</p></li><li><p><code>npx webpack --config webpack.config.js</code><br> 指定使用的配置文件</p></li><li><p><code>npx webpack --config webpack.prod.js</code><br> 使用生产环境配置</p></li><li><p><code>npx webpack --mode development</code><br> 使用开发模式（不压缩、快速构建）</p></li><li><p><code>npx webpack --mode production</code><br> 使用生产模式（压缩、优化、Tree Shaking）</p></li><li><p><code>npx webpack serve</code><br> 启动开发服务器</p></li><li><p><code>npx webpack serve --port 3000</code><br> 指定开发端口</p></li><li><p><code>npx webpack serve --open</code><br> 自动打开浏览器</p></li><li><p><code>npx webpack serve --hot</code><br> 启用热模块替换（HMR）</p></li><li><p><code>npx webpack serve --static public</code><br> 指定静态资源目录</p></li><li><p><code>npx webpack --output-path dist</code><br> 指定输出目录</p></li><li><p><code>npx webpack --output-filename bundle.js</code><br> 指定输出文件名</p></li><li><p><code>npx webpack --progress</code><br> 显示构建进度条</p></li><li><p><code>npx webpack --watch</code><br> 监听文件变化，自动重新构建</p></li><li><p><code>npx webpack --stats detailed</code><br> 输出详细构建信息</p></li><li><p><code>npx webpack --profile</code><br> 显示构建性能数据</p></li><li><p><code>npx webpack serve --mode development --open</code><br> 本地开发常用启动方式</p></li><li><p><code>npx webpack --mode production</code><br> 生产环境打包</p></li></ul><h3 id="【Webpack打包流程】"><a href="#【Webpack打包流程】" class="headerlink" title="【Webpack打包流程】"></a>【Webpack打包流程】</h3><h4 id="第一步：读取入口（Entry）"><a href="#第一步：读取入口（Entry）" class="headerlink" title="第一步：读取入口（Entry）"></a><strong>第一步：读取入口（Entry）</strong></h4><p>打包从一个或多个<strong>入口文件</strong>开始。</p><p>入口的意义不是“第一个执行的文件”，而是：</p><blockquote><p><strong>依赖分析的起点</strong></p></blockquote><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">src</span>/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span><br></code></pre></td></tr></table></figure><p>打包工具会认为：</p><ul><li>这个文件是应用的根节点</li><li>所有代码必须从这里“可达”</li></ul><hr><h4 id="第二步：构建依赖关系图（Dependency-Graph）"><a href="#第二步：构建依赖关系图（Dependency-Graph）" class="headerlink" title="第二步：构建依赖关系图（Dependency Graph）"></a><strong>第二步：构建依赖关系图（Dependency Graph）</strong></h4><p>这是整个打包过程<strong>最核心的一步</strong>。</p><p>打包工具会做什么？</p><ul><li>解析 <code>import / require</code></li><li>找到当前模块依赖的所有模块</li><li>对依赖模块递归执行同样的过程</li><li>最终形成一个完整的依赖图</li></ul><p>这个依赖图本质是一个<strong>有向图</strong>：</p><ul><li>节点：模块</li><li>边：依赖关系</li></ul><hr><h4 id="第三步：模块内容转换（Transpilation）"><a href="#第三步：模块内容转换（Transpilation）" class="headerlink" title="第三步：模块内容转换（Transpilation）"></a><strong>第三步：模块内容转换（Transpilation）</strong></h4><p>在依赖图构建过程中，每一个模块都会被“加工”。</p><p>为什么要转换？</p><p>因为源码通常包含：</p><ul><li>浏览器不支持的语法</li><li>非 JS 资源</li><li>工程阶段的写法</li></ul><p>转换内容包括：</p><ul><li>TypeScript → JavaScript</li><li>JSX → JavaScript</li><li>SCSS → CSS</li><li>新语法 → 旧语法</li></ul><p>这一步的结果是：</p><blockquote><p><strong>所有模块在逻辑层面都变成“可执行的 JS 模块”</strong></p></blockquote><hr><h4 id="第四步：模块合并与拆分"><a href="#第四步：模块合并与拆分" class="headerlink" title="第四步：模块合并与拆分"></a><strong>第四步：模块合并与拆分</strong></h4><p>此时，打包工具已经：</p><ul><li>知道所有模块</li><li>知道它们的依赖关系</li><li>知道模块的最终代码内容</li></ul><p>接下来要解决的问题是：</p><p><strong>这些模块应该如何组织成最终文件？</strong></p><p>可能的策略包括：</p><ul><li>合并成一个文件（小项目）</li><li>拆成多个 Chunk（按路由、按功能）</li><li>抽离公共依赖（vendor）</li></ul><p>这是<strong>性能优化决策阶段</strong>。</p><hr><h4 id="第五步：构建阶段优化"><a href="#第五步：构建阶段优化" class="headerlink" title="第五步：构建阶段优化"></a><strong>第五步：构建阶段优化</strong></h4><p>在确定输出结构后，打包工具会进行一系列“只在构建阶段存在”的优化：</p><ul><li>Tree Shaking：删除无用代码</li><li>Minify：压缩代码</li><li>Scope Hoisting：减少函数包裹</li><li>资源压缩（CSS &#x2F; 图片）</li></ul><p>这些优化<strong>不会改变业务逻辑，只改变代码形态</strong>。</p><hr><h4 id="第六步：生成最终产物（Output）"><a href="#第六步：生成最终产物（Output）" class="headerlink" title="第六步：生成最终产物（Output）"></a><strong>第六步：生成最终产物（Output）</strong></h4><p>最终输出的是：</p><ul><li>HTML（可能自动生成）</li><li>JS 文件（带 hash）</li><li>CSS 文件</li><li>静态资源</li></ul><p>这些文件的特点是：</p><ul><li>浏览器可直接加载</li><li>内容稳定</li><li>可长期缓存</li><li>与源码结构无直接对应关系</li></ul><h2 id="Vite-1"><a href="#Vite-1" class="headerlink" title="Vite"></a>Vite</h2><p>Vite 的“构建”分两条线：</p><ul><li>开发阶段（dev）：不做整体打包，按需提供模块</li><li>生产阶段（build）：做完整打包、压缩、拆包、产物输出</li></ul><p>理解 Vite 的关键是分清：<strong>开发不是 build，只是 dev server + 按需编译</strong>。</p><h3 id="【开发阶段的本质】"><a href="#【开发阶段的本质】" class="headerlink" title="【开发阶段的本质】"></a>【开发阶段的本质】</h3><p>Vite 在开发时更像一个“模块服务器”：</p><ul><li>浏览器用原生 ES Module（import）加载模块</li><li>Vite 负责把浏览器请求到的文件：<ul><li>必要时转换（TS、JSX、Vue SFC、CSS 等）</li><li>返回给浏览器</li></ul></li><li>浏览器继续解析 import，再去请求下一个模块</li><li>Vite 再按需处理并返回</li></ul><p>也就是说：<strong>依赖图不是 Vite 一次性扫描出来的，而是浏览器在运行时逐步触发请求，Vite 逐步响应。</strong></p><hr><h3 id="【完整请求链路】"><a href="#【完整请求链路】" class="headerlink" title="【完整请求链路】"></a>【完整请求链路】</h3><p>假设入口是 <code>index.html</code>，其中有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器的行为与 Vite 的行为按时间顺序是：</p><ol><li>浏览器请求 <code>GET /index.html</code><ul><li>Vite 返回 HTML</li><li>同时会在 HTML 中注入 HMR 客户端脚本（用于热更新通信）</li></ul></li><li>浏览器看到 <code>&lt;script type=&quot;module&quot; src=&quot;/src/main.ts&quot;&gt;</code><ul><li>请求 <code>GET /src/main.ts</code></li></ul></li><li>Vite 收到 <code>/src/main.ts</code> 请求<ul><li>如果是 TS：用 esbuild 做快速转译成 JS（不做类型检查）</li><li>如果里面有 import：Vite 会把 import 路径改写成浏览器可请求的 URL 形式（重要）</li><li>返回转译后的 JS 给浏览器</li></ul></li><li>浏览器执行并解析 import，例如：<ul><li><code>import App from &#39;./App.vue&#39;</code> → 浏览器会请求 <code>GET /src/App.vue</code></li><li><code>import &#123; createApp &#125; from &#39;vue&#39;</code> → 浏览器会请求一个被改写后的依赖地址（通常带 <code>/@modules/</code> 或 <code>/node_modules/.vite/deps/...</code> 的形式，取决于版本与实现）</li></ul></li><li>Vite 针对不同资源类型做不同处理并返回<ul><li><code>.vue</code>：走 Vue 插件，把 SFC 拆成多个虚拟模块（template&#x2F;script&#x2F;style），再分别返回</li><li><code>.css</code>：转换成 JS 模块（用于插入样式或 CSS Modules 处理），并建立 HMR 依赖</li><li>图片字体等：返回 URL 或内联数据（取决于大小与配置）</li><li>第三方依赖：优先走“依赖预构建”后的产物（下面详讲）</li></ul></li><li>浏览器继续递归请求所有 import 依赖<ul><li>Vite 继续按需编译与返回</li><li>没有“全量打包”这一步</li></ul></li></ol><p>这就是 Vite 开发阶段启动快的根源：<strong>启动时不需要扫描整个项目并生成 bundle，只要起服务即可。</strong></p><h3 id="【最重要的三件事】"><a href="#【最重要的三件事】" class="headerlink" title="【最重要的三件事】"></a>【最重要的三件事】</h3><h4 id="1-import-路径改写（为什么必须改写）"><a href="#1-import-路径改写（为什么必须改写）" class="headerlink" title="1. import 路径改写（为什么必须改写）"></a>1. import 路径改写（为什么必须改写）</h4><p>浏览器对 ESM 的 import 有严格规则：</p><ul><li>必须是相对路径或绝对路径 URL（<code>./</code>、<code>../</code>、<code>/</code>、或完整 URL）</li><li>不能直接识别 Node 的包解析规则（例如 <code>import vue from &#39;vue&#39;</code> 这种 bare import）</li></ul><p>所以 Vite 必须把 bare import 改写成浏览器能请求的地址。</p><p>例如把：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br></code></pre></td></tr></table></figure><p>改写成类似：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/node_modules/.vite/deps/vue.js?v=xxxx&#x27;</span><br></code></pre></td></tr></table></figure><p>这样浏览器才能发起 HTTP 请求拿到对应模块。</p><p>改写不仅针对第三方包，也会处理一些特殊资源引用与查询参数模块（如 <code>?import</code>、<code>?url</code>、<code>?raw</code>）。</p><hr><h4 id="2-依赖预构建（pre-bundling，为什么要做）"><a href="#2-依赖预构建（pre-bundling，为什么要做）" class="headerlink" title="2. 依赖预构建（pre-bundling，为什么要做）"></a>2. 依赖预构建（pre-bundling，为什么要做）</h4><p>如果开发阶段完全不处理依赖，会遇到两个大问题：</p><ol><li>第三方库可能是 CommonJS 或 UMD，浏览器无法直接按 ESM 方式加载</li><li>第三方库内部文件多，如果浏览器逐个请求，会导致请求数量爆炸，开发体验很差</li></ol><p>因此 Vite 会在 dev 启动或依赖变动时，对 <code>node_modules</code> 做一次“预构建”：</p><ul><li>使用 esbuild（速度极快）</li><li>把常用依赖：<ul><li>转成 ESM</li><li>合并成更少的模块文件</li><li>产物缓存到 <code>node_modules/.vite/deps</code>（常见位置）</li></ul></li></ul><p>这样浏览器加载第三方依赖时：</p><ul><li>既是 ESM</li><li>请求数显著减少</li><li>还能利用强缓存</li></ul><p>依赖预构建的触发时机</p><ul><li>首次启动 dev server</li><li>lockfile 改变（package-lock&#x2F;yarn.lock&#x2F;pnpm-lock）</li><li>依赖安装变化</li><li><code>optimizeDeps</code> 配置变化</li><li>某些依赖无法被正确扫描，需要手动 include&#x2F;exclude</li></ul><hr><h4 id="3-HMR（热更新）为什么会更快"><a href="#3-HMR（热更新）为什么会更快" class="headerlink" title="3. HMR（热更新）为什么会更快"></a>3. HMR（热更新）为什么会更快</h4><p>传统 bundler 的 HMR 通常要基于打包产物与依赖图做复杂替换。</p><p>Vite 的 HMR 更轻，是因为它的模块天然就是 ESM：</p><ul><li>每个模块都是独立的请求与响应</li><li>修改某个文件时：<ul><li>Vite 只需要让浏览器更新这个模块</li><li>并沿着模块依赖边界做最小范围的传播</li></ul></li></ul><p>HMR 的工作机制（概念层）</p><ol><li>文件变更（监听）</li><li>Vite 判定变更模块类型（JS、CSS、Vue SFC 等）</li><li>生成更新 payload（包含模块 id、变更类型等）</li><li>通过 WebSocket 推送给浏览器 HMR 客户端</li><li>浏览器按模块粒度执行更新逻辑：<ul><li>CSS 通常直接替换样式</li><li>Vue 组件更新会尽量保留状态（取决于边界与实现）</li><li>JS 模块需要模块接受更新（HMR accept），否则触发页面刷新</li></ul></li></ol><hr><h3 id="【Vite-如何处理常见资源】"><a href="#【Vite-如何处理常见资源】" class="headerlink" title="【Vite 如何处理常见资源】"></a>【Vite 如何处理常见资源】</h3><h4 id="1-TypeScript"><a href="#1-TypeScript" class="headerlink" title="1. TypeScript"></a>1. TypeScript</h4><ul><li>默认使用 esbuild 做“语法转译”</li><li>不做类型检查（类型检查建议单独跑 <code>tsc --noEmit</code> 或用插件&#x2F;脚本）</li></ul><p>所以你会看到：</p><ul><li>转译很快</li><li>但类型错误不一定阻止 dev 运行（除非你加了额外检查）</li></ul><hr><h4 id="2-Vue-单文件组件（-vue）"><a href="#2-Vue-单文件组件（-vue）" class="headerlink" title="2. Vue 单文件组件（.vue）"></a>2. Vue 单文件组件（.vue）</h4><p>Vite 通过插件将 <code>.vue</code> 拆成多段模块：</p><ul><li>script 部分：转成 JS 模块</li><li>template 部分：编译成 render 函数模块</li><li>style 部分：作为 CSS 模块处理并注入 HMR</li></ul><p>这也是为什么 Vue + Vite 的开发体验很顺滑：<strong>SFC 的编译是按需且增量的</strong>。</p><hr><h4 id="3-CSS-与预处理器"><a href="#3-CSS-与预处理器" class="headerlink" title="3. CSS 与预处理器"></a>3. CSS 与预处理器</h4><p>CSS 在 Vite 中通常会被当成模块依赖处理：</p><ul><li>在 dev：注入到页面（或通过插件机制处理）</li><li>在 build：抽离成独立 CSS 文件并做压缩（由 Rollup 生态完成）</li></ul><p>CSS Modules、PostCSS、Sass&#x2F;Less 等也都是在这个链路中按需处理。</p><hr><h4 id="4-静态资源（图片、字体等）"><a href="#4-静态资源（图片、字体等）" class="headerlink" title="4. 静态资源（图片、字体等）"></a>4. 静态资源（图片、字体等）</h4><p>常见两种使用方式：</p><ul><li><code>import imgUrl from &#39;./a.png&#39;</code><ul><li>dev：返回一个可访问 URL</li><li>build：根据规则复制到 <code>dist/assets</code> 并重写引用</li></ul></li><li><code>?raw</code>、<code>?url</code> 等查询参数<ul><li><code>?raw</code>：当成纯文本返回（常用于加载 shader、md 等）</li><li><code>?url</code>：强制返回 URL 字符串</li></ul></li></ul><hr><h3 id="【生产构建阶段（vite-build）】"><a href="#【生产构建阶段（vite-build）】" class="headerlink" title="【生产构建阶段（vite build）】"></a>【生产构建阶段（vite build）】</h3><p>开发阶段不打包，但生产必须打包，因为要：</p><ul><li>合并与压缩</li><li>Tree Shaking</li><li>代码分割（懒加载 chunk）</li><li>产物 hash（缓存）</li><li>资源拷贝与引用重写</li><li>生成最终可部署目录 <code>dist</code></li></ul><p>【构建链路概览】</p><ol><li>以 <code>index.html</code> 为构建入口（Vite 的一个重要点）</li><li>Rollup 负责构建依赖图与打包输出</li><li>插件体系介入（Vite 插件兼容 Rollup 插件思想）</li><li>输出到 <code>dist</code>，包含：<ul><li><code>assets/*.js</code></li><li><code>assets/*.css</code></li><li>静态资源文件</li><li>处理后的 <code>index.html</code></li></ul></li></ol><p>【生产构建的关键能力】</p><ul><li>Tree Shaking：基于 ESM 的静态分析移除未使用代码</li><li>Code Splitting：动态 import 自动切 chunk</li><li>资源指纹：<code>[hash]</code> 用于长期缓存</li><li>压缩：JS&#x2F;CSS 压缩与优化（取决于配置与版本）</li></ul><hr><p>【为什么 Vite 要“dev 用 esbuild，build 用 Rollup”】</p><p>这不是矛盾，而是分工明确：</p><ul><li>dev 最关心：启动快、更新快<ul><li>esbuild 在转译层面极快，适合 dev 的“按需编译”</li></ul></li><li>build 最关心：产物质量、生态成熟、可控的拆包与输出<ul><li>Rollup 在打包与产物优化上生态成熟，适合生产构建</li></ul></li></ul><p>因此 Vite 采取“混合策略”：</p><ul><li>dev：模块服务器 + esbuild 转译 + 依赖预构建</li><li>build：Rollup 打包</li></ul>]]></content>
    
    
    <categories>
      
      <category>NodeJS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.JS的数据类型总结</title>
    <link href="/2025/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/3-JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2025/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/3-JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ol><li>JavaScript有哪些数据类型，它们的区别(堆和栈 &#x2F; 基础数据类型和引用数据类型 &#x2F; Symbol的用法）？</li><li>引用数据类型常用方法？ （Object &#x2F; Function &#x2F; Array &#x2F; Map &#x2F; Set &#x2F; Class）</li><li>数据类型判断的方式有哪些？</li><li><code>null</code>和<code>undefined</code>的区别？</li><li><code>typeof null</code>错误的原因是什么？</li><li><code>0.1+0.2 !== 0.3</code>的原因是什么？</li><li>如何获取安全的 undefined 值？</li><li>isNaN 和 Number.isNaN 函数的区别是什么？</li></ol><span id="more"></span><h2 id="JS的数据类型总结"><a href="#JS的数据类型总结" class="headerlink" title="JS的数据类型总结"></a>JS的数据类型总结</h2><h3 id="1-JavaScript的数据类型"><a href="#1-JavaScript的数据类型" class="headerlink" title="1.JavaScript的数据类型"></a>1.JavaScript的数据类型</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>);<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>);<br>s1 !== s2;<br></code></pre></td></tr></table></figure><ul><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">9007199254740991n</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>这些数据可以分为基本数据类型和引用数据类型：</p><ul><li>栈：基本数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由<strong>垃圾回收机制回收</strong>。</li></ul><h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h3><blockquote><p><a href="https://www.yuque.com/cuggz/feplus/cp4k8o">数组</a></p><p><a href="https://cxdlogver.github.io/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#Map">MAP &#x2F; SET</a></p><p><a href="https://www.yuque.com/cuggz/feplus/wgzgsv">循环遍历</a></p></blockquote><h3 id="3-数据类型检测的方式有哪些"><a href="#3-数据类型检测的方式有哪些" class="headerlink" title="3. 数据类型检测的方式有哪些"></a>3. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>);           <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object    </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);    <span class="hljs-comment">// function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，其内部运行机制是<strong>判断在其原型链中能否找到该类型的原型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);                    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);                <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);                <span class="hljs-comment">// false </span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);                    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);                   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3）</strong> <strong>constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">true</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-string">&#x27;str&#x27;</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([]).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;&#125;;<br> <br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br> <br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Fn</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-number">2</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;str&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>([]));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，<code>obj.toString()</code>的结果和<code>Object.prototype.toString.call(obj)</code>的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><p><strong>数组类型判断的所有方式汇总</strong></p><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArrray</span>(obj);<br></code></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure><ul><li>通过constructor判断</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><blockquote><p>一句话：typeof是根据类型标签来判断类型。null和object的类型标签都是000</p></blockquote><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">000</span>: object   - 当前存储的数据指向一个对象。<br>  <span class="hljs-number">1</span>: int      - 当前存储的数据是一个 <span class="hljs-number">31</span> 位的有符号整数。<br><span class="hljs-number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。<br><span class="hljs-number">100</span>: string   - 当前存储的数据指向一个字符串。<br><span class="hljs-number">110</span>: boolean  - 当前存储的数据是布尔值。<br></code></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-为什么0-1-0-2-0-3，如何让其相等"><a href="#6-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="6. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>6. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><p><strong>一句话：</strong>因为 <strong>JavaScript 用 IEEE-754 双精度浮点数</strong>存小数，很多十进制小数在二进制里是<strong>无限循环小数</strong>，只能近似存。<code>0.1</code> 和 <code>0.2</code> 实际存成了两段“近似值”，相加后得到的近似值稍微大于 <code>0.3</code>，显示为 <code>0.30000000000000004</code>，所以 <code>0.1 + 0.2 !== 0.3</code>。 相等的方法就是<code>toFixed</code>取舍。</p><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">0.1</span>, n2 = <span class="hljs-number">0.2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n1 + n2)  <span class="hljs-comment">// 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(n1 + n2).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span><br></code></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的：</p><img src="/2025/12/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/3-JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/1603641384908-7958dffa-6d26-4e36-963e-b41c9e3ca8b0.png" class title="img"><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="hljs-number">10011.</span>..<br></code></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="hljs-number">2</span>^-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023&#x3D; -1022，e最大值是2046，则2046-1023&#x3D;1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023&#x3D; -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s&#x3D;0时表示正无穷，s&#x3D;1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 &#x3D; 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> <span class="hljs-number">1111111011</span> <span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2&#x3D;0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 &#x3D;&#x3D;&#x3D;0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numberepsilon</span>(<span class="hljs-params">arg1,arg2</span>)&#123;                   <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(arg1 - arg2) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;        <br>&#125;        <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numberepsilon</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="7-获取安全的-undefined-值？"><a href="#7-获取安全的-undefined-值？" class="headerlink" title="7. 获取安全的 undefined 值？"></a>7. 获取安全的 undefined 值？</h3><blockquote><ul><li>什么叫安全的<code>undefined</code>值</li><li><code>void</code> 和 undefined的区别</li><li><code>void</code> 的作用</li></ul></blockquote><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p><p>undefined并不是javascript中的保留字，我们可以使用undefined作为变量名字，然后给它赋值。void 0输出唯一的结果undefined，保证了不变性</p><h3 id="8-isNaN-和-Number-isNaN-函数的区别"><a href="#8-isNaN-和-Number-isNaN-函数的区别" class="headerlink" title="8. isNaN 和 Number.isNaN 函数的区别"></a>8. isNaN 和 Number.isNaN 函数的区别</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D; &#x3D; NaN 为 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>isNaN 和 Number.isNaN 函数的区别？</strong></p><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.JS面向对象编程</title>
    <link href="/2025/12/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/2-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/12/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/2-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ol><li>如何理解JS中的对象和函数？</li><li>构造函数和普通函数的区别是什么？</li><li><code>new</code>关键字的原理是什么？</li><li><code>instanceof</code>的原理是什么？</li></ol><span id="more"></span><h2 id="JS的面向对象编程"><a href="#JS的面向对象编程" class="headerlink" title="JS的面向对象编程"></a>JS的面向对象编程</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/08/04/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">JavaScript基础 - 相</a></p></blockquote><h3 id="1-对象和函数"><a href="#1-对象和函数" class="headerlink" title="1.对象和函数"></a>1.对象和函数</h3><p>对象是对现实事物的一个抽象概述，面对对象编程就是将所有的程序封装成一个个对象,程序的运行过程就是一系列对象之间相互协作、消息传递的过程。</p><p>对象包括 属性和方法，表示事物的状态和动作。</p><blockquote><p>每个对象都有一个内部属性 <code>[[Prototype]]</code>（通常访问为 <code>__proto__</code>），它指向另一个对象，这个对象称为“原型”。当访问对象的某个属性时，如果对象本身没有这个属性，则会去它的原型对象上查找，这就是“原型链查找”机制。原型本身也是对象，也有原型，因此构成一个原型链，直到最顶层<code>null</code>终止.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><h4 id="【Object和Function】"><a href="#【Object和Function】" class="headerlink" title="【Object和Function】"></a>【<code>Object</code>和<code>Function</code>】</h4><p><strong><code>Object</code>和<code>Function</code>是构造器，而构造器本身也是一个实例对象。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>        <span class="hljs-comment">// Object 是由 Function 构造出来的</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>      <span class="hljs-comment">// Function 由自己构造出来</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// 函数对象的原型最终继承自 Object.prototype</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// 根据上面推导</span><br></code></pre></td></tr></table></figure><p>如何理解：</p><ul><li><code>Object</code> 是由 <code>Function</code> 构造出来的。<code>Function</code> 是由自己构造出来的。</li><li><code>Object.prototye</code>是所有对象的顶层原型，<code>Object.prototype.__proto__ === null</code>。 </li><li><code>Function.prototype</code> 是所有函数对象的原型（包括 <code>Object</code> 和 <code>Function</code> 自身）</li><li>函数本身也是对象，所以顶层原型在函数对象的原型链上。</li></ul><table><thead><tr><th>对象</th><th>说明</th></tr></thead><tbody><tr><td><code>Function</code></td><td>所有函数的构造器</td></tr><tr><td><code>Object</code></td><td>普通对象的构造器</td></tr><tr><td><code>Function</code> 本身</td><td>也是函数 → 也是 Function 的实例</td></tr><tr><td><code>Object</code> 本身</td><td>也是函数 → 也是 Function 的实例</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span><br>  ├── __proto__ → <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  │                   │<br>  │                   └── __proto__ → <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> → <span class="hljs-literal">null</span><br>  │<br><span class="hljs-title class_">Object</span><br>  └── __proto__ → <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><br></code></pre></td></tr></table></figure><p>函数对象和普通对象通过一些属性来区分，比如<code>typeof</code> 内部其实就是检测对象是否有 <code>[[Call]]</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;); <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;); <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure><p>在 JS 里，一个对象是不是某个构造器的实例，只看一件事：</p><blockquote><p><strong>这个构造器的 <code>prototype</code> 是否出现在该对象的原型链上</strong></p></blockquote><p>也就是 <code>instanceof</code> 的本质。</p><h3 id="2-构造函数和普通函数"><a href="#2-构造函数和普通函数" class="headerlink" title="2.构造函数和普通函数"></a>2.构造函数和普通函数</h3><ul><li><strong>构造函数</strong>：除了有 <code>[[Call]]</code>，还具备 <code>[[Construct]]</code> 内部方法，所以能用 <code>new</code>。</li><li><strong>普通函数</strong>：如果没有 <code>[[Construct]]</code>，用 <code>new</code> 会报错。</li></ul><h4 id="【创建方式】"><a href="#【创建方式】" class="headerlink" title="【创建方式】"></a>【创建方式】</h4><p>只有<code>function</code>和<code>class</code>创建的函数对象才有<code>Construct</code>构造器。</p><table><thead><tr><th>函数类型</th><th>是否有 <code>[[Call]]</code></th><th>是否有 <code>[[Construct]]</code></th><th>能否 <code>new</code></th></tr></thead><tbody><tr><td>普通函数 <code>function f()&#123;&#125;</code></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>class</td><td>❌（不能直接调用）</td><td>✅</td><td>✅</td></tr><tr><td>箭头函数 <code>() =&gt; &#123;&#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>方法简写 <code>&#123; foo()&#123;&#125; &#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>Function.prototype.bind</code> 返回的函数</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>Generator 函数 <code>function* f()&#123;&#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>Async 函数 <code>async function f()&#123;&#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();   <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bar</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>();             <span class="hljs-comment">// TypeError: bar is not a constructor</span><br></code></pre></td></tr></table></figure><h4 id="【constructor-属性】"><a href="#【constructor-属性】" class="headerlink" title="【constructor 属性】"></a>【constructor 属性】</h4><ul><li><p><code>constructor</code>是区分 构造器函数 和 普通函数 的标准。</p></li><li><p>构造器函数在创建时，都会自动获得一个 <code>prototype</code> 属性，指向一个原型对象。该原型对象上默认有一个 <code>constructor</code> 属性，指向函数本身。</p></li><li><p>实例对象通过原型链可以访问到这个 <code>constructor</code>。</p></li><li><p>普通函数没有<code>prototype</code>和<code>constructor</code>，但依然是实例对象，所有具备<code>__proto__</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br>[].<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br></code></pre></td></tr></table></figure><h4 id="【构造函数】"><a href="#【构造函数】" class="headerlink" title="【构造函数】"></a>【构造函数】</h4><ol><li><strong>构造函数</strong>是用 <code>new</code> 调用的函数，可以创建对象。</li><li><strong>类 (class)</strong> 是构造函数的语法糖，本质上还是函数。</li><li><strong>Function</strong> 是所有函数的构造器，它本身也是函数（自举特性）。<ul><li><code>Function instanceof Function</code> → true</li><li><code>Function instanceof Object</code> → true</li><li><code>Object instanceof Function</code> → true</li></ul></li><li>关系链可以画成这样：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span> (构造所有函数)<br>   ↑<br><span class="hljs-keyword">class</span> / 普通函数 (本质是 <span class="hljs-title class_">Function</span> 的实例)<br>   ↑<br>实例对象 (由构造函数 / <span class="hljs-keyword">class</span> 生成)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure><p>得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-new关键字"><a href="#3-new关键字" class="headerlink" title="3.new关键字"></a>3.new关键字</h3><p>理解到这一步，我们就可以理解new关键字原理中每一步的含义。</p><p>当你写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure><p>引擎内部大致做了 <strong>4 步</strong>：</p><ol><li><p><strong>创建一个空对象</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let obj <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>把这个对象的原型指向构造函数的 <code>prototype</code></strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj.__proto__</span> = Person.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>执行构造函数，把 <code>this</code> 绑定到新对象</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-type">Person</span>.call(obj, <span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>返回对象</strong></p><ul><li>如果构造函数返回的是一个 <strong>对象</strong>，则返回它；</li><li>否则，返回刚创建的 <code>obj</code>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">return</span> (typeof <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> &quot;object&quot; <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">!=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">result</span> : obj;<br></code></pre></td></tr></table></figure></li></ol><p>手写一个 <code>myNew</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Constructor, ...args</span>) &#123;<br>  <span class="hljs-comment">// 1. 创建空对象，并链接原型</span><br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <br>  <span class="hljs-comment">// 2. 执行构造函数，绑定 this</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, args);<br>  <br>  <span class="hljs-comment">// 3. 返回对象</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; result !== <span class="hljs-literal">null</span>) ? result : obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&quot;Alice&quot;</span>);<br>p.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi, I&#x27;m Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="4-intanceof-复现"><a href="#4-intanceof-复现" class="headerlink" title="4.intanceof 复现"></a>4.intanceof 复现</h3><p> instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left)<br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.浏览器中的跨域问题（Q1.Nginx配置）</title>
    <link href="/2025/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/1-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2025/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/1-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>浏览器跨域问题，跨域的作用，如何解决跨域问题，CORS策略，Nginx基本配置，Vite配置代理服务器。</p><span id="more"></span><p><strong>面试题：</strong></p><img src="/2025/12/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/1-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20251213053437226.png" class title="image-20251213053437226"><h2 id="浏览器中的跨域问题-CORS策略-Nginx"><a href="#浏览器中的跨域问题-CORS策略-Nginx" class="headerlink" title="浏览器中的跨域问题 &#x2F; CORS策略 &#x2F; Nginx"></a>浏览器中的跨域问题 &#x2F; CORS策略 &#x2F; Nginx</h2><blockquote><p><a href="https://www.yuque.com/tianyu-coder/openshare/aksmvpbebgw7savk#AwdCU">跨域问题梳理</a></p></blockquote><p> 补充内容：</p><ol><li>跨域请求的作用是什么，举个例子？</li><li>为什么同一个域名的不同端口要规定成不同源？</li><li>什么是Nginx，Nginx的三大作用？</li><li>Web服务器的定义是什么？</li><li>写一个基础的Nginx代理服务器配置？</li><li>写一个基础的Vite脚手架服务器配置？</li></ol><blockquote><p><a href="https://github.com/cxDlogver/Front_End/tree/main/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/1.%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">示例代码：Front_End&#x2F;手写代码&#x2F;1.跨域问题 at main · cxDlogver&#x2F;Front_End</a></p></blockquote><h3 id="1-跨域请求的作用"><a href="#1-跨域请求的作用" class="headerlink" title="1.跨域请求的作用"></a>1.跨域请求的作用</h3><p>跨域问题<strong>只作用于浏览器</strong>，一个网页的 JS，不能读取另一个“源”的资源返回结果，防止越权读取其他网站的敏感数据，保护用户安全。</p><p>如果<strong>没有跨域限制</strong>，会发生什么？</p><p>假设场景（非常危险）</p><p>你登录了：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//bank.com</span><br></code></pre></td></tr></table></figure><p>浏览器自动保存了你的登录 Cookie。</p><p>此时你又访问了一个恶意网站：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//evil.com</span><br></code></pre></td></tr></table></figure><p>如果<strong>没有跨域限制</strong>，evil.com 可以在 JS 中直接：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">&quot;https://bank.com/api/account&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><p>浏览器会<strong>自动携带你的 bank.com Cookie</strong>，恶意网站就能读到你的银行信息</p><h3 id="2-同一个域名的不同端口"><a href="#2-同一个域名的不同端口" class="headerlink" title="2.同一个域名的不同端口"></a>2.同一个域名的不同端口</h3><table><thead><tr><th>地址</th><th>实际含义</th></tr></thead><tbody><tr><td><code>http://127.0.0.1:80</code></td><td>Web 服务（Nginx &#x2F; Apache）</td></tr><tr><td><code>http://127.0.0.1:3306</code></td><td>MySQL</td></tr><tr><td><code>http://127.0.0.1:6379</code></td><td>Redis</td></tr><tr><td><code>http://127.0.0.1:8080</code></td><td>后端 API</td></tr><tr><td><code>http://127.0.0.1:5173</code></td><td>前端开发服务器</td></tr></tbody></table><p><strong>同一个 IP，不同端口，通常是完全不同的程序、不同权限、不同信任级别</strong></p><p>浏览器如果只按 IP 判断“同源”，就等于说：“只要在同一台机器上跑的服务，网页就可以互相读数据” 这是非常危险的。</p><p>同一个 IP 的不同端口，在浏览器安全模型中被视为“不同应用、不同安全域”，必须隔离，否则任何网页都能攻击用户本地和内网服务。</p><h3 id="3-什么是Nginx，Nginx的三大作用？"><a href="#3-什么是Nginx，Nginx的三大作用？" class="headerlink" title="3.什么是Nginx，Nginx的三大作用？"></a>3.什么是Nginx，Nginx的三大作用？</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1F5411J7vK/?spm_id_from=333.337.search-card.all.click&vd_source=ff414aaf189e3a685358d2a984fd4742">【狂神说】Nginx最新教程通俗易懂，40分钟搞定！_哔哩哔哩_bilibili</a></p></blockquote><p>Nginx 是一个高性能的 http 和 Web 服务器，Nginx 的三大作用：反向代理， 负载均衡， Web服务器（静态资源服务器）</p><h4 id="反向代理（Reverse-Proxy）"><a href="#反向代理（Reverse-Proxy）" class="headerlink" title="反向代理（Reverse Proxy）"></a>反向代理（Reverse Proxy）</h4><p>当一个项目面临高并发访问时，单台服务器的计算资源、网络带宽和连接数都存在上限，往往无法同时承载所有请求。为提升系统的并发处理能力和稳定性，实际工程中通常会将同一业务部署在多台服务器上，通过扩展来分摊访问压力。大型互联网平台如腾讯、阿里等，均采用多实例部署，而非依赖单一服务器。</p><p>在这种部署模式下，不同服务器通常对应不同的 IP 地址或端口号。如果直接由前端或用户指定访问目标服务器，将导致请求入口分散、调用方式不统一，既增加了前端复杂度，也不利于系统的统一管理与扩展。</p><p>因此，现代系统架构的核心思想是在客户端与后端服务之间引入一层统一的访问入口。这一中间层负责对外暴露稳定、规范的访问接口，对内完成请求转发、负载分配与服务隔离。客户端只需面向这一统一入口发起请求，而无需感知后端服务的数量、位置或变化情况。</p><p><strong>反向代理是 Nginx 最核心的功能</strong>。客户端访问的目标是 Nginx，由 Nginx 决定请求转发到哪一个后端服务。</p><p>主要作用包括：</p><ul><li>隐藏后端真实 IP 和端口</li><li>统一访问入口与域名</li><li>在前后端分离架构中解决跨域问题</li><li>为后端提供安全隔离</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> api.example.com;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户访问：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//api.example.com</span><br></code></pre></td></tr></table></figure><p>实际上是：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Nginx → http<span class="hljs-punctuation">:</span><span class="hljs-comment">//127.0.0.1:8080</span><br></code></pre></td></tr></table></figure><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>当你后端不止一个服务实例时：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backend &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.1:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.2:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.3:8080</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 可以在多个实例之间分配请求流量。轮询、加权轮询等调度策略，提升系统并发能力与稳定性。</p><h4 id="Web-服务器（静态资源服务）"><a href="#Web-服务器（静态资源服务）" class="headerlink" title="Web 服务器（静态资源服务）"></a>Web 服务器（静态资源服务）</h4><p>Nginx 可以直接向客户端提供静态资源，如 HTML、CSS、JavaScript、图片和文件下载。</p><p><strong>为什么不用后端语言来发静态文件？</strong></p><p>因为 Nginx本身的特点：</p><ul><li>Nginx 是 <strong>事件驱动 + 非阻塞 IO</strong></li><li>内存占用极低</li><li>并发能力极强</li></ul><table><thead><tr><th>模型</th><th>特点</th></tr></thead><tbody><tr><td>传统服务器</td><td>一个请求一个线程</td></tr><tr><td>Nginx</td><td>一个线程处理成千上万连接</td></tr></tbody></table><p>这也是它能扛 <strong>10 万级并发连接</strong> 的原因</p><h3 id="4-Web服务器的定义是什么？"><a href="#4-Web服务器的定义是什么？" class="headerlink" title="4.Web服务器的定义是什么？"></a>4.Web服务器的定义是什么？</h3><p><strong>Web 服务端</strong>是指<strong>通过 HTTP&#x2F;HTTPS 协议对外提供 Web 访问能力的服务程序</strong>，负责接收来自浏览器或客户端的请求，并返回符合 Web 协议规范的响应。</p><p>从定义上看，Web 服务端的核心特征是两点：</p><ol><li>对外监听 HTTP&#x2F;HTTPS 端口（如 80、443）</li><li>按 Web 协议格式处理请求与响应</li></ol><p><strong>一个程序要被称为 Web 服务器，必须满足以下条件：</strong></p><ol><li>长期运行、常驻进程</li><li>直接监听 HTTP&#x2F;HTTPS 端口（80&#x2F;443）</li><li>实现完整的 HTTP 协议处理</li><li>能独立向客户端返回合法的 HTTP 响应</li><li>以网络与协议处理为主要职责</li></ol><p>与之对应的是应用服务器：</p><p><strong>承载具体业务逻辑、数据处理和业务规则的服务进程或服务器</strong>，通常不直接面向公网用户。</p><p>后端服务器的核心职责包括：</p><ul><li>实现业务逻辑（计算、校验、流程控制）</li><li>数据读写（数据库、缓存、文件系统）</li><li>对外提供业务接口（API）</li></ul><p>常见的后端服务形态包括：</p><ul><li>Java 应用（Spring Boot）</li><li>Python 应用（Flask、FastAPI、Django）</li><li>Node.js 应用（Express、NestJS）</li></ul><p><strong>为什么要把两则分开？</strong></p><p>在早期或小型系统中，Web 服务端和后端服务器可能部署在同一进程或同一台服务器上。但在中大型系统中，通常将二者分离，原因包括：</p><ul><li>Web 层需要承受大量并发连接</li><li>后端业务层更关注计算与逻辑复杂度</li><li>职责分离有利于独立扩展和维护</li><li>提高系统整体稳定性与安全性</li></ul><p>这种分层设计体现的是“关注点分离”的工程思想。</p><h3 id="5-Nginx代理服务器示例"><a href="#5-Nginx代理服务器示例" class="headerlink" title="5.Nginx代理服务器示例"></a>5.Nginx代理服务器示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;  <span class="hljs-comment"># 工作进程数，根据服务器性能调整</span><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types; <span class="hljs-comment"># 包含 MIME 类型配置</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream; <span class="hljs-comment"># 默认 MIME 类型</span><br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;  <span class="hljs-comment"># 开启高效文件传输模式</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;  <span class="hljs-comment"># 保持连接超时时间，单位秒</span><br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8088</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br><br>        <span class="hljs-attribute">root</span> C:/client; <span class="hljs-comment"># 静态资源目录</span><br>        <span class="hljs-attribute">index</span> index.html; <span class="hljs-comment"># 将C:/client/index.html作为入口文件</span><br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>        &#125;<br><br>        <span class="hljs-section">location</span> /api/ &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:3000/; <span class="hljs-comment"># 目标服务器源</span><br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-Vite代理服务器示例"><a href="#6-Vite代理服务器示例" class="headerlink" title="6.Vite代理服务器示例"></a>6.Vite代理服务器示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">5173</span>,<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&quot;&quot;</span>),<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【⭐】JavaScript面试题</title>
    <link href="/2025/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="一、什么是面向对象编程？JS-的面向对象有什么特点？"><a href="#一、什么是面向对象编程？JS-的面向对象有什么特点？" class="headerlink" title="一、什么是面向对象编程？JS 的面向对象有什么特点？"></a>一、什么是面向对象编程？JS 的面向对象有什么特点？</h3><p><strong>口述模板：</strong></p><p>面向对象编程是一种编程思想，它把程序看作是<strong>一组对象之间相互协作、传递信息的过程</strong>。<br> 对象封装了事物的行为和数据，其中行为对应方法，数据对应属性，程序的执行过程就是对象之间调用方法、修改状态的过程。</p><p>JavaScript 也是支持面向对象编程的，但它和 Java、C++ 这类传统语言不同。<br> JavaScript 本质上是<strong>基于对象和原型的面向对象编程方式</strong>，而不是基于类复制实例。<br> ES6 引入的 class 只是语法糖，底层依然依赖原型机制。</p><p>所以理解 JS 面向对象的关键，不在于会不会写 class，而在于是否理解<strong>对象、原型以及原型链</strong>。</p><hr><h3 id="二、JavaScript-中创建对象的方式有哪些？"><a href="#二、JavaScript-中创建对象的方式有哪些？" class="headerlink" title="二、JavaScript 中创建对象的方式有哪些？"></a>二、JavaScript 中创建对象的方式有哪些？</h3><p><strong>口述模板：</strong></p><p>JavaScript 创建对象主要有四种常见方式。</p><p>第一种是对象字面量，适合创建结构简单、一次性使用的对象；<br> 第二种是构造函数配合 new 关键字，用于批量创建结构相同的对象；<br> 第三种是 Object.create，可以显式指定对象的原型，更贴近原型继承的本质；<br> 第四种是 ES6 的 class 写法，它是对构造函数和 prototype 的封装，让代码结构更清晰、更易维护。</p><p>在工程中，class 更常用于表达对外的抽象结构，但底层原理仍然是原型。</p><hr><h3 id="三、什么是原型？原型链是如何工作的？"><a href="#三、什么是原型？原型链是如何工作的？" class="headerlink" title="三、什么是原型？原型链是如何工作的？"></a>三、什么是原型？原型链是如何工作的？</h3><p><strong>口述模板：</strong></p><p>在 JavaScript 中，每一个对象在创建时都会关联一个内部原型，用于实现属性和方法的共享。<br> 当访问对象的某个属性或方法时，如果对象自身没有，JS 引擎就会到它的原型对象上查找，这个过程叫做原型链查找。</p><p>原型对象本身也是对象，它也有自己的原型，于是层层向上，就形成了一条原型链，直到到达最顶层的 Object.prototype，它的原型是 null，查找结束。</p><p>原型链的意义在于：<br> <strong>让方法只需要定义一份，就能被多个实例共享</strong>，这是 JS 面向对象在性能和内存上的重要优势，也是 JS 实现继承的基础。</p><hr><h3 id="四、JavaScript-是如何实现继承的？class-继承的本质是什么？"><a href="#四、JavaScript-是如何实现继承的？class-继承的本质是什么？" class="headerlink" title="四、JavaScript 是如何实现继承的？class 继承的本质是什么？"></a>四、JavaScript 是如何实现继承的？class 继承的本质是什么？</h3><p><strong>口述模板：</strong></p><p>JavaScript 的继承本质上是<strong>原型的继承</strong>。</p><p>在 ES6 之前，继承通常是通过修改原型链实现的，比如让子构造函数的 prototype 指向父构造函数的实例或原型对象。<br> ES6 的 class extends 只是让这种写法更直观，并没有改变底层机制。</p><p>class 继承本质上做了两件事：<br> 一是让子类实例的原型指向父类的 prototype；<br> 二是让子类构造函数本身的原型指向父类构造函数。</p><p>因此，class 继承只是对原型继承的一层语法封装。</p><hr><h3 id="五、JavaScript-是否支持封装、继承和多态？"><a href="#五、JavaScript-是否支持封装、继承和多态？" class="headerlink" title="五、JavaScript 是否支持封装、继承和多态？"></a>五、JavaScript 是否支持封装、继承和多态？</h3><p><strong>口述模板：</strong></p><p>从能力上讲，JavaScript 是支持面向对象三大特性的，但实现方式比较灵活。</p><p>封装可以通过作用域和闭包实现，在 ES6 之后，也可以通过 class 的私有字段来实现更清晰的封装；<br> 继承依赖原型链实现；<br> 多态则体现在“同一接口，不同实现”上。</p><p>JavaScript 的多态是典型的<strong>鸭子类型</strong>体现，它更关注对象“能做什么”，而不是对象“属于什么类型”。<br> 只要不同对象实现了同名方法，就天然支持多态，而不依赖显式类型声明。</p><hr><h3 id="六、this-在面向对象中的指向规则是什么？"><a href="#六、this-在面向对象中的指向规则是什么？" class="headerlink" title="六、this 在面向对象中的指向规则是什么？"></a>六、this 在面向对象中的指向规则是什么？</h3><p><strong>口述模板：</strong></p><p>this 是 JavaScript 面向对象中非常容易出问题的点，因为它是在<strong>调用时确定</strong>的，而不是定义时。</p><p>作为对象方法调用时，this 指向调用该方法的对象；<br> 作为普通函数调用时，在非严格模式下指向全局对象，在严格模式下是 undefined；<br> 作为构造函数调用时，this 指向新创建的实例对象；<br> 通过 call、apply、bind，可以显式指定 this 的指向。</p><p>很多 this 的问题，本质上都是调用方式发生了变化。</p><hr><h3 id="七、如何理解-JS-中的构造函数和构造器体系？"><a href="#七、如何理解-JS-中的构造函数和构造器体系？" class="headerlink" title="七、如何理解 JS 中的构造函数和构造器体系？"></a>七、如何理解 JS 中的构造函数和构造器体系？</h3><p><strong>口述模板：</strong></p><p>在 JavaScript 中，构造函数本质上也是普通函数，只是当它通过 new 调用时，承担了“创建对象”的角色。</p><p>Function 是所有函数对象的构造器，<br> Object 是普通对象的构造器。<br> Function 本身既是函数，又是对象，它是由自己构造出来的；<br> 而 Object 也是函数，也是对象，它是由 Function 构造出来的。</p><p>Object.prototype 是所有普通对象的最顶层原型，<br> Function.prototype 是所有函数对象的原型，包括 Object 和 Function 本身。</p><p>这套关系体现了 JavaScript 构造器体系的自举特性。</p><hr><h3 id="八、new-关键字到底做了什么？"><a href="#八、new-关键字到底做了什么？" class="headerlink" title="八、new 关键字到底做了什么？"></a>八、new 关键字到底做了什么？</h3><p><strong>口述模板：</strong></p><p>new 调用构造函数时，主要做了四件事：<br> 首先创建一个空对象；<br> 然后将这个对象的原型指向构造函数的 prototype；<br> 接着把构造函数内部的 this 绑定到这个新对象；<br> 最后返回这个对象。</p><p>这也是为什么构造函数和普通函数的最大区别，在于是否通过 new 调用。</p><hr><h3 id="九、方法定义在实例上和原型上有什么区别？"><a href="#九、方法定义在实例上和原型上有什么区别？" class="headerlink" title="九、方法定义在实例上和原型上有什么区别？"></a>九、方法定义在实例上和原型上有什么区别？</h3><p><strong>口述模板：</strong></p><p>如果方法定义在实例对象上，那么每个实例都会拥有一份独立的方法，占用更多内存；<br> 如果方法定义在原型对象上，那么所有实例共享同一份方法，内存利用率更高。</p><p>表达式方式和箭头方式定义的函数会定义在实例对象上。</p><p>因此在工程实践中，<strong>共享行为通常定义在原型上，实例只保存状态数据</strong>，这是 JS 面向对象的常见设计方式。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【⭐】TypeScript面试题</title>
    <link href="/2025/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p><a href="https://www.yuque.com/tianyu-coder/openshare/iw72s142l51odpgo">TypeScript 快速上手</a></p></blockquote><h2 id="面试题一：TypeScript-是什么？为什么要在项目里用-TypeScript？"><a href="#面试题一：TypeScript-是什么？为什么要在项目里用-TypeScript？" class="headerlink" title="面试题一：TypeScript 是什么？为什么要在项目里用 TypeScript？"></a>面试题一：TypeScript 是什么？为什么要在项目里用 TypeScript？</h2><p><strong>口述回答模板：</strong></p><p>TypeScript 是 JavaScript 的一个超集，它在 JS 语法基础上增加了类型系统，并最终编译成 JavaScript 运行。它解决的核心问题是：在中大型项目里，纯 JavaScript 的动态类型会导致很多错误只能在运行时暴露，而 TypeScript 通过静态代码检测能把一部分错误前置到编译期发现，比如参数类型不匹配、对象字段拼写错误、接口返回结构不稳定等。</p><p>从工程角度看，TypeScript 的价值不只是“更安全”，更重要的是它显著提升了可维护性和协作效率。类型本身就是一种可执行的文档，能让 IDE 更智能地提示、跳转、重构，并且让团队在接口、数据模型、组件 props、API 返回结构上形成统一约束。尤其是在多人协作、长期迭代的项目里，TS 能降低沟通成本和线上事故概率。</p><p>需要补充的一点是，TS 并不改变 JS 的运行机制，它只是通过编译阶段的类型检查，让我们用更低的成本获得更稳定的工程质量。</p><h2 id="面试题二：TypeScript-的类型系统特点是什么？和传统强类型语言有什么不同？"><a href="#面试题二：TypeScript-的类型系统特点是什么？和传统强类型语言有什么不同？" class="headerlink" title="面试题二：TypeScript 的类型系统特点是什么？和传统强类型语言有什么不同？"></a>面试题二：TypeScript 的类型系统特点是什么？和传统强类型语言有什么不同？</h2><p><strong>口述回答模板：</strong></p><p>TypeScript 的类型系统有几个核心特点：它是结构化类型系统，也就是更关注“形状是否匹配”，而不是名义上的继承关系；它是渐进式的，允许项目逐步引入类型，甚至在某些地方用 any 或 unknown 先过渡；它的类型检查发生在编译阶段，不影响运行时，运行时并没有类型信息。</p><p>与传统强类型语言相比，TypeScript 更强调对 JavaScript 生态的兼容和工程落地，所以它允许更灵活的写法，例如类型推断非常强，很多时候不需要显式标注类型</p><p>所以可以理解为：TS 是一种面向工程的类型系统，它追求在不牺牲 JS 灵活性的前提下，尽可能提升可维护性和正确性。</p><h2 id="面试题三：interface-和-type-有什么区别？项目里怎么选？"><a href="#面试题三：interface-和-type-有什么区别？项目里怎么选？" class="headerlink" title="面试题三：interface 和 type 有什么区别？项目里怎么选？"></a>面试题三：interface 和 type 有什么区别？项目里怎么选？</h2><p><strong>口述回答模板：</strong></p><p>interface 和 type 都能用来描述类型，但侧重点不同。interface 更适合描述“对象形状”和“面向扩展”的场景，它支持声明合并，适合对外暴露的公共接口或者需要被多处增强的类型定义。type 更像是类型别名，表达能力更强，可以定义联合类型、交叉类型、元组类型以及复杂的类型组合，适合做抽象和组合。</p><p>在工程实践中，我通常的选择原则是：如果是描述对象结构、组件 props、API 入参出参这类“稳定的接口形状”，优先用 interface；如果涉及联合、交叉、工具类型组合，或者需要更强表达能力，优先用 type。两者并不是互斥的，关键是统一团队规范，保证可读性和可维护性。</p><h2 id="面试题四：any、unknown、never-分别是什么？什么时候用？"><a href="#面试题四：any、unknown、never-分别是什么？什么时候用？" class="headerlink" title="面试题四：any、unknown、never 分别是什么？什么时候用？"></a>面试题四：any、unknown、never 分别是什么？什么时候用？</h2><p><strong>口述回答模板：</strong></p><p>any 表示放弃类型检查，它会让 TypeScript 退化成 JavaScript，类型不再提供保护，通常只建议在迁移期或确实无法描述类型时临时使用，并且要尽量控制范围，否则会把类型系统打穿。</p><p>unknown 表示“我不知道是什么类型”，它比 any 更安全，因为 unknown 不能直接被当作具体类型使用，必须先做类型缩小，比如判断类型或断言之后才能访问属性或调用方法。实际工程里，unknown 很适合用于处理外部不可信输入，比如后端返回、用户输入、JSON 解析结果等。</p><p>never 表示“不可能发生的类型”，典型场景是函数永远不会正常返回，比如直接抛错，或者在联合类型缩小后，某个分支理论上不可能出现。never 常用于穷尽性检查，能帮助我们在新增分支时让编译器提醒，避免遗漏逻辑。</p><hr><h2 id="面试题五：什么是类型缩小？TypeScript-如何根据代码推断更具体的类型？"><a href="#面试题五：什么是类型缩小？TypeScript-如何根据代码推断更具体的类型？" class="headerlink" title="面试题五：什么是类型缩小？TypeScript 如何根据代码推断更具体的类型？"></a>面试题五：什么是类型缩小？TypeScript 如何根据代码推断更具体的类型？</h2><p><strong>口述回答模板：</strong></p><p>类型缩小指的是：当一个变量可能是多种类型时，TypeScript 会根据运行时判断逻辑，把它在某个代码分支里收敛成更具体的类型，从而允许安全地访问属性或调用方法。最常见的缩小方式包括 typeof 判断、in 操作符判断字段是否存在、instanceof 判断构造函数，以及自定义类型守卫函数。</p><p>类型缩小的意义是让联合类型在工程里真正可用。我们可以先用联合类型表达“多种可能”，再通过缩小让每个分支都具备明确类型，从而在不牺牲灵活性的前提下保证安全性和可读性。这也是 TS 能在复杂业务逻辑里保持可维护性的关键能力之一。</p><hr><h2 id="面试题六：泛型是什么？为什么泛型在-TS-里很重要？"><a href="#面试题六：泛型是什么？为什么泛型在-TS-里很重要？" class="headerlink" title="面试题六：泛型是什么？为什么泛型在 TS 里很重要？"></a>面试题六：泛型是什么？为什么泛型在 TS 里很重要？</h2><p><strong>口述回答模板：</strong></p><p>泛型的核心目标是：在不丢失类型信息的前提下，让函数、类型或组件具备复用能力。比如一个函数接收什么类型就返回什么类型，如果不用泛型只能写成 any，这会丢失类型约束；用了泛型就能让调用方得到精确的返回类型推断，并且在错误使用时能在编译期发现问题。</p><p>在项目中，泛型大量用于封装通用能力，例如请求函数、表单组件、列表组件、状态管理工具等。它不仅提升复用性，还能让类型从输入一路传递到输出，形成“类型的闭环”，让 IDE 提示非常准确，减少误用。可以说，TS 的泛型能力是它能支撑大型工程抽象的基础。</p><hr><h2 id="面试题七：TypeScript-的声明文件-d-ts-是什么？什么时候需要写？"><a href="#面试题七：TypeScript-的声明文件-d-ts-是什么？什么时候需要写？" class="headerlink" title="面试题七：TypeScript 的声明文件 d.ts 是什么？什么时候需要写？"></a>面试题七：TypeScript 的声明文件 d.ts 是什么？什么时候需要写？</h2><p><strong>口述回答模板：</strong></p><p>d.ts 是 TypeScript 的类型声明文件，用来告诉编译器“某个 JS 模块在类型层面长什么样”。因为很多库在运行时只有 JS 代码，但 TS 需要类型信息才能在编译期检查和提示，所以就通过声明文件来补齐类型。</p><p>通常有几种场景需要写 d.ts：第一是项目引入了没有类型定义的第三方库；第二是项目里有一些全局变量或环境注入的对象需要声明；第三是对外提供 SDK 或组件库时，需要对外暴露稳定的类型接口。写好声明文件的好处是让类型成为接口契约的一部分，提升可用性，也减少使用方踩坑。</p><hr><h2 id="面试题八：TypeScript-的类型体操和工具类型在项目中怎么用？要注意什么？"><a href="#面试题八：TypeScript-的类型体操和工具类型在项目中怎么用？要注意什么？" class="headerlink" title="面试题八：TypeScript 的类型体操和工具类型在项目中怎么用？要注意什么？"></a>面试题八：TypeScript 的类型体操和工具类型在项目中怎么用？要注意什么？</h2><p><strong>口述回答模板：</strong></p><p>TypeScript 的工具类型和类型体操，本质上是用类型系统去描述“类型之间的变换关系”，比如从对象类型里挑选字段、把字段变成可选、从联合类型里提取某一类分支、根据条件生成不同结构等。它在工程中常用于统一 DTO、约束 API 返回、封装组件 props、生成表单模型等，能显著减少重复定义并保持一致性。</p><p>但需要注意度的把握：类型过于复杂会导致可读性下降、编译变慢、团队维护困难。我的原则是：工具类型用于“稳定且高频的抽象”，并且要配套清晰命名和注释；对于一次性或过度复杂的类型推导，宁可写清晰的显式类型，也不要追求炫技。类型的终极目标是可维护，而不是复杂度本身。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScripe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【⭐】NodeJS面试题</title>
    <link href="/2025/12/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/NodeJS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/12/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/NodeJS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="1-npm-pnpm-yarn-常用的命令有哪些？"><a href="#1-npm-pnpm-yarn-常用的命令有哪些？" class="headerlink" title="1. npm &#x2F; pnpm &#x2F; yarn 常用的命令有哪些？"></a>1. npm &#x2F; pnpm &#x2F; yarn 常用的命令有哪些？</h3><p><strong>Yarn</strong></p><ul><li>安装速度快（比 npm 早期版本快很多）</li><li>默认使用 <code>yarn.lock</code> 锁定依赖</li><li>支持 <strong>Plug’n’Play（PnP）</strong>，跳过 <code>node_modules</code></li></ul><p><strong>pnpm</strong></p><ul><li>采用 <strong>符号链接 + 全局内容寻址存储</strong> 节省磁盘空间</li><li>更严格的依赖隔离，防止 <code>npm</code> 和 <code>yarn</code> 容易出现的“幽灵依赖”</li><li>支持 monorepo（内置 workspace）</li></ul><table><thead><tr><th>功能</th><th>npm 命令</th><th>yarn 命令</th><th>pnpm 命令</th></tr></thead><tbody><tr><td>初始化项目</td><td><code>npm init</code> <code>npm init -y</code></td><td><code>yarn init</code> <code>yarn init -y</code></td><td><code>pnpm init</code> <code>pnpm init -y</code></td></tr><tr><td>安装依赖（全部）</td><td><code>npm install</code> <code>npm i</code></td><td><code>yarn install</code></td><td><code>pnpm install</code></td></tr><tr><td>安装依赖（指定）</td><td><code>npm install 包名</code></td><td><code>yarn add 包名</code></td><td><code>pnpm add 包名</code></td></tr><tr><td>安装开发依赖</td><td><code>npm install 包名 --save-dev</code> <code>npm i 包名 -D</code></td><td><code>yarn add 包名 --dev</code></td><td><code>pnpm add 包名 -D</code></td></tr><tr><td>安装全局包</td><td><code>npm install -g 包名</code></td><td><code>yarn global add 包名</code></td><td><code>pnpm add -g 包名</code></td></tr><tr><td>移除依赖</td><td><code>npm uninstall 包名</code> <code>npm rm 包名</code></td><td><code>yarn remove 包名</code></td><td><code>pnpm remove 包名</code></td></tr><tr><td>更新依赖</td><td><code>npm update 包名</code></td><td><code>yarn upgrade 包名</code></td><td><code>pnpm update 包名</code></td></tr><tr><td>查看过期依赖</td><td><code>npm outdated</code></td><td><code>yarn outdated</code></td><td><code>pnpm outdated</code></td></tr><tr><td>运行脚本</td><td><code>npm run 脚本名</code></td><td><code>yarn run 脚本名</code> <code>yarn 脚本名</code></td><td><code>pnpm run 脚本名</code> <code>pnpm 脚本名</code></td></tr><tr><td>清缓存</td><td><code>npm cache clean --force</code></td><td><code>yarn cache clean</code></td><td><code>pnpm store prune</code></td></tr><tr><td>查看依赖树</td><td><code>npm list</code></td><td><code>yarn list</code></td><td><code>pnpm list</code></td></tr><tr><td>安装指定版本</td><td><code>npm install 包名@版本</code></td><td><code>yarn add 包名@版本</code></td><td><code>pnpm add 包名@版本</code></td></tr><tr><td>安装本地包</td><td><code>npm install ./路径</code></td><td><code>yarn add ./路径</code></td><td><code>pnpm add ./路径</code></td></tr></tbody></table><h3 id="2-什么是-RESTful（口述回答模板）"><a href="#2-什么是-RESTful（口述回答模板）" class="headerlink" title="2. 什么是 RESTful（口述回答模板）"></a>2. 什么是 RESTful（口述回答模板）</h3><blockquote><p>RESTful 是一种 <strong>接口设计风格</strong>，核心思想是<strong>把服务器资源当成资源来设计</strong>，通过 <strong>URL 表示资源，通过 HTTP 方法表示操作</strong>。</p><p>在 RESTful 规范中，<strong>URL 通常使用名词表示资源</strong>，比如用户、订单；<br> <strong>具体做什么操作由 HTTP 方法决定</strong>，比如 GET 用来查询，POST 用来新增，PUT 或 PATCH 用来修改，DELETE 用来删除。</p><p>RESTful 强调接口<strong>语义清晰、风格统一、前后端解耦</strong>，因此在前后端分离项目中使用非常普遍。</p></blockquote><h3 id="3-Chrome-开发者工具使用过哪些？"><a href="#3-Chrome-开发者工具使用过哪些？" class="headerlink" title="3. Chrome 开发者工具使用过哪些？"></a><strong>3. Chrome</strong> <strong>开发者工具使用过哪些</strong>？</h3><ul><li><strong>Elements</strong>：修改 HTML&#x2F;CSS</li><li><strong>Console</strong>：打印日志、调试 JS</li><li><strong>Network</strong>：查看 HTTP 请求、CORS</li><li><strong>Sources</strong>：断点调试</li><li><strong>Performance</strong>：性能分析</li><li><strong>Memory</strong>：内存泄漏检查</li><li><strong>Application</strong>：查看 Cookie、LocalStorage、SessionStorage</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="面试题一：什么是-Promise？为什么要引入-Promise？"><a href="#面试题一：什么是-Promise？为什么要引入-Promise？" class="headerlink" title="面试题一：什么是 Promise？为什么要引入 Promise？"></a>面试题一：什么是 Promise？为什么要引入 Promise？</h3><p><strong>口述回答模板：</strong></p><p>Promise 是 JavaScript 中用于处理异步操作的一套标准化解决方案，本质上它是一个对象，用来描述“未来某一时刻才会有结果”的操作。</p><p>在 Promise 出现之前，JavaScript 的异步逻辑主要依赖回调函数实现。但当异步流程变复杂之后，会出现两个明显问题：<br> 第一是回调地狱，多个异步操作层层嵌套，代码结构非常混乱，可读性和可维护性都很差；<br> 第二是错误处理分散，每一层回调都需要单独处理异常，很难做到统一管理。</p><p>Promise 的核心价值在于：<strong>把异步操作本身抽象成一个对象</strong>，通过状态管理和链式调用来组织异步流程。这样可以用更接近同步的写法描述异步逻辑，同时集中处理成功和失败情况。</p><p>在工程实践中，Promise 不仅解决了回调地狱和错误分散的问题，也为 async &#x2F; await 的出现提供了基础，使异步代码的可读性和可维护性显著提升。</p><hr><h3 id="面试题二：Promise-有哪几种状态？状态是如何流转的？"><a href="#面试题二：Promise-有哪几种状态？状态是如何流转的？" class="headerlink" title="面试题二：Promise 有哪几种状态？状态是如何流转的？"></a>面试题二：Promise 有哪几种状态？状态是如何流转的？</h3><p><strong>口述回答模板：</strong></p><p>Promise 在整个生命周期中只有三种状态：pending、fulfilled 和 rejected。<br> pending 表示初始状态，说明异步操作正在进行但尚未完成；<br> fulfilled 表示异步操作成功完成；<br> rejected 表示异步操作执行失败。</p><p>Promise 的状态流转有两个非常重要的特性。<br> 第一，<strong>状态不可逆</strong>，只能从 pending 变为 fulfilled 或 rejected，不能反向切换；<br> 第二，<strong>状态只会改变一次</strong>，无论 resolve 还是 reject，只要其中一个生效，后续调用都会被忽略。</p><p>这种设计的意义在于保证异步结果的确定性。只要 Promise 的状态已经确定，无论在什么时候通过 then 或 catch 去订阅，都一定能拿到相同的结果，这也是 Promise 可以被安全复用和组合的基础。</p><hr><h3 id="面试题三：Promise-是如何实现链式调用的？为什么可以一直-then-下去？"><a href="#面试题三：Promise-是如何实现链式调用的？为什么可以一直-then-下去？" class="headerlink" title="面试题三：Promise 是如何实现链式调用的？为什么可以一直 then 下去？"></a>面试题三：Promise 是如何实现链式调用的？为什么可以一直 then 下去？</h3><p><strong>口述回答模板：</strong></p><p>Promise 能实现链式调用的根本原因是：<strong>then 方法本身一定会返回一个新的 Promise 对象</strong>。</p><p>当上一个 Promise 状态变为 fulfilled 或 rejected 时，then 中对应的回调函数会被放入微任务队列执行。这个回调函数的返回值，会直接决定下一个 Promise 的状态。</p><p>如果回调返回的是普通值，这个值会被自动包装成一个 fulfilled 状态的 Promise；<br> 如果返回的是一个 Promise，那么下一个 Promise 会直接“接管”它的状态；<br> 如果在回调中抛出异常，下一个 Promise 就会进入 rejected 状态。</p><p>正是因为这种“返回新 Promise + 状态接力”的机制，Promise 才能把多个异步步骤自然地串联成一条清晰、线性的异步执行链。</p><hr><h3 id="面试题四：Promise-的错误是如何传递的？catch-和-then-的区别是什么？"><a href="#面试题四：Promise-的错误是如何传递的？catch-和-then-的区别是什么？" class="headerlink" title="面试题四：Promise 的错误是如何传递的？catch 和 then 的区别是什么？"></a>面试题四：Promise 的错误是如何传递的？catch 和 then 的区别是什么？</h3><p><strong>口述回答模板：</strong></p><p>Promise 的错误传递采用的是类似同步异常的“冒泡机制”。<br> 一旦在某个 then 中抛出异常，或者返回了 rejected 状态，这个错误就会沿着 Promise 链一直向后传递，直到被最近的 catch 捕获。</p><p>then 方法本身可以接收两个回调参数，分别用于成功和失败处理，但在实际工程中并不推荐这样使用。<br> catch 本质上等价于 then 的第二个参数，但它语义更清晰，也更适合做统一错误处理。</p><p>另外一个很容易被忽略的点是：<strong>catch 本身也会返回一个新的 Promise</strong>。<br> 如果 catch 中处理了错误并返回了一个正常值，后续的 then 仍然可以继续执行；<br> 如果 catch 中再次抛出异常，错误会继续向后传递。</p><p>因此在工程中，通常会在 Promise 链的末尾统一写一个 catch，用来集中处理所有异常情况。</p><hr><h3 id="面试题五：Promise-有哪些常用静态方法？分别解决什么问题？"><a href="#面试题五：Promise-有哪些常用静态方法？分别解决什么问题？" class="headerlink" title="面试题五：Promise 有哪些常用静态方法？分别解决什么问题？"></a>面试题五：Promise 有哪些常用静态方法？分别解决什么问题？</h3><p><strong>口述回答模板：</strong></p><p>Promise 提供了一组静态方法，用于处理多个异步任务的组合场景。</p><p>Promise.resolve 用于返回一个成功状态的 Promise，参数可以是普通值，也可以是一个 Promise；如果传入的是一个 <strong>Promise 对象</strong>，那么 Promise.resolve 不会改变它的状态，而是<strong>直接返回一个与该 Promise 状态保持一致的 Promise</strong>。</p><p>Promise.reject 用于返回一个失败状态的 Promise。</p><p>Promise.all 用于并行执行多个 Promise，只有当所有 Promise 都成功时才会成功，只要有一个失败就会整体失败，适合所有结果都必须具备的场景；</p><p>Promise.race 返回最先完成的 Promise 结果，不论成功还是失败，常用于超时控制；</p><p>Promise.allSettled 会等待所有 Promise 执行完毕，并返回每一个 Promise 的最终状态，不关心成功或失败；</p><p>Promise.any 只要有一个 Promise 成功就返回成功结果，只有全部失败才会失败。</p><p>这些方法本质上解决的是“多个异步任务如何协同完成”的问题。</p><hr><h3 id="面试题六：Promise-和-async-await-的关系是什么？本质区别在哪里？"><a href="#面试题六：Promise-和-async-await-的关系是什么？本质区别在哪里？" class="headerlink" title="面试题六：Promise 和 async &#x2F; await 的关系是什么？本质区别在哪里？"></a>面试题六：Promise 和 async &#x2F; await 的关系是什么？本质区别在哪里？</h3><p><strong>口述回答模板：</strong></p><p>async &#x2F; await 本质上是 Promise 的语法糖，而不是一种新的异步模型。</p><p>async 函数一定会返回一个 Promise，函数内部的 return 会被自动包装成 fulfilled 状态，而抛出的异常会被自动包装成 rejected 状态。</p><p>await 的作用是暂停当前 async 函数的执行，等待 Promise 的结果返回，但这种暂停不会阻塞主线程，只会阻塞当前函数后续代码的执行。</p><p>从底层机制上看，await 后面的代码依然是通过微任务的方式继续执行的。<br> 在实际开发中，Promise 更适合底层能力封装，而 async &#x2F; await 更适合编写业务流程代码，两者是配合关系而不是替代关系。</p><hr><h3 id="面试题七：Promise-在事件循环中的执行顺序是怎样的？"><a href="#面试题七：Promise-在事件循环中的执行顺序是怎样的？" class="headerlink" title="面试题七：Promise 在事件循环中的执行顺序是怎样的？"></a>面试题七：Promise 在事件循环中的执行顺序是怎样的？</h3><p><strong>口述回答模板：</strong></p><p>Promise 的 then 和 catch 回调并不会立即执行，而是会被放入<strong>微任务队列</strong>。</p><p>当当前宏任务执行完成、调用栈清空之后，事件循环会优先清空所有微任务，然后才会进入下一轮宏任务。因此，Promise 回调的执行优先级高于 setTimeout 等宏任务。</p><p>需要注意的是，then 回调是否进入微任务队列，取决于 Promise 状态是否发生改变。<br> 当 Promise 被 resolve 或 reject 时，对应的回调才会被推入微任务队列，而不是在调用 then 的那一刻立即执行。</p><p>这也是理解 Promise 执行顺序和调试异步问题的关键。</p><h2 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h2><h3 id="面试题一：什么是会话控制？为什么需要会话控制？"><a href="#面试题一：什么是会话控制？为什么需要会话控制？" class="headerlink" title="面试题一：什么是会话控制？为什么需要会话控制？"></a>面试题一：什么是会话控制？为什么需要会话控制？</h3><p><strong>口述回答模板：</strong></p><p>会话控制指的是：在 HTTP 这种无状态协议之上，<strong>识别同一个用户的多次请求，并维持其登录态和业务上下文的机制</strong>。</p><p>HTTP 本身是无状态的，每一次请求在服务器看来都是独立的，如果没有会话控制，服务器无法判断两次请求是否来自同一个用户，也无法知道用户是否已经登录。这在登录校验、购物车、权限控制等场景下是不可接受的。</p><p>因此，会话控制的核心目标就是：<br> 在多次请求之间建立“用户身份连续性”，让服务器能够识别用户是谁、是否登录、拥有哪些权限。<br> Cookie、Session 和 Token，都是围绕这个目标产生的不同实现方案。</p><hr><h3 id="面试题二：Cookie-是什么？它在会话控制中起什么作用？"><a href="#面试题二：Cookie-是什么？它在会话控制中起什么作用？" class="headerlink" title="面试题二：Cookie 是什么？它在会话控制中起什么作用？"></a>面试题二：Cookie 是什么？它在会话控制中起什么作用？</h3><p><strong>口述回答模板：</strong></p><p>Cookie 是浏览器存储的一小段键值对数据，由服务器通过响应头下发，并在后续请求中由浏览器自动携带发送给服务器。</p><p>在会话控制中，Cookie 本身并不保存复杂的会话信息，而是<strong>承担“客户端标识”的角色</strong>。最典型的用法是：服务器生成一个唯一的会话标识，比如 sessionId，通过 Cookie 下发给浏览器，浏览器之后每次请求都会带上这个标识。</p><p>Cookie 的优势在于使用简单、浏览器自动管理，但缺点也比较明显：<br> 一是大小和数量受限；<br> 二是安全性依赖配置，如果没有合理设置 HttpOnly、Secure 等属性，容易被窃取或滥用；<br> 三是 Cookie 会自动随请求发送，在跨域和前后端分离场景中不够灵活。</p><p>因此，Cookie 更像是会话控制中的“载体”，而不是完整的身份方案。</p><hr><h3 id="面试题三：Session-是什么？它和-Cookie-是如何配合工作的？"><a href="#面试题三：Session-是什么？它和-Cookie-是如何配合工作的？" class="headerlink" title="面试题三：Session 是什么？它和 Cookie 是如何配合工作的？"></a>面试题三：Session 是什么？它和 Cookie 是如何配合工作的？</h3><p><strong>口述回答模板：</strong></p><p>Session 是服务器端的会话存储机制，用来保存用户的登录状态和相关会话数据，比如用户 ID、权限信息等。</p><p>典型的 Session 工作流程是：<br> 用户第一次访问时，服务器创建一个 Session，并生成一个唯一的 sessionId；<br> 服务器将这个 sessionId 通过 Cookie 返回给浏览器；<br> 浏览器在后续请求中携带这个 sessionId；<br> 服务器根据 sessionId 查找对应的 Session 数据，从而识别用户身份。</p><p>这种模式的核心特点是：<strong>会话数据存储在服务器端，客户端只保存一个标识</strong>。<br> 它的安全性相对较高，因为敏感信息不暴露在客户端，但也带来了问题，比如服务器需要维护 Session 状态，在分布式或多实例部署时，需要额外的 Session 共享或粘性策略。</p><hr><h3 id="面试题四：Token-是什么？为什么前后端分离项目更常用-Token？"><a href="#面试题四：Token-是什么？为什么前后端分离项目更常用-Token？" class="headerlink" title="面试题四：Token 是什么？为什么前后端分离项目更常用 Token？"></a>面试题四：Token 是什么？为什么前后端分离项目更常用 Token？</h3><p><strong>口述回答模板：</strong></p><p>Token 是一种<strong>自包含的身份凭证</strong>，通常由服务器在用户登录成功后生成，并返回给客户端。客户端在后续请求中，主动通过请求头携带 Token，而不是依赖浏览器自动发送。</p><p>与 Session 不同，Token 模式下服务器通常不保存会话状态，而是通过校验 Token 的合法性来确认用户身份。这种设计使得 Token 天然适合前后端分离和分布式系统。</p><p>Token 的优势主要体现在三点：<br> 第一，不依赖 Cookie，跨域和多端使用更灵活；<br> 第二，服务器无状态，天然支持横向扩展；<br> 第三，可以携带用户信息和权限声明，减少服务器查询开销。</p><p>当然，Token 也并非没有代价，比如一旦泄露，在过期之前都可能被滥用，因此通常会配合过期时间、刷新机制和 HTTPS 一起使用。</p><hr><h3 id="面试题五：Cookie-Session-和-Token-的核心区别是什么？"><a href="#面试题五：Cookie-Session-和-Token-的核心区别是什么？" class="headerlink" title="面试题五：Cookie + Session 和 Token 的核心区别是什么？"></a>面试题五：Cookie + Session 和 Token 的核心区别是什么？</h3><p><strong>口述回答模板：</strong></p><p>Cookie + Session 属于<strong>服务端有状态方案</strong>，服务器需要保存会话数据，客户端只保存一个 sessionId；<br> Token 属于<strong>服务端无状态方案</strong>，服务器不保存会话，只校验 Token 本身。</p><p>前者的优势是安全直观、控制力强，适合传统单体应用；<br> 后者的优势是可扩展性好、跨端友好，适合前后端分离、微服务架构。</p><p>本质上，两者解决的是同一个问题：用户身份识别，只是状态存放的位置不同，一个在服务器，一个在客户端。</p><hr><h3 id="面试题六：Token-放在哪里？和-Cookie-相比有什么不同？"><a href="#面试题六：Token-放在哪里？和-Cookie-相比有什么不同？" class="headerlink" title="面试题六：Token 放在哪里？和 Cookie 相比有什么不同？"></a>面试题六：Token 放在哪里？和 Cookie 相比有什么不同？</h3><p><strong>口述回答模板：</strong></p><p>Token 一般不会自动携带，而是由客户端主动放在请求头中，比如 Authorization 字段。这一点和 Cookie 有本质区别。</p><p>Cookie 是浏览器自动管理的，适合传统页面应用；<br> Token 由业务代码控制，更适合移动端、小程序以及前后端分离架构。</p><p>但需要注意的是，如果 Token 存储在本地存储中，需要防范 XSS 攻击；如果存储在 Cookie 中，又需要防范 CSRF，因此具体方案需要结合业务场景权衡安全策略。</p><hr><h3 id="面试题七：在实际项目中，如何选择-Cookie、Session-还是-Token？"><a href="#面试题七：在实际项目中，如何选择-Cookie、Session-还是-Token？" class="headerlink" title="面试题七：在实际项目中，如何选择 Cookie、Session 还是 Token？"></a>面试题七：在实际项目中，如何选择 Cookie、Session 还是 Token？</h3><p><strong>口述回答模板：</strong></p><p>选择哪种会话控制方式，本质上取决于系统架构和安全需求。</p><p>如果是传统服务端渲染应用，用户规模不大，Cookie + Session 简单可靠；<br> 如果是前后端分离或多端统一登录，Token 更灵活；<br> 如果是分布式或微服务系统，Token 或基于 Token 的统一认证中心更容易扩展。</p><p>实际工程中，也经常是混合使用，比如 Cookie 承载 Token，Token 表达身份，结合多种安全策略共同完成会话控制。</p><h3 id="面试题八：什么是-JWT？它解决了什么问题？"><a href="#面试题八：什么是-JWT？它解决了什么问题？" class="headerlink" title="面试题八：什么是 JWT？它解决了什么问题？"></a>面试题八：什么是 JWT？它解决了什么问题？</h3><p><strong>口述回答模板：</strong></p><p>JWT，全称是 JSON Web Token，是一种<strong>用于在客户端和服务器之间安全传递身份信息的标准化 Token 格式</strong>。<br> 它的核心作用是在<strong>无状态的 HTTP 协议之上，实现用户身份认证和授权</strong>。</p><p>JWT 产生的背景是：在前后端分离和分布式系统中，传统基于 Session 的方案需要服务器保存会话状态，不利于横向扩展。JWT 的思路是把用户身份信息直接放进 Token 中，由客户端保存，每次请求时主动携带，服务器只需要校验 Token 的合法性即可。</p><p>因此，JWT 的本质不是“加密技术”，而是一种<strong>自包含、可校验、无状态的身份凭证设计方案</strong>，非常适合微服务、多端登录和跨域场景。</p><hr><h3 id="面试题九：JWT-的结构是怎样的？每一部分有什么作用？"><a href="#面试题九：JWT-的结构是怎样的？每一部分有什么作用？" class="headerlink" title="面试题九：JWT 的结构是怎样的？每一部分有什么作用？"></a>面试题九：JWT 的结构是怎样的？每一部分有什么作用？</h3><p><strong>口述回答模板：</strong></p><p>JWT 由三部分组成，分别是 Header、Payload 和 Signature，它们通过点号连接成一个字符串。</p><p>Header 用来描述 Token 的元信息，比如使用的签名算法类型；<br> Payload 用来存放实际的业务声明，也就是用户身份信息、权限信息以及一些标准字段，比如过期时间；<br> Signature 是通过 Header 和 Payload 再结合服务器的密钥计算出来的签名，用于防止 Token 被篡改。</p><p>需要特别强调的是：<strong>JWT 默认并不是加密的，而只是签名的</strong>。<br> Payload 中的数据是可以被解码查看的，但如果被篡改，签名校验一定会失败，这也是 JWT 安全性的核心所在。</p><hr><h3 id="面试题十：JWT-的工作流程是怎样的？"><a href="#面试题十：JWT-的工作流程是怎样的？" class="headerlink" title="面试题十：JWT 的工作流程是怎样的？"></a>面试题十：JWT 的工作流程是怎样的？</h3><p><strong>口述回答模板：</strong></p><p>JWT 的典型工作流程是这样的：<br> 用户在登录成功后，服务器根据用户信息生成一个 JWT，并返回给客户端；<br> 客户端将这个 JWT 保存起来，比如存在内存或本地存储中；<br> 在后续请求中，客户端通过请求头主动携带 JWT；<br> 服务器接收到请求后，验证 JWT 的签名和有效期，如果校验通过，就认为用户身份是可信的。</p><p>整个过程中，服务器不需要保存任何会话状态，这也是 JWT 被称为“无状态认证”的原因。</p><h3 id="面试题一：什么是-XSS？它和会话控制有什么关系？"><a href="#面试题一：什么是-XSS？它和会话控制有什么关系？" class="headerlink" title="面试题一：什么是 XSS？它和会话控制有什么关系？"></a>面试题一：什么是 XSS？它和会话控制有什么关系？</h3><p><strong>口述回答模板：</strong></p><p>XSS，全称是跨站脚本攻击，本质上是攻击者把恶意脚本注入到网页中，让浏览器在用户的上下文里执行这些脚本。</p><p>XSS 和会话控制的关系非常直接，因为一旦发生 XSS，攻击者就有机会<strong>窃取或滥用用户的会话凭证</strong>，比如 Cookie 中的 sessionId，或者本地存储中的 Token。<br> 也就是说，XSS 的真正危害并不只是页面被篡改，而是它可以直接导致用户身份被冒用。</p><p>从攻击视角看，XSS 是“绕过服务器认证，直接站在用户角度发请求”；<br> 从防御视角看，任何基于 Cookie、Session 或 Token 的会话控制方案，一旦前端存在 XSS 漏洞，都会面临会话被劫持的风险。</p><hr><h3 id="面试题二：XSS-如何影响-Cookie-Session-Token？"><a href="#面试题二：XSS-如何影响-Cookie-Session-Token？" class="headerlink" title="面试题二：XSS 如何影响 Cookie &#x2F; Session &#x2F; Token？"></a>面试题二：XSS 如何影响 Cookie &#x2F; Session &#x2F; Token？</h3><p><strong>口述回答模板：</strong></p><p>如果使用的是 Cookie + Session 模型，并且 Cookie 没有设置 HttpOnly，那么 XSS 脚本可以直接读取 Cookie 中的 sessionId，并发送给攻击者，从而实现会话劫持。</p><p>如果使用的是 Token，并且 Token 存储在 localStorage 或 sessionStorage 中，那么 XSS 脚本同样可以直接读取 Token，这在前后端分离项目中尤为常见。</p><p>需要强调的是：<strong>XSS 并不会绕过认证逻辑，而是窃取合法身份凭证后再正常使用它</strong>。<br> 因此，从安全角度看，XSS 是所有会话控制方案中最优先需要防范的一类攻击。</p><hr><h3 id="面试题三：什么是-CSRF？它和会话控制的关系是什么？"><a href="#面试题三：什么是-CSRF？它和会话控制的关系是什么？" class="headerlink" title="面试题三：什么是 CSRF？它和会话控制的关系是什么？"></a>面试题三：什么是 CSRF？它和会话控制的关系是什么？</h3><p><strong>口述回答模板：</strong></p><p>CSRF，全称是跨站请求伪造，它的核心特点是：<strong>攻击者无法读取用户信息，但可以借助用户已登录的身份发起请求</strong>。</p><p>CSRF 的前提是浏览器会自动携带身份凭证，比如 Cookie。<br> 如果用户在登录状态下访问了恶意网站，该网站就可以构造请求，利用浏览器自动携带 Cookie 的机制，向目标服务器发送请求，从而以用户身份执行操作。</p><p>因此，CSRF 的攻击目标并不是窃取会话，而是<strong>滥用已有会话</strong>。<br> 它与会话控制的关系在于：只要身份凭证会被浏览器自动发送，就天然存在 CSRF 风险。</p><hr><h3 id="面试题四：为什么-Cookie-Session-容易受到-CSRF-攻击，而-Token-相对不容易？"><a href="#面试题四：为什么-Cookie-Session-容易受到-CSRF-攻击，而-Token-相对不容易？" class="headerlink" title="面试题四：为什么 Cookie + Session 容易受到 CSRF 攻击，而 Token 相对不容易？"></a>面试题四：为什么 Cookie + Session 容易受到 CSRF 攻击，而 Token 相对不容易？</h3><p><strong>口述回答模板：</strong></p><p>Cookie + Session 模式下，浏览器会在符合域名条件时自动携带 Cookie，这正是 CSRF 能成立的根本原因。<br> 攻击者不需要知道 sessionId，只需要诱导用户发起请求，浏览器就会自动附带身份信息。</p><p>而 Token 通常通过请求头由前端代码主动携带，而不是浏览器自动附带。<br> 恶意网站无法在不触发同源限制的情况下构造携带 Token 的请求，因此 Token 天然规避了大多数 CSRF 攻击场景。</p><p>需要注意的是，这并不意味着 Token 完全免疫 CSRF，而是<strong>Token 的携带方式让 CSRF 的攻击成本显著提高</strong>。</p><hr><h3 id="面试题五：如何防御-XSS？从会话安全角度如何设计？"><a href="#面试题五：如何防御-XSS？从会话安全角度如何设计？" class="headerlink" title="面试题五：如何防御 XSS？从会话安全角度如何设计？"></a>面试题五：如何防御 XSS？从会话安全角度如何设计？</h3><p><strong>口述回答模板：</strong></p><p>防御 XSS 的核心原则是：<strong>永远不要信任用户输入</strong>。<br> 在前端和后端都需要对用户输入进行转义或过滤，避免脚本被当作可执行代码插入页面。</p><p>从会话控制角度，最重要的防御措施包括：<br> 对 Cookie 设置 HttpOnly，防止脚本读取；<br> 对 Token 避免暴露在容易被脚本读取的位置；<br> 启用 Content Security Policy，限制脚本加载来源。</p><p>可以总结为一句话：XSS 一旦成立，会话控制基本失效，因此必须在源头阻断 XSS。</p><hr><h3 id="面试题六：如何防御-CSRF？常见方案有哪些？"><a href="#面试题六：如何防御-CSRF？常见方案有哪些？" class="headerlink" title="面试题六：如何防御 CSRF？常见方案有哪些？"></a>面试题六：如何防御 CSRF？常见方案有哪些？</h3><p><strong>口述回答模板：</strong></p><p>防御 CSRF 的核心思路是：<strong>让请求具备“攻击者无法伪造”的特征</strong>。</p><p>最常见的方案是 CSRF Token，即服务器为每个用户生成一个随机值，要求客户端在请求中主动携带，并在服务器端校验。<br> 由于攻击者无法读取页面内容，因此也无法构造合法的 CSRF Token。</p><p>另外，合理设置 Cookie 的 SameSite 属性，也可以在浏览器层面阻止跨站请求自动携带 Cookie。<br> 在前后端分离项目中，使用 Token 并通过请求头携带，本身就是一种有效的 CSRF 防御手段。</p><h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><h3 id="面试题：什么是前端打包工具？"><a href="#面试题：什么是前端打包工具？" class="headerlink" title="面试题：什么是前端打包工具？"></a>面试题：什么是前端打包工具？</h3><p>前端打包工具（Bundler &#x2F; Build Tool）的核心目标是：</p><p><strong>将分散的源代码与资源，转换、整合并输出为浏览器或运行环境可理解的高性能生产代码。</strong></p><p>打包工具到底“打包”了什么</p><p>打包工具处理的不是只有 JS，而是整个前端工程的所有输入：</p><ul><li>JavaScript &#x2F; TypeScript</li><li>CSS &#x2F; SCSS &#x2F; Less</li><li>图片 &#x2F; 字体 &#x2F; SVG</li><li>JSON &#x2F; WASM</li><li>环境变量 &#x2F; 配置文件</li></ul><p>最终目标只有一个：</p><blockquote><p> <strong>生成一组浏览器能够高效加载、稳定运行、长期缓存的静态资源。</strong></p></blockquote><h3 id="面试题：前端打包工具的作用是什么？"><a href="#面试题：前端打包工具的作用是什么？" class="headerlink" title="面试题：前端打包工具的作用是什么？"></a>面试题：前端打包工具的作用是什么？</h3><p>前端打包工具本质上解决三类问题。<br> 第一是工程化问题，现代前端采用模块化开发，但浏览器无法理解工程结构，需要打包工具分析模块依赖并整合代码。<br> 第二是兼容性问题，工程中使用的 TypeScript、SCSS 以及新语法浏览器无法直接识别，需要在打包阶段进行转换和降级。<br> 第三是性能问题，工程化拆分会带来大量文件和请求，打包工具通过合并、拆分和按需加载等方式，在构建阶段优化最终加载性能。</p><h3 id="面试题：前端打包工具的流程是什么？"><a href="#面试题：前端打包工具的流程是什么？" class="headerlink" title="面试题：前端打包工具的流程是什么？"></a>面试题：前端打包工具的流程是什么？</h3><p>从入口文件开始，先分析模块之间的依赖关系，构建完整的依赖图；<br> 然后对每个模块进行代码转换，把工程化语言转成浏览器可执行代码；<br> 接着根据依赖关系决定代码如何合并或拆分；<br> 在此基础上进行构建阶段的优化，比如压缩和删除无用代码；<br> 最后生成浏览器可以直接加载的最终产物。</p><h3 id="面试题：常见的前端打包工具有哪些？"><a href="#面试题：常见的前端打包工具有哪些？" class="headerlink" title="面试题：常见的前端打包工具有哪些？"></a>面试题：常见的前端打包工具有哪些？</h3><p>常见的前端打包工具包括 Webpack、Vite、Rollup、esbuild 和 Parcel。Webpack 功能最全面，适合复杂工程；Vite 基于原生 ESM，开发体验最好；Rollup 更适合打包类库，输出干净；esbuild 以极致性能著称，常作为底层构建工具；Parcel 强调零配置，适合小型项目和快速原型。</p><h3 id="面试题：什么是Webpack？"><a href="#面试题：什么是Webpack？" class="headerlink" title="面试题：什么是Webpack？"></a>面试题：什么是Webpack？</h3><p>Webpack 是一个<strong>以模块为核心</strong>的前端构建工具，其本质是：</p><blockquote><p><strong>从一个或多个入口文件出发，构建整个应用的依赖图（Dependency Graph），并将其打包为若干个可部署的静态资源。</strong></p></blockquote><hr><p>Webpack 的核心思想</p><ul><li>一切皆模块 JS&#x2F;CSS&#x2F;图片&#x2F;字体&#x2F;JSON</li><li>模块之间通过 <code>import / require</code> 建立依赖</li><li>Webpack 递归分析依赖，最终形成资源图</li></ul><h3 id="面试题：什么是-loader？为什么需要-loader？"><a href="#面试题：什么是-loader？为什么需要-loader？" class="headerlink" title="面试题：什么是 loader？为什么需要 loader？"></a>面试题：什么是 loader？为什么需要 loader？</h3><p><strong>口述回答模板：</strong></p><p>在 Webpack 中，loader 本质上是一个<strong>文件转换器</strong>。<br> 因为 Webpack 本身只认识 JavaScript 和 JSON，而在真实项目中，我们会使用 CSS、图片、字体、TypeScript、JSX、Vue 文件等各种非 JS 资源，所以需要 loader 把这些资源<strong>转换成 Webpack 能理解和处理的模块</strong>。</p><p>从工程角度看，loader 解决的问题是：<br> <strong>如何把不同类型的资源，统一纳入模块依赖图中进行打包处理</strong>。<br> <span style="color:#1677FF">每一个 loader 只做一件事，比如编译、转换、提取或注入，多个 loader 还可以串联形成流水线。</span></p><p>需要注意的是，loader 工作在<strong>构建阶段</strong>，不参与运行时，它的目标是生成最终可执行的模块代码。</p><hr><h3 id="面试题：loader-的执行机制是怎样的？"><a href="#面试题：loader-的执行机制是怎样的？" class="headerlink" title="面试题：loader 的执行机制是怎样的？"></a>面试题：loader 的执行机制是怎样的？</h3><p><strong>口述回答模板：</strong></p><p>loader 的执行是<strong>从右到左、从下到上</strong>的，也可以理解为“先处理源代码，再逐步包装结果”。<br> 每一个 loader 接收上一个 loader 的输出作为输入，最终生成 Webpack 可识别的模块。</p><p>这种设计让 loader 具备很强的组合能力，比如先做语法转换，再做样式处理，再做资源注入，每一步职责都很清晰。</p><hr><h3 id="面试题：常见的-loader-有哪些？分别解决什么问题？"><a href="#面试题：常见的-loader-有哪些？分别解决什么问题？" class="headerlink" title="面试题：常见的 loader 有哪些？分别解决什么问题？"></a>面试题：常见的 loader 有哪些？分别解决什么问题？</h3><p><strong>口述回答模板：</strong></p><p>在实际项目中，常见 loader 可以按资源类型来理解。</p><ul><li>处理 JavaScript 和语法转换的，最典型的是 babel-loader，用来把 ES6+ 代码转换成兼容性更好的 JavaScript；</li><li>处理 TypeScript 的是 ts-loader 或 babel-loader 配合 TypeScript 插件，用于类型编译和语法转换；</li><li>处理 CSS 的是 css-loader，它负责解析 CSS 中的依赖关系，比如 @import 和 url；style-loader 用于把 CSS 通过 style 标签注入到页面中，而在生产环境中，通常会用 MiniCssExtractPlugin 配合 loader 把 CSS 抽离成独立文件；</li><li>预处理器相关的有 sass-loader、less-loader，用于把 Sass、Less 编译成标准 CSS；</li><li>处理图片和字体等静态资源的有 file-loader、url-loader，在 Webpack 5 中更多由内置的 asset 模块替代；</li><li>在 Vue 项目中，vue-loader 用于解析 .vue 单文件组件，把 template、script、style 拆分并分别交给对应 loader 处理。</li></ul><p>这些 loader 各司其职，共同完成从源码到最终资源的转换过程。</p><hr><h3 id="面试题：loader-和-plugin-有什么区别？"><a href="#面试题：loader-和-plugin-有什么区别？" class="headerlink" title="面试题：loader 和 plugin 有什么区别？"></a>面试题：loader 和 plugin 有什么区别？</h3><p><strong>口述回答模板：</strong></p><p>loader 和 plugin 的核心区别在于<strong>职责不同</strong>。</p><p>loader 关注的是“<strong>某一类文件如何被转换</strong>”，它作用于模块本身，通常是单输入单输出；<br> plugin 关注的是“<strong>整个构建过程如何被增强或控制</strong>”，它可以介入打包的任意生命周期，比如资源优化、文件生成、环境注入等。</p><p>可以简单理解为：<br> loader 是流水线上的加工工人，<br> plugin 是控制整个流水线流程的调度器。</p><h3 id="面试题：plugin-的工作原理是什么？"><a href="#面试题：plugin-的工作原理是什么？" class="headerlink" title="面试题：plugin 的工作原理是什么？"></a>面试题：plugin 的工作原理是什么？</h3><p><strong>口述回答模板：</strong></p><p>plugin 的核心原理是：<strong>基于事件机制的生命周期钩子系统</strong>。</p><p>Webpack 在内部会在关键阶段触发不同的钩子，plugin 在初始化时把自己的逻辑注册到这些钩子上。<br> 当构建流程执行到对应阶段时，Webpack 会调用 plugin 提供的回调，从而让 plugin 有机会读取、修改或新增构建过程中的数据。</p><p>从实现角度看，一个 plugin 本质上是一个带有 apply 方法的对象，Webpack 会在启动阶段调用这个 apply 方法，并传入 compiler 对象，plugin 再通过 compiler 或 compilation 上的钩子介入构建。</p><hr><h3 id="面试题：常见的-plugin-有哪些？分别解决什么问题？"><a href="#面试题：常见的-plugin-有哪些？分别解决什么问题？" class="headerlink" title="面试题：常见的 plugin 有哪些？分别解决什么问题？"></a>面试题：常见的 plugin 有哪些？分别解决什么问题？</h3><p><strong>口述回答模板：</strong></p><p>在实际项目中，常见的 plugin 往往围绕构建优化和工程能力展开。</p><p>比如 HtmlWebpackPlugin 用于根据模板自动生成 HTML 文件，并注入打包后的资源；<br> DefinePlugin 用于在构建阶段注入全局常量，常用于区分开发和生产环境；<br> MiniCssExtractPlugin 用于将 CSS 从 JS 中抽离成独立文件；<br> CleanWebpackPlugin 用于在每次构建前清理输出目录；<br> CopyWebpackPlugin 用于拷贝静态资源；<br> BundleAnalyzerPlugin 用于分析打包结果，帮助优化体积。</p><p>这些 plugin 的共同特点是：它们并不关心单个文件内容，而是关注整个构建产物和流程。</p><hr><h3 id="面试题：什么时候应该写-plugin，而不是-loader？"><a href="#面试题：什么时候应该写-plugin，而不是-loader？" class="headerlink" title="面试题：什么时候应该写 plugin，而不是 loader？"></a>面试题：什么时候应该写 plugin，而不是 loader？</h3><p><strong>口述回答模板：</strong></p><p>当需求只是“如何处理某一类文件”时，应该使用 loader；<br> 当需求涉及“构建流程控制、资源生成、全局注入、打包结果处理”时，就必须使用 plugin。</p><p>比如：<br> 编译一种新语法用 loader；<br> 根据打包结果生成文件、统计信息或优化策略，就需要 plugin。</p><h3 id="面试题：你对-Babel-的理解是什么？它解决了什么问题？"><a href="#面试题：你对-Babel-的理解是什么？它解决了什么问题？" class="headerlink" title="面试题：你对 Babel 的理解是什么？它解决了什么问题？"></a>面试题：你对 Babel 的理解是什么？它解决了什么问题？</h3><p><strong>口述回答模板：</strong></p><p>Babel 是一个 JavaScript 编译器，核心作用是把<strong>高版本或非标准的 JavaScript 语法，转换成兼容性更好的 JavaScript</strong>，从而让代码能够在更多浏览器和运行环境中正常运行。</p><p>在前端工程中，我们希望使用最新的语言特性来提升开发效率和代码可读性，但实际运行环境可能并不支持这些新语法。Babel 的价值就在于把“开发阶段的现代语法”和“运行阶段的兼容代码”解耦，让开发体验和兼容性可以同时兼顾。</p><hr><h3 id="面试题：Babel-的工作原理是怎样的？"><a href="#面试题：Babel-的工作原理是怎样的？" class="headerlink" title="面试题：Babel 的工作原理是怎样的？"></a>面试题：Babel 的工作原理是怎样的？</h3><p><strong>口述回答模板：</strong></p><p>Babel 的编译过程可以概括为三个阶段：解析、转换和生成。</p><p>首先是解析阶段，Babel 会把源代码解析成抽象语法树，也就是 AST；<br> 接着是转换阶段，通过一系列插件对 AST 进行遍历和修改，把新语法结构转换成旧语法对应的 AST 结构；<br> 最后是生成阶段，根据修改后的 AST 重新生成目标 JavaScript 代码。</p><p>理解这三步非常重要，因为 Babel 的所有能力，本质上都是在“如何分析和修改 AST”。</p><h3 id="面试题：什么是-Webpack-的热加载？它解决了什么问题？"><a href="#面试题：什么是-Webpack-的热加载？它解决了什么问题？" class="headerlink" title="面试题：什么是 Webpack 的热加载？它解决了什么问题？"></a>面试题：什么是 Webpack 的热加载？它解决了什么问题？</h3><p><strong>口述回答模板：</strong></p><p>Webpack 的热加载，通常指的是 <strong>Hot Module Replacement，也就是 HMR</strong>。<br> 它的核心作用是在开发环境中，<strong>当模块代码发生变化时，只替换发生变化的模块，而不是刷新整个页面</strong>。</p><p>在没有热加载的情况下，代码一改动，浏览器就会整体刷新页面，应用状态会全部丢失，比如表单输入、滚动位置、组件内部状态等，这会严重影响开发效率。<br> 而 HMR 的目标是：<strong>尽量保留页面当前状态，只更新必要的代码</strong>，让开发反馈更快、更接近真实交互。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">webpack serve<br></code></pre></td></tr></table></figure><hr><h3 id="面试题：Webpack-热加载的工作原理是什么？"><a href="#面试题：Webpack-热加载的工作原理是什么？" class="headerlink" title="面试题：Webpack 热加载的工作原理是什么？"></a>面试题：Webpack 热加载的工作原理是什么？</h3><p><strong>口述回答模板：</strong></p><p>Webpack 热加载的本质是：<strong>构建阶段 + 浏览器运行时之间的一套模块替换机制</strong>。</p><p>在开发模式下，Webpack 会启动一个开发服务器，并在构建时为每个模块维护依赖关系。当某个模块的源码发生变化时，Webpack 会重新编译这个模块以及它受影响的依赖，而不是重新打包整个应用。</p><p>编译完成后，开发服务器通过 WebSocket 等方式，把“模块更新信息”推送给浏览器。<br> 浏览器端的 HMR runtime 会根据这些信息，找到对应的旧模块，并尝试用新模块进行替换。</p><p>如果模块本身或它的父模块<strong>显式接受这次更新</strong>，那么替换就会成功，页面不会刷新；<br> 如果没有任何模块能接受更新，Webpack 才会退化为整页刷新。</p><h3 id="面试题：Webpack-是如何优化前端性能的？"><a href="#面试题：Webpack-是如何优化前端性能的？" class="headerlink" title="面试题：Webpack 是如何优化前端性能的？"></a>面试题：Webpack 是如何优化前端性能的？</h3><p><strong>口述回答模板：</strong></p><p>Webpack 对前端性能的优化，本质上发生在<strong>构建阶段</strong>，目标是生成<strong>体积更小、加载更快、执行更高效</strong>的资源，从而提升页面加载和运行性能。</p><p>首先是<strong>代码体积层面的优化</strong>。<br> Webpack 通过生产模式下的压缩与 Tree Shaking，移除未使用的代码，减少最终 bundle 的体积。<br> Tree Shaking 基于 ES Module 的静态分析能力，只保留真正被引用的导出，这对第三方库和工具函数的体积优化非常关键。</p><p>其次是<strong>代码拆分和按需加载</strong>。<br> Webpack 支持 Code Splitting，可以把应用拆成多个 chunk，把首屏不需要的代码延后加载。<br> 典型场景包括路由懒加载、组件异步加载等，这能显著降低首屏 JS 体积，提升首屏渲染速度。</p><p>第三是<strong>缓存友好的构建策略</strong>。<br> Webpack 可以通过内容哈希来为资源生成稳定的文件名，当代码不变时文件名不变，浏览器就能命中缓存。<br> 同时通过拆分 runtime、vendor 和业务代码，可以避免一次小改动导致整个 bundle 失效，提高长期缓存命中率。</p><p>第四是<strong>资源处理与加载优化</strong>。<br> Webpack 可以压缩图片、抽离 CSS、合并和优化静态资源，并结合 preload、prefetch 等机制，合理控制资源加载的优先级，让关键资源更早加载，非关键资源延后加载。</p><p>第五是<strong>构建效率和开发体验的间接优化</strong>。<br> 在开发阶段，通过 HMR 热更新、缓存 loader 结果、多进程打包等方式，减少构建等待时间，提高开发效率，从而加快迭代节奏，这虽然不直接影响线上性能，但对整体工程效率非常重要。</p><p>最后，通过 <strong>构建结果分析工具</strong>，比如分析 bundle 体积和依赖结构，持续发现性能瓶颈，形成性能优化的闭环。</p><h3 id="面试题：在-Webpack-中，module、chunk、bundle-分别是什么？它们之间是什么关系？"><a href="#面试题：在-Webpack-中，module、chunk、bundle-分别是什么？它们之间是什么关系？" class="headerlink" title="面试题：在 Webpack 中，module、chunk、bundle 分别是什么？它们之间是什么关系？"></a>面试题：在 Webpack 中，module、chunk、bundle 分别是什么？它们之间是什么关系？</h3><p><strong>口述回答模板：</strong></p><p>在 Webpack 中，module、chunk 和 bundle 是三个不同层级的概念，分别对应<strong>源码层、构建层和产物层</strong>。</p><p>首先是 <strong>module</strong>。<br> module 是 Webpack 能处理的最小单元，本质上就是“模块”。<br> 在项目中，一个 JS 文件、一个 CSS 文件、一张图片，经过 loader 处理后，都会被当作一个 module。<br> module 关注的是<strong>源码层面的依赖关系</strong>，也就是谁 import 了谁，谁依赖了谁。</p><p>接下来是 <strong>chunk</strong>。<br> chunk 是 Webpack 在<strong>构建过程中</strong>，根据模块依赖关系和代码拆分规则，把多个 module 组合在一起形成的一个中间产物。<br> chunk 并不是最终输出的文件，而是 Webpack 用来做打包、拆分、优化的逻辑单位。<br> 比如入口 chunk、异步 chunk、vendor chunk，本质上都是由一组 module 组成的。</p><p>最后是 <strong>bundle</strong>。<br> bundle 是 Webpack <strong>最终输出到磁盘上的文件</strong>，也就是浏览器真正加载的 JS 或 CSS 文件。<br> 通常情况下，一个 chunk 会对应生成一个或多个 bundle 文件，但 bundle 一定是构建完成后的结果。</p><hr><h3 id="面试题：chunk-是什么时候产生的？由什么决定？"><a href="#面试题：chunk-是什么时候产生的？由什么决定？" class="headerlink" title="面试题：chunk 是什么时候产生的？由什么决定？"></a>面试题：chunk 是什么时候产生的？由什么决定？</h3><p><strong>口述回答模板：</strong></p><p>chunk 是在 Webpack 构建阶段产生的。<br> 它的生成规则由入口配置、动态 import、代码拆分策略以及优化配置共同决定。</p><p>比如：<br> 每一个 entry 默认会生成一个入口 chunk；<br> 通过动态 import 引入的模块，会生成异步 chunk；<br> 通过 splitChunks 配置，Webpack 还可以把公共模块抽成独立的 chunk。</p><p>因此，chunk 是 Webpack 做性能优化和代码拆分的核心载体。</p><hr><h3 id="面试题：bundle-和-chunk-是一一对应的吗？"><a href="#面试题：bundle-和-chunk-是一一对应的吗？" class="headerlink" title="面试题：bundle 和 chunk 是一一对应的吗？"></a>面试题：bundle 和 chunk 是一一对应的吗？</h3><p><strong>口述回答模板：</strong></p><p>在大多数情况下，一个 chunk 会对应一个 bundle 文件，但并不是绝对的一一对应。</p><p>比如在开启 CSS 抽离时，一个 chunk 可能会同时生成 JS bundle 和 CSS bundle；<br> 在某些优化场景下，也可能出现多个 chunk 合并成一个 bundle 的情况。</p><p>所以更准确地说是：<br> <strong>chunk 决定了“逻辑拆分”，bundle 决定了“物理输出”。</strong></p><h3 id="面试题：单页应用是一个-bundle-还是多个-chunk？"><a href="#面试题：单页应用是一个-bundle-还是多个-chunk？" class="headerlink" title="面试题：单页应用是一个 bundle 还是多个 chunk？"></a>面试题：单页应用是一个 bundle 还是多个 chunk？</h3><p><strong>口述回答模板：</strong></p><p>单页应用在概念上是“一个应用、一个入口页面”，但在构建结果上，<strong>并不等于只有一个 bundle</strong>。<br> 更准确地说，<strong>单页应用通常是：一个入口 + 多个 chunk + 多个 bundle</strong>。</p><p>从 Webpack 的角度看，单页应用通常只有一个入口 entry，这个入口会生成一个入口 chunk。<br> 如果不做任何优化，所有代码都会被打进这个入口 chunk，最终输出一个 bundle，这种情况确实是“一个 SPA 一个 bundle”。</p><p>但在实际工程中，为了性能优化，单页应用几乎一定会做<strong>代码拆分</strong>。<br> 比如路由懒加载、组件异步加载、第三方库拆分，这些都会让 Webpack 在构建阶段生成<strong>多个 chunk</strong>。</p><p>这些 chunk 在输出阶段会对应生成多个 bundle 文件，浏览器会根据需要按需加载。<br> 因此，大多数现代单页应用在运行时，页面初始只加载必要的 bundle，后续再动态加载其他 bundle。</p><h3 id="面试题：什么是-Vite？它解决了什么问题？"><a href="#面试题：什么是-Vite？它解决了什么问题？" class="headerlink" title="面试题：什么是 Vite？它解决了什么问题？"></a>面试题：什么是 Vite？它解决了什么问题？</h3><p><strong>口述回答模板：</strong></p><p>Vite 是一个现代前端构建工具，核心目标是<strong>大幅提升开发阶段的启动速度和更新速度</strong>。<br> 它的名字来源于法语，意思是“快”，这也正是它设计的出发点。</p><p>在传统构建工具中，比如 Webpack，开发服务器启动前需要先把整个项目打包成 bundle，项目越大，启动和热更新就越慢。<br> Vite 的创新点在于：<strong>在开发阶段不做整体打包，而是基于浏览器原生 ES Module 的能力，按需加载源码</strong>。</p><p>因此，Vite 把“开发体验”和“生产构建”这两个阶段彻底拆开，分别采用最适合的技术方案。</p><hr><h3 id="面试题：Vite-的核心工作原理是什么？"><a href="#面试题：Vite-的核心工作原理是什么？" class="headerlink" title="面试题：Vite 的核心工作原理是什么？"></a>面试题：Vite 的核心工作原理是什么？</h3><p><strong>口述回答模板：</strong></p><p>在开发环境下，Vite 并不会先打包整个应用。<br> 它启动的是一个基于原生 ESM 的开发服务器，当浏览器请求某个模块时，Vite 才即时编译并返回这个模块。</p><p>这种方式让冷启动速度几乎只和“启动服务器”有关，而和项目体积关系不大。<br> 当代码发生变化时，Vite 只需要重新处理被修改的模块，并通过模块级别的热更新推送给浏览器，更新速度非常快。</p><p>而在生产环境中，Vite 并不会自己造轮子，而是使用成熟的打包工具来完成构建，确保输出的代码体积和性能。</p><hr><h3 id="面试题：Vite-和-Webpack-的核心区别是什么？"><a href="#面试题：Vite-和-Webpack-的核心区别是什么？" class="headerlink" title="面试题：Vite 和 Webpack 的核心区别是什么？"></a>面试题：Vite 和 Webpack 的核心区别是什么？</h3><p><strong>口述回答模板：</strong></p><p>Vite 和 Webpack 的最大区别在于<strong>开发阶段的构建模型不同</strong>。</p><p>Webpack 在开发和生产阶段，都是以“打包”为核心思路；<br> Vite 在开发阶段是“按需编译 + 原生 ESM”，在生产阶段才进行完整打包。</p><p>这也是为什么在大型项目中，Vite 的启动速度和热更新体验明显优于传统打包工具，而在生产构建质量上又能保持可靠性。</p><hr><h3 id="面试题：Vite-为什么热更新这么快？"><a href="#面试题：Vite-为什么热更新这么快？" class="headerlink" title="面试题：Vite 为什么热更新这么快？"></a>面试题：Vite 为什么热更新这么快？</h3><p><strong>口述回答模板：</strong></p><p>Vite 的热更新是<strong>基于 ES Module 的模块级更新</strong>，而不是 bundle 级别的更新。</p><p>当一个模块发生变化时，Vite 只会重新编译这个模块，并通知浏览器精确更新对应的依赖关系，而不是重新生成整个依赖图。<br> 这种“最小更新单元”的设计，使得热更新的耗时几乎与项目规模无关。</p><h3 id="面试题：vite完整流程"><a href="#面试题：vite完整流程" class="headerlink" title="面试题：vite完整流程"></a>面试题：vite完整流程</h3><h4 id="【完整请求链路】"><a href="#【完整请求链路】" class="headerlink" title="【完整请求链路】"></a>【完整请求链路】</h4><p>假设入口是 <code>index.html</code>，其中有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器的行为与 Vite 的行为按时间顺序是：</p><ol><li>浏览器请求 <code>GET /index.html</code><ul><li>Vite 返回 HTML</li><li>同时会在 HTML 中注入 HMR 客户端脚本（用于热更新通信）</li></ul></li><li>浏览器看到 <code>&lt;script type=&quot;module&quot; src=&quot;/src/main.ts&quot;&gt;</code><ul><li>请求 <code>GET /src/main.ts</code></li></ul></li><li>Vite 收到 <code>/src/main.ts</code> 请求<ul><li>如果是 TS：用 esbuild 做快速转译成 JS（不做类型检查）</li><li>如果里面有 import：Vite 会把 import 路径改写成浏览器可请求的 URL 形式（重要）</li><li>返回转译后的 JS 给浏览器</li></ul></li><li>浏览器执行并解析 import，例如：<ul><li><code>import App from &#39;./App.vue&#39;</code> → 浏览器会请求 <code>GET /src/App.vue</code></li><li><code>import &#123; createApp &#125; from &#39;vue&#39;</code> → 浏览器会请求一个被改写后的依赖地址（通常带 <code>/@modules/</code> 或 <code>/node_modules/.vite/deps/...</code> 的形式，取决于版本与实现）</li></ul></li><li>Vite 针对不同资源类型做不同处理并返回<ul><li><code>.vue</code>：走 Vue 插件，把 SFC 拆成多个虚拟模块（template&#x2F;script&#x2F;style），再分别返回</li><li><code>.css</code>：转换成 JS 模块（用于插入样式或 CSS Modules 处理），并建立 HMR 依赖</li><li>图片字体等：返回 URL 或内联数据（取决于大小与配置）</li><li>第三方依赖：优先走“依赖预构建”后的产物（下面详讲）</li></ul></li><li>浏览器继续递归请求所有 import 依赖<ul><li>Vite 继续按需编译与返回</li><li>没有“全量打包”这一步</li></ul></li></ol><p>这就是 Vite 开发阶段启动快的根源：<strong>启动时不需要扫描整个项目并生成 bundle，只要起服务即可。</strong></p><h3 id="面试题：Vite-是如何处理各种前端资源的？"><a href="#面试题：Vite-是如何处理各种前端资源的？" class="headerlink" title="面试题：Vite 是如何处理各种前端资源的？"></a>面试题：Vite 是如何处理各种前端资源的？</h3><p><strong>口述回答模板：</strong></p><p>Vite 对资源的处理核心思路是：<strong>开发阶段尽量不打包、按需处理；生产阶段再统一打包和优化</strong>。<br> 不同类型的资源，在这两个阶段的处理方式是不同的。</p><p>在<strong>开发阶段</strong>，Vite 基于浏览器原生 ES Module。<br> JavaScript 和 TypeScript 源码会在浏览器请求时被即时编译并返回，而不是提前打包成 bundle。<br> 对于 TypeScript，Vite 只做语法层面的转译，不做类型检查，从而保证启动和更新速度。</p><p>对于 <strong>CSS 资源</strong>，Vite 会把 CSS 当作模块处理。<br> 浏览器请求到 CSS 时，Vite 会直接返回编译后的 CSS，并通过 HMR 实现样式的局部热更新，更新时不会刷新页面，也不会丢失应用状态。<br> 预处理器如 Sass、Less 会在请求时被即时编译成 CSS。</p><p>对于 <strong>图片、字体等静态资源</strong>，Vite 会把它们当作 URL 模块来处理。<br> 在开发阶段，资源通常以原始路径或带 hash 的 URL 形式被引用，不做复杂的合并和压缩，保证请求链路简单、调试友好。</p><p>对于 <strong>JSON 等非   JS 资源</strong>，Vite 会自动将其转换成 ES Module，让它们可以被直接 import 使用。</p><p>当进入<strong>生产构建阶段</strong>时，Vite 会把整个项目交给底层的打包器进行统一处理。<br> 这一步会完成代码压缩、Tree Shaking、资源合并、代码拆分、hash 命名、CSS 抽离等优化操作，生成适合线上部署的 bundle 产物。</p><p>因此可以总结为：<br> 开发阶段，Vite 更像是一个“按需编译的资源服务器”；<br> 生产阶段，Vite 才真正完成“构建和打包”的工作。</p>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue核心面试题</title>
    <link href="/2025/12/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E6%A0%B8%E5%BF%83%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/12/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E6%A0%B8%E5%BF%83%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="Vue-和-React的核心区别是什么？"><a href="#Vue-和-React的核心区别是什么？" class="headerlink" title="Vue 和 React的核心区别是什么？"></a>Vue 和 React的核心区别是什么？</h2><blockquote><p>Vue 和 React 的核心区别主要在<strong>定位和设计理念</strong>上。</p><p><strong>Vue 更偏向一个完整框架</strong>，官方提供了比较完善的解决方案，比如路由、状态管理等，上手成本低、开发规范统一，比较适合快速开发和团队协作。</p><p><strong>React 更偏向一个视图库</strong>，主要负责 UI 渲染，其它能力需要开发者自行选择和组合，灵活性更高，但对工程能力要求也更高。</p><p>从使用感受上看，Vue 对初学者更友好，React 更适合大型、长期维护的复杂项目。</p></blockquote><img src="/2025/12/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue%E6%A0%B8%E5%BF%83%E9%9D%A2%E8%AF%95%E9%A2%98/image-20260109160505657.png" class title="image-20260109160505657"><h2 id="面试题：介绍一下-Vue-的生命周期"><a href="#面试题：介绍一下-Vue-的生命周期" class="headerlink" title="面试题：介绍一下 Vue 的生命周期"></a>面试题：介绍一下 Vue 的生命周期</h2><p><strong>口述回答模板：</strong></p><p>Vue 的生命周期指的是：<strong>一个组件从创建、挂载、更新到销毁的完整过程</strong>。<br> Vue 在这个过程中，在关键阶段暴露了一系列生命周期钩子，让开发者可以在合适的时机执行逻辑，比如初始化数据、发起请求、操作 DOM、清理副作用等。</p><p>从整体上看，Vue 的生命周期可以分为四个阶段：<strong>创建、挂载、更新和销毁</strong>。</p><hr><p>在<strong>创建阶段</strong>，组件实例刚被创建，但 DOM 还没有生成。<br> 这个阶段的特点是：<strong>数据已经初始化，但还不能访问真实 DOM</strong>。<br> 通常在这里做一些与 DOM 无关的初始化工作，比如初始化数据结构、读取本地缓存、设置定时器配置等。</p><hr><p>接下来是<strong>挂载阶段</strong>。<br> 在这个阶段，Vue 会把模板编译成真实 DOM，并挂载到页面中。<br> 当组件真正挂载完成后，就可以安全地访问和操作 DOM 了。<br> 因此，涉及 DOM 读取、第三方库初始化、依赖页面结构的逻辑，通常都放在挂载完成之后执行。</p><hr><p>第三个阶段是<strong>更新阶段</strong>。<br> 当组件的响应式数据发生变化时，Vue 会触发重新渲染流程。<br> 在更新前和更新后，Vue 都提供了对应的生命周期钩子，让我们可以在数据变化前后做一些处理，比如对比新旧数据、在更新后获取最新的 DOM 状态等。</p><p>需要注意的是，这个阶段可能会被多次触发，因此不适合在这里做高成本或一次性的逻辑。</p><hr><p>最后是<strong>销毁阶段</strong>。<br> 当组件从页面中被移除时，会进入销毁流程。<br> 在这个阶段，Vue 会解绑事件、停止响应式追踪，并释放资源。<br> 开发者需要在这里手动清理一些副作用，比如定时器、全局事件监听、订阅关系等，防止内存泄漏。</p><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="二、面试题一：什么是-Vue-的响应式原理？"><a href="#二、面试题一：什么是-Vue-的响应式原理？" class="headerlink" title="二、面试题一：什么是 Vue 的响应式原理？"></a>二、面试题一：什么是 Vue 的响应式原理？</h3><p><strong>口述回答模板：</strong></p><p>Vue 的响应式原理指的是：<strong>当数据层的状态发生变化时，框架能够自动感知这个变化，并驱动视图层进行更新，而不需要开发者手动操作 DOM</strong>。</p><p>从整体模型来看，它体现的是一种数据驱动视图的思想，也就是 Model 变化 → View 自动更新。<br> Vue 在中间做的事情，是建立数据和视图之间的依赖关系，并在数据变化时，精准通知相关视图进行更新。</p><hr><h3 id="三、面试题二：Vue-响应式的核心思想是什么？"><a href="#三、面试题二：Vue-响应式的核心思想是什么？" class="headerlink" title="三、面试题二：Vue 响应式的核心思想是什么？"></a>三、面试题二：Vue 响应式的核心思想是什么？</h3><p><strong>口述回答模板：</strong></p><p>Vue 响应式的核心思想可以概括为两点：<strong>数据劫持 + 依赖收集与派发更新</strong>。</p><p>数据劫持负责“感知变化”，也就是在数据被读取或修改时能够被拦截；<br> 依赖收集和派发更新负责“通知变化”，也就是知道哪些地方用到了这个数据，并在数据变化时通知它们重新执行。</p><p>这套机制保证了 Vue 能做到<strong>精确更新，而不是全量刷新视图</strong>。</p><hr><h3 id="四、面试题三：Vue-2-的响应式原理是如何实现的？"><a href="#四、面试题三：Vue-2-的响应式原理是如何实现的？" class="headerlink" title="四、面试题三：Vue 2 的响应式原理是如何实现的？"></a>四、面试题三：Vue 2 的响应式原理是如何实现的？</h3><p><strong>口述回答模板：</strong></p><p>在 Vue 2 中，响应式是通过 <code>Object.defineProperty</code> 来实现的。</p><p>Vue 会在初始化阶段，遍历 data 中的每一个属性，为它们定义 getter 和 setter。<br> 当属性被读取时，会触发 getter，在 getter 中完成<strong>依赖收集</strong>，把当前使用这个数据的 Watcher 记录下来；<br> 当属性被修改时，会触发 setter，在 setter 中进行<strong>派发更新</strong>，通知所有依赖这个数据的 Watcher 重新执行，从而触发视图更新。</p><p>在渲染过程中，模板中用到的数据都会触发 getter，因此 Vue 能自动建立“数据 → Watcher → 视图”的依赖关系。</p><hr><h3 id="五、面试题四：Vue-2-响应式有什么缺陷？为什么？"><a href="#五、面试题四：Vue-2-响应式有什么缺陷？为什么？" class="headerlink" title="五、面试题四：Vue 2 响应式有什么缺陷？为什么？"></a>五、面试题四：Vue 2 响应式有什么缺陷？为什么？</h3><p><strong>口述回答模板：</strong></p><p>Vue 2 响应式的缺陷，根源在于 <code>Object.defineProperty</code> 的能力限制。</p><p>首先，它只能拦截<strong>已经存在的属性</strong>，如果后续给对象新增或删除属性，是无法触发 getter 和 setter 的；<br> 其次，对于数组，它无法拦截通过索引直接赋值的行为，比如 <code>arr[0] = xxx</code>，因为这相当于新增属性。</p><p>因此在 Vue 2 中，需要通过特定 API，比如 <code>$set</code>，或者通过数组变异方法，来保证响应式更新。</p><hr><h3 id="六、面试题五：Vue-3-的响应式原理和-Vue-2-有什么不同？"><a href="#六、面试题五：Vue-3-的响应式原理和-Vue-2-有什么不同？" class="headerlink" title="六、面试题五：Vue 3 的响应式原理和 Vue 2 有什么不同？"></a>六、面试题五：Vue 3 的响应式原理和 Vue 2 有什么不同？</h3><p><strong>口述回答模板：</strong></p><p>Vue 3 在思想上和 Vue 2 是一致的，仍然是<strong>数据劫持 + 依赖收集 + 派发更新</strong>，但底层实现发生了变化。</p><p>Vue 3 使用的是 <code>Proxy</code> 和 <code>Reflect</code>，通过代理整个对象来拦截操作。<br> 由于 Proxy 是基于对象本身进行代理的，它可以天然拦截属性的读取、修改、新增和删除操作，因此彻底解决了 Vue 2 中新增属性和数组索引不响应的问题。</p><hr><h3 id="七、面试题六：Vue-3-的-Proxy-是深度代理吗？"><a href="#七、面试题六：Vue-3-的-Proxy-是深度代理吗？" class="headerlink" title="七、面试题六：Vue 3 的 Proxy 是深度代理吗？"></a>七、面试题六：Vue 3 的 Proxy 是深度代理吗？</h3><p><strong>口述回答模板：</strong></p><p>Vue 3 采用的是<strong>懒代理机制</strong>，而不是一次性递归代理所有嵌套对象。</p><p>也就是说，只有当访问某个嵌套对象时，Vue 才会在那一刻对它进行 Proxy 包装。<br> 这种设计可以显著减少初始化阶段的性能开销，同时保证访问到的对象一定是响应式的。</p><h2 id="Vue模板解析的过程"><a href="#Vue模板解析的过程" class="headerlink" title="Vue模板解析的过程"></a>Vue模板解析的过程</h2><h3 id="1-总览："><a href="#1-总览：" class="headerlink" title="1. 总览："></a>1. 总览：</h3><p>核心思想：**View &#x3D; f(state)**，Vue 用响应式系统知道“什么时候重新算 f”，用 VDOM+Diff 知道“怎么算得更省”。</p><hr><h3 id="2-Template-到-Render：Vue-编译做了什么"><a href="#2-Template-到-Render：Vue-编译做了什么" class="headerlink" title="2. Template 到 Render：Vue 编译做了什么"></a>2. Template 到 Render：Vue 编译做了什么</h3><h4 id="2-1-编译阶段的-3-步（Template-→-AST-→-Render）"><a href="#2-1-编译阶段的-3-步（Template-→-AST-→-Render）" class="headerlink" title="2.1 编译阶段的 3 步（Template → AST → Render）"></a>2.1 编译阶段的 3 步（Template → AST → Render）</h4><ul><li><strong>Parse</strong>：把模板字符串解析成 <strong>AST（抽象语法树）</strong></li><li><strong>Optimize（Vue2 典型）</strong>：标记静态节点&#x2F;静态根（不依赖数据的部分）</li><li><strong>Generate</strong>：生成 <code>render()</code> 字符串代码，再 <code>new Function</code> 得到真正的 render 函数</li></ul><h4 id="2-2-render-大概长什么样（理解即可）"><a href="#2-2-render-大概长什么样（理解即可）" class="headerlink" title="2.2 render() 大概长什么样（理解即可）"></a>2.2 render() 大概长什么样（理解即可）</h4><p>render 的本质就是一堆 <code>_c()</code> &#x2F; <code>h()</code> 调用，返回 VNode：</p><ul><li>Vue2：<code>_c(&#39;div&#39;, data, children)</code> 生成 VNode</li><li>Vue3：<code>h(&#39;div&#39;, props, children)</code>（并且编译器会加很多 PatchFlag 做优化）</li></ul><p>你只要记住：<strong>模板不是直接渲染 DOM，而是先被编译成“创建 VNode 的函数”</strong>。</p><hr><h3 id="3-虚拟-DOM（VNode）到底是什么"><a href="#3-虚拟-DOM（VNode）到底是什么" class="headerlink" title="3. 虚拟 DOM（VNode）到底是什么"></a>3. 虚拟 DOM（VNode）到底是什么</h3><h4 id="3-1-VNode-的本质"><a href="#3-1-VNode-的本质" class="headerlink" title="3.1 VNode 的本质"></a>3.1 VNode 的本质</h4><p>VNode 是一个 JS 对象，描述真实 DOM 节点所需的信息，例如：</p><ul><li><code>tag</code>：标签名（div、span…）</li><li><code>data/props</code>：属性、事件、指令相关信息</li><li><code>children</code>：子 VNode 列表</li><li><code>text</code>：文本节点内容</li><li><code>key</code>：用于列表 Diff 的稳定标识</li><li><code>elm</code>：对应的真实 DOM 引用（patch 后才有）</li></ul><p>关键点：VNode 不是为了“比 DOM 快”，而是为了：</p><ul><li>把渲染过程抽象成<strong>可比较的数据结构</strong></li><li>让更新变成：<strong>比较两棵树 → 做最少 DOM 操作</strong></li></ul><h4 id="3-2-为什么不直接操作-DOM"><a href="#3-2-为什么不直接操作-DOM" class="headerlink" title="3.2 为什么不直接操作 DOM"></a>3.2 为什么不直接操作 DOM</h4><p>DOM 操作的成本不只在“读写慢”，更在：</p><ul><li>触发布局&#x2F;重排&#x2F;重绘的链式代价</li><li>操作不可控、难以批量合并<br> VDOM 的价值：<strong>把多次状态变化合并成一次批量更新</strong>（watcher 队列 + nextTick），并且用 Diff 限制 DOM 改动范围。</li></ul><hr><h3 id="4-首次渲染：VNode-如何变成真实-DOM"><a href="#4-首次渲染：VNode-如何变成真实-DOM" class="headerlink" title="4. 首次渲染：VNode 如何变成真实 DOM"></a>4. 首次渲染：VNode 如何变成真实 DOM</h3><p>首次渲染时，<code>oldVnode</code> 可能是一个真实 DOM 容器（挂载点），流程类似：</p><ol><li>执行 <code>render()</code> 得到 <code>vnode</code></li><li><code>patch(container, vnode)</code></li><li>patch 发现 old 是 DOM：走 <strong>createElm(vnode)</strong></li><li>递归创建子节点、设置属性、绑定事件、插入 DOM</li><li>保存 <code>vnode.elm</code> 指向真实节点，后续更新复用</li></ol><p>首次渲染没有 Diff 的“最小更新”意义，因为没有旧树可比，基本是“整棵树创建”。</p><hr><h3 id="5-响应式如何驱动更新（更新为什么会发生）"><a href="#5-响应式如何驱动更新（更新为什么会发生）" class="headerlink" title="5. 响应式如何驱动更新（更新为什么会发生）"></a>5. 响应式如何驱动更新（更新为什么会发生）</h3><h4 id="5-1-Vue2：Object-defineProperty（你面试常说这一套）"><a href="#5-1-Vue2：Object-defineProperty（你面试常说这一套）" class="headerlink" title="5.1 Vue2：Object.defineProperty（你面试常说这一套）"></a>5.1 Vue2：Object.defineProperty（你面试常说这一套）</h4><ul><li>每个响应式属性都有 getter&#x2F;setter</li><li><strong>getter</strong>：当前正在渲染的 watcher（渲染 watcher）会被收集进 dep</li><li><strong>setter</strong>：值变化 → dep.notify → watcher.update()</li></ul><h4 id="5-2-Vue3：Proxy（理解差异点即可）"><a href="#5-2-Vue3：Proxy（理解差异点即可）" class="headerlink" title="5.2 Vue3：Proxy（理解差异点即可）"></a>5.2 Vue3：Proxy（理解差异点即可）</h4><ul><li>Proxy 能拦截更多操作（新增&#x2F;删除属性、数组索引等）</li><li>依赖收集&#x2F;触发机制仍是：track（收集） &#x2F; trigger（触发）</li></ul><h4 id="5-3-watcher-队列与-nextTick：为什么不是立刻更新"><a href="#5-3-watcher-队列与-nextTick：为什么不是立刻更新" class="headerlink" title="5.3 watcher 队列与 nextTick：为什么不是立刻更新"></a>5.3 watcher 队列与 nextTick：为什么不是立刻更新</h4><p>数据可能在同一轮事件循环里被改很多次：</p><ul><li>Vue 会把 watcher <strong>去重入队</strong></li><li>在微任务&#x2F;宏任务合适时机统一 flush<br> 效果：<strong>一次 UI 更新覆盖多次状态变动</strong>，降低抖动与重复渲染成本。</li></ul><hr><h3 id="6-Diff：新旧-VNode-怎么比"><a href="#6-Diff：新旧-VNode-怎么比" class="headerlink" title="6. Diff：新旧 VNode 怎么比"></a>6. Diff：新旧 VNode 怎么比</h3><p>Diff 的目标不是“算出所有不同”，而是<strong>在可接受复杂度内找到足够好的最小变更</strong>。Vue 的 Diff 基于几个关键假设：</p><ul><li>同级节点（siblings）之间的比较是主要场景（不做跨层级的最优匹配）</li><li><strong>key 决定节点身份</strong>（尤其列表）</li><li>同一个 vnode 是否“同一个节点”，取决于 <code>sameVnode</code>（Vue2）&#x2F; 等价判断（Vue3）</li></ul><h4 id="6-1-sameVnode（判断是否能复用真实节点）"><a href="#6-1-sameVnode（判断是否能复用真实节点）" class="headerlink" title="6.1 sameVnode（判断是否能复用真实节点）"></a>6.1 sameVnode（判断是否能复用真实节点）</h4><p>典型判断维度：</p><ul><li><code>tag</code> 相同</li><li><code>key</code> 相同（很重要）</li><li>一些细节：是否是注释节点、输入类型等</li></ul><p>如果不是 sameVnode：直接替换（删除旧的，创建新的）<br> 如果是 sameVnode：复用 <code>elm</code>，进入<strong>精细对比</strong>（props&#x2F;text&#x2F;children）</p><hr><h3 id="7-Patch：Diff-之后怎么更新真实-DOM"><a href="#7-Patch：Diff-之后怎么更新真实-DOM" class="headerlink" title="7. Patch：Diff 之后怎么更新真实 DOM"></a>7. Patch：Diff 之后怎么更新真实 DOM</h3><p>Patch 做三类事：</p><ol><li><strong>更新节点自身</strong>：class&#x2F;style&#x2F;attrs&#x2F;domProps&#x2F;events</li><li><strong>更新文本节点</strong>：text 不同就改 <code>textContent</code></li><li><strong>更新子节点 children</strong>：最复杂，也最核心</li></ol><hr><h3 id="8-核心：列表-children-的-Diff（双端比较）"><a href="#8-核心：列表-children-的-Diff（双端比较）" class="headerlink" title="8. 核心：列表 children 的 Diff（双端比较）"></a>8. 核心：列表 children 的 Diff（双端比较）</h3><p>Vue2 的经典策略是 <strong>双端指针 + key 映射</strong>（能背出来就很稳）：</p><p>设旧 children：<code>oldStart ~ oldEnd</code><br> 新 children：<code>newStart ~ newEnd</code></p><p>循环比较四种命中（命中就移动指针并 patch）：</p><ol><li><code>oldStart</code> vs <code>newStart</code>：头头相同 → patch，指针都 +1</li><li><code>oldEnd</code> vs <code>newEnd</code>：尾尾相同 → patch，指针都 -1</li><li><code>oldStart</code> vs <code>newEnd</code>：旧头 &#x3D; 新尾 → patch，并把旧头对应 DOM <strong>移动到末尾</strong></li><li><code>oldEnd</code> vs <code>newStart</code>：旧尾 &#x3D; 新头 → patch，并把旧尾对应 DOM <strong>移动到开头</strong></li></ol><p>都不命中时：</p><ul><li>建一个 old 的 <code>key -&gt; index</code> 映射表</li><li>用 <code>newStart.key</code> 去找：<ul><li>找不到：说明是新增节点 → createElm 插入到合适位置</li><li>找到了：取出旧 vnode → patch → 把它对应 DOM 移动到 newStart 前 → 旧位置标记为空</li></ul></li></ul><p>循环结束后：</p><ul><li>新的还有剩：批量新增</li><li>旧的还有剩：批量删除</li></ul><p>你要传达的重点：</p><ul><li>Diff 主要优化的是<strong>同层列表重排</strong></li><li>key 的存在让“查找复用节点”变成 O(1) 级别</li><li>双端比较覆盖了大量头尾移动的高频场景</li></ul><hr><h3 id="9-key-为什么这么重要"><a href="#9-key-为什么这么重要" class="headerlink" title="9. key 为什么这么重要"></a>9. key 为什么这么重要</h3><h4 id="9-1-不加-key-的后果（或用-index-当-key）"><a href="#9-1-不加-key-的后果（或用-index-当-key）" class="headerlink" title="9.1 不加 key 的后果（或用 index 当 key）"></a>9.1 不加 key 的后果（或用 index 当 key）</h4><p>Vue 可能采用“就地复用”策略：按位置对齐 patch<br> 如果列表发生插入&#x2F;删除&#x2F;排序：</p><ul><li>DOM 节点会被错误复用到别的数据项上</li><li>表单输入、组件内部状态会串</li><li>造成性能浪费（本该移动，结果变成大量 patch）</li></ul><h4 id="9-2-正确的-key"><a href="#9-2-正确的-key" class="headerlink" title="9.2 正确的 key"></a>9.2 正确的 key</h4><ul><li>应该是<strong>稳定且唯一</strong>：如 id、业务唯一标识</li><li>不推荐用 index（除非列表不增删不重排、纯展示）</li></ul><hr><h3 id="10-从“改数据”到“页面更新”的口述闭环模板"><a href="#10-从“改数据”到“页面更新”的口述闭环模板" class="headerlink" title="10. 从“改数据”到“页面更新”的口述闭环模板"></a>10. 从“改数据”到“页面更新”的口述闭环模板</h3><ul><li>模板先被编译成 render 函数</li><li>首次渲染执行 render 得到 VNode 树，patch 把它变成真实 DOM</li><li>渲染过程中读取响应式数据会触发 getter，收集当前渲染 watcher</li><li>当数据修改触发 setter，会通知 watcher 入队，nextTick 批量刷新</li><li>刷新时重新执行 render 生成新 VNode，与旧 VNode 做 Diff</li><li>patch 把差异同步到真实 DOM，达到最小化更新</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【⭐】Vue Router面试题</title>
    <link href="/2025/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue-Router%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue-Router%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1）Vue-Router-的核心作用是什么？为什么需要它？"><a href="#1）Vue-Router-的核心作用是什么？为什么需要它？" class="headerlink" title="1）Vue Router 的核心作用是什么？为什么需要它？"></a>1）Vue Router 的核心作用是什么？为什么需要它？</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/#%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC">8.前端页面跳转 - 相</a></p></blockquote><p><strong>Vue Router 是 Vue 官方的前端路由管理工具，用于在单页应用（SPA）中实现 URL 与组件视图之间的映射关系。</strong></p><p>在 SPA 中，整个应用生命周期内浏览器只会加载一次 HTML，页面切换不再依赖浏览器向服务器请求新的 HTML，而是由前端 JavaScript 接管。</p><p>Vue Router 通过<strong>监听 URL 的变化</strong>（如 <code>history</code> 或 <code>hash</code>），根据配置好的路由规则进行匹配，并将匹配到的组件<strong>渲染到 <code>&lt;router-view&gt;</code> 容器中</strong>，从而完成页面切换，而不刷新整个页面。</p><p>同时，Vue Router 提供了<strong>路由守卫机制</strong>，可以在路由跳转的不同阶段做<strong>权限控制、登录校验和身份认证</strong>，这是大型前端应用中不可或缺的能力。</p><p><strong>总结来说，Vue Router 的核心价值是：让前端在 SPA 架构下具备“像多页应用一样清晰的页面结构和可控的页面流转”。</strong></p><p><strong>一句话版</strong></p><blockquote><p>Vue Router 的作用是：<strong>监听 URL 变化 → 匹配路由规则 → 切换组件视图，从而在 SPA 中实现页面级导航与权限控制。</strong></p></blockquote><hr><h2 id="为什么要使用-SPA（单页应用）？"><a href="#为什么要使用-SPA（单页应用）？" class="headerlink" title="为什么要使用 SPA（单页应用）？"></a>为什么要使用 SPA（单页应用）？</h2><p>使用 SPA 的核心原因是：<strong>提升用户体验、降低页面切换成本、并更好地支撑复杂前端应用。</strong></p><p>在传统多页应用（MPA）中，每一次页面跳转都会重新向服务器请求新的 HTML，原有页面会被销毁，浏览器需要重新解析 HTML、CSS 和 JS，切换成本高、体验不连贯。</p><p>SPA 的特点是<strong>整个应用生命周期只加载一次 HTML</strong>，之后的页面切换由前端 JavaScript 控制，通常只是组件的卸载与挂载或局部视图更新，不会刷新整页，因此切换更快、更流畅。</p><p>同时，SPA 天然适合复杂交互场景，例如后台管理系统、即时通信、数据可视化等，前后端可以彻底解耦，通过 API 进行数据通信。</p><p><strong>总结来说，SPA 用一次加载换取后续的高效切换和更好的交互体验，是现代复杂 Web 应用的主流形态。</strong>SPA 也有代价，比如首屏加载体积大、SEO 不友好，因此实际工程中通常会结合 <strong>代码分割、懒加载</strong></p><blockquote><p>SPA 的本质是用前端 JS 接管页面切换，用更少的网络请求换取更流畅、更可控的用户体验。</p></blockquote><h2 id="2）hash-模式和-history-模式有什么区别？怎么选？"><a href="#2）hash-模式和-history-模式有什么区别？怎么选？" class="headerlink" title="2）hash 模式和 history 模式有什么区别？怎么选？"></a>2）hash 模式和 history 模式有什么区别？怎么选？</h2><p><strong>回答模板</strong><br> Vue Router 常见两种模式：</p><ul><li>hash：URL 带 <code>#</code>，依赖 <code>hashchange</code>，不需要服务端配合；刷新不会 404。</li><li>history：URL 干净，依赖 <code>popstate</code>，需要服务端把所有路由都回退到同一个 <code>index.html</code>，否则刷新会 404。</li></ul><p>选择上：</p><ul><li>内网、静态部署、无法改服务端规则：优先 hash</li><li>正式站点、SEO&#x2F;URL 美观、能配服务端 rewrite：优先 history</li></ul><p><strong>要点</strong></p><ul><li>history 必须配 rewrite（Nginx&#x2F;Apache&#x2F;Node）</li><li>hash 兼容性好但 URL 不够美观</li><li>两者都能做 SPA 路由，只是地址机制不同</li></ul><hr><h2 id="3）路由的完整导航过程是怎样的？"><a href="#3）路由的完整导航过程是怎样的？" class="headerlink" title="3）路由的完整导航过程是怎样的？"></a>3）路由的完整导航过程是怎样的？</h2><p>Vue Router 的一次完整导航过程可以概括为：<br> <strong>触发导航 → 路由匹配 → 执行守卫 → 确认导航 → 组件渲染与更新。</strong></p><p>当调用 <code>router.push</code>、点击 <code>&lt;router-link&gt;</code> 或浏览器前进后退时，会触发一次导航。<br> Router 会根据目标 URL 进行路由匹配，生成 <code>to.matched</code> 路由记录。</p><p>接着按顺序执行 **全局前置守卫 → 路由独享守卫 → 组件内 <code>beforeRouteEnter</code>**，<br> 所有守卫通过后确认导航，更新地址栏。</p><p>最后销毁旧组件、创建新组件并渲染到 <code>&lt;router-view&gt;</code> 中，<br> 组件挂载完成后触发 <code>beforeRouteEnter</code> 中的 <code>next(vm =&gt; &#123;&#125;)</code> 以及 <code>afterEach</code> 钩子。</p><blockquote><p>Vue Router 的导航流程本质是：<br> <strong>先根据 URL 生成 matched 路由记录，再按顺序执行守卫确认导航，最后根据 matched 结果复用或重建组件并完成视图渲染。</strong></p></blockquote><h3 id="导航在哪一步真正改变-URL？"><a href="#导航在哪一步真正改变-URL？" class="headerlink" title="导航在哪一步真正改变 URL？"></a>导航在哪一步真正改变 URL？</h3><blockquote><p>在所有守卫通过后的 <strong>导航确认阶段</strong>。</p></blockquote><hr><h2 id="4）router-push-replace-go-有什么区别？"><a href="#4）router-push-replace-go-有什么区别？" class="headerlink" title="4）router.push &#x2F; replace &#x2F; go 有什么区别？"></a>4）router.push &#x2F; replace &#x2F; go 有什么区别？</h2><p><strong>回答模板</strong></p><ul><li><code>push</code>：新增一条历史记录，用户可以回退到上一页</li><li><code>replace</code>：替换当前历史记录，用户回退不会回到替换前</li><li><code>go(n)</code>：在历史栈中前进&#x2F;后退 n 步，等价于 <code>history.go(n)</code></li></ul><p><strong>要点</strong></p><ul><li>典型场景：登录成功跳转用 <code>replace</code>（避免回到登录页）</li><li>列表到详情用 <code>push</code>（允许回退到列表）</li></ul><hr><h2 id="5）声明式导航-和编程式导航有什么差别？"><a href="#5）声明式导航-和编程式导航有什么差别？" class="headerlink" title="5）声明式导航 &lt;router-link&gt; 和编程式导航有什么差别？"></a>5）声明式导航 <code>&lt;router-link&gt;</code> 和编程式导航有什么差别？</h2><p><strong>回答模板</strong><br> <code>&lt;router-link&gt;</code> 是声明式，适合纯跳转场景，语义清晰且自带 active 状态；编程式（<code>router.push/replace</code>）适合在业务逻辑完成后跳转，比如登录校验通过、提交表单成功后跳转、点击行触发携带参数跳转等。</p><p><code>active-class</code> 用于自定义 router-link 在路由匹配时自动添加的激活类名，默认是 <code>router-link-active</code>，采用包含式匹配；如果需要严格匹配才高亮，则使用 <code>exact-active-class</code> 或全局的 <code>linkExactActiveClass</code>。</p><p><strong>要点</strong></p><ul><li>router-link 自动处理 active class</li><li>编程式更适合“先处理业务再跳转”</li></ul><hr><h2 id="6）params-和-query-的区别？什么时候用？"><a href="#6）params-和-query-的区别？什么时候用？" class="headerlink" title="6）params 和 query 的区别？什么时候用？"></a>6）params 和 query 的区别？什么时候用？</h2><p><strong>回答模板</strong></p><ul><li><p><strong>params 是路径参数</strong>，属于路由的一部分，通常通过动态路由声明，例如 <code>/user/:id</code>，参数缺失会导致路由无法匹配，更偏向“资源唯一标识”。</p></li><li><p><strong>query 是查询参数</strong>，表现为 URL 后的 <code>?key=value</code>，不影响路由匹配，可选性强，常用于筛选条件、分页、状态控制等。</p><p>简单来说：</p></li></ul><table><thead><tr><th>对比点</th><th>params</th><th>query</th></tr></thead><tbody><tr><td>URL 位置</td><td>路径中 <code>/user/123</code></td><td>查询串 <code>?page=1</code></td></tr><tr><td>是否影响路由匹配</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>是否必填</td><td>通常必填</td><td>可选</td></tr><tr><td>路由声明</td><td>需在 <code>path</code> 中声明</td><td>无需声明</td></tr><tr><td>语义</td><td>资源 &#x2F; 身份标识</td><td>条件 &#x2F; 状态</td></tr><tr><td>SEO 友好</td><td>更好</td><td>一般</td></tr><tr><td>刷新是否丢失</td><td>不丢</td><td>不丢</td></tr></tbody></table><p>实践上：</p><ul><li>资源主键&#x2F;必需标识：用 params</li><li>列表筛选、分页、排序：用 query</li><li>params 在刷新&#x2F;直达时更稳定（因为在 path 里），query 本身也稳定但语义不同</li></ul><p><strong>要点</strong></p><ul><li>params 需要 route 配置里有动态段 <code>:id</code>（或通过 name + params）</li><li>query 适合可选项与组合条件</li></ul><hr><h2 id="7）为什么有时-params-丢失？如何避免？"><a href="#7）为什么有时-params-丢失？如何避免？" class="headerlink" title="7）为什么有时 params 丢失？如何避免？"></a>7）为什么有时 params 丢失？如何避免？</h2><p><strong>回答模板</strong><br> 常见原因：用 <code>path</code> + <code>params</code> 组合跳转时，params 会被忽略。Vue Router 推荐：</p><ul><li>要传 params：用 <code>name</code> + <code>params</code></li><li>或直接把 params 写进 path</li></ul><p>举例：</p><ul><li>正确：<code>router.push(&#123; name: &#39;user&#39;, params: &#123; id: 1 &#125; &#125;)</code></li><li>风险：<code>router.push(&#123; path: &#39;/user&#39;, params: &#123; id: 1 &#125; &#125;)</code>（可能丢）</li></ul><p><strong>要点</strong></p><ul><li>params 依赖命名路由或动态 path</li><li>面试官在问你是否理解“路由生成规则”</li></ul><hr><h2 id="8）动态路由-id-如何拿到？路由变化如何监听？"><a href="#8）动态路由-id-如何拿到？路由变化如何监听？" class="headerlink" title="8）动态路由 :id 如何拿到？路由变化如何监听？"></a>8）动态路由 <code>:id</code> 如何拿到？路由变化如何监听？</h2><p><strong>回答模板</strong><br> 动态参数通过 <code>useRoute()</code>：</p><ul><li><code>route.params.id</code> 获取路径参数</li><li><code>route.query.xxx</code> 获取查询参数<br> 路由变化监听两种：<br> 1）监听 route：<code>watch(() =&gt; route.params.id, ...)</code><br> 2）组件复用场景用组件内守卫：<code>beforeRouteUpdate(to, from, next)</code> 来处理同组件不同参数的更新逻辑</li></ul><p><strong>要点</strong></p><ul><li>复用组件不会重新 mounted，需要自己处理参数变化</li><li>数据请求要跟参数变化绑定</li></ul><h2 id="当只有参数发生改变时，会有新的路由记录写入历史栈吗？"><a href="#当只有参数发生改变时，会有新的路由记录写入历史栈吗？" class="headerlink" title="当只有参数发生改变时，会有新的路由记录写入历史栈吗？"></a>当只有参数发生改变时，会有新的路由记录写入历史栈吗？</h2><p>结论先行（一句话版）</p><blockquote><p><strong>是否写入历史栈，取决于导航方式（push &#x2F; replace）以及参数是否导致 URL 发生变化，而不是取决于参数类型本身（params &#x2F; query）。</strong></p></blockquote><p>在 Vue Router 中，<strong>只要触发了一次导航，并且 URL 发生变化，默认就会向浏览器历史栈写入一条新的记录</strong>。</p><p>无论是 <code>params</code> 变化还是 <code>query</code> 变化，只要使用的是 <code>router.push</code>，并且生成的 URL 与当前不同，就会新增一条历史记录。</p><p>如果使用的是 <code>router.replace</code>，即使参数变化，也只会<strong>替换当前历史记录</strong>，不会新增。</p><p>因此，<strong>是否写入历史栈的关键不是“参数变没变”，而是“用了 push 还是 replace，以及 URL 是否真的变了”。</strong></p><blockquote><p><strong>Vue Router 的 match 是“每次导航都会做的事”</strong><br> 不管是 path &#x2F; params &#x2F; query<br> <strong>只要 URL 变化 → 就是一次新的导航 → 就会重新 match</strong></p></blockquote><hr><p>✅ 重新 match</p><p>✅ 全局守卫执行</p><p>❌ 组件不销毁</p><p>✅ 触发 <code>beforeRouteUpdate / watch</code></p><p>那为什么组件没重建？</p><p>因为 Vue Router 会在 <strong>match 完成后做 diff</strong>：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">new</span> matched vs <span class="hljs-keyword">old</span> matched<br></code></pre></td></tr></table></figure><ul><li>如果是<strong>同一个 RouteRecord</strong><ul><li>组件复用</li><li>不走创建生命周期</li></ul></li><li>但路由级流程已经完整走了一遍</li></ul><hr><h2 id="9）嵌套路由是什么？-如何工作？"><a href="#9）嵌套路由是什么？-如何工作？" class="headerlink" title="9）嵌套路由是什么？&lt;router-view&gt; 如何工作？"></a>9）嵌套路由是什么？<code>&lt;router-view&gt;</code> 如何工作？</h2><p><strong>回答模板</strong><br> 嵌套路由就是父子路由结构，父路由组件里放 <code>&lt;router-view&gt;</code> 作为子路由的渲染出口。匹配时会得到一条 <code>matched</code> 链，父组件先渲染，然后把子路由组件渲染到父组件的 <code>&lt;router-view&gt;</code> 中，实现“布局 + 内容区”的结构。</p><p><strong>要点</strong></p><ul><li>常用于 Layout：侧边栏&#x2F;头部固定，内容区变化</li><li><code>matched</code> 的层级关系就是嵌套层级</li></ul><hr><h2 id="10）什么是命名路由（name）？有什么优势？"><a href="#10）什么是命名路由（name）？有什么优势？" class="headerlink" title="10）什么是命名路由（name）？有什么优势？"></a>10）什么是命名路由（name）？有什么优势？</h2><p><strong>回答模板</strong><br> 命名路由给路由一个稳定标识。优势：<br> 1）跳转更稳定（path 改了只改配置，不改业务跳转）<br> 2）与 params 配合更可靠<br> 3）做权限映射、菜单生成更方便（以 name 作为 key）</p><p><strong>要点</strong></p><ul><li>大项目常用 name 做路由权限表、keepAlive include 等</li></ul><hr><h2 id="11）路由懒加载怎么做？有什么收益？"><a href="#11）路由懒加载怎么做？有什么收益？" class="headerlink" title="11）路由懒加载怎么做？有什么收益？"></a>11）路由懒加载怎么做？有什么收益？</h2><p><strong>回答模板</strong><br> 路由懒加载通常用动态 import：只有访问到该路由才加载对应 chunk。收益：</p><p>本质：<strong>代码分割（Code Splitting）+ 按需加载（On-Demand Loading）</strong>。</p><ul><li>首屏更快（减少初始 JS 体积）</li><li>按需加载（减少无用代码下载）</li><li>配合分包策略提升缓存命中</li></ul><p><strong>要点</strong></p><ul><li><code>() =&gt; import(&#39;...&#39;)</code></li><li>关注 chunk 拆分与预加载（prefetch&#x2F;preload）策略</li></ul><blockquote><p>路由懒加载是指将路由对应的页面组件通过 <code>import()</code> 动态加载，只有在路由被访问时才下载对应代码。<br> 这样可以显著减少首屏 JS 体积，提升首屏渲染和可交互时间，同时更利于大型项目的模块拆分和长期维护。<br> 实际项目中通常对页面级组件启用懒加载，并根据业务模块合理合并 chunk。</p></blockquote><hr><h2 id="什么是-Code-Splitting-Code-Splitting-和懒加载有什么区别"><a href="#什么是-Code-Splitting-Code-Splitting-和懒加载有什么区别" class="headerlink" title="什么是 Code Splitting Code Splitting 和懒加载有什么区别"></a>什么是 Code Splitting Code Splitting 和懒加载有什么区别</h2><p><strong>Code Splitting（代码分割）是一种前端性能优化手段，指的是把原本打包在一起的 JavaScript 拆分成多个按需加载的代码块，而不是一次性全部加载。</strong></p><p>它的核心目的，是<strong>降低首屏加载体积、提升首屏渲染速度</strong>。</p><p>在实际运行时，只有当用户访问某个页面或触发某个功能时，对应的代码才会被下载和执行。</p><p>在 Vue 项目中，最常见的应用场景是<strong>路由级懒加载和组件级懒加载</strong>，这是 SPA 项目中非常重要的性能优化手段。</p><blockquote><p>Code Splitting 是<strong>打包阶段的代码拆分策略</strong>，懒加载是<strong>运行时按需加载代码的行为</strong>，两者通常配合使用。</p><p>Code Splitting 是在构建阶段把代码拆成多个 chunk，懒加载是在运行时按需加载这些 chunk</p></blockquote><p>1️⃣ 路由级代码分割（最常见、最重要）</p><p><strong>使用场景：</strong></p><ul><li>多页面 SPA</li><li>后台管理系统</li><li>页面之间功能差异大</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const UserPage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/User.vue&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>不访问的页面，不下载对应 JS</li><li>首屏性能显著提升</li></ul><hr><p>2️⃣ 组件级代码分割（按功能加载）</p><p><strong>使用场景：</strong></p><ul><li>弹窗、抽屉、复杂表单</li><li>低频组件</li><li>重型组件（编辑器、图表）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Comp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Comp.vue&#x27;</span>),<br>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">Loading</span>,<br>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComp</span>,<br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><hr><blockquote><p><strong><code>defineAsyncComponent</code> 是 Vue 3 官方内置的异步组件 API，用于实现组件级懒加载和代码分割。</strong></p></blockquote><p>3️⃣ 第三方库拆分（减少首包体积）</p><p><strong>使用场景：</strong></p><ul><li>echarts、monaco-editor、three.js</li><li>只在部分页面使用的大型库</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadChart</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> echarts = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;echarts&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>4️⃣ 按业务模块拆分（大型项目）</p><p><strong>使用场景：</strong></p><ul><li>管理端 &#x2F; 用户端</li><li>不同角色功能完全不同</li><li>多系统集成</li></ul><p><strong>Code Splitting 在 Vue 项目中的典型落地方式</strong></p><p>路由懒加载（最常考）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/User.vue&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>组件懒加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./AsyncComp.vue&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><hr><h3 id="配合构建工具（Webpack-Vite）"><a href="#配合构建工具（Webpack-Vite）" class="headerlink" title="配合构建工具（Webpack &#x2F; Vite）"></a>配合构建工具（Webpack &#x2F; Vite）</h3><ul><li>Webpack：<code>import()</code> → 自动生成 chunk</li><li>Vite：ESM + 动态 import → 原生支持</li></ul><h2 id="12）导航守卫有哪些？分别适合做什么？"><a href="#12）导航守卫有哪些？分别适合做什么？" class="headerlink" title="12）导航守卫有哪些？分别适合做什么？"></a>12）导航守卫有哪些？分别适合做什么？</h2><p><strong>回答模板</strong><br> 守卫分三类：<br> 1）全局：<code>beforeEach / beforeResolve / afterEach</code><br> 2）路由独享：<code>beforeEnter</code><br> 3）组件内：<code>beforeRouteEnter / beforeRouteUpdate / beforeRouteLeave</code></p><p>应用：</p><ul><li>鉴权：beforeEach 判断 token&#x2F;权限，不通过则重定向</li><li>埋点：afterEach 上报 PV</li><li>离开确认：beforeRouteLeave 弹窗提示未保存</li><li>复用组件更新：beforeRouteUpdate 处理同组件不同参数</li></ul><p><strong>要点</strong></p><ul><li><code>beforeRouteEnter</code> 里拿不到 <code>this</code>（组件实例还未创建）</li><li>afterEach 不接收 next（它是确认后的回调）</li></ul><hr><h2 id="13）守卫里如何处理异步？如何避免导航卡死？"><a href="#13）守卫里如何处理异步？如何避免导航卡死？" class="headerlink" title="13）守卫里如何处理异步？如何避免导航卡死？"></a>13）守卫里如何处理异步？如何避免导航卡死？</h2><p><strong>回答模板</strong><br> 守卫里可以做异步，比如拉取用户信息、菜单权限。关键是：</p><ul><li>必须确保每条分支最终都放行或重定向（调用 next 或返回对应值，取决于版本写法）</li><li>异步要加超时&#x2F;错误处理，失败要有降级策略（跳登录&#x2F;提示）</li><li>避免重复重定向导致死循环（例如已在 login 还重定向 login）</li></ul><p><strong>要点</strong></p><ul><li>常见坑：漏掉放行导致页面不跳转</li><li>常见坑：权限不足重定向自己导致无限循环</li></ul><hr><h2 id="14）如何做“登录鉴权-动态路由-菜单权限”？"><a href="#14）如何做“登录鉴权-动态路由-菜单权限”？" class="headerlink" title="14）如何做“登录鉴权 + 动态路由 + 菜单权限”？"></a>14）如何做“登录鉴权 + 动态路由 + 菜单权限”？</h2><p><strong>回答模板</strong><br> 典型方案：<br> 1）登录后拿到 token，存本地（或内存+刷新恢复）<br> 2）路由守卫 beforeEach：</p><ul><li>无 token：只允许白名单（login）</li><li>有 token：如果用户信息&#x2F;权限未加载，则请求权限并生成可访问路由<br> 3）调用 <code>router.addRoute()</code> 动态注入路由（通常注入到 layout 子路由下）<br> 4）生成菜单数据（通常来自同一份权限路由表），渲染侧边栏<br> 5）访问未授权路由：跳 403 或重定向到首页</li></ul><p><strong>要点</strong></p><ul><li>动态路由注入必须在放行前完成，否则会出现“刷新丢路由&#x2F;404”</li><li>菜单与路由建议同源（同一份配置&#x2F;后端返回）避免不一致</li></ul><hr><h2 id="15）router-addRoute-什么时候用？刷新为什么会丢？"><a href="#15）router-addRoute-什么时候用？刷新为什么会丢？" class="headerlink" title="15）router.addRoute 什么时候用？刷新为什么会丢？"></a>15）<code>router.addRoute</code> 什么时候用？刷新为什么会丢？</h2><p><strong>回答模板</strong><br> <code>addRoute</code> 用于运行时动态注入路由，常见于权限系统。刷新丢失是因为：动态注入只存在于内存，刷新后路由表重置，所以需要在应用启动时（或首次进入时）根据 token 恢复权限并重新注入。</p><p><strong>要点</strong></p><ul><li>需要“启动恢复逻辑”：有 token → 拉权限 → addRoute → 再进入目标页</li><li>处理好“首次进入目标路由但路由还未注入”的时序问题</li></ul><hr><h2 id="16）路由-meta-有什么用？常见字段怎么设计？"><a href="#16）路由-meta-有什么用？常见字段怎么设计？" class="headerlink" title="16）路由 meta 有什么用？常见字段怎么设计？"></a>16）路由 meta 有什么用？常见字段怎么设计？</h2><p><strong>回答模板</strong><br> <code>meta</code> 用于放路由的业务元信息，不参与匹配但参与渲染与控制，例如：</p><ul><li><code>title</code>：页面标题</li><li><code>requiresAuth</code>：是否需要登录</li><li><code>roles</code>：允许角色列表</li><li><code>keepAlive</code>：是否缓存</li><li><code>icon</code>：菜单图标</li><li><code>hidden</code>：是否在菜单中隐藏</li><li><code>breadcrumb</code>：面包屑显示规则</li></ul><p><strong>要点</strong></p><ul><li>meta 是权限和菜单系统的核心载体</li><li>建议形成统一的 meta 规范，避免散落判断</li></ul><hr><h2 id="17）route-matched-是什么？有什么典型用法？"><a href="#17）route-matched-是什么？有什么典型用法？" class="headerlink" title="17）route.matched 是什么？有什么典型用法？"></a>17）<code>route.matched</code> 是什么？有什么典型用法？</h2><p><strong>回答模板</strong><br> <code>route.matched</code> 是“当前 URL 匹配到的路由记录数组”，从父到子依次排列。典型用途：</p><ul><li>面包屑：遍历 matched 取 meta.title</li><li>菜单高亮：根据 matched 中的路径&#x2F;name 做激活</li><li>布局判断：判断是否命中某个 layout 路由</li></ul><p><strong>要点</strong></p><ul><li>嵌套路由越深 matched 越长</li><li>matched 是“路由记录”，不是组件实例</li></ul><hr><h2 id="18）如何实现路由级-keep-alive-缓存？常见坑有哪些？"><a href="#18）如何实现路由级-keep-alive-缓存？常见坑有哪些？" class="headerlink" title="18）如何实现路由级 keep-alive 缓存？常见坑有哪些？"></a>18）如何实现路由级 keep-alive 缓存？常见坑有哪些？</h2><p><strong>回答模板</strong><br> 实现思路：</p><ul><li>在 layout 中用 <code>&lt;keep-alive&gt;</code> 包住 <code>&lt;router-view&gt;</code> 渲染的组件</li><li>通过 <code>route.meta.keepAlive</code> 控制是否缓存</li><li>对需要缓存的页面保证组件 <code>name</code> 稳定（用于 include&#x2F;exclude）</li></ul><p>常见坑：</p><ul><li>组件复用但 key 不当导致缓存无效或缓存错乱</li><li>缓存页面返回后数据不更新，需要配合 activated 生命周期或 watch route</li></ul><p><strong>要点</strong></p><ul><li><code>activated/deactivated</code> 管理缓存页面的进入离开</li><li>key 决定“是否认为是同一个实例”</li></ul><hr><h2 id="19）路由重定向-redirect-和别名-alias-的区别？"><a href="#19）路由重定向-redirect-和别名-alias-的区别？" class="headerlink" title="19）路由重定向 redirect 和别名 alias 的区别？"></a>19）路由重定向 redirect 和别名 alias 的区别？</h2><p><strong>回答模板</strong></p><ul><li>redirect：访问 A 实际跳到 B，地址栏会变成 B</li><li>alias：A 是 B 的别名，访问 A 渲染 B 的组件，但地址栏仍然是 A</li></ul><p><strong>要点</strong></p><ul><li>redirect 用于“统一入口&#x2F;默认页&#x2F;兼容旧地址跳新地址”</li><li>alias 用于“多个入口同一页面但保留不同 URL”</li></ul><hr><h2 id="20）404-403-一般怎么做？"><a href="#20）404-403-一般怎么做？" class="headerlink" title="20）404 &#x2F; 403 一般怎么做？"></a>20）404 &#x2F; 403 一般怎么做？</h2><p><strong>回答模板</strong></p><ul><li>404：配置兜底路由 <code>/:pathMatch(.*)*</code> 指向 NotFound</li><li>403：权限不足时重定向到 Forbidden 页面，或在守卫里拦截后跳转<br> 并且在动态路由场景下，保证：路由未注入前不要直接放行到受控路由，否则容易先 404 再注入。</li></ul><p><strong>要点</strong></p><ul><li>404 兜底路由建议放最后</li><li>动态路由要处理“注入时序”</li></ul><hr><h2 id="21）如何传递状态：路由参数-vs-store？"><a href="#21）如何传递状态：路由参数-vs-store？" class="headerlink" title="21）如何传递状态：路由参数 vs store？"></a>21）如何传递状态：路由参数 vs store？</h2><p><strong>回答模板</strong></p><ul><li>路由参数：适合可分享、可恢复、刷新不丢的状态（筛选条件、页码、资源 id）</li><li>store：适合全局共享、与 URL 无关或敏感信息（用户信息、临时 UI 状态）<br> 一般建议：能进 URL 的尽量进 URL，保证可回放与可分享；敏感或不稳定状态放 store。</li></ul><p><strong>要点</strong></p><ul><li>URL 是“可见的状态机”，利于排查与复现</li><li>敏感信息不要放 query（泄露风险）</li></ul><hr><h2 id="22）你在项目里用-Vue-Router-解决过什么问题？"><a href="#22）你在项目里用-Vue-Router-解决过什么问题？" class="headerlink" title="22）你在项目里用 Vue Router 解决过什么问题？"></a>22）你在项目里用 Vue Router 解决过什么问题？</h2><p><strong>回答模板（项目型）</strong><br> 我主要用 Vue Router 做了三件事：<br> 1）基于 beforeEach 的鉴权拦截，结合 meta.roles 控制路由访问，未授权重定向 403<br> 2）动态路由：登录后拉取权限路由表，<code>addRoute</code> 注入到 layout 下，同步生成侧边菜单，保证路由与菜单一致<br> 3）路由缓存：对高频列表页启用 keepAlive，结合 meta.keepAlive 与组件 activated 做数据刷新策略，解决返回列表重刷和滚动位置丢失的问题</p><p><strong>要点</strong></p><ul><li>面试官更看重：你是否处理过“动态路由时序”“缓存策略”“权限闭环”</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【⭐】浏览器/网络相关面试题</title>
    <link href="/2025/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2025/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><h3 id="面试题-1：什么是跨域？为什么会有跨域问题？"><a href="#面试题-1：什么是跨域？为什么会有跨域问题？" class="headerlink" title="面试题 1：什么是跨域？为什么会有跨域问题？"></a>面试题 1：什么是跨域？为什么会有跨域问题？</h3><p><strong>回答模板：</strong><br> 跨域本质是<strong>浏览器的同源策略限制</strong>。<br> 同源指的是：<strong>协议、域名、端口</strong>三者完全一致。<br> 只要三者中任意一个不同，浏览器就会认为是跨域，从而<strong>限制前端脚本读取响应内容</strong>，以防止恶意网站窃取用户数据。<br> 需要注意的是：<strong>跨域是浏览器层面的安全限制，服务器本身并不受影响</strong>。</p><h3 id="面试题-2：同源策略限制了哪些行为？"><a href="#面试题-2：同源策略限制了哪些行为？" class="headerlink" title="面试题 2：同源策略限制了哪些行为？"></a>面试题 2：同源策略限制了哪些行为？</h3><p><strong>回答模板：</strong><br> 同源策略主要限制的是：</p><ul><li>JS 读取跨域响应内容（<code>response / responseText</code>）</li><li>跨域 Cookie 的自动携带与读取</li><li>跨域 DOM、Storage 的访问</li></ul><p>但<strong>不会限制请求是否发出</strong>，例如：<br> <code>img / script / link / form</code> 都可以发起跨域请求，并且能够绕过跨域问题</p><h3 id="面试题-3：前端常见的跨域解决方案有哪些？"><a href="#面试题-3：前端常见的跨域解决方案有哪些？" class="headerlink" title="面试题 3：前端常见的跨域解决方案有哪些？"></a>面试题 3：前端常见的跨域解决方案有哪些？</h3><p>第一种：CORS（跨域资源共享，最标准）</p><p>CORS 是 <strong>浏览器制定的一套跨域访问规范</strong>。<br> 浏览器会根据这套规范，<strong>通过请求头和响应头来判断是否允许跨域访问</strong>。</p><p>核心思想是：</p><blockquote><p><strong>是否允许跨域，不由前端决定，而是由服务器通过响应头声明。</strong></p></blockquote><p>服务器可以通过设置诸如：</p><ul><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Allow-Headers</code></li><li><code>Access-Control-Allow-Credentials</code></li></ul><p>来精细化控制哪些源、哪些方法、哪些请求头可以跨域访问。</p><p>CORS 支持：</p><ul><li>所有 HTTP 方法</li><li>复杂请求</li><li>Cookie &#x2F; 认证信息</li></ul><p>因此它是<strong>生产环境中最规范、最安全、最常用的跨域方案</strong>。</p><hr><p>第二种：反向代理（工程中非常常见）</p><p>反向代理的核心原理是：</p><blockquote><p><strong>浏览器与服务器之间存在跨域限制，但服务器与服务器之间不存在跨域问题。</strong></p></blockquote><p>具体做法是：</p><ul><li>在前端同源的服务器上设置一台代理服务器（如 Nginx、开发服务器）</li><li>浏览器请求代理服务器（同源请求）</li><li>代理服务器再向真实后端服务器转发请求</li><li>后端返回数据给代理服务器</li><li>代理服务器再将数据转发给浏览器</li></ul><p>从浏览器视角来看：</p><ul><li>请求始终是<strong>同源请求</strong></li><li>因此<strong>不会触发跨域问题</strong></li></ul><p>这种方式：</p><ul><li><strong>开发环境非常常见</strong></li><li>生产环境也常用于 API 网关、统一入口</li></ul><hr><p>第三种：JSONP（已过时）</p><p>JSONP 是一种<strong>早期的跨域解决方案</strong>，原理是：</p><ul><li>利用 <code>&lt;script&gt;</code> 标签<strong>不受同源策略限制</strong></li><li>通过 URL 参数传递一个回调函数名</li><li>服务器返回一段<strong>调用该回调函数的 JS 代码</strong></li><li>浏览器执行这段 JS，从而获取数据</li></ul><p>这种方式的缺点非常明显：</p><ul><li><strong>只支持 GET 请求</strong></li><li>存在安全风险</li><li>不符合现代前后端分离架构</li></ul><p>因此 <strong>现在基本已经被淘汰，不推荐使用</strong>。</p><ul><li>有安全风险，基本不再推荐</li></ul><h3 id="面试题-4：为什么有的请求会触发-CORS-预检（OPTIONS）？"><a href="#面试题-4：为什么有的请求会触发-CORS-预检（OPTIONS）？" class="headerlink" title="面试题 4：为什么有的请求会触发 CORS 预检（OPTIONS）？"></a>面试题 4：为什么有的请求会触发 CORS 预检（OPTIONS）？</h3><blockquote><p>浏览器根据 CORS 规范将跨域请求分为简单请求和非简单请求。<br> 当请求不满足简单请求条件，比如使用 <code>application/json</code> 或自定义请求头时，会先发送一次 <code>OPTIONS</code> 预检请求，用于确认服务器是否允许跨域访问。<br> 预检结果可以通过 <code>Access-Control-Max-Age</code> 缓存，避免每次都触发。</p></blockquote><p>标准回答模板</p><p>有些请求会触发 CORS 预检，是因为<strong>浏览器根据 CORS 规范，将跨域请求分为「简单请求」和「非简单请求」两类</strong>。</p><p>当浏览器判定当前请求是<strong>非简单请求</strong>时，会在真正的业务请求之前，<strong>先自动发送一次 <code>OPTIONS</code> 预检请求</strong>，用来确认服务器是否允许该跨域请求。</p><hr><p>一、什么情况下会触发预检请求？</p><p>只要请求<strong>不满足简单请求的条件</strong>，浏览器就会触发 <code>OPTIONS</code> 预检。</p><hr><p>二、什么是简单请求？</p><p>简单请求必须<strong>同时满足以下三个条件</strong>：</p><h4 id="1️⃣-请求方法只能是三种之一"><a href="#1️⃣-请求方法只能是三种之一" class="headerlink" title="1️⃣ 请求方法只能是三种之一"></a>1️⃣ 请求方法只能是三种之一</h4><ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul><hr><h4 id="2️⃣-请求头只能是-CORS-规范允许的“安全请求头”"><a href="#2️⃣-请求头只能是-CORS-规范允许的“安全请求头”" class="headerlink" title="2️⃣ 请求头只能是 CORS 规范允许的“安全请求头”"></a>2️⃣ 请求头只能是 CORS 规范允许的“安全请求头”</h4><p>通常情况下：</p><blockquote><p><strong>只要不手动添加自定义请求头（如 <code>Authorization</code>），就满足这一条件</strong></p></blockquote><hr><h4 id="3️⃣-Content-Type-只能是以下三种之一"><a href="#3️⃣-Content-Type-只能是以下三种之一" class="headerlink" title="3️⃣ Content-Type 只能是以下三种之一"></a>3️⃣ Content-Type 只能是以下三种之一</h4><ul><li><code>text/plain</code></li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><p>⚠️ <strong>重点：</strong></p><blockquote><p><code>application/json</code> <strong>不属于简单请求的 Content-Type</strong></p></blockquote><p>因此：</p><ul><li>只要使用 <code>application/json</code> 发送请求</li><li>浏览器就会将其判定为 <strong>非简单请求</strong></li><li>从而触发 <code>OPTIONS</code> 预检</li></ul><hr><p>三、什么是 OPTIONS 预检请求？</p><p><code>OPTIONS</code> 预检请求的作用是：</p><blockquote><p><strong>在真正发送跨域请求之前，先询问服务器是否允许本次跨域访问</strong></p></blockquote><p>服务器会在预检响应中返回：</p><ul><li>是否允许该源访问</li><li>是否允许该请求方法</li><li>是否允许这些请求头</li><li>是否允许携带 Cookie</li></ul><p>如果预检通过：</p><ul><li>浏览器才会发送真正的业务请求（GET &#x2F; POST 等）</li></ul><p>如果预检失败：</p><ul><li><strong>浏览器直接拦截</strong></li><li>业务请求根本不会发出</li></ul><hr><p>四、为什么不是每次都发送 OPTIONS？</p><p>CORS 允许服务器通过响应头：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Access</span>-Control-<span class="hljs-built_in">Max</span>-Age<br></code></pre></td></tr></table></figure><p>指定：</p><blockquote><p><strong>预检结果的缓存时间</strong></p></blockquote><p>在该时间内：</p><ul><li>浏览器不会重复发送 OPTIONS</li><li>可以直接复用上一次的预检结果</li><li>这是 CORS 的重要性能优化机制</li></ul><h3 id="面试题-5-一次非简单请求的完整校验是怎样的？"><a href="#面试题-5-一次非简单请求的完整校验是怎样的？" class="headerlink" title="面试题 5: 一次非简单请求的完整校验是怎样的？"></a>面试题 5: 一次非简单请求的完整校验是怎样的？</h3><h3 id="标准回答模板（紧凑版）"><a href="#标准回答模板（紧凑版）" class="headerlink" title="标准回答模板（紧凑版）"></a>标准回答模板（紧凑版）</h3><p>一次<strong>非简单跨域请求</strong>的完整校验流程，严格按照 <strong>CORS 规范</strong>分为以下几个步骤：</p><hr><p><strong>1️⃣ 浏览器判定请求类型</strong><br> 浏览器在发起请求前，会先根据 CORS 规则判断是否为非简单请求：</p><ul><li>使用了非简单方法</li><li>使用了自定义请求头（如 <code>Authorization</code>）</li><li><code>Content-Type</code> 为 <code>application/json</code><br> 只要满足任意一条，就会进入预检流程。</li></ul><hr><p><strong>2️⃣ 发送 OPTIONS 预检请求</strong><br> 浏览器自动向目标服务器发送 <code>OPTIONS</code> 请求，用于“探测”是否允许跨域。<br> 预检请求中会携带：</p><ul><li><code>Origin</code></li><li><code>Access-Control-Request-Method</code></li><li><code>Access-Control-Request-Headers</code></li></ul><hr><p><strong>3️⃣ 服务器返回预检响应</strong><br> 服务器根据自身 CORS 配置返回响应头：</p><ul><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Allow-Headers</code></li><li>（可选）<code>Access-Control-Allow-Credentials</code></li><li>（可选）<code>Access-Control-Max-Age</code></li></ul><hr><p><strong>4️⃣ 浏览器校验预检结果</strong><br> 浏览器会对响应头进行校验：</p><ul><li>源是否被允许</li><li>方法是否被允许</li><li>请求头是否被允许</li></ul><p>若任意一项不通过，流程直接终止，<strong>业务请求不会发送</strong>。</p><hr><p><strong>5️⃣ 发送真正的业务请求</strong><br> 预检通过后，浏览器才会发送真正的跨域请求（GET &#x2F; POST &#x2F; PUT 等），并携带 Cookie（如已开启 credentials）。</p><hr><p><strong>6️⃣ 浏览器校验业务响应</strong><br> 浏览器再次检查业务响应中的 CORS 头：</p><ul><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Credentials</code><br> 校验通过后，JS 才能正常读取响应数据。</li></ul><hr><p><strong>7️⃣ 预检结果缓存（性能优化）</strong><br> 如果服务器返回了 <code>Access-Control-Max-Age</code>，<br> 在有效期内，相同请求将<strong>不再重复发送 OPTIONS 预检</strong>。</p><hr><h3 id="面试题-6：跨域请求为什么-Cookie-传不过去？"><a href="#面试题-6：跨域请求为什么-Cookie-传不过去？" class="headerlink" title="面试题 6：跨域请求为什么 Cookie 传不过去？"></a>面试题 6：跨域请求为什么 Cookie 传不过去？</h3><p><strong>回答模板：</strong><br> 跨域 Cookie 需要<strong>前后端同时满足条件</strong>：</p><ul><li>前端：<ul><li><code>xhr.withCredentials = true</code></li></ul></li><li>后端：<ul><li><code>Access-Control-Allow-Credentials: true</code></li><li><code>Access-Control-Allow-Origin</code> 不能为 <code>*</code></li></ul></li></ul><p>缺一不可，否则浏览器会直接拦截 Cookie。</p><hr><h3 id="面试题-7：OPTIONS-请求失败会发生什么？"><a href="#面试题-7：OPTIONS-请求失败会发生什么？" class="headerlink" title="面试题 7：OPTIONS 请求失败会发生什么？"></a>面试题 7：OPTIONS 请求失败会发生什么？</h3><p><strong>回答模板：</strong><br> 如果 OPTIONS 预检失败：</p><ul><li>浏览器<strong>不会发送真正的业务请求</strong></li><li>控制台会直接报 CORS 错误</li><li>后端日志中通常只看到 OPTIONS，没有 GET&#x2F;POST</li></ul><p>这是前端“看似请求没发出去”的常见原因。</p><h3 id="面试题-8：开发环境是怎么解决跨域的？"><a href="#面试题-8：开发环境是怎么解决跨域的？" class="headerlink" title="面试题 8：开发环境是怎么解决跨域的？"></a>面试题 8：开发环境是怎么解决跨域的？</h3><p><strong>回答模板：</strong><br> 开发环境通常使用<strong>本地代理</strong>：</p><ul><li>Vite &#x2F; Webpack Dev Server</li><li>将 <code>/api</code> 请求代理到真实后端</li><li>浏览器认为请求仍然是同源</li></ul><p>这种方式<strong>只解决开发阶段问题</strong>，生产环境仍需 CORS 或网关代理。</p><hr><h3 id="面试题-9：为什么-Postman-没有跨域问题？"><a href="#面试题-9：为什么-Postman-没有跨域问题？" class="headerlink" title="面试题 9：为什么 Postman 没有跨域问题？"></a>面试题 9：为什么 Postman 没有跨域问题？</h3><p><strong>回答模板：</strong><br> 因为跨域是<strong>浏览器的安全策略</strong>。<br> Postman、curl、后端服务之间的请求：</p><ul><li>不受同源策略限制</li><li>可以自由访问任何接口</li></ul><p>这也是“Postman 能通，前端不通”的根本原因。</p><h3 id="面试题10：-Nginx-的特点是什么？常见的三大作用？"><a href="#面试题10：-Nginx-的特点是什么？常见的三大作用？" class="headerlink" title="面试题10： Nginx 的特点是什么？常见的三大作用？"></a>面试题10： Nginx 的特点是什么？常见的三大作用？</h3><blockquote><p>Nginx 是一个高性能的 Web 服务器和反向代理服务器，采用事件驱动模型，支持高并发、低内存占用。<br> 常见三大作用是：作为静态资源服务器、反向代理服务器以及负载均衡器，在前后端分离和高并发架构中非常常见。</p></blockquote><p>一、Nginx 的核心特点（先说优势）</p><p><strong>标准回答模板：</strong><br> Nginx 是一个<strong>高性能的 Web 服务器和反向代理服务器</strong>，核心特点是：</p><ul><li><strong>事件驱动、异步非阻塞 I&#x2F;O</strong>（单进程可支撑大量并发）</li><li><strong>高并发、低内存占用</strong>（C10K 问题的经典解决方案）</li><li><strong>配置简单、模块化清晰</strong></li><li><strong>稳定性强，适合长期运行</strong></li></ul><p>一句话概括：</p><blockquote><p>Nginx 用更少的资源，支撑更多的并发连接。</p></blockquote><hr><p>二、Nginx 的三大常见作用（必考重点）</p><hr><p>1️⃣ Web 服务器（静态资源服务器）</p><p><strong>作用说明：</strong></p><ul><li>直接对外提供 HTTP 服务</li><li>高效处理：<ul><li>HTML</li><li>CSS &#x2F; JS</li><li>图片 &#x2F; 视频等静态资源</li></ul></li></ul><p><strong>优势：</strong></p><ul><li>静态资源处理能力极强</li><li>比后端应用服务器（如 Node &#x2F; Java）更省资源</li><li>常用于<strong>前后端分离架构中的静态资源托管</strong></li></ul><hr><p>2️⃣ 反向代理服务器（最常用）</p><p><strong>作用说明：</strong></p><ul><li>浏览器 → Nginx → 后端服务</li><li>客户端只感知 Nginx，不直接访问后端</li></ul><p><strong>典型用途：</strong></p><ul><li><strong>解决跨域问题</strong></li><li>隐藏真实后端地址</li><li>统一入口（API Gateway）</li><li>请求转发、权限隔离</li></ul><p><strong>核心原理一句话：</strong></p><blockquote><p>浏览器与 Nginx 同源，服务器与服务器之间不存在跨域问题。</p></blockquote><hr><p>3️⃣ 负载均衡器（高并发架构核心）</p><p><strong>作用说明：</strong></p><ul><li>将请求分发到多台后端服务器</li><li>避免单点瓶颈</li></ul><p><strong>常见策略：</strong></p><ul><li>轮询（默认）</li><li>权重轮询</li><li>IP Hash</li><li>最少连接数</li></ul><p><strong>典型场景：</strong></p><ul><li>高并发 Web 服务</li><li>微服务架构</li><li>集群部署</li></ul><h3 id="面试题11：Web-服务器和应用服务器的区别是什么？"><a href="#面试题11：Web-服务器和应用服务器的区别是什么？" class="headerlink" title="面试题11：Web 服务器和应用服务器的区别是什么？"></a>面试题11：Web 服务器和应用服务器的区别是什么？</h3><p>标准回答模板</p><p>Web 服务器和应用服务器的核心区别在于：<br> <strong>Web 服务器主要负责处理 HTTP 请求和静态资源，而应用服务器负责执行业务逻辑并生成动态内容。</strong></p><hr><p><strong>Web 服务器：</strong></p><ul><li>主要职责是接收 HTTP 请求、返回静态资源（HTML、CSS、JS、图片等）</li><li>也常作为反向代理，将请求转发给后端应用</li><li>特点是高并发、低资源消耗</li><li>常见的有：Nginx、Apache</li></ul><p><strong>应用服务器：</strong></p><ul><li>主要职责是执行业务逻辑，处理动态请求</li><li>通常需要访问数据库、缓存等后端资源</li><li>返回的是动态生成的数据或页面（如 JSON、HTML）</li><li>常见的有：Node.js、Tomcat、Spring Boot、Django 等</li></ul><hr><p><strong>实际项目中通常是两者配合使用：</strong></p><ul><li>Web 服务器作为统一入口，处理静态资源和请求转发</li><li>应用服务器专注于业务逻辑处理</li></ul><hr><p>一句话总结（面试加分）</p><blockquote><p>Web 服务器负责“接收和转发请求、提供静态资源”，<br> 应用服务器负责“执行业务逻辑、生成动态数据”，<br> 两者分工协作是现代 Web 架构的常见模式。</p></blockquote><hr><p>30 秒极简版</p><blockquote><p>Web 服务器主要处理 HTTP 和静态资源，比如 Nginx；<br> 应用服务器主要处理业务逻辑和动态请求，比如 Node 或 Java 服务；<br> 实际项目中通常由 Web 服务器作为入口，再将请求交给应用服务器处理。</p></blockquote><h3 id="面试题12：-手写Nginx和Vue配置代理服务器的代码？"><a href="#面试题12：-手写Nginx和Vue配置代理服务器的代码？" class="headerlink" title="面试题12： 手写Nginx和Vue配置代理服务器的代码？"></a>面试题12： 手写Nginx和Vue配置代理服务器的代码？</h3><p><code>nginx</code></p><blockquote><p>放到 <code>nginx.conf</code> 的 <code>http &#123;&#125;</code> 里或单独的 <code>conf.d/app.conf</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">server &#123;<br>  listen <span class="hljs-number">80</span>;<br>  server_name localhost;<br><br>  # 反向代理：/api -&gt; 后端<br>  location /api/ &#123;<br>    proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1:8080/;  # 注意结尾的 /</span><br>    proxy_set_header <span class="hljs-title class_">Host</span> $host;<br>    proxy_set_header X-<span class="hljs-title class_">Real</span>-<span class="hljs-variable constant_">IP</span> $remote_addr;<br>    proxy_set_header X-<span class="hljs-title class_">Forwarded</span>-<span class="hljs-title class_">For</span> $proxy_add_x_forwarded_for;<br>    proxy_set_header X-<span class="hljs-title class_">Forwarded</span>-<span class="hljs-title class_">Proto</span> $scheme;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果你希望把 <code>/api</code> 前缀去掉再转发（上面已经是“去掉”的效果），关键就是 <code>location /api/</code> + <code>proxy_pass .../</code> **都带尾部 <code>/</code>**。</p></blockquote><p><code>vite.config.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://127.0.0.1:8080&quot;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// 如果后端不需要 /api 前缀就打开下面这行</span><br>        <span class="hljs-comment">// rewrite: (path) =&gt; path.replace(/^\/api/, &quot;&quot;),</span><br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><h3 id="面试题1：一次完整的-URL-请求通常会经历哪些步骤？"><a href="#面试题1：一次完整的-URL-请求通常会经历哪些步骤？" class="headerlink" title="面试题1：一次完整的 URL 请求通常会经历哪些步骤？"></a>面试题1：一次完整的 URL 请求通常会经历哪些步骤？</h3><blockquote><p>一次完整的 URL 请求通常会经历：<strong>URL 解析 → DNS 解析 → 建立连接（TCP&#x2F;UDP + TLS）→ 发送 HTTP 请求 → 服务端处理并返回 → 浏览器接收与缓存处理 → 解析渲染页面（HTML&#x2F;CSS&#x2F;JS）→ 资源加载与执行 → 首屏呈现与后续交互</strong>。</p></blockquote><p><strong>1）输入 URL 与浏览器预处理</strong></p><ul><li><strong>解析 URL</strong>：协议（http&#x2F;https）、域名、端口、路径、query、hash</li><li><strong>HSTS&#x2F;升级</strong>：可能把 http 自动升级为 https</li><li><strong>查缓存&#x2F;预连接</strong>：浏览器可能命中 <strong>DNS 缓存 &#x2F; 连接池 &#x2F; HTTP 缓存</strong>，命中则跳过部分步骤</li></ul><p><strong>2）DNS 解析（把域名变成 IP）</strong></p><ul><li>查询顺序通常是：<strong>浏览器 DNS 缓存 → 系统缓存 → hosts → 本地 DNS → 递归解析（根&#x2F;顶级&#x2F;权威）</strong></li><li>结果会有 <strong>TTL</strong>，决定缓存时长</li><li>性能优化：<code>dns-prefetch</code>、减少跨域域名数量</li></ul><p><strong>3）建立连接（传输层 + 安全层）</strong></p><p><strong>3.1 TCP（三次握手）</strong>（HTTP&#x2F;1.1、HTTP&#x2F;2 通常跑在 TCP 上）</p><ul><li>SYN → SYN&#x2F;ACK → ACK</li><li>建立后进入连接复用（Keep-Alive）</li></ul><p><strong>3.2 TLS 握手（HTTPS 才有）</strong></p><ul><li>证书校验、协商加密套件、生成会话密钥</li><li>优化点：TLS1.3、会话复用、OCSP Stapling</li></ul><blockquote><p>补充：HTTP&#x2F;3 基于 **QUIC(UDP)**，把“传输层握手 + TLS”合并加速，减少延迟（面试可加分一句）。</p></blockquote><p><strong>4）发送 HTTP 请求（应用层）</strong></p><ul><li>组成：<strong>请求行（method&#x2F;path）+ headers + body</strong></li><li>常见行为：<ul><li>携带 Cookie &#x2F; Authorization</li><li><code>Accept-Encoding</code> 触发 gzip&#x2F;br 压缩</li><li>跨域且“非简单请求”会先发 <strong>OPTIONS 预检</strong></li></ul></li></ul><p><strong>5）服务端处理与返回响应</strong></p><ul><li>典型链路：<strong>CDN&#x2F;反向代理(Nginx) → 应用服务器 → DB&#x2F;缓存&#x2F;微服务</strong></li><li>返回：<strong>状态码、响应头（缓存&#x2F;类型&#x2F;长度）、响应体</strong></li><li>性能指标：TTFB（Time To First Byte）</li></ul><p><strong>6）浏览器接收响应：缓存与连接管理</strong></p><ul><li>根据响应头决定缓存策略：<ul><li>强缓存：<code>Cache-Control: max-age</code> &#x2F; <code>Expires</code></li><li>协商缓存：<code>ETag/If-None-Match</code>、<code>Last-Modified/If-Modified-Since</code></li></ul></li><li><code>304 Not Modified</code> 走协商缓存，减少下载</li></ul><p><strong>7）解析与渲染（浏览器渲染流水线）</strong></p><ul><li><strong>解析 HTML → DOM</strong></li><li><strong>解析 CSS → CSSOM</strong></li><li>DOM + CSSOM → <strong>Render Tree</strong></li><li><strong>Layout（回流）→ Paint（绘制）→ Composite（合成）</strong></li><li>JS 可能阻塞解析（尤其是同步脚本），并触发重排&#x2F;重绘</li></ul><p><strong>8）资源加载与执行（并行&#x2F;优先级）</strong></p><ul><li>遇到 <code>link/script/img</code> 会发起更多请求</li><li>HTTP&#x2F;2 多路复用提升并发效率；浏览器也有优先级调度</li><li><code>defer/async</code>、<code>preload/prefetch</code> 会影响加载顺序与首屏</li></ul><p><strong>9）页面可用：首屏、交互、后续请求</strong></p><ul><li>首屏渲染完成后进入交互期</li><li>SPA 场景下：后续路由切换多为 <strong>JS 驱动渲染</strong>，但接口请求仍走同样的网络链路</li></ul><h3 id="面试题2：DNS解析的步骤是什么？"><a href="#面试题2：DNS解析的步骤是什么？" class="headerlink" title="面试题2：DNS解析的步骤是什么？"></a>面试题2：DNS解析的步骤是什么？</h3><p><strong>步骤：</strong></p><ol><li><strong>浏览器缓存</strong>：检查是否有未过期的 DNS 记录（TTL）</li><li><strong>操作系统缓存 &#x2F; hosts</strong>：本地 DNS Cache 与 hosts 文件</li><li><strong>本地 DNS 服务器（递归解析器）</strong>：通常由运营商或企业提供</li><li><strong>根域名服务器（.）</strong>：返回对应的顶级域服务器地址</li><li><strong>顶级域服务器（TLD，如 .com）</strong>：返回目标域名的权威 DNS 服务器</li><li><strong>权威 DNS 服务器</strong>：返回最终解析结果（A &#x2F; AAAA &#x2F; CNAME）</li><li><strong>结果缓存并返回</strong>：递归服务器、OS、浏览器按 TTL 缓存，浏览器使用 IP 建立连接</li></ol><blockquote><p>客户端<strong>递归</strong>地把解析任务交给本地 DNS，本地 DNS 再<strong>迭代</strong>地向各级域名服务器查询，最终拿到 IP 并返回。</p></blockquote><h3 id="面试3：TCP-连接是怎么建立的？"><a href="#面试3：TCP-连接是怎么建立的？" class="headerlink" title="面试3：TCP 连接是怎么建立的？"></a>面试3：<strong>TCP 连接是怎么建立的？</strong></h3><p><strong>口述模板：</strong></p><p>TCP 通过<strong>三次握手</strong>建立连接，核心目的有三个：<br> <strong>确认双方收发能力、同步初始序列号、防止历史连接误建立。</strong></p><p>第一次，<strong>客户端发送 SYN</strong>，表示我要建立连接，并告诉服务端我的初始序列号；</p><p>第二次，<strong>服务端返回 SYN + ACK</strong>，表示我收到了你的请求，同时告诉客户端我的初始序列号；</p><p>第三次，<strong>客户端再回一个 ACK</strong>，表示我确认收到了你的确认，至此双方状态一致，连接建立完成。</p><h4 id="面试题：三次握手过程中如果报文丢失，会发生什么？"><a href="#面试题：三次握手过程中如果报文丢失，会发生什么？" class="headerlink" title="面试题：三次握手过程中如果报文丢失，会发生什么？"></a>面试题：<strong>三次握手过程中如果报文丢失，会发生什么？</strong></h4><p>TCP 在三次握手过程中，对任意一次报文丢失都设计了<strong>超时重传和状态回退机制</strong>。</p><hr><p>第一种情况：第一次 SYN 丢失</p><p>客户端发送 SYN 后进入 <strong>SYN-SENT 状态</strong>。<br> 如果服务器没有收到该 SYN，就不会返回任何响应。<br> 客户端在超时后会<strong>重传 SYN</strong>，多次失败后连接建立失败。</p><hr><p>第二种情况：第二次 SYN+ACK 丢失</p><p>服务器收到 SYN 后，会返回 <strong>SYN+ACK</strong>，并进入 <strong>SYN-RECEIVED（半连接）状态</strong>。<br> 如果这个 SYN+ACK 丢失：</p><ul><li>客户端仍处于 SYN-SENT，会<strong>重传 SYN</strong></li><li>服务器在半连接状态下，会<strong>重传 SYN+ACK</strong></li></ul><p>双方不断重试，直到成功完成握手或超时清理半连接。</p><hr><p>第三种情况：第三次 ACK 丢失</p><p>客户端收到 SYN+ACK 后，会立即发送 ACK，并认为连接已建立。<br> 如果这个 ACK 丢失：</p><ul><li>服务器仍停留在 <strong>SYN-RECEIVED 状态</strong></li><li>会再次发送 SYN+ACK</li><li>客户端每次收到重复的 SYN+ACK，都会<strong>重新发送 ACK</strong></li></ul><p>最终服务器收到 ACK，连接建立；否则超时释放半连接。</p><hr><p>总结收尾（一定要说）</p><blockquote><p>三次握手的设计可以确保通信双方都具备收发能力，<br> 并同步初始序列号，同时防止服务器因异常或丢包长期处于半连接状态。</p></blockquote><h4 id="什么不能两次握手？"><a href="#什么不能两次握手？" class="headerlink" title="什么不能两次握手？"></a><strong>什么不能两次握手？</strong></h4><p><strong>口述模板：</strong></p><p>如果只有两次握手，服务端无法确认客户端是否真的收到了确认包，<br> 一旦出现<strong>延迟的旧 SYN 报文</strong>，服务端可能会错误地建立连接，造成资源浪费。<br> 第三次握手的作用，就是<strong>确认客户端的接收能力并清理历史请求</strong>。</p><h3 id="面试题：为什么-TCP-不能只用两次握手？"><a href="#面试题：为什么-TCP-不能只用两次握手？" class="headerlink" title="面试题：为什么 TCP 不能只用两次握手？"></a>面试题：<strong>为什么 TCP 不能只用两次握手？</strong></h3><p>口述回答模板（清晰版）</p><p>TCP 不能只用两次握手，<strong>核心原因是无法避免服务器长期处于半连接状态，从而占用服务器资源</strong>。</p><hr><p>第一层原因：<strong>无法确认客户端的接收能力</strong></p><p>如果只有两次握手：<br> 客户端发送 <strong>SYN</strong>，服务器返回 <strong>SYN + ACK</strong> 后就认为连接建立。</p><p>但如果这个 <strong>SYN + ACK 丢失</strong>：</p><ul><li>服务器已经进入 <strong>半连接状态（SYN-RECEIVED）</strong></li><li>客户端由于收不到响应，会判断连接失败</li><li>服务器却无法确认客户端是否存在，<strong>只能等待超时</strong></li></ul><p>第三次握手的 ACK，作用就是<strong>明确告诉服务器：客户端确实收到了你的响应</strong>。</p><hr><p>第二层原因：<strong>无法防止历史延迟的 SYN 造成错误连接</strong></p><p>如果网络中存在<strong>延迟的旧 SYN 报文</strong>：</p><ul><li>客户端早已放弃该连接</li><li>延迟的 SYN 在之后到达服务器</li></ul><p>在两次握手模型下：</p><ul><li>服务器会误认为这是一次新的连接请求</li><li>从而建立一个<strong>无效的半连接</strong></li></ul><p>第三次 ACK 可以明确区分：</p><ul><li>这是一次真实的当前连接</li><li>还是一条历史失效请求</li></ul><hr><p>第三层原因（安全层面）：<strong>容易被 SYN Flood 攻击</strong></p><p>如果只有两次握手：<br> 攻击者可以持续向服务器发送大量 <strong>SYN 请求</strong>，<br> 但<strong>从不发送最后的确认</strong>。</p><p>服务器就会：</p><ul><li>维持大量半连接</li><li>占用 TCP 控制块和内存资源</li><li>导致正常用户无法建立连接</li></ul><p>这类攻击称为 <strong>SYN Flood（半连接攻击）</strong>。</p><hr><p>总结收尾（一定要说）</p><blockquote><p>第三次握手的存在，不仅是为了完成连接确认，<br> 更重要的是<strong>防止服务器因异常、延迟或攻击长期处于半连接状态</strong>，<br> 从而保证 TCP 连接的可靠性和安全性。</p></blockquote><h3 id="面试题：TCP-连接是怎么断开的？"><a href="#面试题：TCP-连接是怎么断开的？" class="headerlink" title="面试题：TCP 连接是怎么断开的？"></a>面试题：<strong>TCP 连接是怎么断开的？</strong></h3><p><strong>口述模板：</strong></p><p>TCP 通过<strong>四次挥手</strong>断开连接，<br> 这是因为 TCP 是<strong>全双工协议</strong>，双方的发送方向必须<strong>分别关闭</strong>。</p><hr><p>第一次挥手：客户端 → 服务器（FIN）</p><p>客户端向服务器发送 <strong>FIN 报文</strong>，<br> 表示：<strong>客户端已经没有数据要发送了</strong>，<br> 此时客户端进入 <strong>FIN-WAIT-1 状态</strong>。</p><hr><p>第二次挥手：服务器 → 客户端（ACK）</p><p>服务器收到 FIN 后，返回 <strong>ACK 报文</strong>，<br> 表示：<strong>已确认客户端的关闭请求</strong>。</p><p>此时：</p><ul><li>客户端不再发送数据</li><li>但服务器仍然可以向客户端发送数据</li><li>连接尚未完全关闭</li></ul><hr><p>第三次挥手：服务器 → 客户端（FIN）</p><p>当服务器把<strong>剩余数据全部发送完毕后</strong>，<br> 会向客户端发送 <strong>FIN 报文</strong>，<br> 表示：<strong>服务器也准备关闭发送方向</strong>。</p><hr><p>第四次挥手：客户端 → 服务器（ACK）</p><p>客户端收到服务器的 FIN 后，<br> 返回 <strong>ACK 报文</strong>，<br> 至此，服务器连接关闭，客户端进入 <strong>TIME_WAIT 状态</strong>。</p><hr><h4 id="为什么断开是四次，而建立是三次？"><a href="#为什么断开是四次，而建立是三次？" class="headerlink" title="为什么断开是四次，而建立是三次？"></a><strong>为什么断开是四次，而建立是三次？</strong></h4><p><strong>口述模板：</strong></p><p>建立连接时，服务端可以把 <strong>SYN 和 ACK 合并发送</strong>，是因为<strong>服务器在确认客户端关闭请求时，可能还有数据没有发送完</strong>。</p><ul><li>第二次的 <strong>ACK</strong>：只是确认客户端“我知道你要关了”</li><li>第三次的 <strong>FIN</strong>：是服务器真正关闭自己发送方向的请求</li></ul><p>这两个动作<strong>在时间上不一定同时发生</strong>，<br> 因此一般不能合并发送。</p><h4 id="TIME-WAIT-状态的作用"><a href="#TIME-WAIT-状态的作用" class="headerlink" title="TIME_WAIT 状态的作用"></a>TIME_WAIT 状态的作用</h4><p><strong>口述模板：</strong></p><p>客户端在发送最后一个 ACK 后，并不会立刻关闭连接，<br> 而是进入 <strong>TIME_WAIT 状态</strong>，通常持续 <strong>2MSL</strong>。</p><p>TIME_WAIT 的作用有两点：</p><ol><li><strong>确保服务器能够收到最后一个 ACK</strong></li><li><strong>防止旧连接的延迟报文影响新连接</strong></li></ol><p>因此，TIME_WAIT 状态<strong>经常出现在客户端</strong>，<br> 因为<strong>主动关闭连接的一方会进入 TIME_WAIT</strong>。</p><h3 id="面试题：TCP-是怎么保证可靠传输的？"><a href="#面试题：TCP-是怎么保证可靠传输的？" class="headerlink" title="面试题：TCP 是怎么保证可靠传输的？"></a>面试题：<strong>TCP 是怎么保证可靠传输的？</strong></h3><p><strong>口述模板：</strong></p><p>TCP 通过五个核心机制保证可靠性：<br> <strong>序列号保证顺序、ACK 确认接收、超时重传防止丢包、滑动窗口保证连续传输、<br> 流量控制和拥塞控制防止压垮接收方和网络。</strong></p><hr><h3 id="面试题：流量控制和拥塞控制有什么区别？"><a href="#面试题：流量控制和拥塞控制有什么区别？" class="headerlink" title="面试题：流量控制和拥塞控制有什么区别？"></a>面试题：<strong>流量控制和拥塞控制有什么区别？</strong></h3><p><strong>口述模板：</strong></p><p><strong>流量控制</strong>关注的是<strong>接收方是否接得住</strong>，<br> TCP 通过<strong>接收窗口 rwnd</strong>实现，<br> 接收方在 ACK 中告诉发送方还能接收多少数据，<br> 发送方发送的数据量不能超过 rwnd，<br> 本身<strong>没有复杂算法</strong>，是一个动态窗口调节机制。</p><p><strong>拥塞控制</strong>关注的是<strong>网络是否扛得住</strong>，<br> TCP 通过<strong>拥塞窗口 cwnd</strong>控制发送速率，<br> 实际发送窗口大小是 **min(rwnd, cwnd)**，<br> 拥塞控制包含一套完整算法体系。</p><p>经典的拥塞控制算法包括：<br> <strong>慢启动</strong>：cwnd 从小开始指数增长；<br> <strong>拥塞避免</strong>：达到阈值后线性增长；<br> <strong>快重传</strong>：收到 3 个重复 ACK 立即重传；<br> <strong>快恢复</strong>：重传后不回慢启动，直接进入拥塞避免。</p><h4 id="TCP-拥塞控制完整流程"><a href="#TCP-拥塞控制完整流程" class="headerlink" title="TCP 拥塞控制完整流程"></a>TCP 拥塞控制完整流程</h4><p>1️⃣ 慢启动（Slow Start）</p><ul><li>连接建立后，<strong>cwnd 从 1 MSS 开始</strong></li><li><strong>每收到一个 ACK，cwnd 翻倍增长</strong></li><li>目的：<strong>快速探测网络的承载能力</strong></li><li>当 <strong>cwnd ≥ ssthresh（慢启动阈值）</strong> → 进入拥塞避免</li></ul><hr><p>2️⃣ 拥塞避免（Congestion Avoidance）</p><ul><li>cwnd <strong>不再指数增长</strong></li><li>改为：<strong>每个 RTT 线性增长 1 MSS</strong></li><li>目的：<strong>避免过快增长引发网络拥塞</strong></li><li>如果此阶段<strong>发生丢包</strong> → 触发重传机制</li></ul><hr><p>3️⃣ 快重传（Fast Retransmit）</p><ul><li>如果发送方收到 <strong>3 个重复 ACK</strong></li><li>判断：<strong>某个数据包丢失</strong></li><li><strong>不等待超时，立即重传丢失报文</strong></li><li>同时调整阈值：<ul><li><code>ssthresh = 当前 cwnd / 2</code></li></ul></li></ul><hr><p>4️⃣ 快恢复（Fast Recovery）</p><ul><li>重传完成后：<ul><li><strong>cwnd 直接降到 ssthresh</strong></li><li><strong>不回到慢启动</strong></li></ul></li><li>直接进入 <strong>拥塞避免阶段</strong></li><li>目的：<strong>快速恢复吞吐量，避免从头开始</strong></li></ul><hr><p>一句话流程总结（强背）</p><blockquote><p>TCP 先慢启动指数增长，<br> 到阈值后拥塞避免线性增长，<br> 出现丢包触发快重传，<br> 再通过快恢复直接回到拥塞避免。</p></blockquote><h3 id="面试题：TCP-和-UDP-有什么区别？"><a href="#面试题：TCP-和-UDP-有什么区别？" class="headerlink" title="面试题：TCP 和 UDP 有什么区别？"></a>面试题：TCP 和 UDP 有什么区别？</h3><p>口述模板（紧凑版）</p><p>TCP 和 UDP 的核心区别是：<br> <strong>TCP 面向连接、可靠、有序；UDP 无连接、不可靠、无序，但实时性更好。</strong></p><p><strong>连接方式</strong>：</p><ul><li>TCP 需要三次握手、四次挥手</li><li>UDP 直接发送，不建立连接</li></ul><p><strong>可靠性</strong>：</p><ul><li>TCP 通过序列号、ACK、重传、流量控制和拥塞控制保证可靠</li><li>UDP 不确认、不重传、不保证顺序</li></ul><p><strong>数据形式</strong>：</p><ul><li>TCP 面向字节流，可能粘包</li><li>UDP 面向报文，保留消息边界</li></ul><p><strong>性能特点</strong>：</p><ul><li>TCP 延迟较高但稳定</li><li>UDP 延迟低、开销小</li></ul><p><strong>典型场景</strong>：</p><ul><li>TCP：HTTP&#x2F;HTTPS、文件传输</li><li>UDP：音视频、实时通信、DNS</li></ul><h3 id="面试题：WebSocket-可以代替-UDP-的适用场景吗？"><a href="#面试题：WebSocket-可以代替-UDP-的适用场景吗？" class="headerlink" title="面试题：WebSocket 可以代替 UDP 的适用场景吗？"></a>面试题：<strong>WebSocket 可以代替 UDP 的适用场景吗？</strong></h3><p>口述模板（先给结论）</p><p><strong>WebSocket 不能完全代替 UDP 的适用场景，只能覆盖其中一部分。</strong><br> 因为两者的“实时性”来源于<strong>不同的层次</strong>。</p><hr><p>一、WebSocket 的实时性是什么？</p><p><strong>口述模板：</strong></p><p>WebSocket 的实时性体现在<strong>应用层</strong>，<br> 它相对于 HTTP 的优势在于：</p><ul><li>连接是<strong>长连接</strong></li><li><strong>服务器可以主动向客户端推送数据</strong></li></ul><p>但 WebSocket <strong>本质仍然是基于 TCP 的</strong>，<br> 数据依然以 <strong>TCP 报文</strong>传输，<br> 必须满足 TCP 的可靠性机制，包括：</p><ul><li>流量控制</li><li>拥塞控制</li><li>超时重传</li><li>有序传输</li></ul><p>因此，WebSocket 的实时性是<br> <strong>“可靠前提下的实时”</strong>。</p><hr><p>二、UDP 的实时性是什么？</p><p><strong>口述模板：</strong></p><p>UDP 的实时性体现在<strong>传输层</strong>，<br> 它通过<strong>主动牺牲可靠性</strong>来换取极低延迟。</p><p>UDP 的特点是：</p><ul><li>无连接</li><li>不确认</li><li>不重传</li><li>无流量控制、无拥塞控制</li></ul><p>数据一发即走，<br> <strong>延迟最低，但可能丢包、乱序</strong>。</p><hr><p>三、为什么 WebSocket 不能代替 UDP？</p><p><strong>口述模板：</strong></p><p>由于 WebSocket 运行在 TCP 之上，<br> 必须遵守 TCP 的可靠性和控制机制，<br> 在网络拥塞或丢包时：</p><ul><li>会等待确认</li><li>会触发重传</li><li>会降低发送速率</li></ul><p>这些机制虽然保证了可靠性，<br> 但也决定了 <strong>WebSocket 无法达到 UDP 的超低延迟</strong>。</p><hr><p>四、各自适用场景（面试官很爱听）</p><p><strong>WebSocket 适用场景：</strong></p><ul><li>即时聊天（IM）</li><li>实时通知 &#x2F; 推送</li><li>在线协作</li><li>实时监控面板<br> 👉 <strong>要求实时，但不能丢消息</strong></li></ul><p><strong>UDP 适用场景：</strong></p><ul><li>音视频通话 &#x2F; 直播</li><li>实时游戏状态同步</li><li>高速传感器数据<br> 👉 <strong>允许丢数据，但不能卡</strong></li></ul><h3 id="面试题：浏览器缓存有哪些？强缓存和协商缓存有什么区别？"><a href="#面试题：浏览器缓存有哪些？强缓存和协商缓存有什么区别？" class="headerlink" title="面试题：浏览器缓存有哪些？强缓存和协商缓存有什么区别？"></a>面试题：<strong>浏览器缓存有哪些？强缓存和协商缓存有什么区别？</strong></h3><p>口述模板（先给结论）</p><p>浏览器缓存主要分为<strong>强缓存</strong>和<strong>协商缓存</strong>。<br> <strong>强缓存优先级最高，其次才是协商缓存。</strong></p><hr><p>一、强缓存（Strong Cache）</p><p><strong>口述模板：</strong></p><p>强缓存是指<strong>浏览器直接从本地读取资源</strong>，<br> <strong>不再向服务器发送 HTTP 请求</strong>。</p><p>强缓存通过响应头来控制：</p><ul><li>**<code>Expires</code>**：设置一个绝对过期时间（HTTP&#x2F;1.0）</li><li>**<code>Cache-Control: max-age</code>**：设置相对过期时间（HTTP&#x2F;1.1，优先级更高）</li></ul><p>只要资源在有效期内：</p><ul><li>浏览器直接使用缓存</li><li>状态码通常显示为 <strong>200（from cache）</strong></li></ul><hr><p>二、协商缓存（Conditional Cache）</p><p><strong>口述模板：</strong></p><p>当强缓存<strong>失效或未命中</strong>时，<br> 浏览器会向服务器发送请求，<br> <strong>询问资源是否发生变化</strong>，这就是协商缓存。</p><p>协商缓存依赖的字段主要有：</p><ul><li><strong><code>Last-Modified / If-Modified-Since</code></strong></li><li><strong><code>ETag / If-None-Match</code></strong></li></ul><p>如果资源<strong>没有发生变化</strong>：</p><ul><li>服务器返回 <strong>304 Not Modified</strong></li><li>浏览器继续使用本地缓存</li></ul><p>如果资源<strong>发生变化</strong>：</p><ul><li>服务器返回 <strong>200 + 最新资源</strong></li><li>浏览器更新本地缓存</li></ul><h4 id="浏览器缓存本质是什么？"><a href="#浏览器缓存本质是什么？" class="headerlink" title="浏览器缓存本质是什么？"></a>浏览器缓存本质是什么？</h4><p><strong>口述模板：</strong></p><p>浏览器缓存本质上是 <strong>HTTP 缓存机制</strong>，<br> 用于<strong>减少网络请求、提升加载性能</strong>。</p><p>它的特点是：</p><ul><li>缓存的是 <strong>HTTP 请求返回的资源</strong></li><li>是否缓存、缓存多久 <strong>由服务器响应头控制</strong></li><li><strong>浏览器自动管理</strong>，前端不可精细干预</li><li>参与 <strong>强缓存 &#x2F; 协商缓存 &#x2F; 304</strong> 流程</li></ul><p>所以它是<strong>网络通信过程的一部分</strong>。</p><h4 id="点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h4><ul><li><strong>点击刷新按钮或者按 F5：</strong>浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li><li><strong>用户按 Ctrl+F5（强制刷新）：</strong>浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li><li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li></ul><h3 id="面试题：浏览器的存储方式有哪些？"><a href="#面试题：浏览器的存储方式有哪些？" class="headerlink" title="面试题：浏览器的存储方式有哪些？"></a>面试题：浏览器的存储方式有哪些？</h3><p>从工程视角看，浏览器存储主要分为四类：协议级存储 Cookie、页面级状态存储 Web Storage、本地数据层 IndexedDB，以及网络缓存层 Cache API。</p><p>Cookie 是 HTTP 协议级存储机制，主要用于会话保持和身份识别，最大特点是会在满足条件时自动随请求发送给服务器，并支持 HttpOnly、Secure、SameSite 等安全属性，因此非常适合存放 Session ID 等高安全信息，但不适合存储业务数据。</p><p>localStorage 和 sessionStorage 属于 Web Storage，用于在前端持久化保存少量状态数据，不参与 HTTP 请求。二者区别在于生命周期：localStorage 是持久化的、同源多标签共享；sessionStorage 只在当前标签页有效。它们都是同步 API，适合存储用户偏好或页面中间态，但不适合高频、大数据或安全敏感信息。</p><p>IndexedDB 是浏览器内置的本地数据库，支持异步 API、对象存储、索引和事务，能够存储大规模结构化数据。所有读写操作必须在事务中完成，通过原子提交和自动回滚保证数据一致性，因此 IndexedDB 通常作为前端的数据层，用于离线应用、大数据缓存或实时系统的数据缓冲。</p><p>Cache API 是用于缓存 HTTP 请求与响应的存储机制，通常与 Service Worker 配合使用，主要解决静态资源缓存、接口响应缓存、离线访问和首屏性能优化等问题。它缓存的是 Request-Response，而不是业务对象，与 IndexedDB 的职责是明确区分的。</p><p>总体来说，浏览器存储并不是相互替代关系，而是协议层、状态层、数据层和网络层各司其职，在实际工程中往往需要组合使用。</p><h3 id="面试题：HTTP-不同版本协议的区别？"><a href="#面试题：HTTP-不同版本协议的区别？" class="headerlink" title="面试题：HTTP 不同版本协议的区别？"></a>面试题：HTTP 不同版本协议的区别？</h3><p>口述模板（按时间线）</p><p><strong>HTTP&#x2F;1.0</strong></p><ul><li>短连接，请求完成即断开</li><li>每个请求都要重新建 TCP 连接，效率低</li></ul><p><strong>HTTP&#x2F;1.1</strong></p><ul><li>支持长连接（Keep-Alive）</li><li>支持 Host 头，完善缓存控制</li><li>仍然是<strong>串行请求</strong>，存在队头阻塞</li></ul><p><strong>HTTP&#x2F;2</strong></p><ul><li>基于 TCP</li><li><strong>多路复用</strong>：一个连接并发多个请求</li><li>二进制分帧、头部压缩、服务端推送</li><li>解决应用层队头阻塞，但仍受 TCP 丢包影响</li></ul><p><strong>HTTP&#x2F;3</strong></p><ul><li>基于 <strong>QUIC（UDP）</strong>，不再使用 TCP</li><li>每个流独立，<strong>彻底解决队头阻塞</strong></li><li>建连更快（0-RTT），支持连接迁移</li></ul><h3 id="面试题：HTTPS-是什么？它是如何保证安全性的？"><a href="#面试题：HTTPS-是什么？它是如何保证安全性的？" class="headerlink" title="面试题：HTTPS 是什么？它是如何保证安全性的？"></a>面试题：<strong>HTTPS 是什么？它是如何保证安全性的？</strong></h3><blockquote><p><a href="https://cxdlogver.github.io/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/9-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/">9.浏览器安全协议 - 相</a></p></blockquote><p>HTTPS（HyperText Transfer Protocol Secure）是 <strong>HTTP + TLS&#x2F;SSL</strong> 的组合。<br> 它的本质是：<strong>在 HTTP 的基础上，通过 TLS 协议为通信提供安全保障</strong>，确保浏览器与服务器之间的数据传输是安全的。</p><p>HTTPS 主要解决三个问题：</p><ul><li><strong>数据是否被窃听</strong></li><li><strong>数据是否被篡改</strong></li><li><strong>服务器身份是否可信</strong></li></ul><blockquote><p>HTTPS 通过非对称加密完成身份认证和密钥协商，再使用对称加密进行高效的数据传输，并结合完整性校验，保证通信过程不被窃听和篡改。</p></blockquote><p>HTTPS 本质上是 <strong>HTTP + TLS 协议</strong>，它的核心作用是 <strong>在不安全的网络环境中，保证浏览器与服务器之间通信的安全性</strong>，主要解决三类问题：<strong>数据是否被窃听、是否被篡改、以及服务器身份是否可信</strong>。</p><p>首先，HTTP 本身是明文传输的，如果只做数据完整性校验，比如使用哈希函数，中间人依然可以截获请求、修改内容、重新计算摘要，再转发给服务器，这样完整性校验仍然可以通过，所以 <strong>单纯依赖哈希并不能保证安全</strong>。</p><p>因此 HTTPS 的第二层是 <strong>对数据进行加密传输</strong>。在实际通信过程中，HTTPS 使用的是 <strong>对称加密算法</strong>。对称加密的特点是通信双方使用同一把密钥进行加解密，性能高、速度快，适合 HTTP 这种高频、持续的数据传输场景。</p><p>但对称加密存在一个核心问题：<strong>通信双方必须先安全地协商出这把对称密钥</strong>，而密钥协商本身又需要通过网络进行，这时网络仍然是不安全的。</p><p>为了解决这个问题，HTTPS 引入了 <strong>非对称加密机制</strong>。非对称加密有一对密钥：公钥和私钥。公钥是公开的，私钥只由服务器持有。客户端可以使用服务器的公钥加密数据，只有持有私钥的服务器才能解密，这样可以保证密钥协商过程不被中间人破解。</p><p>在这个过程中，服务器会通过 <strong>数字证书</strong> 将自己的公钥发送给客户端。客户端会对证书进行校验，以确认服务器身份的真实性，从而防止中间人伪造服务器。</p><p><strong>整个流程包括：</strong></p><p><strong>客户端发起请求</strong></p><ul><li>发送支持的加密算法</li><li>发送一个随机数</li></ul><p><strong>服务器响应</strong></p><ul><li>返回服务器随机数</li><li>返回服务器公钥</li><li>返回服务器证书</li></ul><p><strong>客户端校验证书</strong></p><ul><li>确认服务器身份可信</li></ul><p><strong>生成会话密钥</strong></p><ul><li>双方基于随机数 + 协商结果</li><li>得到同一把对称密钥</li></ul><p><strong>最终确认</strong></p><ul><li>双方发送加密校验消息</li><li>确认握手未被篡改</li></ul><p><strong>正式通信</strong></p><ul><li>使用对称加密 + 完整性校验</li><li>保证安全传输</li></ul><h4 id="一、为什么不用非对称加密直接加密所有数据？"><a href="#一、为什么不用非对称加密直接加密所有数据？" class="headerlink" title="一、为什么不用非对称加密直接加密所有数据？"></a>一、为什么不用非对称加密直接加密所有数据？</h4><p><strong>结论一句话：</strong><br> 因为<strong>非对称加密性能开销太大，不适合用于大量、持续的数据传输</strong>。</p><p><strong>展开说明：</strong></p><ol><li>非对称加密（如 RSA）计算复杂<ul><li>涉及大整数运算</li><li>加解密速度远慢于对称加密</li></ul></li><li>HTTP 通信是高频、连续的数据流<ul><li>一个页面可能包含大量请求和响应</li><li>如果全部用非对称加密，会严重影响性能和延迟</li></ul></li></ol><hr><h4 id="二、证书为什么能够解决身份认证问题？"><a href="#二、证书为什么能够解决身份认证问题？" class="headerlink" title="二、证书为什么能够解决身份认证问题？"></a>二、证书为什么能够解决身份认证问题？</h4><p><strong>结论一句话：</strong><br> 因为<strong>数字证书通过可信第三方（CA）对服务器公钥进行背书，防止公钥被伪造</strong>。</p><p><strong>展开说明：</strong></p><ol><li>服务器自己声明“这是我的公钥”是不可信的<ul><li>中间人也可以伪造一对公私钥</li><li>客户端无法判断公钥属于谁</li></ul></li><li>数字证书由 CA 机构签发<ul><li>CA 会校验服务器身份</li><li>再用 CA 的私钥对服务器公钥进行签名</li></ul></li><li>客户端内置了可信 CA 的公钥<ul><li>可以验证证书签名是否合法</li><li>从而确认：<ul><li>公钥未被篡改</li><li>公钥确实属于目标服务器</li></ul></li></ul></li></ol><p><strong>结论强化：</strong><br> 证书解决的是 <strong>“这个公钥到底是不是这个服务器的”</strong> 问题。</p><hr><h4 id="三、TLS-握手中的随机数是干什么的？"><a href="#三、TLS-握手中的随机数是干什么的？" class="headerlink" title="三、TLS 握手中的随机数是干什么的？"></a>三、TLS 握手中的随机数是干什么的？</h4><p><strong>结论一句话：</strong><br> 随机数用于 <strong>保证每一次 HTTPS 会话生成的密钥都是唯一的，防止重放和密钥复用攻击</strong>。</p><p><strong>展开说明：</strong></p><ol><li>TLS 握手过程中<ul><li>客户端和服务器都会各自生成随机数</li><li>这些随机数参与会话密钥的生成</li></ul></li><li>即使使用相同的证书和算法<ul><li>不同随机数会生成不同的会话密钥</li><li>保证每次连接的独立性</li></ul></li><li>安全意义在于：<ul><li>防止攻击者复用历史密钥</li><li>防止重放旧的加密通信内容</li></ul></li></ol><h3 id="面试题：常见网络攻击类型有哪些？"><a href="#面试题：常见网络攻击类型有哪些？" class="headerlink" title="面试题：常见网络攻击类型有哪些？"></a>面试题：常见网络攻击类型有哪些？</h3><p>1️⃣ 中间人攻击（Man-in-the-Middle, MITM）</p><p><strong>核心特征：</strong><br> 攻击者同时与客户端和服务器通信，双方都以为在“直连”。</p><p><strong>常见形式：</strong></p><ul><li>HTTP 明文劫持</li><li>伪造 HTTPS 证书</li><li>Wi-Fi 钓鱼热点</li></ul><p><strong>危害：</strong></p><ul><li>窃听数据</li><li>篡改请求和响应</li><li>注入恶意内容</li></ul><p><strong>HTTPS 主要就是为了解决这一类问题。</strong></p><hr><p>2️⃣ 重放攻击（Replay Attack）</p><p><strong>攻击方式：</strong></p><ul><li>攻击者截获一段合法请求</li><li>在之后的时间重复发送该请求</li></ul><p><strong>典型场景：</strong></p><ul><li>重复提交转账请求</li><li>重复使用已认证的数据包</li></ul><p><strong>防御方式：</strong></p><ul><li>使用随机数（nonce）</li><li>使用时间戳</li><li>会话级密钥</li></ul><hr><p>3️⃣ 窃听攻击（Eavesdropping）</p><p><strong>攻击方式：</strong></p><ul><li>被动监听网络流量</li><li>不修改数据，只读取内容</li></ul><p><strong>常见于：</strong></p><ul><li>HTTP 明文通信</li><li>公共 Wi-Fi</li></ul><p><strong>防御方式：</strong></p><ul><li>加密通信（HTTPS、TLS）</li></ul><hr><p>4️⃣ 数据篡改攻击（Tampering）</p><p><strong>攻击方式：</strong></p><ul><li>修改请求参数</li><li>修改响应内容</li><li>注入恶意脚本或错误数据</li></ul><p><strong>特点：</strong></p><ul><li>如果没有完整性校验，很难发现</li></ul><p><strong>防御方式：</strong></p><ul><li>MAC &#x2F; HMAC</li><li>TLS 完整性校验</li></ul><hr><p>5️⃣ 身份冒充攻击（Spoofing）</p><p><strong>常见类型：</strong></p><ul><li>IP 欺骗</li><li>DNS 欺骗</li><li>ARP 欺骗</li><li>服务器冒充</li></ul><p><strong>典型例子：</strong></p><ul><li>DNS 被污染，访问到假网站</li><li>返回伪造服务器证书</li></ul><p><strong>防御方式：</strong></p><ul><li>数字证书</li><li>CA 验证</li><li>DNSSEC（部分场景）</li></ul><hr><p>6️⃣ 会话劫持（Session Hijacking）</p><p><strong>攻击方式：</strong></p><ul><li>窃取 Cookie &#x2F; Session ID</li><li>冒充合法用户继续访问</li></ul><p><strong>常见原因：</strong></p><ul><li>Cookie 明文传输</li><li>XSS 注入</li><li>Session 固定攻击</li></ul><p><strong>防御方式：</strong></p><ul><li>HTTPS</li><li>HttpOnly &#x2F; Secure Cookie</li><li>Session 失效机制</li></ul><hr><p>7️⃣ 拒绝服务攻击（DoS &#x2F; DDoS）</p><p><strong>攻击目标：</strong></p><ul><li>让服务器无法正常提供服务</li></ul><p><strong>常见形式：</strong></p><ul><li>SYN Flood</li><li>HTTP Flood</li><li>分布式流量攻击（DDoS）</li></ul><p><strong>防御方式：</strong></p><ul><li>流量清洗</li><li>限流</li><li>CDN</li></ul><h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><h3 id="面试题：浏览器是如何渲染页面的？（完整流程题）"><a href="#面试题：浏览器是如何渲染页面的？（完整流程题）" class="headerlink" title="面试题：浏览器是如何渲染页面的？（完整流程题）"></a>面试题：浏览器是如何渲染页面的？（完整流程题）</h3><p><strong>口述模板：</strong></p><p>浏览器渲染页面可以拆成五个阶段：<br> 解析 HTML 构建 DOM 树，解析 CSS 构建 CSSOM 树，将 DOM 和 CSSOM 合并生成 Render Tree，然后进行 Layout 计算元素的几何信息，最后通过 Paint 将像素绘制到屏幕。</p><p>在这个过程中，HTML 解析、CSS 下载是并行的，但 Render Tree 的生成必须等待 DOM 和 CSSOM 都准备完成，这也是 CSS 会影响首屏渲染速度的根本原因。</p><hr><h3 id="面试题：HTML、CSS、JS-在渲染过程中是如何相互影响的？"><a href="#面试题：HTML、CSS、JS-在渲染过程中是如何相互影响的？" class="headerlink" title="面试题：HTML、CSS、JS 在渲染过程中是如何相互影响的？"></a>面试题：HTML、CSS、JS 在渲染过程中是如何相互影响的？</h3><p><strong>口述模板：</strong></p><p>HTML 负责结构，CSS 负责样式，JS 负责行为。<br> HTML 解析过程中可以并行下载 CSS，但 CSS 未解析完成之前，浏览器无法确定元素最终样式，因此会阻塞渲染。</p><p>而 JavaScript 因为可能读取或修改 DOM 和 CSSOM，一旦执行就必须保证它看到的是一致的结构和样式，因此默认情况下 JS 会阻塞 HTML 解析和渲染。</p><hr><h3 id="面试题：async-和-defer-在浏览器层面的本质区别是什么？"><a href="#面试题：async-和-defer-在浏览器层面的本质区别是什么？" class="headerlink" title="面试题：async 和 defer 在浏览器层面的本质区别是什么？"></a>面试题：async 和 defer 在浏览器层面的本质区别是什么？</h3><p><strong>口述模板：</strong></p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li>执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li>脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><hr><h3 id="面试题：CSS-为什么会阻塞-JS-执行？（高级追问）"><a href="#面试题：CSS-为什么会阻塞-JS-执行？（高级追问）" class="headerlink" title="面试题：CSS 为什么会阻塞 JS 执行？（高级追问）"></a>面试题：CSS 为什么会阻塞 JS 执行？（高级追问）</h3><p><strong>口述模板：</strong></p><p>如果 JavaScript 中访问了样式相关的 API，比如 <code>getComputedStyle</code>，而 CSSOM 尚未构建完成，浏览器就无法返回正确结果。因此在某些场景下，浏览器会等 CSS 加载和解析完成后再执行 JS，从而保证样式计算的准确性。</p><p>这也是为什么把 CSS 放在 head，把 JS 放在 body 底部有利于性能。</p><hr><h3 id="面试题：DOMContentLoaded-和-load-在渲染流程中的真实含义？"><a href="#面试题：DOMContentLoaded-和-load-在渲染流程中的真实含义？" class="headerlink" title="面试题：DOMContentLoaded 和 load 在渲染流程中的真实含义？"></a>面试题：DOMContentLoaded 和 load 在渲染流程中的真实含义？</h3><p><strong>口述模板：</strong></p><p>DOMContentLoaded 表示 HTML 解析完成、DOM 树构建完成，此时可以安全操作 DOM，但不保证图片、字体等资源加载完成。</p><p>load 事件则表示页面依赖的所有资源全部加载完成，包括图片、样式、脚本和 iframe，此时页面进入完全可交互状态。</p><p>从用户体验角度看，DOMContentLoaded 更接近“页面可用”，而 load 更接近“页面完全加载完成”。</p><hr><h3 id="面试题：回流（Layout）和重绘（Paint）在渲染中的角色？"><a href="#面试题：回流（Layout）和重绘（Paint）在渲染中的角色？" class="headerlink" title="面试题：回流（Layout）和重绘（Paint）在渲染中的角色？"></a>面试题：回流（Layout）和重绘（Paint）在渲染中的角色？</h3><p><strong>口述模板：</strong></p><p>Layout 负责计算元素的几何信息，比如位置和大小；Paint 负责将这些信息转化为像素绘制到屏幕。</p><p>修改元素的尺寸、位置、字体大小等会触发回流，而只修改颜色、背景等不影响布局的属性通常只会触发重绘。回流的性能开销远大于重绘，因此在实际开发中需要尽量减少回流次数。</p><hr><h3 id="面试题：为什么说“减少-DOM-操作可以提升性能”？"><a href="#面试题：为什么说“减少-DOM-操作可以提升性能”？" class="headerlink" title="面试题：为什么说“减少 DOM 操作可以提升性能”？"></a>面试题：为什么说“减少 DOM 操作可以提升性能”？</h3><p><strong>口述模板：</strong></p><p>DOM 的任何修改都有可能触发样式重新计算、回流和重绘，尤其是在频繁操作 DOM 时，会导致渲染流水线被反复打断。</p><p>因此常见的优化手段包括：<br> 批量修改 DOM、使用文档片段、避免在循环中频繁读取布局信息，以及通过 CSS 动画代替 JS 驱动的动画。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><blockquote><p><a href="https://www.yuque.com/cuggz/feplus/fy7hl8#V6pcu">进程与线程</a></p><p><a href="https://www.yuque.com/cuggz/interview/browser#e5da94c4ea214cc0b8f68f36354cfc1b">前端面试题之浏览器原理篇</a></p></blockquote><h3 id="面试题：什么是进程和线程？"><a href="#面试题：什么是进程和线程？" class="headerlink" title="面试题：什么是进程和线程？"></a>面试题：什么是进程和线程？</h3><p>进程是操作系统进行<strong>资源分配的最小单位</strong>，每个进程都有独立的地址空间、内存、文件描述符等资源。<br> 线程是操作系统进行<strong>CPU 调度的最小单位</strong>，线程必须依附于进程存在，一个进程可以包含多个线程。<br> 同一进程内的线程<strong>共享进程资源</strong>，但各自拥有独立的执行栈和程序计数器，因此线程切换成本比进程更低。</p><p><strong>进程和线程的区别可以从三个层面理解：</strong></p><p>第一，<strong>本质不同</strong>。<br> 进程是一个正在运行的程序实例，是资源的拥有者；<br> 线程是进程中的执行单元，负责具体的代码执行。</p><p>第二，<strong>资源隔离程度不同</strong>。<br> 进程之间资源相互隔离，通信需要通过 IPC；<br> 同一进程内的线程共享内存、全局变量、文件句柄，因此通信成本低，但安全性更弱。</p><p>第三，<strong>调度与性能不同</strong>。<br> 线程是 CPU 调度的基本单位，线程切换只涉及寄存器和栈，开销小；<br> 进程切换需要切换地址空间，开销更大，但稳定性和安全性更好。</p><p>一句话总结：<br> <strong>进程负责“隔离和资源”，线程负责“并发和执行”。</strong></p><hr><h3 id="面试题：浏览器的进程有哪些？"><a href="#面试题：浏览器的进程有哪些？" class="headerlink" title="面试题：浏览器的进程有哪些？"></a>面试题：浏览器的进程有哪些？</h3><ul><li>1 个浏览器主进程</li><li>1 个 GPU 进程</li><li>1 个网络进程</li><li>多个渲染进程</li><li>多个插件进程</li></ul><p>这些进程的功能：</p><ul><li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ul><li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><h3 id="面试题：浏览器为什么要多进程"><a href="#面试题：浏览器为什么要多进程" class="headerlink" title="面试题：浏览器为什么要多进程"></a>面试题：<strong>浏览器为什么要多进程</strong></h3><p>浏览器采用多进程架构，主要是为了解决 <strong>稳定性、安全性和性能</strong> 三个问题。<br> 单进程模型下，一个页面崩溃会导致整个浏览器崩溃，而且 JS 阻塞会卡死 UI。<br> 多进程通过把不同页面和功能拆分到独立进程中，实现 <strong>页面隔离、崩溃隔离和安全沙箱</strong>，同时提升多核 CPU 的利用率。</p><p>浏览器之所以使用多进程，核心原因有三点：</p><p>第一，<strong>稳定性</strong>。<br> 一个渲染进程崩溃，只会影响当前标签页，不会导致整个浏览器退出。</p><p>第二，<strong>安全性</strong>。<br> 不同页面运行在不同进程中，配合沙箱机制，可以防止恶意脚本跨站点窃取数据。</p><p>第三，<strong>性能与并行能力</strong>。<br> 多进程可以充分利用多核 CPU，让多个页面同时渲染、执行 JS 和发起网络请求。</p><p>一句话总结：<br> <strong>多进程是浏览器在复杂网页场景下，实现高并发、高安全、高稳定的基础架构选择。</strong></p><hr><h3 id="面试题：渲染进程里有哪些线程"><a href="#面试题：渲染进程里有哪些线程" class="headerlink" title="面试题：渲染进程里有哪些线程"></a>面试题：<strong>渲染进程里有哪些线程</strong></h3><p>渲染进程内部是多线程结构，主要包括：</p><ol><li><strong>GUI 渲染线程</strong>：负责 DOM、CSSOM、布局和绘制</li><li><strong>JS 引擎线程</strong>：负责执行 JavaScript</li><li><strong>事件触发线程</strong>：管理事件循环</li><li><strong>定时器线程</strong>：处理 setTimeout、setInterval</li><li><strong>异步网络线程</strong>：处理 fetch、XHR 回调</li></ol><p>其中 <strong>GUI 渲染线程和 JS 引擎线程互斥执行</strong>。</p><p>渲染进程内部最核心的是两条线程：</p><p>第一，<strong>GUI 渲染线程</strong><br> 负责解析 HTML 和 CSS，生成 DOM 树、CSSOM，完成布局和绘制。</p><p>第二，<strong>JS 引擎线程</strong><br> 负责执行 JavaScript 代码，比如事件回调、同步脚本逻辑。</p><p>为了保证页面状态一致性，这两个线程 <strong>不能同时执行</strong>，<br> 所以当 JS 执行时间过长时，会阻塞页面渲染，导致卡顿。</p><p>除此之外，还有：</p><ul><li>事件触发线程：维护事件队列</li><li>定时器线程：管理时间到期的回调</li><li>网络线程：处理异步请求结果</li></ul><p>一句话总结：<br> <strong>渲染进程是“多线程协作”，但 JS 与渲染是互斥的。</strong></p><h3 id="面试题：一次页面打开涉及哪些进程"><a href="#面试题：一次页面打开涉及哪些进程" class="headerlink" title="面试题：一次页面打开涉及哪些进程"></a>面试题：<strong>一次页面打开涉及哪些进程</strong></h3><p>一次页面打开，主要涉及：</p><ol><li><strong>浏览器主进程</strong>：处理地址栏输入，创建渲染进程</li><li><strong>网络进程</strong>：发起 HTTP 请求，下载 HTML 和资源</li><li><strong>渲染进程</strong>：解析 HTML&#x2F;CSS，执行 JS，渲染页面</li><li><strong>GPU 进程</strong>：负责页面合成和图形加速（如果需要）</li></ol><p>完整流程可以分为四步：</p><p>第一步，用户输入 URL，<strong>浏览器主进程</strong> 进行导航决策，判断是否新建渲染进程。</p><p>第二步，<strong>网络进程</strong> 发起请求，获取 HTML 文档和相关资源。</p><p>第三步，HTML 返回后，<strong>渲染进程</strong> 开始解析 HTML、CSS，构建 DOM 树，执行 JS，并进行页面布局和绘制。</p><p>第四步，如果涉及动画、3D、Canvas 等，<strong>GPU 进程</strong> 参与页面合成，提高渲染性能。</p><p>一句话总结：<br> <strong>主进程负责调度，网络进程负责请求，渲染进程负责页面，GPU 进程负责加速。</strong></p><h3 id="面试题：进程之间的通信有哪些？"><a href="#面试题：进程之间的通信有哪些？" class="headerlink" title="面试题：进程之间的通信有哪些？"></a>面试题：进程之间的通信有哪些？</h3><p><strong>进程之间通信，本质是解决两个问题：</strong></p><p>第一，<strong>如何把数据从一个进程传给另一个进程</strong>；<br> 第二，<strong>如何在相互隔离的地址空间中保证数据安全和同步</strong>。</p><p>因此操作系统提供了多种 IPC 机制，比如 <strong>管道、消息队列、共享内存、信号、Socket</strong>。<br> 其中共享内存效率最高，但需要自己做同步；<br> Socket 最通用，既能进程通信，也能跨机器通信。</p><p>进程之间之所以需要通信，是因为 <strong>进程拥有独立的地址空间，不能直接读写彼此内存</strong>。<br> IPC 的核心思想可以总结为三类：</p><p>第一类，<strong>基于内核中转的通信</strong><br> 比如管道、消息队列。<br> 数据需要先从进程 A 拷贝到内核，再拷贝到进程 B，安全但性能一般。</p><p>第二类，<strong>基于共享内存的通信</strong><br> 多个进程映射同一块物理内存，读写效率最高。<br> 但操作系统只负责“共享”，<strong>不负责同步</strong>，需要配合信号量或互斥锁。</p><p>第三类，<strong>基于网络抽象的通信</strong><br> 比如 Socket，把本地进程通信抽象成网络通信模型，通用性最强。</p><p>一句话总结：<br> <strong>IPC 的本质是在“隔离”和“共享”之间做权衡。</strong></p><p><strong>常见 IPC 方式速记版</strong></p><ol><li>管道（Pipe）</li></ol><ul><li>半双工</li><li>主要用于父子进程</li><li>简单，但不适合大量数据</li></ul><ol start="2"><li>消息队列</li></ol><ul><li>按消息发送</li><li>解耦发送方和接收方</li><li>有格式，但性能一般</li></ul><ol start="3"><li>共享内存</li></ol><ul><li>速度最快</li><li>多进程直接访问同一块内存</li><li><strong>必须自己处理并发安全</strong></li></ul><ol start="4"><li>信号 &#x2F; 信号量</li></ol><ul><li>信号：通知事件发生</li><li>信号量：控制并发访问</li><li>常用于同步，而不是大量数据传输</li></ul><ol start="5"><li>Socket</li></ol><ul><li>最通用</li><li>可本地、可远程</li><li>Web 服务、浏览器进程通信常用</li></ul><p><strong>浏览器多进程之间如何通信？</strong></p><p>浏览器通常采用 <strong>基于消息的 IPC</strong>：</p><ul><li>主进程 ↔ 渲染进程</li><li>通过序列化消息进行通信</li><li>避免直接共享内存，提升安全性</li></ul><p>把请求和数据序列化成消息，由主进程、网络进程等统一处理，从而保证安全性和稳定性。</p><p>例如：<br> 用户点击页面 → 渲染进程发送事件消息 → 主进程处理 → 返回结果。</p><p>网页里写了：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">&#x27;/api/data&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure><p>你以为是 JS 在发请求？不是。</p><p>真实流程是：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">JS（渲染进程）<br> → 发消息：我要请求这个 <span class="hljs-built_in">URL</span><br> → 网络进程真的去请求<br> → 再把结果“传纸条”回来<br></code></pre></td></tr></table></figure><h3 id="面试题：产生死锁的原因和预防方法？"><a href="#面试题：产生死锁的原因和预防方法？" class="headerlink" title="面试题：产生死锁的原因和预防方法？"></a>面试题：产生死锁的原因和预防方法？</h3><p><strong>产生死锁的原因：</strong></p><p><strong>（1）竞争资源</strong></p><ul><li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li><li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li></ul><p><strong>（2）进程间推进顺序非法</strong></p><p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p><p><strong>产生死锁的必要条件：</strong></p><ul><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li></ul><p><strong>预防死锁的方法：</strong></p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="面试题：CDN-和-Service-worker是什么？"><a href="#面试题：CDN-和-Service-worker是什么？" class="headerlink" title="面试题：CDN 和 Service worker是什么？"></a>面试题：CDN 和 Service worker是什么？</h3><p>一、CDN 的介绍（面试模板）</p><p><strong>CDN（内容分发网络）</strong> 是通过在全球各地部署边缘节点，把静态资源缓存到离用户最近的节点，从而减少网络延迟、减轻源站压力、提升访问速度。<br> 用户请求资源时，优先从就近节点命中缓存，只有未命中时才回源站。</p><hr><p>CDN 的核心思想是 <strong>“空间换时间”</strong>。</p><p>当用户访问资源时：</p><ol><li>请求首先到达 CDN 节点</li><li>如果节点有缓存，直接返回（命中）</li><li>如果没有缓存，向源站请求资源并缓存下来（回源）</li></ol><p>CDN 主要解决三类问题：</p><ul><li><strong>访问速度慢</strong>（就近访问）</li><li><strong>源站压力大</strong>（请求被分流）</li><li><strong>高并发不稳定</strong>（节点分担流量）</li></ul><p>一句话总结：<br> <strong>CDN 是网络层面的缓存和加速方案。</strong></p><p><strong>CDN 通常缓存什么？</strong></p><ul><li>JS &#x2F; CSS &#x2F; 图片 &#x2F; 视频</li><li>部分可缓存的接口响应（配合缓存策略）</li></ul><p><strong>CDN 是否一定比源站快？</strong></p><p><strong>CDN的工作原理：</strong></p><p>（1）用户未使用CDN缓存资源的过程：</p><ol><li>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</li><li>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</li><li>服务器向浏览器返回响应数据</li></ol><p>（2）用户使用CDN缓存资源的过程：</p><ol><li>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</li><li>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</li><li>用户向CDN的全局负载均衡设备发起数据请求</li><li>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li><li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</li><li>全局负载均衡设备把服务器的IP地址返回给用户</li><li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li></ol><p>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</p><p> 不一定，首次请求或缓存未命中时仍需回源。</p><hr><p>二、Service Worker 的介绍（面试模板）</p><p><strong>Service Worker 是运行在浏览器中的独立脚本线程</strong>，位于页面和网络之间，可以拦截网络请求，实现资源缓存、离线访问和请求控制，是 PWA 的核心能力之一。</p><p>Service Worker 的本质是一个 <strong>浏览器侧的网络代理</strong>。</p><p>它的特点包括：</p><ul><li>不运行在主线程，不阻塞页面渲染</li><li>可以拦截 <code>fetch</code> 请求</li><li>可以把请求结果缓存到 Cache Storage</li><li>在离线或弱网环境下返回缓存内容</li></ul><p>典型工作流程是：</p><ol><li>页面注册 Service Worker</li><li>Service Worker 安装并激活</li><li>拦截请求，决定 <strong>走网络 &#x2F; 走缓存 &#x2F; 组合返回</strong></li></ol><p>一句话总结：<br> <strong>Service Worker 是客户端层面的缓存和请求控制机制。</strong></p><p><strong>Service Worker 能缓存接口请求吗？</strong><br> 可以，只要是 <code>fetch</code> 请求，都可以被拦截并缓存。</p><p><strong>Service Worker 和 HTTP 缓存的关系？</strong><br> Service Worker 的优先级更高，可以完全绕过 HTTP 缓存规则。</p><hr><p>CDN 和 Service Worker 都能提升访问速度，但<strong>层级不同、职责不同</strong>：</p><ul><li>CDN 工作在 <strong>网络侧 &#x2F; 服务器侧</strong></li><li>Service Worker 工作在 <strong>浏览器侧 &#x2F; 客户端</strong></li></ul><p>CDN 解决的是 <strong>“资源怎么更快送到用户”</strong>，<br> Service Worker 解决的是 <strong>“浏览器怎么更聪明地用资源”</strong>。</p><table><thead><tr><th>对比维度</th><th>CDN</th><th>Service Worker</th></tr></thead><tbody><tr><td>工作位置</td><td>网络边缘节点</td><td>浏览器内部</td></tr><tr><td>是否依赖浏览器</td><td>否</td><td>是</td></tr><tr><td>是否支持离线</td><td>否</td><td>是</td></tr><tr><td>控制粒度</td><td>粗（文件级）</td><td>细（请求级）</td></tr><tr><td>典型用途</td><td>静态资源加速</td><td>离线、缓存策略</td></tr></tbody></table><blockquote><p>实际项目中，通常 <strong>CDN + Service Worker 结合使用</strong>：<br> CDN 负责首次访问和大规模分发，<br> Service Worker 负责二次访问、离线体验和弱网优化。</p></blockquote><h3 id="面试题：懒加载和预加载"><a href="#面试题：懒加载和预加载" class="headerlink" title="面试题：懒加载和预加载"></a>面试题：懒加载和预加载</h3><h4 id="面试题一：什么是懒加载？它解决了什么问题？"><a href="#面试题一：什么是懒加载？它解决了什么问题？" class="headerlink" title="面试题一：什么是懒加载？它解决了什么问题？"></a>面试题一：什么是懒加载？它解决了什么问题？</h4><p><strong>口述回答模板：</strong></p><p>本质：<strong>代码分割（Code Splitting）+ 按需加载（On-Demand Loading）</strong>。</p><p>懒加载指的是：资源并不是在页面一开始就全部加载，而是等到真正需要使用的时候才去加载。<br> 这里的资源可以是图片、组件、路由模块，甚至是数据请求。</p><p>引入懒加载的根本原因在于性能优化。现代前端页面资源体积越来越大，如果在首屏阶段一次性加载所有内容，会显著拉长首屏渲染时间，影响用户体验。懒加载通过“延后非关键资源”的加载时机，把带宽和计算资源优先留给首屏和核心功能。</p><p>从工程角度看，懒加载的本质不是少加载，而是<strong>把加载时机推迟到最合适的时间点</strong>，从而在性能和功能之间取得平衡。</p><hr><h4 id="面试题二：什么是预加载？和懒加载的出发点有什么不同？"><a href="#面试题二：什么是预加载？和懒加载的出发点有什么不同？" class="headerlink" title="面试题二：什么是预加载？和懒加载的出发点有什么不同？"></a>面试题二：什么是预加载？和懒加载的出发点有什么不同？</h4><p><strong>口述回答模板：</strong></p><p>预加载的思路和懒加载恰好相反。<br> 预加载是指：在当前阶段还没用到某些资源时，<strong>提前把它们加载到浏览器中</strong>，以便在真正需要时能够立刻使用。</p><p>预加载的出发点不是减少请求数量，而是减少“等待时间”。<br> 比如用户接下来很可能会跳转到下一个页面，如果等到真正跳转时才开始加载资源，就会产生明显的延迟。预加载则是利用浏览器空闲时间，提前准备好未来可能用到的资源。</p><p>因此，预加载关注的是<strong>未来体验的平滑性</strong>，而懒加载关注的是<strong>当前性能的优化</strong>。</p><hr><h4 id="面试题三：懒加载和预加载的核心区别是什么？"><a href="#面试题三：懒加载和预加载的核心区别是什么？" class="headerlink" title="面试题三：懒加载和预加载的核心区别是什么？"></a>面试题三：懒加载和预加载的核心区别是什么？</h4><p><strong>口述回答模板：</strong></p><p>懒加载和预加载的核心区别在于加载时机和目标不同。</p><p>懒加载强调“<strong>非必要不加载</strong>”，优先保证当前页面和首屏体验，把非关键资源推迟到真正需要时再加载；<br> 预加载强调“<strong>即将需要先准备</strong>”，在不影响当前性能的前提下，提前加载未来高概率会用到的资源。</p><p>可以理解为：懒加载是减法，减少首屏负担；预加载是加法，减少未来等待。<br> 在实际工程中，两者并不是对立关系，而是常常配合使用。</p><hr><h4 id="面试题四：前端常见的懒加载和预加载应用场景有哪些？"><a href="#面试题四：前端常见的懒加载和预加载应用场景有哪些？" class="headerlink" title="面试题四：前端常见的懒加载和预加载应用场景有哪些？"></a>面试题四：前端常见的懒加载和预加载应用场景有哪些？</h4><p><strong>口述回答模板：</strong></p><p>懒加载最常见的场景包括：图片懒加载、路由级代码拆分、组件级异步加载以及滚动加载列表数据。这些场景的共同点是：资源在首屏并不一定会用到，但体积或数量较大。</p><p>预加载常见于：路由切换、用户行为可预测的页面跳转、关键交互所需的脚本或样式提前准备等。<br> 比如用户 hover 到某个菜单项时，提前加载对应页面的代码，就是一种典型的预加载策略。</p><p>在复杂应用中，是否使用懒加载或预加载，取决于资源是否关键、使用时机是否可预测以及当前网络和设备性能。</p><hr><h4 id="面试题五：懒加载和预加载在构建和运行阶段是如何实现的？"><a href="#面试题五：懒加载和预加载在构建和运行阶段是如何实现的？" class="headerlink" title="面试题五：懒加载和预加载在构建和运行阶段是如何实现的？"></a>面试题五：懒加载和预加载在构建和运行阶段是如何实现的？</h4><p><strong>口述回答模板：</strong></p><p>从构建角度看，懒加载通常依赖代码拆分，把大资源拆成多个独立块，在运行时按需加载。<br> 而预加载更多是通过构建工具或浏览器机制，提前告诉浏览器“某些资源很快会用到”，从而在合适的时机加载。</p><p>从运行时角度看，懒加载往往和用户行为相关，比如滚动、点击、路由切换；<br> 预加载则更多依赖浏览器调度和开发者对用户路径的预判。</p><p>本质上，两者都是在<strong>控制浏览器加载资源的优先级和时机</strong>。</p><h4 id="面试题：什么是-preload-和-prefetch？它们有什么区别？"><a href="#面试题：什么是-preload-和-prefetch？它们有什么区别？" class="headerlink" title="面试题：什么是 preload 和 prefetch？它们有什么区别？"></a>面试题：什么是 preload 和 prefetch？它们有什么区别？</h4><p><strong>口述回答模板：</strong></p><p>preload 和 prefetch 都是浏览器提供的<strong>资源预加载机制</strong>，本质目的都是：提前获取资源，减少用户等待时间。但它们解决的问题不同，加载优先级和使用时机也完全不同。</p><p>preload 的含义是：<strong>当前页面“马上就要用到”的关键资源，要求浏览器尽早加载</strong>。<br> 它的特点是优先级高，浏览器会把 preload 的资源当作当前页面渲染路径上的一部分来对待。<br> 典型场景是：关键脚本、关键样式、首屏字体等，如果这些资源不及时加载，就会直接影响当前页面的渲染或交互。</p><p>prefetch 的含义是：<strong>当前页面暂时用不到，但未来很可能会用到的资源，提前在空闲时加载</strong>。<br> 它的特点是优先级低，浏览器只会在网络和主线程空闲时才去加载，不会影响当前页面的关键资源。<br> 典型场景是：用户可能即将跳转到的下一个页面所需的脚本或数据。</p><p>从时间维度上看，preload 面向的是“现在”，prefetch 面向的是“将来”；</p><p>从优先级上看，preload 是高优先级，prefetch 是低优先级</p><p>从使用目的上看，preload 是为了解决当前页面性能瓶颈，prefetch 是为了提升未来页面切换的流畅度。</p><h3 id="面试题：对节流与防抖的理解"><a href="#面试题：对节流与防抖的理解" class="headerlink" title="面试题：对节流与防抖的理解"></a>面试题：对节流与防抖的理解</h3><p><strong>口述回答模板：</strong></p><p>节流和防抖都是用来控制高频事件触发频率的手段，解决的问题是：像 scroll、resize、mousemove、input 这种事件触发太密集，会导致频繁执行回调，带来性能问题或者重复请求。</p><p>防抖的思路是“只要触发就重新计时”，也就是事件持续触发时不执行，等到停止触发一段时间后才执行一次。它适合“只关心最终结果”的场景，比如搜索框输入联想、窗口大小调整完成后的重新计算、表单校验等。</p><p>节流的思路是“固定时间窗口最多执行一次”，不管事件多频繁，回调都按节奏执行。它适合“需要过程反馈”的场景，比如滚动监听上报、拖拽过程位置更新、页面滚动加载、mousemove 跟随效果等。</p><p>工程上常见的区别点是：防抖更像把多次触发合并成最后一次；节流更像把触发频率压到一个可控范围。两者都可以做“立即执行”或“尾部再补一次”的变种，具体选哪种取决于业务要的是开始响应、过程响应还是结束响</p><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>];<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 时间戳版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>],<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 定时器版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span> (<span class="hljs-params">fun, wait</span>)&#123;<br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>]<br>    <span class="hljs-keyword">if</span>(!timeout)&#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fun.<span class="hljs-title function_">apply</span>(context, args)<br>        timeout = <span class="hljs-literal">null</span> <br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="面试题：HTTP-状态码概念"><a href="#面试题：HTTP-状态码概念" class="headerlink" title="面试题：HTTP 状态码概念"></a>面试题：HTTP 状态码概念</h3><p>HTTP 状态码用于表示服务器对请求的处理结果，按首位数字分为五类。</p><hr><p>状态码分类</p><ul><li><strong>1xx</strong>：信息（处理中）</li><li><strong>2xx</strong>：成功</li><li><strong>3xx</strong>：重定向</li><li><strong>4xx</strong>：客户端错误</li><li><strong>5xx</strong>：服务器错误</li></ul><hr><p>高频状态码（必背）</p><p><strong>2xx</strong></p><ul><li><strong>200 OK</strong>：请求成功</li><li><strong>201 Created</strong>：资源创建成功</li><li><strong>204 No Content</strong>：成功但无返回体</li></ul><p><strong>3xx</strong></p><ul><li><strong>301 Moved Permanently</strong>：永久重定向（可缓存）</li><li><strong>302 Found</strong>：临时重定向</li><li><strong>304 Not Modified</strong>：资源未修改，使用缓存</li></ul><p><strong>4xx</strong></p><ul><li><strong>400 Bad Request</strong>：请求参数或格式错误</li><li><strong>401 Unauthorized</strong>：未认证（未登录 &#x2F; token 失效）</li><li><strong>403 Forbidden</strong>：已认证但无权限</li><li><strong>404 Not Found</strong>：资源不存在</li></ul><p><strong>5xx</strong></p><ul><li><strong>500 Internal Server Error</strong>：服务器内部错误</li><li><strong>502 Bad Gateway</strong>：网关收到无效上游响应</li><li><strong>503 Service Unavailable</strong>：服务不可用（过载 &#x2F; 维护）</li><li><strong>504 Gateway Timeout</strong>：网关请求上游超时</li></ul><hr><p>面试一句话总结</p><blockquote><p><strong>2xx 成功，3xx 跳转，4xx 客户端错，5xx 服务端错；401 是没身份，403 是没权限，304 是用缓存。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django从0到1搭建</title>
    <link href="/2025/12/05/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Django%E4%BB%8E0%E5%88%B01/"/>
    <url>/2025/12/05/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Django%E4%BB%8E0%E5%88%B01/</url>
    
    <content type="html"><![CDATA[<p>实现一个Django从0到1的搭建过程。</p><span id="more"></span><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><h4 id="Django-DRF基础教程（前后端分离）"><a href="#Django-DRF基础教程（前后端分离）" class="headerlink" title="Django+DRF基础教程（前后端分离）"></a><a href="https://blog.csdn.net/m0_71273766/article/details/133218567">Django+DRF基础教程（前后端分离）</a></h4><h4 id="django框架向DRF框架演变过程详解"><a href="#django框架向DRF框架演变过程详解" class="headerlink" title="django框架向DRF框架演变过程详解"></a><a href="https://blog.csdn.net/qq_39208536/article/details/131701180">django框架向DRF框架演变过程详解</a></h4><h4 id="一文到底——Django使用教程"><a href="#一文到底——Django使用教程" class="headerlink" title="一文到底——Django使用教程"></a><a href="https://blog.csdn.net/Ans_min/article/details/123146335"><strong>一文到底——Django使用教程</strong></a></h4><h4 id="Django官方文档"><a href="#Django官方文档" class="headerlink" title="Django官方文档"></a><a href="https://docs.djangoproject.com/zh-hans/5.0/">Django官方文档</a></h4></blockquote><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h3 id="项目总览"><a href="#项目总览" class="headerlink" title="项目总览"></a>项目总览</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装</span><br>pip install django<br><span class="hljs-comment"># 创建项目</span><br>django-admin startproject mysite<br><span class="hljs-comment"># 创建APP应用</span><br>python manage.py startapp blog<br><span class="hljs-comment"># 目录结构</span><br>mysite/<br>    manage.py<br>    mysite/           <span class="hljs-comment"># 配置目录</span><br>        settings.py<br>        urls.py<br>        wsgi.py<br><span class="hljs-comment"># 运行项目</span><br>python manage.py runserver<br><span class="hljs-comment"># 浏览器访问</span><br>http://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8000</span>/ <span class="hljs-comment"># 默认</span><br></code></pre></td></tr></table></figure><blockquote><p>Django 采用 <strong>“一个项目 Project + 多个应用 App”</strong> 的结构。</p></blockquote><p><img src="/2025/12/05/后端学习/Django从0到1/1aICZBUzrgLgc5GoWuiFHcw.jpegutm_source=chatgpt.jpeg" alt="How to Structure Your Django Project" style="zoom: 50%;"><img src="/2025/12/05/后端学习/Django从0到1/1jRO4h3b3f8cmsxW81NCoig.pngutm_source=chatgpt-1764944514302-1.png" alt="Django Project Architecture: The best project skeleton ever. | by Mandanka  Rajan | Medium" style="zoom: 33%;"></p><h4 id="从0到1的一个Django示例"><a href="#从0到1的一个Django示例" class="headerlink" title="从0到1的一个Django示例"></a>从0到1的一个Django示例</h4><p><a href="https://github.com/cxDlogver/Front_End/tree/main/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/mysite">Front_End&#x2F;实战项目&#x2F;mysite at main · cxDlogver&#x2F;Front_End</a></p><h3 id="项目基本结构"><a href="#项目基本结构" class="headerlink" title="项目基本结构"></a>项目基本结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">mysite/<br>    manage.py<br>    mysite/<br>        __init__.py<br>        settings.py<br>        urls.py<br>        asgi.py<br>        wsgi.py<br>    blog/<br>        __init__.py<br>        admin.py<br>        apps.py<br>        models.py<br>        tests.py<br>        views.py<br>        migrations/<br>            __init__.py<br></code></pre></td></tr></table></figure><h4 id="1-manage-py"><a href="#1-manage-py" class="headerlink" title="1. manage.py"></a>1. manage.py</h4><p>位置：<code>mysite/manage.py</code></p><p>基本代码示例（创建后）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;mysite.settings&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">from</span> django.core.management <span class="hljs-keyword">import</span> execute_from_command_line<br>    <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-keyword">raise</span> ImportError(<br>            <span class="hljs-string">&quot;Couldn&#x27;t import Django.&quot;</span><br>        ) <span class="hljs-keyword">from</span> exc<br>    execute_from_command_line(sys.argv)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>作用</p><ul><li>整个 Django 项目的命令入口。</li><li>负责加载 <code>mysite.settings</code>，并执行各种 <code>manage.py</code> 子命令。</li><li>Django 的 <code>python manage.py &lt;command&gt;</code> 指令体系是<strong>由 manage.py 调用 Django 的命令框架（django.core.management）实现的</strong>。</li><li>Django 从两类位置加载命令： 内置 commands + INSTALLED_APPS 的 custom commands， 每个APP可以自定义命令。</li></ul><p>常用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py runserver          <span class="hljs-comment"># 启动开发服务器</span><br>python manage.py startapp blog      <span class="hljs-comment"># 创建应用</span><br>python manage.py makemigrations     <span class="hljs-comment"># 创建迁移文件</span><br>python manage.py migrate            <span class="hljs-comment"># 应用迁移到数据库</span><br>python manage.py createsuperuser    <span class="hljs-comment"># 创建后台管理员</span><br>python manage.py shell              <span class="hljs-comment"># 启动 Django shell</span><br></code></pre></td></tr></table></figure><blockquote><p>一般不修改此文件。</p></blockquote><h4 id="2-项目包-mysite"><a href="#2-项目包-mysite" class="headerlink" title="2. 项目包 mysite&#x2F;"></a>2. 项目包 mysite&#x2F;</h4><h5 id="2-1-mysite-init-py"><a href="#2-1-mysite-init-py" class="headerlink" title="2.1 mysite&#x2F;init.py"></a>2.1 mysite&#x2F;<strong>init</strong>.py</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 空文件，一般是空的或只做版本标记</span><br></code></pre></td></tr></table></figure><p>作用：标记 <code>mysite</code> 为一个 Python 包。一般不改。</p><hr><h5 id="2-2-mysite-settings-py"><a href="#2-2-mysite-settings-py" class="headerlink" title="2.2 mysite&#x2F;settings.py"></a>2.2 mysite&#x2F;settings.py</h5><p>项目的全局配置文件。</p><p>精简示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>BASE_DIR = Path(__file__).resolve().parent.parent<br><br>SECRET_KEY = <span class="hljs-string">&#x27;开发环境随机密钥&#x27;</span><br><br>DEBUG = <span class="hljs-literal">True</span><br><br>ALLOWED_HOSTS = []  <span class="hljs-comment"># 部署时改为域名 / IP</span><br><br>INSTALLED_APPS = [<br>    <span class="hljs-string">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br><br>    <span class="hljs-string">&#x27;blog&#x27;</span>,  <span class="hljs-comment"># 自己的应用</span><br>]<br><br>MIDDLEWARE = [<br>    <span class="hljs-string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]<br><br>ROOT_URLCONF = <span class="hljs-string">&#x27;mysite.urls&#x27;</span><br><br>TEMPLATES = [<br>    &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,<br>        <span class="hljs-string">&#x27;DIRS&#x27;</span>: [BASE_DIR / <span class="hljs-string">&#x27;templates&#x27;</span>],  <span class="hljs-comment"># 全局模板目录</span><br>        <span class="hljs-string">&#x27;APP_DIRS&#x27;</span>: <span class="hljs-literal">True</span>,                  <span class="hljs-comment"># 自动扫描各 app 的 templates/</span><br>        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;context_processors&#x27;</span>: [<br>                <span class="hljs-string">&#x27;django.template.context_processors.debug&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.template.context_processors.request&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,<br>            ],<br>        &#125;,<br>    &#125;,<br>]<br><br>WSGI_APPLICATION = <span class="hljs-string">&#x27;mysite.wsgi.application&#x27;</span><br><br>DATABASES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.sqlite3&#x27;</span>,      <span class="hljs-comment"># 默认 sqlite</span><br>        <span class="hljs-string">&#x27;NAME&#x27;</span>: BASE_DIR / <span class="hljs-string">&#x27;db.sqlite3&#x27;</span>,<br>    &#125;<br>&#125;<br><br>AUTH_PASSWORD_VALIDATORS = [<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&#x27;</span>,&#125;,<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.MinimumLengthValidator&#x27;</span>,&#125;,<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.CommonPasswordValidator&#x27;</span>,&#125;,<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.NumericPasswordValidator&#x27;</span>,&#125;,<br>]<br><br>LANGUAGE_CODE = <span class="hljs-string">&#x27;zh-hans&#x27;</span><br>TIME_ZONE = <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span><br>USE_I18N = <span class="hljs-literal">True</span><br>USE_TZ = <span class="hljs-literal">True</span><br><br>STATIC_URL = <span class="hljs-string">&#x27;static/&#x27;</span><br>STATICFILES_DIRS = [BASE_DIR / <span class="hljs-string">&#x27;static&#x27;</span>]   <span class="hljs-comment"># 全局静态目录</span><br><br>DEFAULT_AUTO_FIELD = <span class="hljs-string">&#x27;django.db.models.BigAutoField&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>指定项目的所有全局配置。</li><li>关键部分：<ul><li>INSTALLED_APPS：启用哪些应用</li><li>DATABASES：数据库类型和连接配置</li><li>TEMPLATES：模板引擎和模板目录</li><li>STATIC_URL &#x2F; STATICFILES_DIRS：静态文件设置</li><li>LANGUAGE_CODE &#x2F; TIME_ZONE：语言与时区</li><li>DEBUG &#x2F; ALLOWED_HOSTS：调试模式与安全相关设置</li></ul></li></ul><p><strong>常见改动</strong></p><ul><li><p>添加自己的 app：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS += [<span class="hljs-string">&#x27;blog&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li><p>切换数据库到 MySQL、PostgreSQL 等。</p></li><li><p>新增模板目录、静态目录、媒体文件配置等。</p></li></ul><hr><h5 id="2-3-mysite-urls-py"><a href="#2-3-mysite-urls-py" class="headerlink" title="2.3 mysite&#x2F;urls.py"></a>2.3 mysite&#x2F;urls.py</h5><p>全局 URL 路由入口。</p><p><strong>基本代码示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),        <span class="hljs-comment"># 后台站点</span><br>    path(<span class="hljs-string">&#x27;blog/&#x27;</span>, include(<span class="hljs-string">&#x27;blog.urls&#x27;</span>)),   <span class="hljs-comment"># 分发到 blog 应用</span><br>]<br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>接收浏览器请求的 URL，决定交给哪个应用处理。</li><li>每个应用有自己的 <code>urls.py</code>，通过 <code>include()</code> 引入。</li><li>常用模式：项目级 <code>urls.py</code> 里只做路由分发，不写业务逻辑。</li></ul><hr><h5 id="2-4-mysite-wsgi-py"><a href="#2-4-mysite-wsgi-py" class="headerlink" title="2.4 mysite&#x2F;wsgi.py"></a>2.4 mysite&#x2F;wsgi.py</h5><p>WSGI 部署入口，一般用于生产环境部署如 Gunicorn、uWSGI。</p><p><strong>基本代码示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> django.core.wsgi <span class="hljs-keyword">import</span> get_wsgi_application<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;mysite.settings&#x27;</span>)<br><br>application = get_wsgi_application()<br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>提供一个名为 <code>application</code> 的 WSGI 应用对象，供 Web 服务器调用。</li><li>部署时写在 Gunicorn &#x2F; uWSGI 的配置中。</li><li>开发阶段基本不改。</li></ul><hr><h5 id="2-5-mysite-asgi-py"><a href="#2-5-mysite-asgi-py" class="headerlink" title="2.5 mysite&#x2F;asgi.py"></a>2.5 mysite&#x2F;asgi.py</h5><p>ASGI 部署入口，用于异步支持（如 WebSocket）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> django.core.asgi <span class="hljs-keyword">import</span> get_asgi_application<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;mysite.settings&#x27;</span>)<br><br>application = get_asgi_application()<br></code></pre></td></tr></table></figure><p>作用类似 wsgi.py，只是用于 ASGI 服务器（如 uvicorn、daphne）。</p><h4 id="3-应用目录-blog"><a href="#3-应用目录-blog" class="headerlink" title="3. 应用目录 blog&#x2F;"></a>3. 应用目录 blog&#x2F;</h4><h5 id="3-1-blog-init-py"><a href="#3-1-blog-init-py" class="headerlink" title="3.1 blog&#x2F;init.py"></a>3.1 blog&#x2F;<strong>init</strong>.py</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 一般为空</span><br></code></pre></td></tr></table></figure><p>作用：标记 <code>blog</code> 为 Python 包。</p><hr><h5 id="3-2-blog-apps-py"><a href="#3-2-blog-apps-py" class="headerlink" title="3.2 blog&#x2F;apps.py"></a>3.2 blog&#x2F;apps.py</h5><p>应用配置类。</p><p><strong>默认代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.apps <span class="hljs-keyword">import</span> AppConfig<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogConfig</span>(<span class="hljs-title class_ inherited__">AppConfig</span>):<br>    default_auto_field = <span class="hljs-string">&#x27;django.db.models.BigAutoField&#x27;</span><br>    name = <span class="hljs-string">&#x27;blog&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>标识 app 在项目中的配置名。</li><li>如果需要应用级别的启动逻辑（如信号注册），可以在这里扩展。</li><li>通常在 <code>INSTALLED_APPS </code> 中会看到 <code>&#39;blog.apps.BlogConfig&#39;</code> 或简写 <code>&#39;blog&#39;</code>。</li></ul><hr><h5 id="3-3-blog-models-py"><a href="#3-3-blog-models-py" class="headerlink" title="3.3 blog&#x2F;models.py"></a>3.3 blog&#x2F;models.py</h5><p>用于定义数据库表（模型，Model）。</p><p><strong>示例：定义文章模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>(models.Model):<br>    title = models.CharField(max_length=<span class="hljs-number">200</span>, verbose_name=<span class="hljs-string">&#x27;标题&#x27;</span>)<br>    content = models.TextField(verbose_name=<span class="hljs-string">&#x27;内容&#x27;</span>)<br>    created_at = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;创建时间&#x27;</span>)<br>    updated_at = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;更新时间&#x27;</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        ordering = [<span class="hljs-string">&#x27;-created_at&#x27;</span>]           <span class="hljs-comment"># 默认按时间倒序</span><br>        verbose_name = <span class="hljs-string">&#x27;文章&#x27;</span><br>        verbose_name_plural = <span class="hljs-string">&#x27;文章&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.title<br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li><p>每个 Model 类对应数据库中的一张表。</p></li><li><p>字段（Field）对应表中的列，例如 CharField、TextField、DateTimeField 等。</p></li><li><p>定义好后通过：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py makemigrations<br>python manage.py migrate<br></code></pre></td></tr></table></figure><p>来生成并同步数据库结构。</p></li></ul><hr><h5 id="3-4-blog-migrations"><a href="#3-4-blog-migrations" class="headerlink" title="3.4 blog&#x2F;migrations&#x2F;"></a>3.4 blog&#x2F;migrations&#x2F;</h5><p>迁移文件目录。</p><ul><li><code>__init__.py</code> 标记为包。</li><li>每次 <code>makemigrations</code> 会生成类似 <code>0001_initial.py</code> 的文件。</li></ul><p>示例（自动生成，大概结构）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># blog/migrations/0001_initial.py</span><br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> migrations, models<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Migration</span>(migrations.Migration):<br><br>    initial = <span class="hljs-literal">True</span><br><br>    dependencies = []<br><br>    operations = [<br>        migrations.CreateModel(<br>            name=<span class="hljs-string">&#x27;Article&#x27;</span>,<br>            fields=[<br>                (<span class="hljs-string">&#x27;id&#x27;</span>, models.BigAutoField(primary_key=<span class="hljs-literal">True</span>, serialize=<span class="hljs-literal">False</span>)),<br>                (<span class="hljs-string">&#x27;title&#x27;</span>, models.CharField(max_length=<span class="hljs-number">200</span>)),<br>                (<span class="hljs-string">&#x27;content&#x27;</span>, models.TextField()),<br>                (<span class="hljs-string">&#x27;created_at&#x27;</span>, models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>)),<br>            ],<br>        ),<br>    ]<br></code></pre></td></tr></table></figure><p>作用：记录数据库结构变更，可版本化管理、回滚。</p><hr><h5 id="3-5-blog-views-py"><a href="#3-5-blog-views-py" class="headerlink" title="3.5 blog&#x2F;views.py"></a>3.5 blog&#x2F;views.py</h5><p>视图函数或类视图，处理具体业务逻辑。</p><p>示例 1：最简单的 HttpResponse</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;Hello Django, this is blog hello page.&quot;</span>)<br></code></pre></td></tr></table></figure><p>示例 2：结合模板渲染</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Article<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    articles = Article.objects.<span class="hljs-built_in">all</span>()<br>    context = &#123;<span class="hljs-string">&quot;articles&quot;</span>: articles&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;blog/index.html&quot;</span>, context)<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>接收请求对象 <code>request</code>；</li><li>调用 Model 查询数据；</li><li>渲染模板或返回 Json &#x2F; HttpResponse；</li><li>返回响应给浏览器。</li></ul><hr><h5 id="3-6-blog-urls-py"><a href="#3-6-blog-urls-py" class="headerlink" title="3.6 blog&#x2F;urls.py"></a>3.6 blog&#x2F;urls.py</h5><p>需要手动创建，用于定义 blog 应用内的路由。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;hello/&#x27;</span>, views.hello, name=<span class="hljs-string">&#x27;blog_hello&#x27;</span>),<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, views.index, name=<span class="hljs-string">&#x27;blog_index&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><p>然后在 <code>mysite/urls.py</code> 中 include：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;blog/&#x27;</span>, include(<span class="hljs-string">&#x27;blog.urls&#x27;</span>)),<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>把与 blog 相关的 URL 集中维护。</li><li>利于模块化和解耦。</li></ul><hr><h5 id="3-7-blog-admin-py"><a href="#3-7-blog-admin-py" class="headerlink" title="3.7 blog&#x2F;admin.py"></a>3.7 blog&#x2F;admin.py</h5><p>注册模型到 Django Admin 后台。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Article<br><br><span class="hljs-meta">@admin.register(<span class="hljs-params">Article</span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleAdmin</span>(admin.ModelAdmin):<br>    list_display = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;created_at&#x27;</span>)<br>    search_fields = (<span class="hljs-string">&#x27;title&#x27;</span>,)<br>    list_filter = (<span class="hljs-string">&#x27;created_at&#x27;</span>,)<br></code></pre></td></tr></table></figure><p><strong>作用：</strong></p><ul><li>控制对应模型在 <code>/admin/</code> 后台中的展示方式：<ul><li>列表显示哪些字段</li><li>支持搜索、过滤、排序等</li></ul></li><li>是快速构建后台管理界面的关键文件。</li></ul><hr><h5 id="3-8-blog-tests-py"><a href="#3-8-blog-tests-py" class="headerlink" title="3.8 blog&#x2F;tests.py"></a>3.8 blog&#x2F;tests.py</h5><p>编写单元测试。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.test <span class="hljs-keyword">import</span> TestCase<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Article<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleModelTest</span>(<span class="hljs-title class_ inherited__">TestCase</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_create_article</span>(<span class="hljs-params">self</span>):<br>        a = Article.objects.create(title=<span class="hljs-string">&quot;Test&quot;</span>, content=<span class="hljs-string">&quot;Content&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.assertEqual(a.title, <span class="hljs-string">&quot;Test&quot;</span>)<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>用于验证模型、视图等逻辑是否正确。</li><li>在持续集成、重构时尤其重要。</li></ul><h4 id="4-常见辅助目录"><a href="#4-常见辅助目录" class="headerlink" title="4. 常见辅助目录"></a>4. 常见辅助目录</h4><h5 id="4-1-templates"><a href="#4-1-templates" class="headerlink" title="4.1 templates&#x2F;"></a>4.1 templates&#x2F;</h5><p>项目根目录下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mysite/<br>    templates/<br>        blog/<br>            index.html<br></code></pre></td></tr></table></figure><p><code>index.html</code> 示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Blog Index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文章列表<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    &#123;% for a in articles %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; a.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; a.content|truncatechars:100 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>&#123;&#123; a.created_at &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    &#123;% empty %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>暂无文章<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;% endfor %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>作用：存放 HTML 模板，配合 <code>render()</code> 使用。</p><hr><h5 id="4-2-static"><a href="#4-2-static" class="headerlink" title="4.2 static&#x2F;"></a>4.2 static&#x2F;</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mysite/<br>    <span class="hljs-keyword">static</span>/<br>        css/<br>            style.css<br></code></pre></td></tr></table></figure><p><code>style.css</code> 示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">font-family</span>: sans-serif; &#125;<br><span class="hljs-selector-tag">h1</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>; &#125;<br></code></pre></td></tr></table></figure><p>模板里引用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% load static %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% static &#x27;css/style.css&#x27; %&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>作用：管理 CSS &#x2F; JS &#x2F; 图片 等静态资源。</p><h3 id="MVT结构"><a href="#MVT结构" class="headerlink" title="MVT结构"></a>MVT结构</h3><h4 id="1-什么是-Django-的-MVT-结构"><a href="#1-什么是-Django-的-MVT-结构" class="headerlink" title="1. 什么是 Django 的 MVT 结构"></a>1. 什么是 Django 的 MVT 结构</h4><p>Django 使用一种类似 MVC（Model–View–Controller）的架构，但强调 Web 开发中的模板渲染，因此称为 <strong>MVT（Model–View–Template）</strong>。</p><p>核心思想：</p><ul><li><strong>Model</strong>：负责数据层（数据库结构、ORM 操作）</li><li><strong>View</strong>：负责业务逻辑层（处理请求、数据处理、返回响应）</li><li><strong>Template</strong>：负责展示层（HTML 页面渲染）</li></ul><p>与 MVC 的不同点：</p><ul><li>Django 把“控制器”隐藏在框架内部（URL 分发器、模板渲染器），开发者无需手动写 Controller</li><li>视图函数（View）更接近 MVC 中的“Controller”</li></ul><p>因此 Django 实际结构：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">用户请求 → URL 路由 → <span class="hljs-built_in">View</span>(业务逻辑) ↔ <span class="hljs-built_in">Model</span>(数据库)<br>                                    ↓<br>                               <span class="hljs-built_in">Template</span>(页面)<br>                                    ↓<br>                               返回给浏览器<br></code></pre></td></tr></table></figure><hr><h4 id="2-部分的职责与代码位置"><a href="#2-部分的职责与代码位置" class="headerlink" title="2. 部分的职责与代码位置"></a>2. 部分的职责与代码位置</h4><h5 id="2-1-Model（模型层）"><a href="#2-1-Model（模型层）" class="headerlink" title="2.1. Model（模型层）"></a>2.1. Model（模型层）</h5><p>位置：<code>app/models.py</code></p><p>职责：</p><ul><li>定义数据库表结构（映射为 Python 类）</li><li>使用 Django ORM 提供增删改查（查询集 QuerySet）</li><li>承担业务实体的数据规则（字段类型、关系）</li></ul><p>模型的本质：</p><p><strong>数据库的一行记录 -&gt; 一个 Python 对象</strong></p><hr><h5 id="2-2-View（视图层）"><a href="#2-2-View（视图层）" class="headerlink" title="2.2. View（视图层）"></a>2.2. View（视图层）</h5><p>位置：<code>app/views.py</code></p><p>职责：</p><ul><li>接收 HTTP 请求</li><li>调用 Model 获取或处理数据</li><li>选择模板并渲染</li><li>返回 HTTP 响应（HTML、JSON 等）</li></ul><p>View 的本质：</p><p><strong>业务逻辑处理方法，是 Django 中最接近 MVC Controller 的部分</strong></p><hr><h5 id="2-3-Template（模板层）"><a href="#2-3-Template（模板层）" class="headerlink" title="2.3. Template（模板层）"></a>2.3. Template（模板层）</h5><p>位置：<code>templates/目录/*.html</code></p><p>职责：</p><ul><li>负责页面呈现（HTML、CSS）</li><li>不包含业务逻辑（仅渲染数据，不处理数据）</li><li>使用 Django 模板语言（DTL）</li></ul><p>Template 的本质：</p><p><strong>纯展示层，不做逻辑运算，只展示 View 传来的数据</strong></p><hr><h4 id="3-URL-路由（MVT-的入口）"><a href="#3-URL-路由（MVT-的入口）" class="headerlink" title="3. URL 路由（MVT 的入口）"></a>3. URL 路由（MVT 的入口）</h4><p>虽然不属于 MVT 三部分本身，但它是 MVT 的启动点。</p><p>位置：</p><ul><li>项目级：<code>mysite/urls.py</code></li><li>应用级：<code>blog/urls.py</code></li></ul><p>示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># blog/urls.py<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> <span class="hljs-type">path</span><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;articles/&#x27;</span>, views.article_list),<br>]<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>将 URL 与 View 对应起来</li><li>决定用户访问哪个页面时由哪个 View 来处理</li></ul><p>本质上 URL 分发器承担了传统 MVC 的 Controller 中的一部分工作。</p><hr><h4 id="4-MVT-与-MVC-的关系"><a href="#4-MVT-与-MVC-的关系" class="headerlink" title="4. MVT 与 MVC 的关系"></a>4. MVT 与 MVC 的关系</h4><p>Django 的 MVT 对应 MVC 的映射关系如下：</p><table><thead><tr><th>Django</th><th>MVC 对应</th><th>职责</th></tr></thead><tbody><tr><td>Model</td><td>Model</td><td>数据与业务实体</td></tr><tr><td>View</td><td>Controller</td><td>业务逻辑、响应请求</td></tr><tr><td>Template</td><td>View</td><td>展示 HTML 页面</td></tr><tr><td>URL Dispatcher（系统内部）</td><td>Controller</td><td>路由分发</td></tr></tbody></table><p>关键点：</p><ul><li>Django 框架自动处理了 Controller 的大量工作，因此你只需要写 View（业务逻辑）</li></ul><hr><h4 id="5-完整的数据流（面试常问）"><a href="#5-完整的数据流（面试常问）" class="headerlink" title="5. 完整的数据流（面试常问）"></a>5. 完整的数据流（面试常问）</h4><p>请求过程（从访问 URL 到页面显示）：</p><ol><li>浏览器访问 URL，例如 <code>/blog/articles/</code></li><li><code>urls.py</code> 匹配到对应 View，例如 <code>article_list()</code></li><li>View 调用 Model 查询数据库</li><li>View 将数据传给 Template 渲染</li><li>Template 生成 HTML</li><li>View 将 HTML 包装成 HttpResponse 返回给浏览器</li></ol><p>流程图（文字版）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">URL → <span class="hljs-keyword">View</span> → Model → 数据 → <span class="hljs-keyword">View</span> → <span class="hljs-keyword">Template</span> → HTML → Response → 用户<br></code></pre></td></tr></table></figure><blockquote><p>为什么 Django 使用 MVT 而不是 MVC？</p></blockquote><p>原因：</p><ol><li>Web 开发中 HTML 模板是核心部分，因此作为独立层 Template 更合理</li><li>Django 自动处理了传统 MVC 的 Controller，例如路由调度、模板渲染器</li><li>开发者关注点清晰：<ul><li>Model：数据</li><li>View：逻辑</li><li>Template：呈现</li></ul></li></ol><p>Django 提供了更高层封装，使 Web 开发更轻量和快速。</p><blockquote><p>Django 的 MVT 和 MVC 有什么区别？</p></blockquote><p><u>最大的区别即MVT提供了更高层封装，例如URL分发器等框架自动处理了 Controller 的大量工作，将重心放在的业务逻辑处理和页面渲染。</u></p><p>Django 采用 MVT 模式，它是对 MVC 的一种实现变体。三者的角色是：</p><ol><li><strong>Model</strong>：负责数据和业务实体部分，和 MVC 中的 Model 完全一致</li><li><strong>View（Django）</strong>：负责接收请求与业务逻辑，这部分更像 MVC 中的 Controller</li><li><strong>Template</strong>：负责页面展示逻辑，对应 MVC 中的 View</li></ol><p>换句话说：</p><ul><li>Django 把 Controller 的工作拆成两部分：<br>1）URL 分发器（由框架自动处理）<br>2）View（编写的业务逻辑函数或类）</li></ul><p>所以常见映射是：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">MVC              MVT(Django)</span><br><span class="hljs-section">--------------------------------------</span><br>Model     -&gt;     Model<br>View      -&gt;     Template<br>Controller-&gt;     View + URL Dispatcher<br></code></pre></td></tr></table></figure><p>举例说明（文章列表页）：</p><ul><li>在 MVC 里 Controller 负责调取文章数据，并让 View 显示</li><li>在 Django MVT 里 View 负责调取数据，然后把数据交给 Template 展示</li></ul><p>因此 MVT 本质上和 MVC 思想一致，只是名称和职责边界因 Django 的封装而有所不同。</p><h2 id="DRF"><a href="#DRF" class="headerlink" title="DRF"></a>DRF</h2><p>实现 Django REST 和前后端分离，本质上是把「Django 输出 HTML 页面」改成「Django 输出 JSON API」，由前端框架（Vue&#x2F;React 等）来渲染界面。需要调整的部分包括：</p><ol><li>Django REST + 前后端分离的核心是：<strong>后端不再渲染 HTML，只提供 JSON API</strong>，页面由前端框架负责。</li><li>后端需要：引入 DRF、使用 Serializer 和 APIView&#x2F;ViewSet、设计 RESTful URL、改用 Token&#x2F;JWT 认证、处理好 CORS 和 CSRF。</li><li>部署上：前端和后端解耦，往往分域名&#x2F;端口部署，通过 Nginx 或代理把 <code>/api/</code> 转给 Django，其它路径交给前端静态资源。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2025/08/04/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"/>
    <url>/2025/08/04/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>对JavaScript知识总结。</p><span id="more"></span><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h2 id="JavaScript-专业词汇"><a href="#JavaScript-专业词汇" class="headerlink" title="JavaScript 专业词汇"></a>JavaScript 专业词汇</h2><ul><li><code>表达式</code></li><li><code>代码块</code></li><li><code>函数闭包</code></li></ul><h2 id="JavaScript-的数据类型"><a href="#JavaScript-的数据类型" class="headerlink" title="JavaScript 的数据类型"></a>JavaScript 的数据类型</h2><h3 id="【数据类型】"><a href="#【数据类型】" class="headerlink" title="【数据类型】"></a>【数据类型】</h3><p>JavaScript 中的数据类型分为 <strong>原始类型（Primitive Types）</strong> 和 <strong>引用类型（Reference Types）</strong>。</p><p><strong>1. 原始类型（7种）：</strong></p><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Number</code></td><td>数值，包括整数、浮点数、NaN、Infinity等</td><td><code>1</code>, <code>3.14</code>, <code>NaN</code></td></tr><tr><td><code>String</code></td><td>字符串类型</td><td><code>&#39;hello&#39;</code>, <code>&quot;world&quot;</code></td></tr><tr><td><code>Boolean</code></td><td>布尔类型</td><td><code>true</code>, <code>false</code></td></tr><tr><td><code>undefined</code></td><td>表示未定义的变量</td><td><code>let a;</code> <code>typeof a // &quot;undefined&quot;</code></td></tr><tr><td><code>null</code></td><td>表示空值，常用于对象占位</td><td><code>let a = null</code></td></tr><tr><td><code>Symbol</code></td><td>唯一值，用于对象属性名</td><td><code>Symbol(&#39;desc&#39;)</code></td></tr><tr><td><code>BigInt</code></td><td>表示大整数</td><td><code>12345678901234567890n</code></td></tr></tbody></table><ul><li>模板字符串：使用反单引号&#96; 来表示模板字符串模板字符串中可以嵌入变量</li></ul><p><strong>2. 引用类型（对象类型）：</strong></p><table><thead><tr><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>Object</code></td><td><code>&#123;&#125;</code>、<code>&#123;name: &quot;JS&quot;&#125;</code></td></tr><tr><td><code>Array</code></td><td><code>[1, 2, 3]</code></td></tr><tr><td><code>Function</code></td><td><code>function() &#123;&#125;</code> 或箭头函数 <code>() =&gt; &#123;&#125;</code></td></tr><tr><td><code>Date</code></td><td><code>new Date()</code></td></tr><tr><td><code>RegExp</code></td><td><code>/abc/</code></td></tr><tr><td><code>Map</code> &#x2F; <code>Set</code></td><td><code>new Map()</code>, <code>new Set()</code></td></tr><tr><td><code>WeakMap</code> &#x2F; <code>WeakSet</code></td><td>稀疏结构，弱引用</td></tr></tbody></table><p><strong>3. 类型检测方法</strong></p><table><thead><tr><th>方法&#x2F;运算符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>返回原始类型的字符串表示</td><td><code>typeof 123 // &quot;number&quot;</code></td></tr><tr><td><code>instanceof</code></td><td>判断对象是否为某个构造函数的实例</td><td><code>[] instanceof Array // true</code></td></tr><tr><td><code>Object.prototype.toString.call()</code></td><td>精确判断所有类型</td><td><code>Object.prototype.toString.call(null) // &quot;[object Null]&quot;</code></td></tr><tr><td><code>Array.isArray()</code></td><td>判断是否为数组</td><td><code>Array.isArray([]) // true</code></td></tr></tbody></table><h3 id="【类型转换方式】"><a href="#【类型转换方式】" class="headerlink" title="【类型转换方式】"></a>【类型转换方式】</h3><p>JavaScript 支持三种类型转换：</p><ol><li><strong>显式类型转换</strong></li></ol><p>使用内建函数进行强制转换。</p><table><thead><tr><th>目标类型</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>转为字符串</td><td><code>String(value)</code> 或 <code>value.toString()</code></td><td><code>String(123) → &quot;123&quot;</code></td></tr><tr><td>转为数字</td><td><code>Number(value)</code> 或 <code>parseInt</code>, <code>parseFloat</code></td><td><code>Number(&quot;123&quot;) → 123</code></td></tr><tr><td>转为布尔值</td><td><code>Boolean(value)</code></td><td><code>Boolean(&quot;&quot;) → false</code></td></tr></tbody></table><ol start="2"><li><strong>隐式类型转换</strong></li></ol><blockquote><p><font color="#008B8B">弱类型语言</font>：在弱类型语言中，<strong>变量的数据类型可以隐式转换</strong>，而不是强制规定。JavaScript是一种典型的弱类型语言。</p></blockquote><p>JS 在运算时会自动进行类型转换。</p><table><thead><tr><th>情况</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>字符串拼接</td><td><code>&quot;1&quot; + 2 → &quot;12&quot;</code></td><td>数字被转为字符串</td></tr><tr><td>算术运算</td><td><code>&quot;5&quot; * &quot;2&quot; → 10</code></td><td>字符串被转为数字</td></tr><tr><td>布尔上下文</td><td><code>if (&quot;hello&quot;) &#123;...&#125;</code></td><td>非空字符串为 <code>true</code></td></tr><tr><td>与运算符 <code>==</code></td><td><code>null == undefined → true</code></td><td>非严格等于可能发生类型转换</td></tr></tbody></table><ol start="3"><li><strong>自动装箱（Boxing）与解箱（Unboxing）</strong></li></ol><p>原始值在需要对象时被自动包装为对象（如访问 <code>.length</code> 或调用方法时）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">length</span>); <span class="hljs-comment">// 自动装箱为 String 对象</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript的运算符"><a href="#JavaScript的运算符" class="headerlink" title="JavaScript的运算符"></a>JavaScript的运算符</h2><p><strong>1.算术运算符（Arithmetic Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法 &#x2F; 字符串拼接</td><td><code>2 + 3</code></td><td><code>5</code></td></tr><tr><td><code>-</code></td><td>减法</td><td><code>5 - 2</code></td><td><code>3</code></td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>3 * 4</code></td><td><code>12</code></td></tr><tr><td><code>/</code></td><td>除法</td><td><code>10 / 2</code></td><td><code>5</code></td></tr><tr><td><code>%</code></td><td>取模（余数）</td><td><code>10 % 3</code></td><td><code>1</code></td></tr><tr><td><code>**</code></td><td>幂运算（ES6）</td><td><code>2 ** 3</code></td><td><code>8</code></td></tr><tr><td><code>++</code></td><td>自增</td><td><code>x++</code> &#x2F; <code>++x</code></td><td><code>x + 1</code></td></tr><tr><td><code>--</code></td><td>自减</td><td><code>x--</code> &#x2F; <code>--x</code></td><td><code>x - 1</code></td></tr></tbody></table><p><strong>2.赋值运算符（Assignment Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>等同于</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td><code>a = 5</code></td><td></td></tr><tr><td><code>+=</code></td><td>加后赋值</td><td><code>a += 2</code></td><td><code>a = a + 2</code></td></tr><tr><td><code>-=</code></td><td>减后赋值</td><td><code>a -= 1</code></td><td><code>a = a - 1</code></td></tr><tr><td><code>*=</code></td><td>乘后赋值</td><td><code>a *= 3</code></td><td><code>a = a * 3</code></td></tr><tr><td><code>/=</code></td><td>除后赋值</td><td><code>a /= 2</code></td><td><code>a = a / 2</code></td></tr><tr><td><code>%=</code></td><td>取模后赋值</td><td><code>a %= 3</code></td><td><code>a = a % 3</code></td></tr><tr><td><code>**=</code></td><td>幂后赋值（ES6）</td><td><code>a **= 2</code></td><td><code>a = a ** 2</code></td></tr><tr><td><code>??=</code></td><td>空赋值</td><td><code>null ??= defined</code></td><td></td></tr></tbody></table><blockquote><p><code>??=</code> 只有当变量的值为null或undefined时才会对变量进行赋值</p></blockquote><p><strong>3.比较运算符（Comparison Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果类型</th></tr></thead><tbody><tr><td><code>==</code></td><td>相等（类型转换）</td><td><code>&#39;5&#39; == 5</code></td><td><code>true</code></td></tr><tr><td><code>===</code></td><td>全等（值和类型）</td><td><code>&#39;5&#39; === 5</code></td><td><code>false</code></td></tr><tr><td><code>!=</code></td><td>不等</td><td><code>&#39;5&#39; != 5</code></td><td><code>false</code></td></tr><tr><td><code>!==</code></td><td>不全等</td><td><code>&#39;5&#39; !== 5</code></td><td><code>true</code></td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>5 &gt; 3</code></td><td><code>true</code></td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>2 &lt; 4</code></td><td><code>true</code></td></tr><tr><td><code>&gt;=</code></td><td>大于或等于</td><td><code>5 &gt;= 5</code></td><td><code>true</code></td></tr><tr><td><code>&lt;=</code></td><td>小于或等于</td><td><code>3 &lt;= 2</code></td><td><code>false</code></td></tr></tbody></table><blockquote><p>⚠️ 推荐使用 <code>===</code> 和 <code>!==</code>，避免隐式类型转换带来的 bug。</p></blockquote><p><strong>4.逻辑运算符（Logical Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>返回值类型</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>与（AND）</td><td><code>true &amp;&amp; false</code></td><td><code>false</code></td></tr><tr><td>&#96;</td><td></td><td>&#96;</td><td>或（OR）</td></tr><tr><td><code>!</code></td><td>非（NOT）</td><td><code>!true</code></td><td><code>false</code></td></tr><tr><td><code>??</code></td><td>空值合并</td><td><code>null ?? &#39;default&#39;</code></td><td><code>&#39;default&#39;</code></td></tr></tbody></table><blockquote><p><code>??</code> 是 ES2020 引入的，仅在左侧为 <code>null</code> 或 <code>undefined</code> 时返回右侧值。</p></blockquote><p><strong>5.位运算符（Bitwise Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>5 &amp; 1 = 1</code></td></tr><tr><td>&#96;</td><td>&#96;</td><td>按位或</td></tr><tr><td><code>^</code></td><td>按位异或</td><td><code>5 ^ 1 = 4</code></td></tr><tr><td><code>~</code></td><td>按位非（取反）</td><td><code>~5 = -6</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>5 &lt;&lt; 1 = 10</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>有符号右移</td><td><code>5 &gt;&gt; 1 = 2</code></td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移</td><td><code>-5 &gt;&gt;&gt; 1</code></td></tr></tbody></table><p><strong>6.字符串运算符</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>+</code></td><td>拼接字符串</td><td><code>&#39;a&#39; + &#39;b&#39;</code></td><td><code>&#39;ab&#39;</code></td></tr></tbody></table><p><strong>7.三元运算符（Ternary Operator）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">条件 ? 真值 : 假值<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result = age &gt;= <span class="hljs-number">18</span> ? <span class="hljs-string">&#x27;adult&#x27;</span> : <span class="hljs-string">&#x27;minor&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><p><strong>8.类型运算符</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>返回变量的类型字符串</td><td><code>typeof 123 // &quot;number&quot;</code></td></tr><tr><td><code>instanceof</code></td><td>判断是否为某个构造函数的实例</td><td><code>[] instanceof Array // true</code></td></tr><tr><td><code>in</code></td><td>属性是否在对象中</td><td><code>&quot;name&quot; in obj</code></td></tr><tr><td><code>delete</code></td><td>删除对象的属性</td><td><code>delete obj.name</code></td></tr><tr><td><code>void</code></td><td>执行表达式但返回 <code>undefined</code></td><td><code>void 0 // undefined</code></td></tr></tbody></table><p><strong>9.扩展运算符（ES6+）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>...</code></td><td>展开 &#x2F; 剩余运算符</td><td><code>[...arr]</code>, <code>&#123;...obj&#125;</code></td></tr><tr><td><code>?.</code></td><td>可选链运算符（ES2020）</td><td><code>user?.info?.name</code></td></tr></tbody></table><p><strong>10.运算符优先级（常见顺序）</strong></p><p>优先级从高到低（越上面越先执行）：</p><ol><li>括号 <code>()</code></li><li>成员访问 <code>.</code>、<code>[]</code></li><li>函数调用 <code>()</code></li><li>一元运算符 <code>!</code>, <code>typeof</code>, <code>++</code>, <code>--</code></li><li>幂运算 <code>**</code></li><li>乘、除、取模 <code>* / %</code></li><li>加、减 <code>+ -</code></li><li>位运算</li><li>比较运算符</li><li>逻辑运算符</li><li>三元运算符 <code>? :</code></li><li>赋值 <code>= += -=</code></li><li>逗号运算符 <code>,</code></li></ol><h2 id="JavaScript隐式类型转换"><a href="#JavaScript隐式类型转换" class="headerlink" title="JavaScript隐式类型转换"></a>JavaScript隐式类型转换</h2><h3 id="【转换规律】"><a href="#【转换规律】" class="headerlink" title="【转换规律】"></a>【转换规律】</h3><p>JavaScript 中的类型转换主要有三种方向：</p><ul><li><strong>转为字符串（ToString）</strong></li><li><strong>转为数字（ToNumber）</strong></li><li><strong>转为布尔值（ToBoolean）</strong></li></ul><ol><li><strong>转为布尔值（ToBoolean）</strong></li></ol><p>转换为 <code>false</code> 的值（称为“<strong>假值</strong>”）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">false</span><br><span class="hljs-number">0</span><br>-<span class="hljs-number">0</span><br><span class="hljs-number">0n</span>       <span class="hljs-comment">// BigInt 的 0</span><br><span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-literal">null</span><br><span class="hljs-literal">undefined</span><br><span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure><p>其余全部为 <code>true</code>（即便是空数组 <code>[]</code>、空对象 <code>&#123;&#125;</code> 也为真）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>([]) → <span class="hljs-literal">true</span><br><span class="hljs-title class_">Boolean</span>(&#123;&#125;) → <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>2. 转为数字（ToNumber）</strong></p><table><thead><tr><th>值</th><th>转换后</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>1</code></td></tr><tr><td><code>false</code></td><td><code>0</code></td></tr><tr><td><code>null</code></td><td><code>0</code></td></tr><tr><td><code>undefined</code></td><td><code>NaN</code></td></tr><tr><td><code>&#39;&#39;</code></td><td><code>0</code></td></tr><tr><td><code>&#39;123&#39;</code></td><td><code>123</code></td></tr><tr><td><code>&#39;123abc&#39;</code></td><td><code>NaN</code></td></tr><tr><td><code>[]</code></td><td><code>0</code></td></tr><tr><td><code>[123]</code></td><td><code>123</code></td></tr><tr><td><code>&#123;&#125;</code></td><td><code>NaN</code></td></tr></tbody></table><p><strong>3. 转为字符串（ToString）</strong></p><table><thead><tr><th>值</th><th>转换后</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>&quot;true&quot;</code></td></tr><tr><td><code>false</code></td><td><code>&quot;false&quot;</code></td></tr><tr><td><code>null</code></td><td><code>&quot;null&quot;</code></td></tr><tr><td><code>undefined</code></td><td><code>&quot;undefined&quot;</code></td></tr><tr><td><code>123</code></td><td><code>&quot;123&quot;</code></td></tr><tr><td><code>[]</code></td><td><code>&quot;&quot;</code></td></tr><tr><td><code>[1, 2]</code></td><td><code>&quot;1,2&quot;</code></td></tr><tr><td><code>&#123;&#125;</code></td><td><code>&quot;[object Object]&quot;</code></td></tr></tbody></table><h3 id="【隐式类型转换场景】"><a href="#【隐式类型转换场景】" class="headerlink" title="【隐式类型转换场景】"></a>【隐式类型转换场景】</h3><ol><li><strong>与运算符相关的转换</strong></li></ol><table><thead><tr><th>运算符</th><th>示例</th><th>转换说明</th></tr></thead><tbody><tr><td><code>+</code>（加法）</td><td><code>&#39;5&#39; + 3</code> → <code>&#39;53&#39;</code></td><td>若有字符串，先转为字符串拼接</td></tr><tr><td><code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></td><td><code>&#39;5&#39; - 2</code> → <code>3</code></td><td>将字符串转为数字运算</td></tr><tr><td><code>==</code>（宽松相等）</td><td><code>0 == false</code> → <code>true</code></td><td>进行值的转换后再比较</td></tr><tr><td><code>===</code>（严格相等）</td><td><code>0 === false</code> → <code>false</code></td><td>不进行类型转换</td></tr><tr><td><code>!</code>（逻辑非）</td><td><code>!0</code> → <code>true</code></td><td>转换为布尔值取反</td></tr></tbody></table><ol start="2"><li><strong>与条件判断相关的转换</strong></li></ol><p>在 <code>if</code>、<code>while</code>、三元运算符中，会将表达式转换为布尔值。</p><ol start="3"><li><strong>与对象相关的转换</strong></li></ol><p>当对象参与算术或比较运算时，会触发 <code>valueOf()</code> 或 <code>toString()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#125; + <span class="hljs-number">1</span>        <span class="hljs-comment">// &quot;[object Object]1&quot;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + <span class="hljs-number">3</span>    <span class="hljs-comment">// &quot;1,23&quot;</span><br>&#123;&#125; == <span class="hljs-string">&quot;[object Object]&quot;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="【隐式转换规律总结】"><a href="#【隐式转换规律总结】" class="headerlink" title="【隐式转换规律总结】"></a>【隐式转换规律总结】</h3><p>基本规律一：优先转为字符串（尤其是 <code>+</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;2&#x27;</span> + <span class="hljs-number">1</span>        <span class="hljs-comment">// &quot;21&quot;</span><br><span class="hljs-literal">true</span> + <span class="hljs-string">&#x27;abc&#x27;</span>   <span class="hljs-comment">// &quot;trueabc&quot;</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + <span class="hljs-number">3</span>      <span class="hljs-comment">// &quot;1,23&quot;</span><br></code></pre></td></tr></table></figure><p>基本规律二：其他算术运算尝试转为数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;5&#x27;</span> - <span class="hljs-literal">true</span>     <span class="hljs-comment">// 4（&#x27;5&#x27;→5，true→1）</span><br><span class="hljs-literal">null</span> * <span class="hljs-number">8</span>       <span class="hljs-comment">// 0（null→0）</span><br><span class="hljs-string">&#x27;abc&#x27;</span> - <span class="hljs-number">1</span>      <span class="hljs-comment">// NaN（&#x27;abc&#x27; 转为数字失败）</span><br></code></pre></td></tr></table></figure><p>基本规律三：逻辑运算符返回的是<strong>原始值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">false</span> || <span class="hljs-string">&#x27;hello&#x27;</span>     <span class="hljs-comment">// &quot;hello&quot;</span><br><span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">123</span>             <span class="hljs-comment">// 0</span><br><span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;default&#x27;</span>    <span class="hljs-comment">// &quot;default&quot;</span><br></code></pre></td></tr></table></figure><h3 id="【易错点示例】"><a href="#【易错点示例】" class="headerlink" title="【易错点示例】"></a>【易错点示例】</h3><table><thead><tr><th>表达式</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td><code>NaN == NaN</code></td><td><code>false</code></td><td>NaN不和任何值相等，包括它自身</td></tr><tr><td><code>null == undefined</code></td><td><code>true</code></td><td>是相等的</td></tr><tr><td><code>[] == false</code></td><td><code>true</code></td><td><code>[] → &#39;&#39; → 0</code>，<code>false → 0</code></td></tr><tr><td><code>[] == ![]</code></td><td><code>true</code></td><td><code>![] → false</code>，<code>[] == false → true</code></td></tr><tr><td><code>&#123;&#125; + []</code></td><td><code>[object Object]</code></td><td>第一个 <code>&#123;&#125;</code> 被解释为块</td></tr></tbody></table><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="【函数形式】"><a href="#【函数形式】" class="headerlink" title="【函数形式】"></a>【函数形式】</h3><ol><li><strong>函数声明式（Function Declaration）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：可以在声明之前调用（函数提升）。</p><hr><ol start="2"><li><strong>函数表达式（Function Expression）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：必须先定义再调用。可以匿名或具名。</p><ol start="3"><li><strong>箭头函数（Arrow Function）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>更简洁；</li><li>没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code>；</li><li>不能作为构造函数（不能用 <code>new</code> 调用）；</li><li>不能使用 <code>yield</code>，即不能用作生成器函数。</li></ul><ol start="4"><li><strong>构造函数创建（Function 构造器）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：动态创建函数，但不推荐使用（安全性差、性能差）。</p><h3 id="【参数与返回值】"><a href="#【参数与返回值】" class="headerlink" title="【参数与返回值】"></a>【参数与返回值】</h3><p>函数返回值必须是一个值，包括对象、表达式（如函数表达式），没有返回值默认返回<code>undefined</code>。</p><h3 id="【回调函数（Callback）】"><a href="#【回调函数（Callback）】" class="headerlink" title="【回调函数（Callback）】"></a>【回调函数（Callback）】</h3><p><strong>回调函数</strong>是指作为参数传递给另一个函数的函数，并在该函数内部在某个时刻被“调用”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Doing something...&quot;</span>);<br>  <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 调用传入的函数</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">doSomething</span>(sayHello); <span class="hljs-comment">// 输出：Doing something... 然后 Hello!</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>sayHello</code> 是一个 <strong>回调函数</strong>，它作为参数传递给 <code>doSomething</code>，并在内部被调用。</p><p><strong>事件监听</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>数组方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>异步操作（如定时器）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;延迟1秒执行&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>命名 vs 匿名回调函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 匿名回调</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;匿名函数&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 命名回调</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callbackFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;命名函数&quot;</span>);<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(callbackFn, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>箭头函数也可以作为回调函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Arrow function callback&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/m0_46165586/article/details/143785628">为什么JavaScript中函数也能看成对象_js函数也是对象,怎么理解-CSDN博客</a></p></blockquote><h3 id="【window-对象】"><a href="#【window-对象】" class="headerlink" title="【window 对象】"></a>【window 对象】</h3><p>在浏览器中，<code>window</code> 是顶级对象，全局作用域下声明的变量和函数（<code>var</code>、<code>function</code>）都会变成 <code>window</code> 的属性或方法；而 <code>let</code> 和 <code>const</code> 则不会。</p><p><code>window</code> 是<strong>浏览器环境中的全局对象</strong>。表示整个浏览器窗口。它包含了：</p><ul><li><strong>浏览器提供的宿主对象</strong>（如 <code>alert</code>、<code>setTimeout</code>）</li><li><strong>JavaScript 的全局变量和函数</strong></li><li><strong>全局作用域中的变量（var 声明的）和函数</strong></li></ul><p>在浏览器中，所有全局作用域下的 <code>var</code> 变量和 <code>function</code> 声明都会被挂载到 <code>window</code> 上。</p><p><strong>访问方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hi&quot;</span>);   <span class="hljs-comment">// 通过 window 调用 alert 方法</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hi&quot;</span>);          <span class="hljs-comment">// 可省略 window，效果相同</span><br></code></pre></td></tr></table></figure><p><strong>全局变量与 <code>window</code> 的关系</strong></p><p>1.<code>var</code> 声明的变量会挂载在 <code>window</code> 上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>2.<code>let</code> 和 <code>const</code> 声明的变量 <strong>不会</strong>挂在 <code>window</code> 上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>3.没有使用 <code>var/let/const</code> 声明的变量也会挂在 <code>window</code> 上（不推荐，容易污染全局）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  undeclared = <span class="hljs-number">123</span>;<br>&#125;<br><span class="hljs-title function_">test</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">undeclared</span>); <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><ol start="4"><li>普通函数（使用 <code>function</code> 声明）自动挂载为 <code>window</code> 的方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 调用方式等同于 fn()</span><br></code></pre></td></tr></table></figure><p>常用 <code>window</code> 方法示例</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>alert()</code></td><td>弹出提示框</td></tr><tr><td><code>confirm()</code></td><td>弹出确认框（返回 true&#x2F;false）</td></tr><tr><td><code>prompt()</code></td><td>输入框，返回用户输入</td></tr><tr><td><code>setTimeout()</code></td><td>延时执行</td></tr><tr><td><code>setInterval()</code></td><td>定时重复执行</td></tr><tr><td><code>console.log()</code></td><td>控制台输出（也是 window 的一部分）</td></tr></tbody></table><h3 id="【变量和函数的提升】"><a href="#【变量和函数的提升】" class="headerlink" title="【变量和函数的提升】"></a>【变量和函数的提升】</h3><p><code>var</code>、<code>let</code>、函数在声明的时候会在代码开始执行之前声明，用于考虑内存分配。</p><p><strong><code>var</code> 声明的提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>相当于解释器处理成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;          <span class="hljs-comment">// 提升：声明但不赋值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined</span><br>a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p> <strong><code>let</code> 的“暂时性死区”（TDZ）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 报错：Cannot access &#x27;b&#x27; before initialization</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ul><li><code>let</code> 声明虽然也“提升”（被识别），但不会初始化。</li><li>在 <code>let b = 10;</code> 之前的任何访问都会抛出 <code>ReferenceError</code>。</li></ul><p><strong>函数声明的提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 正常执行：alert(&quot;我是fn函数~&quot;)</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是fn函数~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>函数声明（Function Declaration）</strong>：完整地被提升，包含函数体。</li></ul><p><strong>函数表达式不会被完整提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// fn2(); // 报错：fn2 is not a function</span><br><span class="hljs-keyword">var</span> fn2 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;匿名函数&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="【立即执行函数】"><a href="#【立即执行函数】" class="headerlink" title="【立即执行函数】"></a>【立即执行函数】</h3><p><strong>立即执行函数</strong>是定义好之后立即被调用的函数，它的语法形式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;());<br></code></pre></td></tr></table></figure><p>也可以使用箭头函数写法（ES6+）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>JavaScript 中 <code>function</code> 声明默认是函数声明语句，<strong>不能直接执行</strong>。</p><p>将函数用 <code>()</code> 包裹后，<strong>变成表达式</strong>，表达式就可以立即执行。</p><p><strong>为什么要用 IIFE？</strong></p><ol><li><strong>创建私有作用域</strong>，防止变量污染全局命名空间。</li><li>代码模块化的一种早期手段（模块化之前的写法）。</li><li>常用于库、插件或立即执行的逻辑中。</li><li>可用于封装变量、函数，防止外部访问。</li></ol><p><strong>IIFE 模块化用途</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;,<br>    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>      count = <span class="hljs-number">0</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reset&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;)();<br><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">reset</span>();     <span class="hljs-comment">// reset</span><br></code></pre></td></tr></table></figure><h3 id="【函数的-this】"><a href="#【函数的-this】" class="headerlink" title="【函数的 this】"></a>【函数的 <code>this</code>】</h3><p><code>this</code> 是 JavaScript 函数执行时自动传入的一个 <strong>隐含参数</strong>，它的值取决于 <strong>函数的调用方式</strong>。</p><p><strong>基本规则</strong></p><table><thead><tr><th>调用方式</th><th><code>this</code> 指向</th></tr></thead><tbody><tr><td>普通函数调用</td><td>全局对象（浏览器中是 <code>window</code>） 在严格模式下是 <code>undefined</code></td></tr><tr><td>对象方法调用</td><td>调用该方法的对象（即 “点” 左边的对象）</td></tr><tr><td>构造函数调用（<code>new</code>）</td><td>新创建的实例对象</td></tr><tr><td>显式绑定（<code>call/apply/bind</code>）</td><td>显式指定的对象</td></tr><tr><td>箭头函数调用</td><td>**定义时所在作用域的 <code>this</code>**（不会改变）</td></tr></tbody></table><ol><li><strong>普通函数</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 浏览器中输出：window；严格模式下输出：undefined</span><br></code></pre></td></tr></table></figure><p><strong>2. 对象方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>    <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Tom&quot;，this 指向 obj</span><br></code></pre></td></tr></table></figure><p><strong>3. 构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;，this 指向新建的对象 p</span><br></code></pre></td></tr></table></figure><p><strong>4. 显式绑定</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span> &#125;;<br>show.<span class="hljs-title function_">call</span>(user);   <span class="hljs-comment">// &quot;Bob&quot;</span><br>show.<span class="hljs-title function_">apply</span>(user);  <span class="hljs-comment">// &quot;Bob&quot;</span><br><br><span class="hljs-keyword">const</span> boundShow = show.<span class="hljs-title function_">bind</span>(user);<br><span class="hljs-title function_">boundShow</span>();       <span class="hljs-comment">// &quot;Bob&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>箭头函数</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>    <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        &#125;;<br>        <span class="hljs-title function_">arrow</span>();<br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Tom&quot;，箭头函数的 this 继承自 sayHello 的 this</span><br></code></pre></td></tr></table></figure><p><strong>注意点</strong></p><ol><li>箭头函数的 <code>this</code> <strong>不会根据调用方式改变</strong>，它始终指向其定义时的外部作用域。</li><li>在事件监听函数中，若使用普通函数，则 <code>this</code> 是触发事件的元素；若使用箭头函数，<code>this</code> 是定义时的上下文（可能是 <code>window</code> 或外部对象）。</li><li>构造函数中若不使用 <code>new</code>，<code>this</code> 将指向 <code>window</code>，可能导致错误。</li></ol><h3 id="【高阶函数】"><a href="#【高阶函数】" class="headerlink" title="【高阶函数】"></a>【高阶函数】</h3><p><strong>高阶函数</strong>是指<strong>接收函数作为参数</strong>，或者<strong>返回一个函数</strong>的函数。</p><ol><li>接收函数作为参数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processUserInput</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">callback</span>(name));<br>&#125;<br><br><span class="hljs-title function_">processUserInput</span>(greet); <span class="hljs-comment">// 输出: Hello, Alice!</span><br></code></pre></td></tr></table></figure><ol start="2"><li>返回一个函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiplier</span>(<span class="hljs-params">factor</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * factor;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> double = <span class="hljs-title function_">multiplier</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出: 10</span><br></code></pre></td></tr></table></figure><p>常见高阶函数（内置）</p><ul><li><code>Array.prototype.map()</code></li><li><code>Array.prototype.filter()</code></li><li><code>Array.prototype.reduce()</code></li><li><code>Array.prototype.forEach()</code></li><li><code>setTimeout</code>, <code>setInterval</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> doubled = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>); <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="【闭包】"><a href="#【闭包】" class="headerlink" title="【闭包】"></a>【闭包】</h3><p><strong>闭包</strong>是指<strong>一个函数可以访问其定义时的词法作用域，即使这个函数在其定义作用域之外被调用</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><ul><li><code>inner()</code> 函数访问了 <code>outer()</code> 中的局部变量 <code>count</code>。</li><li>即使 <code>outer()</code> 已经执行完，<code>inner()</code> 仍然“记住”了它的词法作用域——形成闭包。</li></ul><p>闭包和类的对比：</p><table><thead><tr><th>场景</th><th>推荐用闭包</th><th>推荐用类</th></tr></thead><tbody><tr><td>只需要几个函数操作内部状态</td><td>✅</td><td>🚫</td></tr><tr><td>有多个对象、共享行为（方法）</td><td>🚫</td><td>✅</td></tr><tr><td>需要完全私有变量</td><td>✅</td><td>✅（用 <code>#</code>）</td></tr><tr><td>多态、继承、原型链等 OOP 特性</td><td>🚫</td><td>✅</td></tr></tbody></table><ul><li><strong>闭包</strong>：每次调用 <code>createXXX</code> 函数会生成新的作用域，内存压力略大，不利于大规模实例化。</li><li><strong>类</strong>：方法可以挂在原型上，共享函数定义，<strong>更节省内存</strong>。</li></ul><h3 id="【argumen和可变参数】"><a href="#【argumen和可变参数】" class="headerlink" title="【argumen和可变参数】"></a>【argumen和可变参数】</h3><p><code>arguments</code></p><ul><li>在 <strong>函数内部</strong>，你可以使用内置的 <code>arguments</code> 对象来访问<strong>所有传入的实参</strong>。</li><li>它是一个<strong>类数组对象</strong>，包含调用函数时传入的所有参数。</li></ul><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 类数组：不是真正的数组</span><br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    total += <span class="hljs-variable language_">arguments</span>[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出: 10</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<code>arguments</code> 不能用于箭头函数（<code>=&gt;</code>），因为它没有自己的 <code>arguments</code> 对象。</p></blockquote><p><strong>可变参数（Rest Parameters）</strong></p><p>可变参数（Rest Parameters）使用 <code>...</code> 语法，将<strong>不定数量的参数</strong>收集到一个真正的数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：6</span><br></code></pre></td></tr></table></figure><ul><li><code>args</code> 是一个<strong>真正的数组</strong>，可以使用数组方法（如 <code>map</code>、<code>reduce</code>、<code>filter</code> 等）；</li><li>可以与固定参数一起使用，但 <code>...rest</code> 必须是最后一个参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">name, ...messages</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(messages); <span class="hljs-comment">// messages 是数组</span><br>&#125;<br><br><span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 输出：Alice</span><br><span class="hljs-comment">//      [&quot;Hello&quot;, &quot;World&quot;]</span><br></code></pre></td></tr></table></figure><p><code>arguments</code> 和 <code>rest 参数</code> 的区别</p><table><thead><tr><th>比较项</th><th><code>arguments</code> 对象</th><th><code>...rest</code> 可变参数</th></tr></thead><tbody><tr><td>是否数组</td><td>❌ 类数组对象</td><td>✅ 真正的数组</td></tr><tr><td>是否能用数组方法</td><td>❌ 需要转化</td><td>✅ 直接可用</td></tr><tr><td>是否支持箭头函数</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>是否支持默认值</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>是否可以命名</td><td>❌ 只能用 <code>arguments</code></td><td>✅ 可自定义名字</td></tr><tr><td>ES版本</td><td>ES3 就有</td><td>ES6 新特性</td></tr></tbody></table><h3 id="【call-apply-bind】"><a href="#【call-apply-bind】" class="headerlink" title="【call,apply,bind】"></a>【<code>call</code>,<code>apply</code>,<code>bind</code>】</h3><p><code>call</code>、<code>apply</code>、<code>bind</code> 是 JavaScript 中用于<strong>改变函数 <code>this</code> 指向</strong>的三个非常重要的方法，常用于手动控制函数的执行上下文。</p><table><thead><tr><th>方法</th><th>作用</th><th>是否立即执行函数</th><th>参数传递方式</th></tr></thead><tbody><tr><td><code>call</code></td><td>改变 <code>this</code> 并执行函数</td><td>✅ 是</td><td>逐个传入参数</td></tr><tr><td><code>apply</code></td><td>改变 <code>this</code> 并执行函数</td><td>✅ 是</td><td><strong>数组</strong>传入参数</td></tr><tr><td><code>bind</code></td><td>改变 <code>this</code>，但<strong>不立即执行</strong>，返回新函数</td><td>❌ 否</td><td>逐个传入参数（可预设）</td></tr></tbody></table><p>示例函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, punctuation</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;greeting&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span><span class="hljs-subst">$&#123;punctuation&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;;<br></code></pre></td></tr></table></figure><p><code>call(thisArg, arg1, arg2, ...)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);<br><span class="hljs-comment">// 输出: Hello, Alice!</span><br></code></pre></td></tr></table></figure><p> <code>apply(thisArg, [arg1, arg2, ...])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;...&#x27;</span>]);<br><span class="hljs-comment">// 输出: Hi, Alice...</span><br></code></pre></td></tr></table></figure><p> <code>bind(thisArg, arg1, arg2, ...)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> greetAlice = greet.<span class="hljs-title function_">bind</span>(person, <span class="hljs-string">&#x27;Hey&#x27;</span>);<br><span class="hljs-title function_">greetAlice</span>(<span class="hljs-string">&#x27;?&#x27;</span>); <span class="hljs-comment">// 输出: Hey, Alice?</span><br></code></pre></td></tr></table></figure><blockquote><p>箭头函数没有自身的this，它的this由外层作用域决定，也无法通过call apply 和 bind修改它的this</p></blockquote><h2 id="JavaScript面向对象编程"><a href="#JavaScript面向对象编程" class="headerlink" title="JavaScript面向对象编程"></a>JavaScript面向对象编程</h2><p><strong>面向对象编程（Object-Oriented Programming）</strong> 是一种编程思想，将现实世界中的事物抽象为对象，所以编写操作基于对象执行。通过 <strong>类（Class）</strong> 和 <strong>对象（Object）</strong> 来封装数据与行为，使程序更易于复用、扩展和维护。</p><p>OOP 三大特性：</p><ul><li><strong>封装</strong>：将数据与方法打包在对象中，隐藏内部实现。</li><li><strong>继承</strong>：子类可以继承父类的属性和方法，代码复用。</li><li><strong>多态</strong>：不同类的对象可以以统一方式调用同名方法（JavaScript中主要通过鸭子类型体现）。</li></ul><h3 id="【类与对象区别】"><a href="#【类与对象区别】" class="headerlink" title="【类与对象区别】"></a>【类与对象区别】</h3><table><thead><tr><th>分类</th><th>类（Class）</th><th>对象（Object）</th></tr></thead><tbody><tr><td>定义</td><td>模板、蓝图</td><td>类的具体实例</td></tr><tr><td>概念</td><td>定义属性和方法的抽象结构</td><td>通过类创建的实体</td></tr><tr><td>示例</td><td><code>class Person &#123;&#125;</code></td><td><code>let p = new Person()</code></td></tr><tr><td>关系</td><td>对象是由类实例化而来的</td><td>类是构造对象的基础</td></tr></tbody></table><ol><li>定义类</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 实例方法</span><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I am <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">20</span>);<br>p1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, I am Alice</span><br></code></pre></td></tr></table></figure><p>javascript对象分为三类</p><ul><li>内建对象：<code>Object</code>,<code>String</code>,<code>Array</code>等</li><li>宿主对象：由浏览器提供的对象，如<code>BOM</code>，<code>DOM</code></li><li>自定义对象：由开发人员自己创建的对象</li></ul><h3 id="【类的属性和方法】"><a href="#【类的属性和方法】" class="headerlink" title="【类的属性和方法】"></a>【类的属性和方法】</h3><p>1.实例属性与方法（在 constructor 或类体中定义，属于对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 实例属性</span><br>  &#125;<br><br>  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> says woof!`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.静态属性与方法（用 static 关键字，属于类本身）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tool</span> &#123;<br>  <span class="hljs-keyword">static</span> version = <span class="hljs-string">&#x27;1.0.0&#x27;</span>; <span class="hljs-comment">// 静态属性</span><br><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">logInfo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Tool Version: <span class="hljs-subst">$&#123;Tool.version&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Tool</span>.<span class="hljs-title function_">logInfo</span>();  <span class="hljs-comment">// Tool Version: 1.0.0</span><br></code></pre></td></tr></table></figure><h3 id="【类的封装】"><a href="#【类的封装】" class="headerlink" title="【类的封装】"></a>【类的封装】</h3><p>封装是面向对象编程的三大特性之一，指的是<strong>将对象的属性和方法包装在类中，并隐藏内部实现细节，仅暴露对外的操作接口</strong>。</p><p><strong>封装的目标</strong>：</p><ol><li><strong>隐藏实现细节</strong>，保护数据安全；</li><li><strong>限制外部直接访问对象属性</strong>；</li><li><strong>通过方法控制属性的读写权限和校验逻辑</strong>。</li></ol><p><strong>如何实现封装（JavaScript 中）</strong></p><ol><li>使用 <code>class</code> 定义类</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="2"><li>使用私有属性（<code>#</code>）</li></ol><blockquote><p>ES2022 引入的私有属性，语法是 <code>#属性名</code>，只能在类内部访问。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  #name;  <span class="hljs-comment">// 私有属性</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#name = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.#name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>提供 getter&#x2F;setter 方法（读写接口）</li></ol><p>方法式访问器（传统写法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;<br>&#125;<br><br><span class="hljs-title function_">setName</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">if</span> (name) <span class="hljs-variable language_">this</span>.#name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性式访问器（现代写法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;<br>&#125;<br><br><span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#name = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>p.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Jerry&quot;</span>;     <span class="hljs-comment">// set</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// get</span><br></code></pre></td></tr></table></figure><p><strong>封装的好处</strong></p><table><thead><tr><th>好处</th><th>说明</th></tr></thead><tbody><tr><td>数据保护</td><td>防止外部随意修改属性值</td></tr><tr><td>控制访问</td><td>通过 <code>getter/setter</code> 控制属性读写权限</td></tr><tr><td>降低耦合</td><td>外部不关心内部实现，提高类的独立性</td></tr><tr><td>便于调试</td><td>可以在访问器中添加调试信息和断点</td></tr></tbody></table><h3 id="【类的多态】"><a href="#【类的多态】" class="headerlink" title="【类的多态】"></a>【类的多态】</h3><p>多态是面向对象三大特性之一，指的是<strong>相同的接口或方法作用于不同的对象时，表现出不同的行为</strong>。</p><ul><li>JavaScript <strong>不检查类型</strong>，只要对象有需要的属性或方法，就能被使用。</li><li>常用表达方式是：<strong>传入不同对象、执行相同操作，结果行为各异</strong>。</li></ul><p>1.JavaScript 不检查类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + obj.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;悟空&quot;</span>)); <span class="hljs-comment">// Hello, 悟空</span><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>));    <span class="hljs-comment">// Hello, 旺财</span><br></code></pre></td></tr></table></figure><p>2.方法重写（Override）：在继承体系中，<strong>子类重写父类的方法</strong>，体现出不同的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;动物发出声音&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;狗叫：汪汪&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;猫叫：喵喵&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> animals = [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>()];<br><br>animals.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">animal</span> =&gt;</span> animal.<span class="hljs-title function_">speak</span>());<br></code></pre></td></tr></table></figure><ul><li>这就是通过<strong>同一个父类方法 <code>speak()</code>，由不同子类表现出不同行为</strong>，实现了<strong>经典的多态</strong>。</li></ul><p>3.函数参数多态（传入不同类型对象）:函数的参数可以是任何类型，这种特性让函数更通用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">describe</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">describe</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        obj.<span class="hljs-title function_">describe</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这个对象没有描述方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【类的继承】"><a href="#【类的继承】" class="headerlink" title="【类的继承】"></a>【类的继承】</h3><p>继承是面向对象编程三大特性之一，是<strong>子类继承父类的属性和方法，从而实现代码复用和扩展功能</strong>的机制。</p><p><strong>JavaScript 中的继承实现方式（ES6+）</strong></p><p>1.使用 <code>extends</code> 关键字实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;动物在叫~&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.<code>super</code> 的用法</p><table><thead><tr><th>场景</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>super(...)</code></td><td>子类构造函数中<strong>调用父类构造函数</strong>，必须写在第一行</td><td><code>super(name)</code></td></tr><tr><td><code>super.方法名()</code></td><td>在子类方法中调用<strong>父类的同名方法</strong></td><td><code>super.sayHello()</code></td></tr></tbody></table><p>3.示例（构造函数 + 方法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);      <span class="hljs-comment">// 调用父类构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 调用父类的方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.方法重写（Override）</p><p>子类可以<strong>定义与父类同名的方法</strong>，用于覆盖父类的方法，实现多态行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数继承注意事项</p><ul><li>如果<strong>子类定义了构造函数</strong>，必须在构造函数第一行调用 <code>super(...)</code>。</li><li>否则会报错：<code>ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39;</code></li></ul><p><strong>继承的好处</strong></p><table><thead><tr><th>好处</th><th>说明</th></tr></thead><tbody><tr><td>代码复用</td><td>子类自动获得父类的属性和方法</td></tr><tr><td>易于维护</td><td>修改父类会自动影响所有子类</td></tr><tr><td>扩展能力强</td><td>子类可添加自己的属性或重写方法</td></tr><tr><td>遵守OCP</td><td>遵循开闭原则：对修改关闭，对扩展开放</td></tr></tbody></table><p><strong>关键点：</strong></p><table><thead><tr><th>概念</th><th>关键字</th><th>示例</th><th>作用</th></tr></thead><tbody><tr><td>继承</td><td><code>extends</code></td><td><code>class Dog extends Animal</code></td><td>让子类继承父类</td></tr><tr><td>调用父构造函数</td><td><code>super(...)</code></td><td><code>super(name)</code></td><td>子类构造函数中必须调用父类构造函数</td></tr><tr><td>调用父类方法</td><td><code>super.方法名()</code></td><td><code>super.sayHello()</code></td><td>子类中调用父类方法</td></tr><tr><td>方法重写</td><td>子类中定义与父类同名的方法</td><td><code>sayHello()</code></td><td>实现不同子类的特有行为（多态）</td></tr></tbody></table><h3 id="【原型对象】"><a href="#【原型对象】" class="headerlink" title="【原型对象】"></a>【原型对象】</h3><blockquote><p>每个对象都有一个内部属性 <code>[[Prototype]]</code>（通常访问为 <code>__proto__</code>），它指向另一个对象，这个对象称为“原型”。当访问对象的某个属性时，如果对象本身没有这个属性，则会去它的原型对象上查找，这就是“原型链查找”机制。原型本身也是对象，也有原型，因此构成一个原型链，直到最顶层<code>null</code>终止</p></blockquote><p><strong>1.查找顺序：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">obj = &#123;&#125;  <span class="hljs-comment">// obj = new Object()</span><br><span class="hljs-comment">// obj -&gt; obj.__proto__(Object.prototype) -&gt; null</span><br></code></pre></td></tr></table></figure><p><strong><font color="#008B8B">注意点：</font></strong></p><ul><li><code>obj</code> 的 <code>__proto__</code> 指向 <code>Object.prototype</code>。</li><li><code>Object.prototype</code> 是所有普通对象的顶层原型，<code>Object.prototype.__proto__ === null</code>。</li><li><code>Object</code>是所有对象的基类。</li><li>JS中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的<strong>实例</strong>，而所有类都默认继承<code>Object</code>基类。</li></ul><p><strong>2.类中的原型：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  &#125;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Animal</code>默认继承<code>Object</code>基类，<code>Animal</code>的原型就是<code>Object</code>实例。</li><li>类的静态属性<code>prototype</code>和对象的属性<code>__proto__</code>作用相同，都是获取原型对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === animal.<span class="hljs-property">__proto__</span> (<span class="hljs-title class_">Object</span>实例)<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === animal.<span class="hljs-property">__proto__</span>.<span class="hljs-property">proto__</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ul><li>原型就相当于是一个<strong>公共的区域</strong>，可以被所有该类实例访问,可以将该类实例中，所有的公共属性（方法）统一存储到原型中,这样我们只需要创建一个属性，即可被所有实例访问</li><li>对原型中的数据修改会影响所有包含该原型的对象实例。</li></ul><p><strong>3.对象结构</strong></p><p>对象中存储属性的区域实际有两个：对象自身和原型对象。</p><ol><li>直接通过对象所添加的属性，位于对象自身中，在类中通过 x &#x3D; y 的形式添加的属性，位于对象自身中。</li><li>在类中通过xxx(){}方式添加的方法和主动向原型中添加的属性或方法，位于原型中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  name = <span class="hljs-string">&#x27;Instance Property&#x27;</span>;<br><br>  <span class="hljs-comment">// 原型方法</span><br>  <span class="hljs-title function_">protoMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;protoMethod this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 实例函数表达式</span><br>  funcExpr = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;funcExpr this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;;<br><br>  <span class="hljs-comment">// 实例箭头函数</span><br>  arrowFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arrowFunc this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;;<br><br>  <span class="hljs-comment">// 静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;staticMethod this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型对象中的数据：</p><ol><li>对象中的数据（属性、方法等）</li><li>constructor （对象的构造函数）</li></ol><p><code>constructor</code>实际就是类，保存所有静态属性和方法。</p><img src="/2025/08/04/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/image-20250802233313942.png" class title="image-20250802233313942"><p><strong>4.访问方式</strong></p><ol><li><code>Object.getPrototypeOf(obj)</code> 返回对象的原型。</li><li><code>obj.__proto__</code> 是非标准访问方式，现代建议使用 <code>Object.getPrototypeOf</code>。</li><li><code>obj.hasOwnProperty(prop)</code> 判断属性是否在对象自身上。</li><li><code>Object.hasOwn(obj, prop) </code>（推荐使用）判断属性是否在对象自身上。</li><li><code>prop in obj</code> 判断属性是否存在（自身或原型链）。</li><li><code>instanceof</code> 检查的是对象的原型链上是否有该类实例</li></ol><blockquote><p>不建议直接对原型对象数据进行修改。</p></blockquote><h3 id="【this-的指向】"><a href="#【this-的指向】" class="headerlink" title="【this 的指向】"></a>【this 的指向】</h3><p>对象中方法的定义位置不同。</p><ol><li><strong>原型方法（<code>method() &#123;&#125;</code>）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;原型方法&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义位置：类的原型上（<code>MyClass.prototype.method</code>）</li><li>不是在构造函数中定义的</li><li>所有实例共享</li><li>正常调用（如 <code>obj.protoMethod()</code>），<code>this</code> 指向实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">protoMethod</span>(); <span class="hljs-comment">// this === obj </span><br><br><span class="hljs-keyword">const</span> f = obj.<span class="hljs-property">funcExpr</span>;<br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// this === undefined（在严格模式下） this === window （非严格模式下）</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>实例方法（字段定义：<code>method = function() &#123;&#125;</code> 或 <code>method = () =&gt; &#123;&#125;</code>）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  method1 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;函数表达式&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>定义位置：构造函数内部</p><blockquote><p>因为 JavaScript 会把这些“字段初始化器”转化为构造函数里的赋值语句</p></blockquote></li><li><p>每个实例一份，每次实例化的时候都会定义一次。</p></li><li><p><code>method2</code>（箭头函数）自动绑定 <code>this</code>，而 <code>method1</code> 不会</p></li><li><p><code>this</code>和原型方法一样。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  method2 = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">method2</span> = () = &gt;&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义位置：构造函数内部</li><li>每个实例一份，每次实例化的时候都会定义一次。</li><li><code>method2</code>（箭头函数）自动绑定 <code>this</code>，</li><li><code>this</code>根据外作用域决定，也就是<code>constructor</code>， <code>this === 实例对象</code>，因此无论怎么调用，<code>this</code> 都不会变</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-keyword">const</span> f = obj.<span class="hljs-property">arrowFunc</span>;<br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// this === obj（永远是实例）</span><br></code></pre></td></tr></table></figure><p><strong>3. 静态方法（<code>static method() &#123;&#125;</code>）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;静态方法&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义位置：类本身（<code>MyClass.method</code>），而不是实例或构造函数里，只定义一次。</li><li>不是在构造函数中定义的</li><li>只能通过类调用，不能通过实例调用，<code>MyClass.staticMethod()</code>，此时 <code>this === MyClass</code></li></ul><table><thead><tr><th>方法类型</th><th>记忆口诀</th></tr></thead><tbody><tr><td>原型方法</td><td>谁调用我，我的 <code>this</code> 就是谁</td></tr><tr><td>实例函数表达式</td><td>和原型方法一样</td></tr><tr><td>箭头函数</td><td>定义时绑定 <code>this</code>，永不改变</td></tr><tr><td>静态方法</td><td>类调用它，<code>this</code> 是类对象</td></tr></tbody></table><h2 id="JavaScript-数组"><a href="#JavaScript-数组" class="headerlink" title="JavaScript 数组"></a>JavaScript 数组</h2><h3 id="【数组常用方法】"><a href="#【数组常用方法】" class="headerlink" title="【数组常用方法】"></a>【数组常用方法】</h3><ul><li><p><strong>Array.from()</strong><br>将类数组或 iterable 转为真正的数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Array.isArray()</strong><br>判断是否为数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Array.of()</strong><br>使用参数创建新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>concat()</strong><br>合并数组，返回新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">concat</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>copyWithin(target, start, end?)</strong><br>把一部分复制到另一部分（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// [1, 3, 4, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>every(callback)</strong><br>所有元素都满足条件返回 <code>true</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>entries()</strong><br>返回键值对迭代器  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [i, val] <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, val); <span class="hljs-comment">// 0 &#x27;a&#x27;, 1 &#x27;b&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>fill(value, start?, end?)</strong><br>用固定值填充（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// [0, 0, 0]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>filter(callback)</strong><br>过滤符合条件的元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>); <span class="hljs-comment">// [2, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>find(callback)</strong><br>找到第一个满足条件的元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p><strong>findIndex(callback)</strong><br>找到第一个满足条件元素的索引  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>flat(depth?)</strong><br>扁平化数组（默认一层）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]].<span class="hljs-title function_">flat</span>(); <span class="hljs-comment">// [1, 2, [3]]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>flatMap(callback)</strong><br>类似 <code>map().flat()</code>，返回新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x, x * <span class="hljs-number">2</span>]); <span class="hljs-comment">// [1, 2, 2, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>forEach(callback)</strong><br>遍历元素（无返回值）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x))<br></code></pre></td></tr></table></figure></li><li><p><strong>includes(value)</strong><br>判断数组是否包含某个值  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>indexOf(value, from?)</strong><br>找元素的首次索引  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>join(separator?)</strong><br>将数组转换为字符串  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">// &quot;1-2-3&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>lastIndexOf(value)</strong><br>找元素最后一次出现的索引  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong>length</strong><br>数组长度（也可设置）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// arr = [1, 2]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>map(callback)</strong><br>转换每个元素，返回新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>); <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>pop()</strong><br>移除最后一个元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 3, arr = [1, 2]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>push(…items)</strong><br>末尾添加元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// arr = [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>reduce(callback, initialValue)</strong><br>从左到右聚合数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li><li><p><strong>reduceRight(callback, initialValue)</strong><br>从右到左聚合数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b); <span class="hljs-comment">// &quot;cba&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>reverse()</strong><br>反转数组顺序（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>shift()</strong><br>删除开头元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 1, arr = [2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>slice(start, end?)</strong><br>截取片段，不修改原数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>some(callback)</strong><br>至少有一个满足条件  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>sort(compareFn?)</strong><br>排序数组（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>splice(start, deleteCount, …items)</strong><br>删除&#x2F;替换&#x2F;添加（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// arr = [1, 9, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>toString()</strong><br>转换为字符串  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>unshift(…items)</strong><br>开头添加元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// arr = [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><p>不修改原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">at()</span><br><span class="hljs-comment">    - 可以根据索引获取数组中的指定元素</span><br><span class="hljs-comment">    - at可以接收负索引作为参数</span><br><span class="hljs-comment">concat()</span><br><span class="hljs-comment">    - 用来连接两个或多个数组</span><br><span class="hljs-comment">    - 非破坏性方法，不会影响原数组，而是返回一个新的数组</span><br><span class="hljs-comment">indexOf()</span><br><span class="hljs-comment">    - 获取元素在数组中第一次出现的索引</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 要查询的元素</span><br><span class="hljs-comment">        2. 查询的其实位置</span><br><span class="hljs-comment">lastIndexOf()</span><br><span class="hljs-comment">    - 获取元素在数组中最后一次出现的位置</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">        找到了则返回元素的索引，</span><br><span class="hljs-comment">        没有找到返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">join()</span><br><span class="hljs-comment">    - 将一个数组中的元素连接为一个字符串</span><br><span class="hljs-comment">    - [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;, &quot;唐僧&quot;, &quot;沙和尚&quot;] -&gt; &quot;孙悟空,猪八戒,沙和尚,唐僧,沙和尚&quot;</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        指定一个字符串作为连接符</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">slice()</span><br><span class="hljs-comment">    - 用来截取数组（非破坏性方法）     </span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 截取的起始位置（包括该位置）</span><br><span class="hljs-comment">        2. 截取的结束位置（不包括该位置）   </span><br><span class="hljs-comment">            - 第二个参数可以省略不写，如果省略则会一直截取到最后</span><br><span class="hljs-comment">            - 索引可以是负值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><p>修改原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">push()</span><br><span class="hljs-comment">    - 向数组的末尾添加一个或多个元素，并返回新的长度</span><br><span class="hljs-comment">pop()</span><br><span class="hljs-comment">    - 删除并返回数组的最后一个元素</span><br><span class="hljs-comment">unshift()</span><br><span class="hljs-comment">    - 向数组的开头添加一个或多个元素，并返回新的长度</span><br><span class="hljs-comment">shift()</span><br><span class="hljs-comment">    - 删除并返回数组的第一个元素</span><br><span class="hljs-comment">splice()</span><br><span class="hljs-comment">    - 可以删除、插入、替换数组中的元素</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 删除的起始位置</span><br><span class="hljs-comment">        2. 删除的数量</span><br><span class="hljs-comment">        3. 要插入的元素</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">        - 返回被删除的元素</span><br><span class="hljs-comment">reverse()</span><br><span class="hljs-comment">    - 反转数组</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;唐僧&quot;</span>, <span class="hljs-string">&quot;白骨精&quot;</span>)<br><br><span class="hljs-comment">// console.log(arr)</span><br><br>result = arr.<span class="hljs-title function_">pop</span>()<br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;牛魔王&quot;</span>)<br>arr.<span class="hljs-title function_">shift</span>()<br><br><span class="hljs-comment">// console.log(arr)</span><br><br>arr = [<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;沙和尚&quot;</span>, <span class="hljs-string">&quot;唐僧&quot;</span>]<br><span class="hljs-comment">// result = arr.splice(1, 3)</span><br><span class="hljs-comment">// result = arr.splice(1, 1, &quot;牛魔王&quot;, &quot;铁扇公主&quot;, &quot;红孩儿&quot;)</span><br>result = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;牛魔王&quot;</span>, <span class="hljs-string">&quot;铁扇公主&quot;</span>, <span class="hljs-string">&quot;红孩儿&quot;</span>)<br><br><span class="hljs-comment">// console.log(result)</span><br><span class="hljs-comment">// console.log(arr)</span><br><br>arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]<br>arr.<span class="hljs-title function_">reverse</span>()<br></code></pre></td></tr></table></figure><p>数组内置的高阶函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">sort()</span><br><span class="hljs-comment">    - sort用来对数组进行排序（会对改变原数组）</span><br><span class="hljs-comment">    - sort默认会将数组升序排列</span><br><span class="hljs-comment">        注意：sort默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序</span><br><span class="hljs-comment">            可能会得到一个不正确的结果</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - 可以传递一个回调函数作为参数，通过回调函数来指定排序规则</span><br><span class="hljs-comment">            (a, b) =&gt; a - b 升序排列</span><br><span class="hljs-comment">            (a, b) =&gt; b - a 降序排列</span><br><span class="hljs-comment">forEach()</span><br><span class="hljs-comment">    - 用来遍历数组</span><br><span class="hljs-comment">    - 它需要一个回调函数作为参数，这个回调函数会被调用多次</span><br><span class="hljs-comment">        数组中有几个元素，回调函数就会调用几次</span><br><span class="hljs-comment">        每次调用，都会将数组中的数据作为参数传递</span><br><span class="hljs-comment">    - 回调函数中有三个参数：</span><br><span class="hljs-comment">        element 当前的元素</span><br><span class="hljs-comment">        index 当前元素的索引</span><br><span class="hljs-comment">        array 被遍历的数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">filter()</span><br><span class="hljs-comment">    - 将数组中符合条件的元素保存到一个新数组中返回</span><br><span class="hljs-comment">    - 需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中</span><br><span class="hljs-comment">    - 非破坏性方法，不会影响原数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">map()</span><br><span class="hljs-comment">    - 根据当前数组生成一个新数组</span><br><span class="hljs-comment">    - 需要一个回调函数作为参数，</span><br><span class="hljs-comment">        回调函数的返回值会成为新数组中的元素</span><br><span class="hljs-comment">    - 非破坏性方法不会影响原数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">reduce()</span><br><span class="hljs-comment">    - 可以用来将一个数组中的所有元素整合为一个值</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 回调函数，通过回调函数来指定合并的规则</span><br><span class="hljs-comment">        2. 可选参数，初始值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">// arr.sort()</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<br><br><span class="hljs-comment">// console.log(arr)</span><br><br>arr = [<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;沙和尚&quot;</span>, <span class="hljs-string">&quot;唐僧&quot;</span>]<br><br><span class="hljs-comment">// arr.forEach((element, index, array) =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(array)</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// arr.forEach((element, index) =&gt; console.log(index, element))</span><br><br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br><span class="hljs-comment">// 获取数组中的所有偶数</span><br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> ele &gt; <span class="hljs-number">5</span>)<br><br>result = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> ele * <span class="hljs-number">2</span>)<br><br>arr = [<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;沙和尚&quot;</span>]<br><br>result = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> <span class="hljs-string">&quot;&lt;li&gt;&quot;</span> + ele + <span class="hljs-string">&quot;&lt;/li&gt;&quot;</span>)<br><br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br>result = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        1, 2</span><br><span class="hljs-comment">        3, 3</span><br><span class="hljs-comment">        6, 4</span><br><span class="hljs-comment">        10, 5</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// console.log(a, b)</span><br><br>    <span class="hljs-keyword">return</span> a * b<br>&#125;)<br><br><span class="hljs-comment">// result = arr.reduce((a, b) =&gt; a + b, 10)</span><br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><h3 id="【浅复制与深复制】"><a href="#【浅复制与深复制】" class="headerlink" title="【浅复制与深复制】"></a>【浅复制与深复制】</h3><p><strong>浅拷贝（shallow copy）</strong>通常对对象的拷贝都是浅拷贝对象的浅层进行复制（只复制一层）如果对象中存储的数据是原始值，那么拷贝的深浅是不重要进行复制，不会复制对象中的属性（或元素）</p><p><strong>数组复制方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> &#125;];<br><br><span class="hljs-comment">// 1. 使用 slice</span><br><span class="hljs-keyword">const</span> copy1 = arr.<span class="hljs-title function_">slice</span>();<br><br><span class="hljs-comment">// 2. 使用 concat</span><br><span class="hljs-keyword">const</span> copy2 = [].<span class="hljs-title function_">concat</span>(arr);<br><br><span class="hljs-comment">// 3. 使用展开运算符</span><br><span class="hljs-keyword">const</span> copy3 = [...arr];<br><br><span class="hljs-comment">// 修改嵌套对象会影响原始数组</span><br>copy1[<span class="hljs-number">2</span>].<span class="hljs-property">a</span> = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">a</span>); <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><p><strong>对象复制方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><br><span class="hljs-comment">// 1. Object.assign</span><br><span class="hljs-keyword">const</span> shallowCopy1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br><br><span class="hljs-comment">// 2. 展开运算符</span><br><span class="hljs-keyword">const</span> shallowCopy2 = &#123; ...obj &#125;;<br><br><span class="hljs-comment">// 修改嵌套对象会影响原对象</span><br>shallowCopy1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">99</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 99</span><br></code></pre></td></tr></table></figure><blockquote><p>… (展开运算符):可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递，最常用的浅复制方法。</p></blockquote><p><strong>深拷贝（deep copy）</strong>深拷贝指不仅复制对象本身，还复制对象中的属性和元素，因为性能问题，通常情况不太使用深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> clone = <span class="hljs-title function_">structuredClone</span>(value);<br></code></pre></td></tr></table></figure><blockquote><p>注意浅复制和引用不同，浅复制第一层是独立的。</p></blockquote><h1 id="JavaScript进阶"><a href="#JavaScript进阶" class="headerlink" title="JavaScript进阶"></a>JavaScript进阶</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值是一种从<strong>数组或对象中提取数据</strong>并快速赋值给变量的语法糖，它让代码更简洁、结构更清晰，尤其适合函数参数、数据提取等场景。</p><h3 id="【数组解构赋值】"><a href="#【数组解构赋值】" class="headerlink" title="【数组解构赋值】"></a>【数组解构赋值】</h3><p> 基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">const</span> [a, b, c] = arr;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c); <span class="hljs-comment">// 10 20 30</span><br></code></pre></td></tr></table></figure><p> 可跳过元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [first, , third] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first, third); <span class="hljs-comment">// 1 3</span><br></code></pre></td></tr></table></figure><p> 设置默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a = <span class="hljs-number">100</span>, b = <span class="hljs-number">200</span>] = [<span class="hljs-number">10</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// 10 200</span><br></code></pre></td></tr></table></figure><p>与 <code>rest</code> 参数结合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [head, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(head); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest); <span class="hljs-comment">// [2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="【对象解构赋值】"><a href="#【对象解构赋值】" class="headerlink" title="【对象解构赋值】"></a>【对象解构赋值】</h3><p>基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> &#123; name, age &#125; = obj;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// Alice 25</span><br></code></pre></td></tr></table></figure><p>重命名变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>: userName &#125; = obj;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userName); <span class="hljs-comment">// Alice</span><br></code></pre></td></tr></table></figure><p>默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; gender = <span class="hljs-string">&#x27;unknown&#x27;</span> &#125; = obj;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gender); <span class="hljs-comment">// unknown</span><br></code></pre></td></tr></table></figure><h3 id="【函数参数解构】"><a href="#【函数参数解构】" class="headerlink" title="【函数参数解构】"></a>【函数参数解构】</h3><p>对象参数解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">&#123; name, age &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>. You are <span class="hljs-subst">$&#123;age&#125;</span>.`</span>);<br>&#125;<br><br><span class="hljs-title function_">greet</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;);<br><span class="hljs-comment">// 输出：Hello, Bob. You are 30.</span><br></code></pre></td></tr></table></figure><p>数组参数解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">[a, b]</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="【嵌套解构】"><a href="#【嵌套解构】" class="headerlink" title="【嵌套解构】"></a>【嵌套解构】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">profile</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">contacts</span>: &#123;<br>      <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;tom@example.com&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> &#123;<br>  <span class="hljs-attr">profile</span>: &#123;<br>    <span class="hljs-attr">contacts</span>: &#123; email &#125;<br>  &#125;<br>&#125; = user;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(email); <span class="hljs-comment">// tom@example.com</span><br></code></pre></td></tr></table></figure><h3 id="【常见用途】"><a href="#【常见用途】" class="headerlink" title="【常见用途】"></a>【常见用途】</h3><p>快速交换变量值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>[a, b] = [b, a];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// 2 1</span><br></code></pre></td></tr></table></figure><p>快速提取 API 返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; data, code, message &#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/info&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在 Vue&#x2F;React 中提取 props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;count&#x27;</span>]);<br><span class="hljs-keyword">const</span> &#123; title, count &#125; = props;<br></code></pre></td></tr></table></figure><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><p><strong>对象序列化（Serialization）就是将 JavaScript 中的对象转换成可以存储或传输</strong>的格式（通常是字符串），最常见的是 <strong>JSON 字符串</strong>。</p><h3 id="【序列和反序列化】"><a href="#【序列和反序列化】" class="headerlink" title="【序列和反序列化】"></a>【序列和反序列化】</h3><p>常用的序列化方式：<code>JSON.stringify</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value, replacer, space)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>value</code></td><td>要序列化的对象</td></tr><tr><td><code>replacer</code></td><td>可选，<strong>函数或数组</strong>，用于定制序列化过程</td></tr><tr><td><code>space</code></td><td>可选，格式化缩进用的空格数（调试时常用）</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonStr); <span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p> 反序列化：<code>JSON.parse</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;&#x27;</span>;<br><span class="hljs-keyword">const</span> parsed = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed.<span class="hljs-property">name</span>); <span class="hljs-comment">// Alice</span><br></code></pre></td></tr></table></figure><p><code>JSON.stringify()</code> 的一些特点和陷阱</p><p><font color="#409eff"> 支持：</font></p><ul><li>数字、字符串、布尔值、数组、对象</li><li><code>null</code></li></ul><p><font color="#409eff">不支持或被忽略：</font></p><table><thead><tr><th>数据类型</th><th>序列化结果</th></tr></thead><tbody><tr><td><code>undefined</code></td><td>被忽略</td></tr><tr><td><code>function</code></td><td>被忽略</td></tr><tr><td><code>symbol</code></td><td>被忽略</td></tr><tr><td>循环引用</td><td>会报错</td></tr><tr><td>BigInt</td><td>会报错（<code>TypeError</code>）</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;x&quot;</span>)<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)); <span class="hljs-comment">// &#123;&quot;a&quot;:1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="【序列化进阶用法】"><a href="#【序列化进阶用法】" class="headerlink" title="【序列化进阶用法】"></a>【序列化进阶用法】</h3><p>1.自定义序列化（toJSON 方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-title function_">toJSON</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">userName</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user)); <span class="hljs-comment">// &#123;&quot;userName&quot;:&quot;Tom&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>2.使用 replacer（过滤或转换字段）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj, [<span class="hljs-string">&#x27;name&#x27;</span>])); <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;Tom&quot;&#125;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span><br>  <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> ? <span class="hljs-literal">undefined</span> : value<br>)); <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;Tom&quot;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="【常见用途】-1"><a href="#【常见用途】-1" class="headerlink" title="【常见用途】"></a>【常见用途】</h3><blockquote><p>对象转换为字符串后，可以将字符串在不同的语言之间进行传递</p></blockquote><table><thead><tr><th>应用场景</th><th>示例</th></tr></thead><tbody><tr><td>浏览器存储</td><td><code>localStorage.setItem(&#39;user&#39;, JSON.stringify(obj))</code></td></tr><tr><td>数据传输</td><td>axios、fetch POST 时发送 JSON 字符串</td></tr><tr><td>深拷贝（有局限）</td><td><code>const newObj = JSON.parse(JSON.stringify(obj))</code></td></tr><tr><td>日志输出</td><td><code>console.log(JSON.stringify(error))</code></td></tr></tbody></table><h3 id="【手动编写JSON字符串】"><a href="#【手动编写JSON字符串】" class="headerlink" title="【手动编写JSON字符串】"></a>【手动编写JSON字符串】</h3><p>也可以手动的编写JSON字符串，在很多程序的配置文件就是使用JSON编写的</p><p>编写JSON的注意事项：</p><ol><li>JSON字符串有两种类型：JSON对象 <code>&#123;&#125;</code> &#x2F; JSON数组 <code>[]</code></li><li>JSON字符串的属性名必须使用双引号引起来</li><li>JSON中可以使用的属性值（元素）<ul><li>数字（Number）</li><li>字符串（String） 必须使用双引号</li><li>布尔值（Boolean）</li><li>空值（Null）</li><li>对象（Object {}）</li><li>数组（Array []）</li></ul></li><li>JSON的格式和JS对象的格式基本上一致的，<br>注意：JSON字符串如果属性是最后一个，则不要再加<code>,</code></li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><p><code>Map</code> 是 ES6 引入的一种新的数据结构，用于存储<strong>键值对</strong>。</p><blockquote><p>与普通对象不同的是，<code>Map</code> 的键可以是<strong>任何类型的值</strong>（包括对象、函数等）。</p></blockquote><h3 id="【Map与Object的区别】"><a href="#【Map与Object的区别】" class="headerlink" title="【Map与Object的区别】"></a>【<code>Map</code>与<code>Object</code>的区别】</h3><table><thead><tr><th>特性</th><th><code>Map</code></th><th><code>Object</code></th></tr></thead><tbody><tr><td>键的类型</td><td>任意类型（对象、函数等）</td><td>只能是字符串或 Symbol。其他类型的属性会自动转换字符串，</td></tr><tr><td>键的顺序</td><td><strong>有序</strong>（按插入顺序）</td><td>无序（某些实现可能有顺序）</td></tr><tr><td>遍历</td><td><code>map.forEach()</code>、<code>for...of</code>、<code>entries()</code></td><td><code>for...in</code>、<code>Object.keys()</code> 等</td></tr><tr><td>默认属性干扰</td><td>无（原型是 <code>null</code>）</td><td>有，继承自 <code>Object.prototype</code></td></tr><tr><td>性能</td><td>更适合频繁增删查操作</td><td>较适合静态结构的对象数据</td></tr></tbody></table><h3 id="【Map常见用法】"><a href="#【Map常见用法】" class="headerlink" title="【Map常见用法】"></a>【<code>Map</code>常见用法】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>set(key, value)</code></td><td>设置键值对</td></tr><tr><td><code>get(key)</code></td><td>获取指定键的值</td></tr><tr><td><code>has(key)</code></td><td>判断键是否存在</td></tr><tr><td><code>delete(key)</code></td><td>删除指定键</td></tr><tr><td><code>clear()</code></td><td>清空 Map</td></tr><tr><td><code>size</code></td><td>获取键值对数量</td></tr><tr><td><code>keys()</code></td><td>返回所有键的迭代器</td></tr><tr><td><code>values()</code></td><td>返回所有值的迭代器</td></tr><tr><td><code>entries()</code></td><td>返回所有键值对的迭代器</td></tr><tr><td><code>forEach(cb)</code></td><td>遍历每个键值对</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 设置键值对</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">42</span>, <span class="hljs-string">&#x27;numberKey&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;, <span class="hljs-string">&#x27;objectKey&#x27;</span>);<br><br><span class="hljs-comment">// 获取值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// Alice</span><br><br><span class="hljs-comment">// 检查是否存在键</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除键</span><br>map.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><br><span class="hljs-comment">// 清空所有键值对</span><br>map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>遍历方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>]<br>]);<br><br><span class="hljs-comment">// for...of 遍历键值对</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;<br><br><span class="hljs-comment">// 遍历 keys</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">keys</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;key:&#x27;</span>, key);<br>&#125;<br><br><span class="hljs-comment">// 遍历 values</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;value:&#x27;</span>, value);<br>&#125;<br><br><span class="hljs-comment">// forEach 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【Map转换成数组】"><a href="#【Map转换成数组】" class="headerlink" title="【Map转换成数组】"></a>【<code>Map</code>转换成数组】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map) <span class="hljs-comment">// [[&quot;name&quot;,&quot;孙悟空&quot;],[&quot;age&quot;,18]]</span><br><span class="hljs-keyword">const</span> arr = [...map]<br><br><span class="hljs-comment">// 数组转成Map，直接创建Map</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>]<br>]);<br></code></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h2><p><code>Set</code> 是一个<strong>无重复值的集合</strong>。它类似数组，但每个值只能出现一次，且值的顺序按插入顺序保存。</p><h3 id="【Set和Array的区别】"><a href="#【Set和Array的区别】" class="headerlink" title="【Set和Array的区别】"></a>【<code>Set</code>和<code>Array</code>的区别】</h3><table><thead><tr><th>特性</th><th><code>Set</code></th><th><code>Array</code></th></tr></thead><tbody><tr><td>是否允许重复值</td><td>❌ 不允许</td><td>✅ 允许</td></tr><tr><td>是否有序</td><td>✅ 插入顺序保留</td><td>✅ 有序</td></tr><tr><td>索引访问</td><td>❌ 不支持下标</td><td>✅ 支持</td></tr><tr><td>是否可迭代</td><td>✅</td><td>✅</td></tr></tbody></table><h3 id="【Set常见用法】"><a href="#【Set常见用法】" class="headerlink" title="【Set常见用法】"></a>【<code>Set</code>常见用法】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>add(value)</code></td><td>添加元素</td></tr><tr><td><code>delete(value)</code></td><td>删除元素</td></tr><tr><td><code>has(value)</code></td><td>是否存在</td></tr><tr><td><code>clear()</code></td><td>清空集合</td></tr><tr><td><code>size</code></td><td>元素数量</td></tr><tr><td><code>forEach(cb)</code></td><td>遍历集合</td></tr><tr><td><code>[...set]</code></td><td>转为数组</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 添加元素</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复的不会添加</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(3) &#123;1, 2, &#x27;hello&#x27;&#125;</span><br><br><span class="hljs-comment">// 判断是否存在</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除元素</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 清空集合</span><br>set.<span class="hljs-title function_">clear</span>();<br><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br><br><span class="hljs-comment">// for...of</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> set) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><br><span class="hljs-comment">// forEach</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item));<br><br><span class="hljs-comment">// 转成数组</span><br><span class="hljs-keyword">const</span> arr = [...set]; <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><br></code></pre></td></tr></table></figure><h3 id="【常见用途】-2"><a href="#【常见用途】-2" class="headerlink" title="【常见用途】"></a>【常见用途】</h3><ol><li>数组去重</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> uniqueArr = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>求交集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br><span class="hljs-keyword">const</span> intersection = [...set1].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> set2.<span class="hljs-title function_">has</span>(x));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(intersection); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>求差集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> diff = [...set1].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !set2.<span class="hljs-title function_">has</span>(x));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(diff); <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a><code>Math</code></h2><p>JavaScript 中的 <code>Math</code> 是一个内置对象，提供了各种<strong>数学运算相关的常用方法和常量</strong>，可以帮助我们进行取整、取绝对值、三角函数、指数、对数等计算。</p><h3 id="【取整相关】"><a href="#【取整相关】" class="headerlink" title="【取整相关】"></a>【取整相关】</h3><table><thead><tr><th>方法</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Math.floor()</code></td><td>向下取整</td><td><code>Math.floor(4.7)</code> → <code>4</code></td></tr><tr><td><code>Math.ceil()</code></td><td>向上取整</td><td><code>Math.ceil(4.1)</code> → <code>5</code></td></tr><tr><td><code>Math.round()</code></td><td>四舍五入</td><td><code>Math.round(4.5)</code> → <code>5</code></td></tr><tr><td><code>Math.trunc()</code></td><td>去除小数部分（ES6）</td><td><code>Math.trunc(4.9)</code> → <code>4</code></td></tr></tbody></table><h3 id="【数值处理】"><a href="#【数值处理】" class="headerlink" title="【数值处理】"></a>【数值处理】</h3><table><thead><tr><th>方法</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Math.abs(x)</code></td><td>绝对值</td><td><code>Math.abs(-3)</code> → <code>3</code></td></tr><tr><td><code>Math.max(...args)</code></td><td>最大值</td><td><code>Math.max(1, 5, 3)</code> → <code>5</code></td></tr><tr><td><code>Math.min(...args)</code></td><td>最小值</td><td><code>Math.min(1, 5, 3)</code> → <code>1</code></td></tr><tr><td><code>Math.pow(x, y)</code></td><td>幂运算</td><td><code>Math.pow(2, 3)</code> → <code>8</code></td></tr><tr><td><code>Math.sqrt(x)</code></td><td>平方根</td><td><code>Math.sqrt(9)</code> → <code>3</code></td></tr><tr><td><code>Math.cbrt(x)</code></td><td>立方根</td><td><code>Math.cbrt(8)</code> → <code>2</code></td></tr></tbody></table><h3 id="【随机数】"><a href="#【随机数】" class="headerlink" title="【随机数】"></a>【随机数】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); <span class="hljs-comment">// 返回 0 ~ 1 之间的随机小数（不包括1）</span><br></code></pre></td></tr></table></figure><p>示例：生成 1~10 的随机整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="【三角函数】"><a href="#【三角函数】" class="headerlink" title="【三角函数】"></a>【三角函数】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Math.sin(x)</code></td><td>正弦（x 是弧度）</td></tr><tr><td><code>Math.cos(x)</code></td><td>余弦</td></tr><tr><td><code>Math.tan(x)</code></td><td>正切</td></tr><tr><td><code>Math.asin(x)</code></td><td>反正弦</td></tr><tr><td><code>Math.acos(x)</code></td><td>反余弦</td></tr><tr><td><code>Math.atan(x)</code></td><td>反正切</td></tr></tbody></table><h3 id="【对数与指数】"><a href="#【对数与指数】" class="headerlink" title="【对数与指数】"></a>【对数与指数】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Math.log(x)</code></td><td>自然对数（以 e 为底）</td></tr><tr><td><code>Math.log10(x)</code></td><td>以 10 为底的对数（ES6）</td></tr><tr><td><code>Math.exp(x)</code></td><td>e 的 x 次幂</td></tr></tbody></table><h3 id="【常用-Math-常量】"><a href="#【常用-Math-常量】" class="headerlink" title="【常用 Math 常量】"></a>【常用 Math 常量】</h3><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>Math.PI</code></td><td>3.14159…</td><td>圆周率</td></tr><tr><td><code>Math.E</code></td><td>2.71828…</td><td>自然对数底数</td></tr><tr><td><code>Math.SQRT2</code></td><td>√2</td><td></td></tr><tr><td><code>Math.SQRT1_2</code></td><td>√(1&#x2F;2)</td><td></td></tr><tr><td><code>Math.LN2</code></td><td>ln(2)</td><td></td></tr><tr><td><code>Math.LN10</code></td><td>ln(10)</td><td></td></tr></tbody></table><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a><code>Date</code></h2><blockquote><p><code>Date</code> 是 JavaScript 中处理<strong>时间与日期的核心类</strong>，可以创建、格式化、比较和操作时间值。</p></blockquote><h3 id="【创建-Date-实例的方式】"><a href="#【创建-Date-实例的方式】" class="headerlink" title="【创建 Date 实例的方式】"></a>【创建 <code>Date</code> 实例的方式】</h3><p>获取当前时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now); <span class="hljs-comment">// 当前本地时间</span><br></code></pre></td></tr></table></figure><p>通过时间字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2025-08-04T10:00:00&quot;</span>);<br><span class="hljs-keyword">const</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;08/04/2025 10:00:00&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过参数（年, 月, 日, 时, 分, 秒, 毫秒）</p><blockquote><p>注意：月从 0 开始（0 &#x3D; 一月）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2025</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 2025年8月4日10:30</span><br></code></pre></td></tr></table></figure><p>通过时间戳（1970 年以来的毫秒数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1691136000000</span>); <span class="hljs-comment">// 指定时间戳</span><br></code></pre></td></tr></table></figure><h3 id="【常用方法】"><a href="#【常用方法】" class="headerlink" title="【常用方法】"></a>【常用方法】</h3><p>获取时间信息</p><table><thead><tr><th>方法</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>getFullYear()</code></td><td>获取年</td><td><code>date.getFullYear()</code></td></tr><tr><td><code>getMonth()</code></td><td>获取月（0-11）</td><td><code>date.getMonth()</code></td></tr><tr><td><code>getDate()</code></td><td>获取日（1-31）</td><td><code>date.getDate()</code></td></tr><tr><td><code>getDay()</code></td><td>获取星期几（0 &#x3D; 周日）</td><td><code>date.getDay()</code></td></tr><tr><td><code>getHours()</code></td><td>获取小时（0-23）</td><td><code>date.getHours()</code></td></tr><tr><td><code>getMinutes()</code></td><td>获取分钟</td><td><code>date.getMinutes()</code></td></tr><tr><td><code>getSeconds()</code></td><td>获取秒</td><td><code>date.getSeconds()</code></td></tr><tr><td><code>getMilliseconds()</code></td><td>毫秒</td><td><code>date.getMilliseconds()</code></td></tr><tr><td><code>getTime()</code></td><td>时间戳（1970 至今的毫秒数）</td><td><code>date.getTime()</code></td></tr></tbody></table><p>设置时间信息</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>setFullYear(y)</code></td><td>设置年份</td></tr><tr><td><code>setMonth(m)</code></td><td>设置月份（0-11）</td></tr><tr><td><code>setDate(d)</code></td><td>设置日期（1-31）</td></tr><tr><td><code>setHours(h)</code></td><td>设置小时（0-23）</td></tr><tr><td><code>setMinutes(min)</code></td><td>设置分钟</td></tr><tr><td><code>setSeconds(s)</code></td><td>设置秒</td></tr><tr><td><code>setTime(ms)</code></td><td>设置时间戳</td></tr></tbody></table><p><code>Date.now()</code> 获取当前的时间戳</p><h3 id="【格式化输出】"><a href="#【格式化输出】" class="headerlink" title="【格式化输出】"></a>【格式化输出】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2025</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toString</span>());        <span class="hljs-comment">// 本地完整时间字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toDateString</span>());    <span class="hljs-comment">// 仅日期部分</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toTimeString</span>());    <span class="hljs-comment">// 仅时间部分</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toISOString</span>());     <span class="hljs-comment">// ISO 标准时间（常用于后端传参）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toLocaleString</span>());  <span class="hljs-comment">// 本地格式日期+时间字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toLocaleDateString</span>());  <span class="hljs-comment">// 本地格式日期字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toLocaleTimeString</span>());  <span class="hljs-comment">// 本地格式时间字符串</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">toLocaleString()</span><br><span class="hljs-comment">    - 可以将一个日期转换为本地时间格式的字符串</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 描述语言和国家信息的字符串</span><br><span class="hljs-comment">            zh-CN 中文中国</span><br><span class="hljs-comment">            zh-HK 中文香港</span><br><span class="hljs-comment">            en-US 英文美国</span><br><span class="hljs-comment">        2. 需要一个对象作为参数，在对象中可以通过对象的属性来对日期的格式进行配置</span><br><span class="hljs-comment">                dateStyle 日期的风格</span><br><span class="hljs-comment">                timeStyle 时间的风格</span><br><span class="hljs-comment">                    full</span><br><span class="hljs-comment">                    long</span><br><span class="hljs-comment">                    medium</span><br><span class="hljs-comment">                    short</span><br><span class="hljs-comment">                hour12 是否采用12小时值</span><br><span class="hljs-comment">                    true</span><br><span class="hljs-comment">                    false</span><br><span class="hljs-comment">                weekday 星期的显示方式</span><br><span class="hljs-comment">                    long</span><br><span class="hljs-comment">                    short</span><br><span class="hljs-comment">                    narrow</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                year</span><br><span class="hljs-comment">                    numeric</span><br><span class="hljs-comment">                    2-digit </span><br><span class="hljs-comment">*/</span><br>result = d.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&quot;zh-CN&quot;</span>, &#123;<br>    <span class="hljs-attr">year</span>: <span class="hljs-string">&quot;numeric&quot;</span>,<br>    <span class="hljs-attr">month</span>: <span class="hljs-string">&quot;long&quot;</span>,<br>    <span class="hljs-attr">day</span>: <span class="hljs-string">&quot;2-digit&quot;</span>,<br>    <span class="hljs-attr">weekday</span>: <span class="hljs-string">&quot;short&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>JavaScript 的<strong>包装类</strong>是对<strong>基本数据类型</strong>（如 <code>string</code>、<code>number</code>、<code>boolean</code>）的<strong>对象封装</strong>，让它们可以像对象一样调用方法。</p><h3 id="【包装类定义】"><a href="#【包装类定义】" class="headerlink" title="【包装类定义】"></a>【包装类定义】</h3><p>包装类包括：</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>string</code></td><td><code>String</code></td></tr><tr><td><code>number</code></td><td><code>Number</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table><p>还有一些不太常见的包装类：</p><table><thead><tr><th>类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>symbol</code></td><td><code>Symbol</code>（本身是对象）</td></tr><tr><td><code>bigint</code></td><td><code>BigInt</code>（本身是对象）</td></tr><tr><td><code>null/undefined</code></td><td>没有包装类</td></tr></tbody></table><p>为什么需要包装类？</p><p>虽然像 <code>&quot;abc&quot;</code> 是字符串字面量，但我们可以写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// &quot;ABC&quot;</span><br></code></pre></td></tr></table></figure><p>这是因为 JavaScript 在背后自动进行了<strong>临时装箱（装入包装类对象）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实际发生的过程（等效于）：</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>).<span class="hljs-title function_">toUpperCase</span>();<br></code></pre></td></tr></table></figure><blockquote><p><strong>执行完后，临时对象立即销毁</strong>。</p></blockquote><p>手动使用包装类，虽然我们通常<strong>不需要手动 new 包装类对象</strong>，但你可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>);<br><span class="hljs-keyword">const</span> boolObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> strObj); <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> numObj); <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> boolObj); <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：这会变成真正的对象，和原始类型不再相等：因此包装类通常不要手动创建，而是解释器隐式使用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;abc&quot;</span>);         <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>());  <span class="hljs-comment">// object</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;abc&quot;</span> === <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// ❌ false</span><br></code></pre></td></tr></table></figure><h3 id="【String-包装类】"><a href="#【String-包装类】" class="headerlink" title="【String 包装类】"></a>【<code>String</code> 包装类】</h3><p>字符串其本质就是一个字符数组，<font color="#409eff">数组很多方法字符串都可以通用的</font>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">//&quot;hello&quot; --&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span><br>s.<span class="hljs-title function_">toUpperCase</span>();       <span class="hljs-comment">// &quot;HELLO&quot;</span><br>s.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;he&quot;</span>);      <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">// &quot;e&quot;</span><br>s.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);   <span class="hljs-comment">// &quot;hexlo&quot;</span><br>s.<span class="hljs-property">length</span>;              <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><ul><li><p><strong><code>charAt(index)</code></strong><br>获取指定索引处的字符。<br><code>&quot;hello&quot;.charAt(1)</code> → <code>&quot;e&quot;</code></p></li><li><p><strong><code>charCodeAt(index)</code></strong><br>获取指定字符的 UTF-16 编码（十进制）。<br><code>&quot;ABC&quot;.charCodeAt(0)</code> → <code>65</code></p></li><li><p><strong><code>concat(str1, str2, ...)</code></strong><br>拼接多个字符串（等效于 <code>+</code>）。<br><code>&quot;Hello&quot;.concat(&quot; &quot;, &quot;World&quot;)</code> → <code>&quot;Hello World&quot;</code></p></li><li><p><strong><code>endsWith(searchString[, length])</code></strong><br>判断字符串是否以某个子串结尾。<br><code>&quot;test.js&quot;.endsWith(&quot;.js&quot;)</code> → <code>true</code></p></li><li><p><strong><code>includes(searchString[, position])</code></strong><br>判断是否包含某个子串。<br><code>&quot;hello world&quot;.includes(&quot;world&quot;)</code> → <code>true</code></p></li><li><p><strong><code>indexOf(searchValue[, fromIndex])</code></strong><br>返回子串首次出现的位置，找不到返回 <code>-1</code>。<br><code>&quot;banana&quot;.indexOf(&quot;a&quot;)</code> → <code>1</code></p></li><li><p><strong><code>lastIndexOf(searchValue[, fromIndex])</code></strong><br>返回子串最后一次出现的位置。<br><code>&quot;banana&quot;.lastIndexOf(&quot;a&quot;)</code> → <code>5</code></p></li><li><p><strong><code>match(regex)</code></strong><br>根据正则表达式匹配内容，返回数组或 <code>null</code>。<br><code>&quot;abc123&quot;.match(/\d+/)</code> → <code>[&quot;123&quot;]</code></p></li><li><p><strong><code>matchAll(regex)</code></strong><br>返回所有正则匹配（需加 <code>g</code>），返回迭代器。<br><code>[...(&quot;a1b2&quot;.matchAll(/\d/g))]</code> → <code>[[&quot;1&quot;], [&quot;2&quot;]]</code></p></li><li><p><strong><code>normalize([form])</code></strong><br>Unicode 正规化（用于特殊字符对比）。<br><code>&quot;é&quot;.normalize(&quot;NFD&quot;)</code></p></li><li><p><strong><code>padEnd(targetLength[, padString])</code></strong><br>在字符串末尾补全到指定长度。<br><code>&quot;5&quot;.padEnd(3, &quot;0&quot;)</code> → <code>&quot;500&quot;</code></p></li><li><p><strong><code>padStart(targetLength[, padString])</code></strong><br>在字符串开头补全到指定长度。<br><code>&quot;5&quot;.padStart(3, &quot;0&quot;)</code> → <code>&quot;005&quot;</code></p></li><li><p><strong><code>repeat(count)</code></strong><br>返回重复多次的字符串。<br><code>&quot;ha&quot;.repeat(3)</code> → <code>&quot;hahaha&quot;</code></p></li><li><p><strong><code>replace(searchValue, replaceValue)</code></strong><br>替换匹配的子串。<br><code>&quot;foo123&quot;.replace(/\d+/, &quot;***&quot;)</code> → <code>&quot;foo***&quot;</code></p></li><li><p><strong><code>replaceAll(searchValue, replaceValue)</code></strong><br>替换<strong>所有</strong>匹配项（ES2021）。<br><code>&quot;a-b-c&quot;.replaceAll(&quot;-&quot;, &quot;_&quot;)</code> → <code>&quot;a_b_c&quot;</code></p></li><li><p><strong><code>search(regex)</code></strong><br>返回正则首次匹配的索引。<br><code>&quot;abc123&quot;.search(/\d/)</code> → <code>3</code></p></li><li><p><strong><code>slice(start[, end])</code></strong><br>截取字符串的一部分（不修改原字符串）。<br><code>&quot;abcdef&quot;.slice(1, 4)</code> → <code>&quot;bcd&quot;</code></p></li><li><p><strong><code>split(separator[, limit])</code></strong><br>按分隔符拆分为数组。<br><code>&quot;a,b,c&quot;.split(&quot;,&quot;)</code> → <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p></li><li><p><strong><code>startsWith(searchString[, position])</code></strong><br>判断字符串是否以指定子串开始。<br><code>&quot;hello&quot;.startsWith(&quot;he&quot;)</code> → <code>true</code></p></li><li><p><strong><code>substring(start[, end])</code></strong><br>提取从 <code>start</code> 到 <code>end</code> 之间的子串。<br><code>&quot;abcdef&quot;.substring(2, 5)</code> → <code>&quot;cde&quot;</code></p></li><li><p><strong><code>toLowerCase()</code></strong><br>转换为小写字母。<br><code>&quot;HeLLo&quot;.toLowerCase()</code> → <code>&quot;hello&quot;</code></p></li><li><p><strong><code>toUpperCase()</code></strong><br>转换为大写字母。<br><code>&quot;HeLLo&quot;.toUpperCase()</code> → <code>&quot;HELLO&quot;</code></p></li><li><p><strong><code>trim()</code></strong><br>去除首尾空白字符。<br><code>&quot;  hello  &quot;.trim()</code> → <code>&quot;hello&quot;</code></p></li><li><p><strong><code>trimStart()</code> &#x2F; <code>trimLeft()</code></strong><br>去除开头空白。<br><code>&quot;  hi&quot;.trimStart()</code> → <code>&quot;hi&quot;</code></p></li><li><p><strong><code>trimEnd()</code> &#x2F; <code>trimRight()</code></strong><br>去除结尾空白。<br><code>&quot;hi  &quot;.trimEnd()</code> → <code>&quot;hi&quot;</code></p></li><li><p><strong><code>valueOf()</code></strong><br>返回原始字符串值（用于隐式类型转换）。<br><code>&quot;abc&quot;.valueOf()</code> → <code>&quot;abc&quot;</code></p></li></ul><h3 id="【Number-包装类】"><a href="#【Number-包装类】" class="headerlink" title="【Number 包装类】"></a>【<code>Number</code> 包装类】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> n = <span class="hljs-number">123.456</span>;<br>n.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);          <span class="hljs-comment">// &quot;123.46&quot;</span><br>n.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);         <span class="hljs-comment">// &quot;1111011&quot;（转为二进制）</span><br></code></pre></td></tr></table></figure><h3 id="【Boolean-包装类】"><a href="#【Boolean-包装类】" class="headerlink" title="【Boolean 包装类】"></a>【<code>Boolean</code> 包装类】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>);            <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&quot;hello&quot;</span>);      <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 是对象，始终为 truthy！</span><br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（Regular Expression）是一种用来描述字符串<strong>匹配规则</strong>的工具，本质是<strong>匹配模式</strong>，可用来检索和替换文本。也是一个对象。格式是<code>/正则/匹配模式</code></p><h3 id="【创建方式】"><a href="#【创建方式】" class="headerlink" title="【创建方式】"></a>【创建方式】</h3><p>方式 1：使用字面量（常用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/abc\d/i</span>;<br></code></pre></td></tr></table></figure><p>方式 2：使用 <code>RegExp</code> 构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;abc\\d&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="【匹配规则】"><a href="#【匹配规则】" class="headerlink" title="【匹配规则】"></a>【匹配规则】</h3><table><thead><tr><th>字符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>.</code></td><td>任意单个字符（除换行）</td><td><code>/a.b/</code> 匹配 <code>a+b</code>, <code>a-b</code></td></tr><tr><td><code>\d</code></td><td>一个数字（0-9）</td><td><code>/\d/</code> 匹配 <code>&quot;3&quot;</code></td></tr><tr><td><code>\w</code></td><td>单词字符（字母、数字、下划线）</td><td><code>/\w/</code> 匹配 <code>&quot;a&quot;</code>, <code>&quot;5&quot;</code></td></tr><tr><td><code>\s</code></td><td>空白字符（空格、换行、制表）</td><td><code>/\s/</code></td></tr><tr><td><code>\D</code></td><td>非数字</td><td><code>/\D/</code></td></tr><tr><td><code>\W</code></td><td>非单词字符</td><td><code>/\W/</code></td></tr><tr><td><code>\S</code></td><td>非空白字符</td><td><code>/\S/</code></td></tr></tbody></table><h3 id="【量词（重复次数）】"><a href="#【量词（重复次数）】" class="headerlink" title="【量词（重复次数）】"></a>【量词（重复次数）】</h3><table><thead><tr><th>量词</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>0 次或多次</td><td><code>/a*/</code> 匹配 <code>&quot;&quot;</code>, <code>&quot;a&quot;</code>, <code>&quot;aaa&quot;</code></td></tr><tr><td><code>+</code></td><td>1 次或多次</td><td><code>/a+/</code> 匹配 <code>&quot;a&quot;</code>, <code>&quot;aaa&quot;</code></td></tr><tr><td><code>?</code></td><td>0 次或 1 次</td><td><code>/a?/</code> 匹配 <code>&quot;&quot;</code>, <code>&quot;a&quot;</code></td></tr><tr><td><code>&#123;n&#125;</code></td><td>恰好 n 次</td><td><code>/a&#123;3&#125;/</code> 匹配 <code>&quot;aaa&quot;</code></td></tr><tr><td><code>&#123;n,&#125;</code></td><td>至少 n 次</td><td><code>/a&#123;2,&#125;/</code> 匹配 <code>&quot;aa&quot;</code>, <code>&quot;aaaa&quot;</code></td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>n 到 m 次</td><td><code>/a&#123;2,4&#125;/</code> 匹配 <code>&quot;aa&quot;</code>, <code>&quot;aaa&quot;</code></td></tr></tbody></table><h3 id="【字符集合与分组】"><a href="#【字符集合与分组】" class="headerlink" title="【字符集合与分组】"></a>【字符集合与分组】</h3><table><thead><tr><th>语法</th><th>含义</th></tr></thead><tbody><tr><td><code>[abc]</code></td><td>匹配 a 或 b 或 c 中的任意一个</td></tr><tr><td><code>[^abc]</code></td><td>除了 a&#x2F;b&#x2F;c 以外的任意字符</td></tr><tr><td><code>(abc)</code></td><td>分组，整体匹配</td></tr><tr><td>&#96;a</td><td>b&#96;</td></tr><tr><td><code>^</code></td><td>匹配开头</td></tr><tr><td><code>$</code></td><td>匹配结尾</td></tr></tbody></table><ul><li>[a-z] 任意的小写字母</li><li>[A-Z] 任意的大写字母</li><li>[a-zA-Z] 任意的字母</li><li>[0-9]任意数字</li></ul><h3 id="【常用修饰符（flags）】"><a href="#【常用修饰符（flags）】" class="headerlink" title="【常用修饰符（flags）】"></a>【常用修饰符（flags）】</h3><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td><code>i</code></td><td>忽略大小写</td></tr><tr><td><code>g</code></td><td>全局匹配（多次匹配）</td></tr><tr><td><code>m</code></td><td>多行匹配（影响 <code>^</code> 和 <code>$</code>）</td></tr></tbody></table><h3 id="【常用方法】-1"><a href="#【常用方法】-1" class="headerlink" title="【常用方法】"></a>【常用方法】</h3><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><code>test(str)</code></td><td><code>Boolean</code></td><td>是否匹配字符串</td></tr><tr><td><code>exec(str)</code></td><td><code>Match对象或null</code></td><td>返回<strong>第一个匹配内容及位置</strong></td></tr></tbody></table><p>示例：<code>test()</code> 用于判断字符串是否匹配正则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;abc123&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;abc&quot;</span>));    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>示例：<code>exec()</code> 用于提取详细匹配信息，每调一次匹配一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-keyword">const</span> result = regex.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&quot;abc123def&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);     <br><span class="hljs-comment">// [&quot;123&quot;, index: 3, input: &quot;abc123def&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><p>JS 字符串与正则结合使用最常见的方式，用于查找、替换、提取等：</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><code>match(regex)</code></td><td>匹配结果数组或 null</td><td>查找匹配内容</td></tr><tr><td><code>matchAll(regex)</code></td><td>可迭代对象</td><td>匹配多个（需 <code>g</code>）</td></tr><tr><td><code>search(regex)</code></td><td>索引或 -1</td><td>查找第一次匹配的位置</td></tr><tr><td><code>replace(regex, 替换值)</code></td><td>新字符串</td><td>替换匹配内容</td></tr><tr><td><code>split(regex)</code></td><td>字符串数组</td><td>用正则切割字符串</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//match()：查找匹配内容</span><br><span class="hljs-string">&quot;abc123xyz&quot;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d+/</span>); <span class="hljs-comment">// [&quot;123&quot;]</span><br><span class="hljs-comment">//matchAll()：获取所有匹配（配合 g 修饰符）</span><br><span class="hljs-keyword">const</span> matches = <span class="hljs-string">&quot;a1b2c3&quot;</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/\d/g</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...matches]); <span class="hljs-comment">// [&#123; 0: &quot;1&quot; &#125;, &#123; 0: &quot;2&quot; &#125;, &#123; 0: &quot;3&quot; &#125;]</span><br><span class="hljs-comment">//search()：返回第一个匹配的索引</span><br><span class="hljs-string">&quot;hello123&quot;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/\d/</span>); <span class="hljs-comment">// 5</span><br><span class="hljs-comment">//replace()：替换匹配的内容</span><br><span class="hljs-string">&quot;abc123xyz&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d+/</span>, <span class="hljs-string">&quot;***&quot;</span>); <span class="hljs-comment">// &quot;abc***xyz&quot;</span><br><span class="hljs-string">&quot;abc123xyz&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d/g</span>, <span class="hljs-string">&quot;*&quot;</span>);   <span class="hljs-comment">// 全局替换，多个 * </span><br><span class="hljs-comment">//split()：基于正则切割字符串</span><br><span class="hljs-string">&quot;a,b;c.d&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[,;.]/</span>); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="【常用示例】"><a href="#【常用示例】" class="headerlink" title="【常用示例】"></a>【常用示例】</h3><p>验证手机号（中国大陆）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">/^<span class="hljs-number">1</span>[<span class="hljs-number">3</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">9</span>&#125;$/<br></code></pre></td></tr></table></figure><p>验证邮箱地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">/^[\w.-]+@[a-zA-Z\d.-]+\.[a-zA-Z]&#123;<span class="hljs-number">2</span>,&#125;$/<br></code></pre></td></tr></table></figure><p>仅匹配数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">/^\d+$/   <span class="hljs-comment">// 正整数</span><br><span class="hljs-regexp">/^-?\d+$/</span> <span class="hljs-comment">// 可带负号</span><br></code></pre></td></tr></table></figure><p>提取数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;价格是 ¥88 元&quot;</span>;<br><span class="hljs-keyword">const</span> match = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d+/</span>); <span class="hljs-comment">// [&quot;88&quot;]</span><br></code></pre></td></tr></table></figure><h1 id="JavaScript-DOM"><a href="#JavaScript-DOM" class="headerlink" title="JavaScript DOM"></a>JavaScript DOM</h1><h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><p>DOM，全称Document Object Model，<font color="#409eff">中文翻译为文档对象模型</font>。DOM属于Web API的一部分。Web API中定义了非常多的对象，通过这些对象可以完成对网页的各种操作（添加删除元素、发送请求、操作浏览器等）。它将网页结构以<strong>“树状结构”</strong>的方式表示出来，每个 HTML 标签、文本、注释都对应成一“节点（Node）”。</p><p>DOM中的D意为Document，即文档。所谓文档就是指整个网页，换言之，DOM是用来操作网页的。O意为Object，即对象。<font color="#409eff">DOM将网页中的每一部分内容都转换为了对象</font>，div有div的对象，input有input的对象，甚至一段文本，一段注释也有其所对应的对象。转换为对象干什么？还记得面向对象吗？转换对象以后，我们就可以以面向对象的方式去操作网页，想要操作哪个元素就获取哪个元素的对象，然后通过调用其方法或属性完成各种操作。M意为Model，即模型。模型用来表示对象之间的关系，也就是父子元素、祖先后代、兄弟元素等，明确关系后我们便可以通过任意一个对象去获取其他的对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>A Heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link Text<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2025/08/04/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220808135838431.png" class title="img"><h3 id="【节点（Node）】"><a href="#【节点（Node）】" class="headerlink" title="【节点（Node）】"></a>【节点（Node）】</h3><p>在DOM标准下，<strong>网页中的每一个部分都会转换为对象。这些对象有一个共同的称呼——节点（Node）</strong>。一个页面将会由多个节点构成，虽然都称为节点，但是它们却有着不同的类型：</p><ol><li>文档节点</li><li>元素节点</li><li>文本节点</li><li>属性节点</li><li>…</li></ol><p>每一个节点都有其不同的作用，文档节点表示整个网页，元素节点表示某个标签，文本节点表示网页中的文本内容，属性节点表示标签中的各种属性。如果从对象的结构上来讲，这些对象都有一个共同的父类Node。总的来说，都是属于节点，但是具体类型不同。</p><h3 id="【关系】"><a href="#【关系】" class="headerlink" title="【关系】"></a>【关系】</h3><ul><li>祖先 —— 包含后代元素的元素是祖先元素</li><li>后代 —— 被祖先元素包含的元素是后代元素</li><li>父 —— 直接包含子元素的元素是父元素</li><li>子 —— 直接被父元素包含的元素是子元素</li><li>兄弟 —— 拥有相同父元素的元素是兄弟元素</li></ul><h2 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a><code>Document对象</code></h2><p>在 JavaScript 中，<code>document</code> 是访问 <strong>DOM（文档对象模型）</strong> 的<strong>入口对象</strong>，它代表整个网页，也叫 <strong>文档对象</strong>。通过它，你可以获取页面上的元素、创建节点、绑定事件、修改结构等。</p><p><code>document</code> 是浏览器提供的一个全局对象，它表示当前加载的 HTML 页面，是 <code>window</code> 对象的属性之一。</p><p>DOM就是一种宿主对象，即由运行环境（浏览器）提供的对象。对象的复杂程度也开始提升，我们先来看看document的继承关系：</p><img src="/2025/08/04/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220808141848408.png" class title="img"><p>在标准中，Document继承了Node，Node继承了EventTarget，换言之EventTarget、Node以及Document中所定义的方法document都可以调用，它在浏览器中的实际结构会更复杂一些，这里我们暂时不过多的赘述。</p><blockquote><p>document对象的原型链 HTMLDocument -&gt; Document -&gt; Node -&gt; EventTarget -&gt; Object.prototype -&gt; null</p></blockquote><p>凡是再原型链中存在的对象的属性和方法都可以调用。</p><p><strong>部分属性：</strong></p><table><thead><tr><th>属性&#x2F;方法</th><th>含义</th></tr></thead><tbody><tr><td><code>document.documentElement</code></td><td>获取 <code>&lt;html&gt;</code> 元素</td></tr><tr><td><code>document.body</code></td><td>获取 <code>&lt;body&gt;</code> 元素</td></tr><tr><td><code>document.head</code></td><td>获取 <code>&lt;head&gt;</code> 元素</td></tr><tr><td><code>document.title</code></td><td>获取&#x2F;设置网页标题</td></tr><tr><td><code>document.URL</code></td><td>当前页面完整 URL</td></tr><tr><td><code>document.domain</code></td><td>当前页面的域名</td></tr><tr><td><code>document.cookie</code></td><td>读取&#x2F;设置 cookie 值</td></tr><tr><td><code>document.readyState</code></td><td>加载状态：<code>loading</code>、<code>interactive</code>、<code>complete</code></td></tr></tbody></table><h2 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h2><p>在网页中所有的元素（标签）都是一个Element对象。Element对象的继承关系和Document类似：</p><img src="/2025/08/04/JavaScript/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220808210844195.png" class title="img"><table><thead><tr><th>特性</th><th><code>Node</code></th><th><code>Element</code></th></tr></thead><tbody><tr><td>类型</td><td>基类</td><td>HTML 元素的专用子类</td></tr><tr><td>包含哪些</td><td>文本、注释、元素等</td><td>只有 HTML 元素</td></tr><tr><td>常用方法</td><td>appendChild 等</td><td>innerHTML、style、classList 等</td></tr></tbody></table><p>可以通过Document或其他元素直接获取已有的Element对象，也可以使用Document来创建新的Element对象。我们先来看看如何通过document获取已有的Element对象。</p><ul><li><code>document.documentElement</code> 获取html根元素</li><li><code>document.body</code> 获取body元素</li><li><code>document.getElementByID()</code> 根据id获取一个元素</li><li><code>document.getElementsByClassName()</code> 根据class属性获取元素（实时更新列表）</li><li><code>document.getElementsByTagName()</code> 根据标签名获取元素（实时更新列表）</li><li><code>document.getElementsByName()</code> 根据name属性获取元素（实时更新列表）</li><li><code>document.querySelector()</code> 根据选择器获取一个元素</li><li><code>document.querySelectorAll()</code> 根据选择器获取一组元素</li></ul><p>通过其他元素获取已有的Element对象：</p><ul><li><code>element.children</code></li><li><code>element.parentNode</code></li><li><code>element.firstElementChild</code></li><li><code>element.lastElementChild</code></li><li>……</li></ul><p>创建Element对象：</p><ul><li><code>document.createElement()</code> 根据标签名创建元素节点对象</li></ul><h3 id="【文本操作】"><a href="#【文本操作】" class="headerlink" title="【文本操作】"></a>【文本操作】</h3><p>在DOM中，文本内容也是一个节点对象（Text），可以通过获取文本对象然后完成对它的各种操作，但这种做法会使得事情变得复杂，并不建议这么做。在大部分场景下，可以通过元素的属性来操作其中的文本内容，比如有如下文本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div中的文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设我们已经获取到了div的元素节点对象，我们可以通过以下的属性来完成对文本的操作：</p><table><thead><tr><th>属性&#x2F;方法</th><th>作用</th></tr></thead><tbody><tr><td><code>innerHTML</code></td><td>获取&#x2F;设置 HTML 内容（会解析标签）</td></tr><tr><td><code>textContent</code></td><td>获取&#x2F;设置纯文本内容（不解析 HTML）</td></tr><tr><td><code>innerText</code></td><td>类似于 <code>textContent</code>，受 CSS 影响</td></tr></tbody></table><h3 id="【属性操作】"><a href="#【属性操作】" class="headerlink" title="【属性操作】"></a>【属性操作】</h3><p>属性也是一个节点对象（Attr），和文本一样，通常我们不会去直接获取节点对象，而是通过元素来完成对属性的操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getAttribute(name)</code></td><td>获取属性</td></tr><tr><td><code>setAttribute(name, value)</code></td><td>设置属性</td></tr><tr><td><code>removeAttribute(name)</code></td><td>删除属性</td></tr><tr><td><code>hasAttribute(name)</code></td><td>检查属性是否存在</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;box&#x27;</span>);<br>element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="【类名操作】"><a href="#【类名操作】" class="headerlink" title="【类名操作】"></a>【类名操作】</h3><p>使用 <code>classList</code> 操作类名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;hidden&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;dark&#x27;</span>); <span class="hljs-comment">// 有则删，无则加</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;dark&#x27;</span>); <span class="hljs-comment">// 检查类名是否存在</span><br></code></pre></td></tr></table></figure><h3 id="【样式操作】"><a href="#【样式操作】" class="headerlink" title="【样式操作】"></a>【样式操作】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;yellow&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p><code>element.style</code> 是操作内联样式，不影响 class 设置的样式。</p></blockquote><h2 id="事件（event）"><a href="#事件（event）" class="headerlink" title="事件（event）"></a>事件（event）</h2><p>事件指用户和网页之间发生的交互行为。比如点击按钮、移动鼠标、改变窗口大小、表单输入等等等等，用户的所有操作都可以被当成是一个事件。JS中通过为事件绑定回调函数来处理事件，绑定回调函数后，事件触发后回调函数便会执行，以此来响应用户的行为，所以事件的回调函数我们也称其为事件的响应函数。</p><h3 id="【绑定回调函数】"><a href="#【绑定回调函数】" class="headerlink" title="【绑定回调函数】"></a>【绑定回调函数】</h3><ol><li>通过标签的事件属性</li><li>通过元素对象的事件属性</li><li>通过元素addEventListener()方法</li></ol><p>方式一：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;按钮被点了！&#x27;)&quot;</span>&gt;</span>点我一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点击了！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>方式三：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>&#125;) <span class="hljs-comment">// 可以绑定多个事件</span><br></code></pre></td></tr></table></figure><h2 id="文档加载事件"><a href="#文档加载事件" class="headerlink" title="文档加载事件"></a>文档加载事件</h2><p>在网页中编写DOM代码时，如果依然将script标签编写到head中，会有无法获取DOM对象情况出现。这是因为网页的加载是自上向下依次加载的，如果将代码写在前边会导致代码执行时网页还没有加载，DOM对象也就无法获取了。</p><p>如何解决这个问题呢？有这么几种方案：</p><ol><li>将script标签写在body的最后</li><li>将js代码编写到window.onload事件的回调函数中</li><li>将js代码编写到document对象的DOMContentLoaded事件的回调函数中</li><li>将js代码编写到外部的js文件中，引入时为script标签添加defer属性</li></ol><p>方式一：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点我一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)</span><br><span class="language-javascript">            btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)</span><br><span class="language-javascript">            &#125;)</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码编写到了body的最后，代码执行时网页已经加载完毕了，不会出现无法获取DOM对象的问题。</p><p>方式二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>将js代码编写到window的load事件的回调函数中，load事件会在页面加载完毕后触发，同样可以避免上述问题。</p><p>方式三：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>将js代码编写到document的DOMContentLoaded事件的回调函数中，代码会在当前文档加载完毕后执行也可以避免上述情况。（相较于load事件，DOMContentLoaded事件的执行更早一些）</p><p>方式四：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置defer后，脚本将会在文档解析之后加载，同样可以避免上述问题。（执行时机早于DOMContentLoaded）</p><h2 id="Element操作"><a href="#Element操作" class="headerlink" title="Element操作"></a>Element操作</h2><h3 id="【增删改查】"><a href="#【增删改查】" class="headerlink" title="【增删改查】"></a>【增删改查】</h3><table><thead><tr><th>操作</th><th>含义</th><th>关键词</th></tr></thead><tbody><tr><td>查</td><td>查询&#x2F;获取元素</td><td><code>getElementById</code>、<code>querySelector</code> 等</td></tr><tr><td>增</td><td>新增元素（创建并添加）</td><td><code>createElement</code> + <code>appendChild</code></td></tr><tr><td>改</td><td>修改内容&#x2F;属性&#x2F;样式</td><td><code>textContent</code>、<code>style</code>、<code>setAttribute</code></td></tr><tr><td>删</td><td>删除已有元素</td><td><code>removeChild()</code> 或 <code>remove()</code></td></tr></tbody></table><p><strong>查（Read）：获取元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;id&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;css选择器&#x27;</span>);      <span class="hljs-comment">// 返回第一个匹配</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;css选择器&#x27;</span>);   <span class="hljs-comment">// 返回所有匹配</span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> title = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>);<br><span class="hljs-keyword">const</span> listItems = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;ul li&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>增（Create）：新增元素</strong></p><p>创建元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>newDiv.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;我是新元素&#x27;</span>;<br></code></pre></td></tr></table></figure><p>插入元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(newDiv);              <span class="hljs-comment">// 添加到 body 最后</span><br>parent.<span class="hljs-title function_">insertBefore</span>(newDiv, referenceNode);     <span class="hljs-comment">// 插入到某个子元素前</span><br>list.<span class="hljs-title function_">insertAdjacentElement</span>(<span class="hljs-string">&quot;afterend&quot;</span>, li)<br><span class="hljs-comment">//insertAdjacentElement()可以向元素的任意位置添加元素</span><br><span class="hljs-comment">//两个参数：1.要添加的位置 2.要添加的元素</span><br><span class="hljs-comment">// beforeend 标签的最后 afterbegin 标签的开始  </span><br><span class="hljs-comment">// beforebegin 在元素的前边插入元素（兄弟元素） afterend 在元素的后边插入元素（兄弟元素）</span><br><span class="hljs-comment">// 容易被xss攻击</span><br></code></pre></td></tr></table></figure><p>创建并插入多个元素（推荐使用 DocumentFragment）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>  li.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;项 &#x27;</span> + (i + <span class="hljs-number">1</span>);<br>  fragment.<span class="hljs-title function_">appendChild</span>(li);<br>&#125;<br>ul.<span class="hljs-title function_">appendChild</span>(fragment);<br></code></pre></td></tr></table></figure><p><strong>改（Update）：修改元素内容&#x2F;样式&#x2F;属性</strong></p><p>修改内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;新文本内容&#x27;</span>;<br>element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;strong&gt;新内容&lt;/strong&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>修改样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;hidden&#x27;</span>);<br></code></pre></td></tr></table></figure><p>修改属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;提示文字&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>删（Delete）：删除元素</strong></p><p>方法一：从父元素中移除子元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parent.<span class="hljs-title function_">removeChild</span>(child);<br></code></pre></td></tr></table></figure><p>方法二：直接删除（现代写法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">remove</span>();  <span class="hljs-comment">// ES6+</span><br></code></pre></td></tr></table></figure><h3 id="【节点复制】"><a href="#【节点复制】" class="headerlink" title="【节点复制】"></a>【节点复制】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> newNode = node.<span class="hljs-title function_">cloneNode</span>(deep);<br></code></pre></td></tr></table></figure><p><code>deep</code>（布尔值）：</p><ul><li><code>true</code>：深拷贝，复制节点本身 <strong>及其所有子节点</strong></li><li><code>false</code>：浅拷贝，只复制当前节点，不复制其子节点</li></ul><p>复制后的节点是<strong>新的节点对象</strong>，你可以对它进行修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> copy = original.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);<br>copy.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;copy&#x27;</span>;                       <span class="hljs-comment">// 改 ID</span><br>copy.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;span&#x27;</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;JS&#x27;</span>; <span class="hljs-comment">// 改内部内容</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(copy);<br></code></pre></td></tr></table></figure><table><thead><tr><th>注意点</th><th>说明</th></tr></thead><tbody><tr><td>不会复制事件</td><td>事件监听器不会被克隆（必须手动添加）</td></tr><tr><td>不会复制绑定的数据</td><td>自定义属性、数据绑定等框架状态不会复制</td></tr><tr><td>不会插入页面</td><td><code>cloneNode()</code> 只是创建节点，需 <code>appendChild()</code> 或 <code>insertBefore()</code> 插入页面</td></tr></tbody></table><h3 id="【样式修改】"><a href="#【样式修改】" class="headerlink" title="【样式修改】"></a>【样式修改】</h3><p>两种常见方式</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>element.style</code></td><td>修改<strong>行内样式</strong></td></tr><tr><td><code>element.classList</code></td><td>通过<strong>类名</strong>控制样式</td></tr></tbody></table><p>使用 <code>element.style</code> 直接修改样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.样式名 = <span class="hljs-string">&#x27;值&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>注意：JS 中的样式名使用 <strong>驼峰命名</strong>，如 <code>backgroundColor</code>、<code>fontSize</code>。</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;box&#x27;</span>);<br><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;              <span class="hljs-comment">// 设置字体颜色</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;yellow&#x27;</span>; <span class="hljs-comment">// 设置背景</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&#x27;20px&#x27;</span>;          <span class="hljs-comment">// 设置字体大小</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;1px solid black&#x27;</span>; <span class="hljs-comment">// 设置边框</span><br></code></pre></td></tr></table></figure><p>清除样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">box.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 清除 color 样式</span><br></code></pre></td></tr></table></figure><p><strong>使用 <code>className</code> 或 <code>classList</code> 控制样式（推荐）</strong></p><p>相比 <code>element.style</code>，使用类名控制样式更整洁、易维护。</p><p>设置整个类名（不推荐直接覆盖）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;box active&#x27;</span>; <span class="hljs-comment">// 替换所有类名</span><br></code></pre></td></tr></table></figure><p>推荐使用 <code>element.classList</code>（常用）</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>add(&#39;class&#39;)</code></td><td>添加类名</td></tr><tr><td><code>remove(&#39;class&#39;)</code></td><td>删除类名</td></tr><tr><td><code>toggle(&#39;class&#39;)</code></td><td>有则删，无则加（切换）</td></tr><tr><td><code>contains(&#39;class&#39;)</code></td><td>检查类名是否存在</td></tr></tbody></table><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;hidden&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;dark-mode&#x27;</span>);<br><span class="hljs-keyword">if</span> (element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;active&#x27;</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前处于激活状态&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>🔁 <code>toggle()</code> 可配合按钮实现样式切换。</p></blockquote><p><strong>完整例子：点击切换样式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.highlight</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>点按钮改变我<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>切换样式<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      text.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>动态修改多个样式</strong></p><p>你可以一次性修改多个样式属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(element.<span class="hljs-property">style</span>, &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;white&#x27;</span>,<br>  <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;10px&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>或者使用 CSS 变量配合样式切换。</p><p>如果你想<font color="#409eff">获取实际生效的样式</font>，而不是行内的，可以用<code>getComputedStyle</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> styles = <span class="hljs-title function_">getComputedStyle</span>(element);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(styles.<span class="hljs-property">color</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(styles.<span class="hljs-property">fontSize</span>);<br></code></pre></td></tr></table></figure><p><strong>style 与 classList 的区别</strong></p><table><thead><tr><th>对比项</th><th><code>element.style</code></th><th><code>element.classList</code></th></tr></thead><tbody><tr><td>修改方式</td><td>直接操作行内样式</td><td>添加&#x2F;删除类名</td></tr><tr><td>可读性</td><td>差</td><td>高</td></tr><tr><td>可维护性</td><td>差</td><td>高（CSS 中集中管理）</td></tr><tr><td>适合情况</td><td>动态计算样式、动画</td><td>常规样式控制、主题切换</td></tr></tbody></table><p><strong>常见坑与注意事项</strong></p><ol><li><p><strong>样式名要用驼峰写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> <span class="hljs-comment">// 而不是 background-color</span><br></code></pre></td></tr></table></figure></li><li><p><strong>缺单位的值会无效</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&#x27;20px&#x27;</span>; <span class="hljs-comment">// 不要忘记 px</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不要直接覆盖 className（容易丢类）</strong></p></li><li><p><strong>事件触发修改样式</strong>时注意不要写错引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><p><strong>根据属性获取样式</strong></p><table><thead><tr><th>属性</th><th>包括哪些部分</th><th>常用于</th></tr></thead><tbody><tr><td><code>clientWidth</code></td><td>内容区 + padding</td><td>可视内容宽度</td></tr><tr><td><code>offsetWidth</code></td><td>内容区 + padding + border（+ 滚动条）</td><td>元素总宽度</td></tr><tr><td><code>scrollWidth</code></td><td>所有内容宽度（即使不可见）</td><td>内容溢出检测、横向滚动</td></tr><tr><td><code>offsetParent</code></td><td>离元素最近的设置了定位的祖先元素</td><td>定位计算</td></tr><tr><td><code>offsetTop</code></td><td>元素顶部相对于 <code>offsetParent</code> 的距离</td><td>绝对&#x2F;相对定位偏移计算</td></tr><tr><td><code>scrollTop</code></td><td>元素垂直滚动偏移量</td><td>滚动判断、回滚顶部&#x2F;底部控制</td></tr></tbody></table><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>事件对象是浏览器在事件触发时自动传递给事件监听函数的<strong>包含事件详细信息的对象</strong>。浏览器在创建事件对象后，会将事件对象作为响应函数的参数传递，所以我们可以在事件的回调函数中定义一个形参来接收事件对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event); <span class="hljs-comment">// 输出事件对象</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>在函数中通常会用 <code>e</code> 或 <code>event</code> 表示该对象。这个对象中<font color="#409eff">封装了事件相关的各种信息.</font></p><h3 id="【基本结构】"><a href="#【基本结构】" class="headerlink" title="【基本结构】"></a>【基本结构】</h3><p>事件对象是各种事件类型的基类对象（如 <code>MouseEvent</code>、<code>KeyboardEvent</code>、<code>InputEvent</code>），都继承自 <code>Event</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">event &#123;<br>  type,          <span class="hljs-comment">// 事件类型，例如 &#x27;click&#x27;</span><br>  target,        <span class="hljs-comment">// 触发事件的元素</span><br>  currentTarget, <span class="hljs-comment">// 当前绑定事件的元素</span><br>  bubbles,       <span class="hljs-comment">// 是否支持冒泡</span><br>  cancelable,    <span class="hljs-comment">// 是否可以取消默认行为</span><br>  timeStamp,     <span class="hljs-comment">// 事件发生时间</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【常用方法属性】"><a href="#【常用方法属性】" class="headerlink" title="【常用方法属性】"></a>【常用方法属性】</h3><p><strong>多种事件对象有一个共同的祖先 Event</strong></p><ol><li><code>event.type</code></li></ol><p>返回事件的类型（如 <code>&quot;click&quot;</code>, <code>&quot;keydown&quot;</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">type</span>); <span class="hljs-comment">// 输出 &#x27;click&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>event.target</code> 和 <code>event.currentTarget</code></li></ol><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>target</code></td><td>实际触发事件的元素</td></tr><tr><td><code>currentTarget</code></td><td>当前绑定事件的元素</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;target:&#x27;</span>, event.<span class="hljs-property">target</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;currentTarget:&#x27;</span>, event.<span class="hljs-property">currentTarget</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li><code>event.preventDefault()</code></li></ol><p>阻止事件的默认行为（如点击链接不跳转）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">link.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="4"><li><code>event.stopPropagation()</code></li></ol><p>阻止事件继续冒泡（向上冒泡被中断）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>鼠标事件特有属性（<code>MouseEvent</code>）</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>clientX</code></td><td>鼠标点击时，视口内 X 坐标</td></tr><tr><td><code>clientY</code></td><td>鼠标点击时，视口内 Y 坐标</td></tr><tr><td><code>pageX</code></td><td>相对于页面的 X 坐标</td></tr><tr><td><code>button</code></td><td>哪个鼠标键触发了事件（0 左，1 中，2 右）</td></tr></tbody></table><p><strong>键盘事件特有属性（<code>KeyboardEvent</code>）</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>key</code></td><td>被按下的键的字符</td></tr><tr><td><code>code</code></td><td>键盘的物理按键代码</td></tr><tr><td><code>ctrlKey</code></td><td>是否按下 Ctrl</td></tr><tr><td><code>shiftKey</code></td><td>是否按下 Shift</td></tr></tbody></table><h3 id="【事件冒泡】"><a href="#【事件冒泡】" class="headerlink" title="【事件冒泡】"></a>【事件冒泡】</h3><p><strong>事件冒泡（Event Bubbling）</strong> 是 DOM 中的一种事件传播机制，指的是：</p><blockquote><p>当一个元素上的事件被触发时，<strong>该事件会从最深层的目标元素向上传播</strong>，依次经过它的父元素、祖先元素，直到 <code>document</code> 根节点。</p></blockquote><p>这就像水泡从水底冒到水面一样，所以称为 “<strong>冒泡</strong>“。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;<br>js复制编辑<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;child&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;子元素被点击&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;parent&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父元素被点击&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">子元素被点击<br>父元素被点击<br></code></pre></td></tr></table></figure><p>因为事件会先在目标元素（<code>child</code>）触发，然后 <strong>冒泡到父元素</strong>（<code>parent</code>）。</p><p><strong>事件传播的三个阶段</strong></p><ol><li><strong>捕获阶段</strong>（Capture）：<ul><li>从 <code>window</code> 一直向下捕获到目标元素，但此阶段默认不会触发监听器。</li></ul></li><li><strong>目标阶段</strong>（Target）：<ul><li>事件在目标元素上触发。</li></ul></li><li><strong>冒泡阶段</strong>（Bubble）：<ul><li>从目标元素向上冒泡到 <code>document</code>，依次触发祖先元素上的监听器（如果有）。</li></ul></li></ol><p> <strong>可视图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">window<br>  ↓<br>document<br>  ↓<br>&lt;html&gt;<br>  ↓<br>&lt;body&gt;<br>  ↓<br>&lt;div id=&quot;parent&quot;&gt;     ← 父元素监听器触发<br>  ↓<br>&lt;button id=&quot;child&quot;&gt;   ← 目标元素监听器触发<br></code></pre></td></tr></table></figure><p>如何阻止事件冒泡？</p><p>使用 <code>event.stopPropagation()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;child&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件冒泡到 parent</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了子元素&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这时点击按钮只会输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">点击了子元素<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>并不是所有事件都支持冒泡，如 <code>blur</code> 和 <code>focus</code> 不冒泡。</li><li>如果用 <code>addEventListener(event, handler, true)</code>，则监听器会在捕获阶段触发。 一般情况下我们不希望事件在捕获阶段触发，所有通常都不需要设置第三个参数</li></ul><p><code>eventPhase</code> 表示事件触发的阶段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">box1.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;1&quot;</span> + event.<span class="hljs-property">eventPhase</span>) <span class="hljs-comment">// eventPhase 表示事件触发的阶段</span><br>                <span class="hljs-comment">//1 捕获阶段 2 目标阶段 3 冒泡阶段</span><br>            &#125;)<br></code></pre></td></tr></table></figure><h3 id="【事件委托】"><a href="#【事件委托】" class="headerlink" title="【事件委托】"></a>【事件委托】</h3><p><strong>事件委托</strong> 是指：将事件监听器绑定在某个父元素上，<strong>通过事件冒泡机制</strong>，统一处理其子元素的事件。</p><p>换句话说，你<strong>不用给每个子元素都绑定事件</strong>，只需要在<strong>父元素上监听一次</strong>，然后判断事件是从哪个子元素触发的。</p><table><thead><tr><th>传统写法问题</th><th>事件委托的优势</th></tr></thead><tbody><tr><td>子元素多，逐个绑定低效</td><td>父元素只绑定一次，节省内存</td></tr><tr><td>子元素可能是动态创建的，无法事先绑定事件</td><td>委托可处理未来创建的子元素</td></tr><tr><td>修改结构需重新绑定事件</td><td>委托天然支持新增 DOM</td></tr></tbody></table><p>点击 <code>&lt;ul&gt;</code> 中的 <code>&lt;li&gt;</code> 项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 错误方式（对每个 li 都绑定事件）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;#list li&#x27;</span>);<br>items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">li</span> =&gt;</span> &#123;<br>  li.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了&#x27;</span>, li.<span class="hljs-property">textContent</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>不支持动态添加的 <code>li</code></li><li>性能差，代码冗余</li></ul><p>正确方式：使用事件委托</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br><br>list.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了&#x27;</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>利用了事件冒泡，<code>e.target</code> 就是实际点击的子元素。</p><p>动态添加项也能触发！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>li.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;新增项&#x27;</span>;<br>list.<span class="hljs-title function_">appendChild</span>(li); <span class="hljs-comment">// 无需绑定事件，自动生效</span><br></code></pre></td></tr></table></figure><p>因为事件绑定在 <code>ul</code> 上，<strong>后添加的子元素也能响应点击</strong>。</p><p><strong>常见应用场景</strong></p><table><thead><tr><th>应用场景</th><th>委托监听的父元素</th><th>子元素判断条件</th></tr></thead><tbody><tr><td>表格中点击某一行</td><td><code>tbody</code></td><td><code>e.target.tagName === &#39;TD&#39;</code></td></tr><tr><td>列表点击删除按钮</td><td><code>ul</code> &#x2F; <code>div.list</code></td><td><code>e.target.classList.contains(&#39;delete-btn&#39;)</code></td></tr><tr><td>表单中输入实时校验</td><td><code>form</code></td><td><code>e.target.name === &#39;email&#39;</code></td></tr><tr><td>整体布局中捕获所有按钮</td><td><code>document.body</code></td><td><code>e.target.matches(&#39;button&#39;)</code></td></tr></tbody></table><p><strong>常用判断方法</strong></p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>e.target.tagName</code></td><td>判断具体 HTML 标签名</td></tr><tr><td><code>e.target.classList.contains()</code></td><td>判断是否有某个类名</td></tr><tr><td><code>e.target.matches(&#39;选择器&#39;)</code></td><td>判断是否符合某个 CSS 选择器</td></tr><tr><td><code>e.target.closest(&#39;选择器&#39;)</code></td><td>向上查找符合的父元素</td></tr></tbody></table><h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><p><strong>BOM（浏览器对象模型）</strong> 是 JavaScript 与浏览器交互的一套对象结构，允许我们控制浏览器窗口和与之相关的功能（如地址栏、历史记录、导航、定时器、弹窗等）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span><br>├── location       → 地址栏相关<br>├── history        → 浏览记录<br>├── navigator      → 浏览器信息<br>├── screen         → 屏幕信息<br>├── <span class="hljs-variable language_">document</span>       → 网页内容（<span class="hljs-variable constant_">DOM</span>）<br>├── <span class="hljs-title function_">alert</span>(), <span class="hljs-built_in">setTimeout</span>() 等全局方法<br></code></pre></td></tr></table></figure><p><code>window</code> 对象（BOM 的核心）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>); <span class="hljs-comment">// 全局窗口对象</span><br></code></pre></td></tr></table></figure><ul><li>JS 中的全局变量和函数都是 <code>window</code> 的属性</li><li>访问 <code>window.x</code> 等价于访问 <code>x</code></li></ul><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你好&quot;</span>); <span class="hljs-comment">// 弹窗</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;定时&quot;</span>), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><code>location</code> 对象（地址栏相关）</li></ol><p>用于访问和修改浏览器的地址栏信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">href</span>);   <span class="hljs-comment">// 当前地址</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hostname</span>); <span class="hljs-comment">// 主机名</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">pathname</span>); <span class="hljs-comment">// 路径名</span><br><br><span class="hljs-comment">// 跳转页面</span><br>location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;https://www.google.com&quot;</span>;<br><br><span class="hljs-comment">// 重新加载</span><br>location.<span class="hljs-title function_">reload</span>();<br></code></pre></td></tr></table></figure><ol start="3"><li><code>history</code> 对象（浏览历史）</li></ol><p>操作用户的访问历史记录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">history.<span class="hljs-title function_">back</span>();    <span class="hljs-comment">// 后退</span><br>history.<span class="hljs-title function_">forward</span>(); <span class="hljs-comment">// 前进</span><br>history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回前一个页面</span><br></code></pre></td></tr></table></figure><p>📌 注意：不能直接查看访问记录内容（出于安全）</p><ol start="4"><li><code>navigator</code> 对象（浏览器信息）</li></ol><p>返回浏览器和系统的相关信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(navigator.<span class="hljs-property">userAgent</span>);     <span class="hljs-comment">// 浏览器标识，用来描述浏览器信息的字符串。 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(navigator.<span class="hljs-property">language</span>);      <span class="hljs-comment">// 当前语言</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(navigator.<span class="hljs-property">platform</span>);      <span class="hljs-comment">// 操作系统平台</span><br></code></pre></td></tr></table></figure><ol start="5"><li><code>screen</code> 对象（屏幕分辨率）</li></ol><p>返回客户端屏幕相关信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(screen.<span class="hljs-property">width</span>);      <span class="hljs-comment">// 屏幕宽度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(screen.<span class="hljs-property">height</span>);     <span class="hljs-comment">// 屏幕高度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(screen.<span class="hljs-property">availWidth</span>); <span class="hljs-comment">// 可用宽度（除去任务栏）</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>DOM（文档对象模型）</th><th>BOM（浏览器对象模型）</th></tr></thead><tbody><tr><td>操作内容</td><td>网页内容</td><td>浏览器窗口及相关功能</td></tr><tr><td>代表对象</td><td><code>document</code></td><td><code>window</code>、<code>location</code> 等</td></tr><tr><td>用途</td><td>操作文档结构</td><td>控制导航、弹窗、定时器等</td></tr><tr><td>是否标准</td><td>是（W3C 标准）</td><td>否（由浏览器厂商定义）</td></tr></tbody></table><h3 id="【常用-BOM-方法（弹窗-定时器）】"><a href="#【常用-BOM-方法（弹窗-定时器）】" class="headerlink" title="【常用 BOM 方法（弹窗&#x2F;定时器）】"></a>【常用 BOM 方法（弹窗&#x2F;定时器）】</h3><p><strong>弹窗类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;提示信息&quot;</span>);<br><span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;你确定要删除吗？&quot;</span>);  <span class="hljs-comment">// 返回 true/false</span><br><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入你的名字&quot;</span>);     <span class="hljs-comment">// 返回用户输入的字符串</span><br></code></pre></td></tr></table></figure><p><strong>定时器类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;一次性定时器&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-keyword">let</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;每秒一次&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 清除</span><br><span class="hljs-built_in">clearTimeout</span>(timer);<br><span class="hljs-built_in">clearInterval</span>(interval);<br></code></pre></td></tr></table></figure><p><code>window.open()</code> 打开新窗口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;https://www.example.com&quot;</span>, <span class="hljs-string">&quot;_blank&quot;</span>);<br></code></pre></td></tr></table></figure><p>现代浏览器常常会屏蔽这种行为，除非用户是主动点击触发。</p><p><strong>浏览器尺寸与滚动</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>);  <span class="hljs-comment">// 浏览器内容区宽度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>);     <span class="hljs-comment">// 页面滚动的垂直距离</span><br></code></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在 JavaScript 中，理解 <strong>调用栈（Call Stack）</strong> 和 <strong>消息队列（Message Queue &#x2F; Task Queue）</strong> 是掌握<strong>异步编程、事件循环（Event Loop）</strong>、<code>setTimeout</code>、<code>Promise</code> 等机制的核心基础。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vb">      ┌───────────────┐<br>      │    调用栈     │ ← 执行同步代码<br>      └────┬──────────┘<br>           │<br>           ▼<br>  ┌─────────────────────┐<br>  │   Web APIs / 回调注册 │ ← setTimeout、DOM事件等交给浏览器处理<br>  └────┬────────────────┘<br>       │（等待完成）<br>       ▼<br> ┌────────────┐<br> │ 消息队列    │ ← 异步回调排队等执行<br> └────┬───────┘<br>      │<br>      ▼<br><span class="hljs-keyword">Event</span> <span class="hljs-keyword">Loop</span> 检查调用栈空 → 把队列中的回调推进栈中执行<br></code></pre></td></tr></table></figure><h3 id="【调用栈（Call-Stack）】"><a href="#【调用栈（Call-Stack）】" class="headerlink" title="【调用栈（Call Stack）】"></a>【调用栈（Call Stack）】</h3><p>调用栈是 JS 引擎用来跟踪函数执行过程的数据结构，<strong>遵循 LIFO（后进先出）</strong> 原则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">bar</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>执行过程：</p><ol><li><code>foo()</code> 进栈</li><li><code>bar()</code> 进栈</li><li><code>console.log()</code> 进栈并执行</li><li><code>console.log()</code> 出栈 → <code>bar()</code> 出栈 → <code>foo()</code> 出栈</li></ol><p>小结：</p><ul><li><strong>同步代码</strong>是依次进入调用栈中执行的</li><li>调用栈满时，不能执行任何新的代码（也不能处理异步）</li></ul><h3 id="【消息队列（Message-Queue）】"><a href="#【消息队列（Message-Queue）】" class="headerlink" title="【消息队列（Message Queue）】"></a>【消息队列（Message Queue）】</h3><p>消息队列是一个等待执行的<strong>异步任务回调列表</strong>，当调用栈清空后，<strong>事件循环（Event Loop）</strong> 会从队列中取出任务并执行。</p><p><strong>包含内容：</strong></p><ul><li><code>setTimeout</code>、<code>setInterval</code> 的回调</li><li>DOM 事件（如点击、键盘）</li><li>网络请求（如 Ajax 回调）</li><li><code>Promise.then()</code>（微任务，不在主消息队列，详见后）</li></ul><h3 id="【事件循环（Event-Loop）】"><a href="#【事件循环（Event-Loop）】" class="headerlink" title="【事件循环（Event Loop）】"></a>【事件循环（Event Loop）】</h3><p>事件循环的核心职责：</p><blockquote><p>💡 “不断地检查调用栈是否为空，如果为空，就从消息队列中取出一个回调执行”。</p></blockquote><p>这是 JS 实现异步非阻塞编程的关键机制。</p><p>经典例子：setTimeout</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);<br></code></pre></td></tr></table></figure><p>setInterval() 没间隔一段时间就将函数添加到消息队列中但是如果函数执行的速度比较慢，它是无法确保每次执行的间隔都是一样的</p><h3 id="输出顺序："><a href="#输出顺序：" class="headerlink" title="输出顺序："></a>输出顺序：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>原因：</p><ul><li><code>console.log(&quot;1&quot;)</code> 进入栈并立即执行</li><li><code>setTimeout(...)</code> 把回调注册到 Web API，并排入<strong>消息队列</strong></li><li><code>console.log(&quot;3&quot;)</code> 进入栈并立即执行</li><li>调用栈清空，事件循环从消息队列中取出 <code>console.log(&quot;2&quot;)</code> 执行</li></ul><h3 id="【微任务队列（Microtask-Queue）】"><a href="#【微任务队列（Microtask-Queue）】" class="headerlink" title="【微任务队列（Microtask Queue）】"></a>【微任务队列（Microtask Queue）】</h3><p>JavaScript 还有一个比消息队列<strong>优先级更高</strong>的队列叫：<strong>微任务队列</strong>。</p><p>常见的微任务来源：</p><ul><li><code>Promise.then()</code>, <code>catch()</code>, <code>finally()</code></li><li><code>MutationObserver</code></li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">start<br>end<br>promise<br></code></pre></td></tr></table></figure><p>原因：微任务在当前宏任务执行完后、下一个宏任务前执行。</p><p><strong>宏任务 vs 微任务</strong></p><table><thead><tr><th>分类</th><th>举例</th></tr></thead><tbody><tr><td>宏任务</td><td><code>setTimeout</code>, <code>setInterval</code>, <code>fetch</code>, <code>DOM事件</code></td></tr><tr><td>微任务</td><td><code>Promise.then</code>, <code>queueMicrotask</code>, <code>MutationObserver</code></td></tr></tbody></table><blockquote><p><strong>调用栈</strong>负责执行同步任务，<strong>消息队列</strong>存放异步回调，<strong>事件循环</strong>协调两者，确保 JavaScript 在单线程下实现异步编程。</p></blockquote><h3 id="【图解执行顺序（带-Promise）】"><a href="#【图解执行顺序（带-Promise）】" class="headerlink" title="【图解执行顺序（带 Promise）】"></a>【图解执行顺序（带 Promise）】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;C&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;D&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="输出顺序：-1"><a href="#输出顺序：-1" class="headerlink" title="输出顺序："></a>输出顺序：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br>D<br>C   ← 微任务先于宏任务<br><span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><blockquote><p><a href="https://lilichao.com/?p=6402">jQuery – 李立超 | lilichao.com</a></p></blockquote><h2 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h2><p>jQuery是一个快速的、小型的、具有丰富功能的JavaScript库。<strong>它的出现使得网页中的DOM、事件、动画、Ajax等操作变得更加简单</strong>。“写更少的代码，做更多的事儿”是jQuery一直坚信的开发理念。</p><p>库就是一组代码，这组代码中包含了一些已经定义好的对象和函数。只需要将库引入到页面中，即可直接使用这些对象和函数。库中的代码通常是为了解决一些我们开发中的一些不便。jQuery中的代码就是为了简化原生JS的操作，同样一个功能使用原生JS你也许要编写五行代码，使用jQuery一行就可以搞定，同时jQuery还可以帮助我们处理掉浏览器的兼容问题。</p><h3 id="【jQuery-——-一个过时的库】"><a href="#【jQuery-——-一个过时的库】" class="headerlink" title="【jQuery —— 一个过时的库】"></a>【jQuery —— 一个过时的库】</h3><p>所有的库都是为了解决我们开发时的痛点而存在的。jQuery解决的问题主要有两个：<font color="#409eff">简化DOM操作、解决浏览器兼容问题</font>。然而随着前端的发展、DOM标准的更新、IE的消亡。DOM操作和浏览器兼容性早已不是什么大问题了，再加上React、Vue、Angular这些大型框架的出现，在实际项目中使用jQuery的机会可以说是少之又少。这是不是就意味着我们没有必要在学习jQuery了呢？是的，确实没有学习jQuery的必要了。所以如果是比较赶时间的同学，完全可以跳过jQuery的学习，不需要再继续听下边的内容了。</p><p><strong>CDN</strong></p><p>使用公共cdn比较简单，以字节跳动静态资源为例，要引入3.x版本的jQuery，只需要将如下代码粘贴到网页中即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者这个：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完整：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="jQuery核心函数"><a href="#jQuery核心函数" class="headerlink" title="jQuery核心函数"></a>jQuery核心函数</h2><p>引入jQuery后，它会自动在全局作用域添加一个名为<code>jQuery</code>的新函数，新函数还有一个别名<code>$</code>。换句话说，通过<code>jQuery</code>和<code>$</code>都可以访问到这个函数，这个函数我们称为jQuery的核心函数。我们引入jQuery目的就是得到这个函数，学习jQuery也就是在学习这个核心函数。</p><p>可以通过两种方式来使用核心函数，一种是将其作为对象使用，此时它是一个工具类，在其中封装了一些属性和方法。</p><ul><li>jQuery.contains()</li><li>jQuery.isArray()</li><li>jQuery.isFunction()</li><li>jQuery.isNumeric()</li><li>……</li></ul><p>另一种是将其作为函数调用，根据参数的不同可以会发挥不同的作用。</p><ul><li>jQuery(函数)</li><li>jQuery(选择器)</li><li>jQuery(DOM对象)</li><li>jQuery(HTML代码)</li></ul><p>注意：上述编写代码时可以使用$代替jQuery。</p><h3 id="【函数作为参数】"><a href="#【函数作为参数】" class="headerlink" title="【函数作为参数】"></a>【函数作为参数】</h3><p>当使用函数作为jQuery的参数时，jQuery会使该函数在文档加载完毕后执行，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="【选择器字符串作为参数】"><a href="#【选择器字符串作为参数】" class="headerlink" title="【选择器字符串作为参数】"></a>【选择器字符串作为参数】</h3><p>如果将一个选择器字符串作为参数传递给核心函数，则jQuery会根据选择器去页面中查询元素，并将查询到的元素返回，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> $box1 = $(<span class="hljs-string">&quot;#box1&quot;</span>) <span class="hljs-comment">// 获取id为box1的元素</span><br><span class="hljs-keyword">var</span> $news = $(<span class="hljs-string">&quot;.news&quot;</span>) <span class="hljs-comment">// 获取class为news的元素</span><br><span class="hljs-keyword">var</span> $hello = $(<span class="hljs-string">&quot;[title=hello]&quot;</span>) <span class="hljs-comment">// 获取title属性为hello的元素</span><br></code></pre></td></tr></table></figure><p>注意！通过jQuery核心函数获取到的对象并不是我们所熟悉的DOM对象，而是一个由jQuery定义的新对象，为了和我们熟悉的DOM对象做区分，这个对象我们称之为jQuery对象。<font color="#409eff">记住！通过jQuery核心函数获取到的对象是jQuery对象。</font></p><p>DOM对象本身存在着一些不足，比如兼容问题、操作不方便等，为了解决这些问题，jQuery设计了一个新的对象，jQuery对象。可以将jQuery对象理解为DOM对象的升级版，为DOM对象增加了许多功能，同时解决了DOM对象的兼容性问题，关于jQuery对象的细节后续讲解。</p><h3 id="【DOM对象作为参数】"><a href="#【DOM对象作为参数】" class="headerlink" title="【DOM对象作为参数】"></a>【DOM对象作为参数】</h3><p>如果将一个DOM对象作为参数，核心函数会将其转换为jQuery对象并返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> box1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box1&quot;</span>) <span class="hljs-comment">// 获取DOM对象</span><br><span class="hljs-keyword">var</span> $box1 = $(box1) <span class="hljs-comment">// 转换为jQuery对象</span><br></code></pre></td></tr></table></figure><h3 id="【HTML代码作为参数】"><a href="#【HTML代码作为参数】" class="headerlink" title="【HTML代码作为参数】"></a>【HTML代码作为参数】</h3><p>如果将一段HTML代码作为参数，核心函数会根据HTML代码创建jQuery对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> $div = $(<span class="hljs-string">&quot;&lt;div/&gt;&quot;</span>)<br><span class="hljs-keyword">var</span> $span = $(<span class="hljs-string">&quot;&lt;span&gt;这是一个span&lt;/span&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p>如上所述，jQuery对象时jQuery中新定义的对象，它像是一个用来存储DOM对象的数组（类型并不是Array）。可以通过length来获取其中DOM元素的数量，也可以通过索引来获取其中的某个元素。但是jQuery对象又并不是那么的简单，在它里边为我们提供了很多好用的方法，使我们可以快速的操作其中的DOM对象。</p><p>使用jQuery对象进行DOM操作时，无需再调用原生DOM的方法，直接调用jQuery对象的方法即可。通过jQuery对象进行修改操作时，会同时修改jQuery对象中的所有DOM对象，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script/jquery/jquery-3.6.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>孙悟空<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>猪八戒<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沙和尚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>唐僧<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>       <br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">            $(<span class="hljs-string">&quot;li&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;新值&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上例中，页面中有四个li，<code>$(&quot;li&quot;)</code>通过选择器获取页面中的所有li，<code>text()</code>是jQuery对象的方法用于获取或修改元素内部的文本内容。<code>$(&quot;li&quot;).text(&quot;新值&quot;)</code>调用后会修改所有的li中的文本内容。</p><p>这一特性被称为隐式迭代，隐式迭代的存在使得我们在修改多个DOM元素时不再需要遍历，一个方法即可修改所有元素。但是隐式迭代并不意外着不迭代不遍历，实际的遍历操作在jQuery对象内部完成。</p><p>jQuery对象的大部分方法都会将jQuery对象自身作为返回值，这意味着通过jQuery对象调用方法后，可以继续调用其他的方法，比如这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script/jquery/jquery-3.6.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>孙悟空<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>猪八戒<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沙和尚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>唐僧<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">            $(<span class="hljs-string">&quot;li&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;新的内容&quot;</span>).<span class="hljs-title function_">css</span>(&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>$(&quot;li&quot;).text(&quot;新的内容&quot;).css(&#123;color:&quot;red&quot;&#125;)</code>在修改文本后继续修改jQuery对象的样式，这一特性被称为链式调用，通过链式调用可以一次性对jQuery对象做多个操作。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>addClass()</p><ul><li>为jQuery对象添加一个或多个class</li></ul><p>hasClass()</p><ul><li>检查jQuery对象是否含有某个class</li></ul><p>removeClass()</p><ul><li>删除jQuery对象的指定class</li></ul><p>toggleClass()</p><ul><li>切换jQuery对象的指定class</li></ul><hr><p>clone()</p><ul><li>复制jQuery元素</li></ul><hr><p>unwrap()</p><ul><li>去除父元素</li></ul><p>wrap()</p><ul><li>添加父元素</li></ul><p>wrapAll()</p><ul><li>添加父元素</li></ul><p>wrapInner()</p><ul><li>在元素内部增加一层</li></ul><hr><p>append()</p><ul><li>添加子元素</li></ul><p>appendTo()</p><ul><li>添加到父元素</li></ul><p>prepend()</p><ul><li>向前添加子元素</li></ul><p>prependTo()</p><ul><li>添加到父元素前</li></ul><p>html()</p><ul><li>读取或设置html代码</li></ul><p>text()</p><ul><li>读取或设置文本内容</li></ul><hr><p>after()</p><ul><li>向后边添加元素</li></ul><p>insertAfter()</p><ul><li>将元素添加到某元素的后边</li></ul><p>before()</p><ul><li>向前边添加元素</li></ul><p>insertBefore()</p><ul><li>将元素添加到某元素的前边</li></ul><hr><p>detach()</p><ul><li>删除元素（保留元素上的事件）</li></ul><p>empty()</p><ul><li>删除所有子元素</li></ul><p>remove()</p><ul><li>删除元素</li></ul><hr><p>replaceAll()</p><ul><li>替换某个元素</li></ul><p>replaceWith()</p><ul><li>被某个元素替换</li></ul><hr><p>attr()</p><ul><li>设置&#x2F;获取元素的指定属性</li><li>布尔值属性会返回实际值</li></ul><p>prop()</p><ul><li>设置&#x2F;获取元素的指定属性</li><li>布尔值属性会返回布尔值</li></ul><p>removeAttr()</p><ul><li>移除属性</li></ul><p>removeProp()</p><ul><li>移除属性</li></ul><p>val()</p><ul><li>设置&#x2F;获取元素的value属性</li></ul><hr><p>css()</p><ul><li>读取&#x2F;设置元素的css样式</li></ul><p>height()</p><ul><li>读取&#x2F;设置元素的高度</li></ul><p>width()</p><ul><li>读取&#x2F;设置元素的宽度</li></ul><p>innerHeight()</p><ul><li>读取&#x2F;设置元素的内部高度</li></ul><p>innerWidth()</p><ul><li>读取&#x2F;设置元素的内部宽度</li></ul><p>outerHeight()</p><ul><li>读取&#x2F;设置元素可见框的高度</li></ul><p>outerWidth()</p><ul><li>读取&#x2F;设置元素可见框的宽度</li></ul><p>offset()</p><ul><li>读取&#x2F;设置元素的偏移量</li></ul><p>position()</p><ul><li>读取元素相当于包含块的偏移量</li></ul><p>scrollLeft()</p><ul><li>读取&#x2F;设置元素水平滚动条的位置</li></ul><p>scrollTop()</p><ul><li>读取&#x2F;设置元素垂直滚动条的位置</li></ul><hr><p>eq()</p><ul><li>获取指定索引的元素</li></ul><p>even()</p><ul><li>获取索引为偶数的元素</li></ul><p>odd()</p><ul><li>获取索引为奇数的元素</li></ul><p>filter()</p><ul><li>筛选元素</li></ul><p>first()</p><ul><li>获取第一个元素</li></ul><p>last()</p><ul><li>获取最后一个元素</li></ul><p>has()</p><ul><li>获取含有指定后代的元素</li></ul><p>is()</p><ul><li>检查是否含有某元素</li></ul><p>map()</p><ul><li>获取对象中的指定数据</li></ul><p>slice()</p><ul><li>截取元素（切片）</li></ul><hr><p>add()</p><ul><li>创建包含当前元素的新的jQuery对象</li></ul><p>addBack()</p><ul><li>将之前操作的集合中的元素添加到当前集合中</li></ul><p>contents()</p><ul><li>获取当前jQuery对象的所有子节点（包括文本节点）</li></ul><p>end()</p><ul><li>将筛选过的列表恢复到之前的状态</li></ul><p>not()</p><ul><li>从列表中去除符合条件的元素</li></ul><hr><p>children()</p><ul><li>获取子元素</li></ul><p>closest()</p><ul><li>获取离当前元素最近的指定元素</li></ul><p>find()</p><ul><li>查询指定的后代元素</li></ul><p>next()</p><ul><li>获取后一个兄弟元素</li></ul><p>nextAll()</p><ul><li>获取后边所有的兄弟元素</li></ul><p>nextUntil()</p><ul><li>获取后边指定位置的兄弟元素</li></ul><p>offsetParent()</p><ul><li>获取定位父元素</li></ul><p>parent()</p><ul><li>获取父元素</li></ul><p>parents()</p><ul><li>获取所有的祖先元素</li></ul><p>parensUntil()</p><ul><li>获取指定的祖先元素</li></ul><p>prev()</p><ul><li>获取前边的兄弟元素</li></ul><p>prevAll()</p><ul><li>获取前边所有的兄弟元素</li></ul><p>prevUntil()</p><ul><li>获取指定的兄弟元素</li></ul><p>siblings()</p><ul><li>获取所有的兄弟元素</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端三件套</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DATABASE</title>
    <link href="/2024/09/18/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/DATABASE/"/>
    <url>/2024/09/18/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/DATABASE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="MYSQL数据库知识汇总"><a href="#MYSQL数据库知识汇总" class="headerlink" title="MYSQL数据库知识汇总"></a>MYSQL数据库知识汇总</h1><h2 id="MySQL数据类型汇总"><a href="#MySQL数据类型汇总" class="headerlink" title="MySQL数据类型汇总"></a>MySQL数据类型汇总</h2><p><font color="yellow">MySQL与Java数据类型的对应关系：</font></p><p><strong>1. 数值类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td><code>byte</code></td><td>范围：-128 到 127</td></tr><tr><td><code>SMALLINT</code></td><td><code>short</code></td><td>范围：-32,768 到 32,767</td></tr><tr><td><code>MEDIUMINT</code></td><td><code>int</code></td><td>范围：-8,388,608 到 8,388,607</td></tr><tr><td><code>INT</code> &#x2F; <code>INTEGER</code></td><td><code>int</code></td><td>范围：-2^31 到 2^31-1</td></tr><tr><td><code>BIGINT</code></td><td><code>long</code></td><td>范围：-2^63 到 2^63-1</td></tr><tr><td><code>DECIMAL(p, s)</code></td><td><code>java.math.BigDecimal</code></td><td>精确的定点数值，可以用于处理货币等需要高精度的值</td></tr><tr><td><code>FLOAT</code></td><td><code>float</code></td><td>单精度浮点数</td></tr><tr><td><code>DOUBLE</code></td><td><code>double</code></td><td>双精度浮点数</td></tr><tr><td><code>BIT</code></td><td><code>boolean</code> 或 <code>byte</code></td><td>用于布尔值或位字段，Java中常用 <code>boolean</code></td></tr></tbody></table><p><strong>2. 字符串类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>CHAR(n)</code></td><td><code>String</code></td><td>固定长度的字符串</td></tr><tr><td><code>VARCHAR(n)</code></td><td><code>String</code></td><td>可变长度的字符串</td></tr><tr><td><code>TEXT</code></td><td><code>String</code></td><td>长文本数据</td></tr><tr><td><code>TINYTEXT</code></td><td><code>String</code></td><td>最多255字节的文本</td></tr><tr><td><code>MEDIUMTEXT</code></td><td><code>String</code></td><td>最多16,777,215字节的文本</td></tr><tr><td><code>LONGTEXT</code></td><td><code>String</code></td><td>最多4GB的文本</td></tr></tbody></table><p><strong>3. 日期和时间类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>DATE</code></td><td><code>java.sql.Date</code></td><td>只包含日期，格式为<code>YYYY-MM-DD</code></td></tr><tr><td><code>DATETIME</code></td><td><code>java.sql.Timestamp</code> 或 <code>java.util.Date</code></td><td>日期和时间，格式为<code>YYYY-MM-DD HH:MM:SS</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>java.sql.Timestamp</code></td><td>带有时区的日期时间戳</td></tr><tr><td><code>TIME</code></td><td><code>java.sql.Time</code></td><td>只包含时间，格式为<code>HH:MM:SS</code></td></tr><tr><td><code>YEAR</code></td><td><code>int</code></td><td>仅年份，范围为 1901 到 2155</td></tr></tbody></table><p><strong>4. 二进制数据类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>BINARY(n)</code></td><td><code>byte[]</code></td><td>固定长度的二进制数据</td></tr><tr><td><code>VARBINARY(n)</code></td><td><code>byte[]</code></td><td>可变长度的二进制数据</td></tr><tr><td><code>BLOB</code></td><td><code>byte[]</code></td><td>二进制大对象，最大长度64KB</td></tr><tr><td><code>TINYBLOB</code></td><td><code>byte[]</code></td><td>最大255字节的二进制数据</td></tr><tr><td><code>MEDIUMBLOB</code></td><td><code>byte[]</code></td><td>最大16MB的二进制数据</td></tr><tr><td><code>LONGBLOB</code></td><td><code>byte[]</code></td><td>最大4GB的二进制数据</td></tr></tbody></table><p><strong>5. 布尔和枚举类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>BOOLEAN</code></td><td><code>boolean</code></td><td><code>BOOLEAN</code> 实际上是 <code>TINYINT(1)</code>，1表示<code>true</code>，0表示<code>false</code></td></tr><tr><td><code>ENUM</code></td><td><code>String</code></td><td>枚举类型，对应Java中的字符串</td></tr></tbody></table><p><strong>6. JSON 数据类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>JSON</code></td><td><code>String</code> 或 <code>org.json.JSONObject</code></td><td>JSON格式的数据，通常在Java中作为<code>String</code>处理，或者通过第三方库（如<code>org.json.JSONObject</code>）处理</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-ElementUI表单</title>
    <link href="/2024/08/07/%E5%85%B6%E4%BB%96/2024-08-07/"/>
    <url>/2024/08/07/%E5%85%B6%E4%BB%96/2024-08-07/</url>
    
    <content type="html"><![CDATA[<p>文章记录了ElementUI中表单的用法。</p><span id="more"></span><h1 id="前端学习-ElementUI表单"><a href="#前端学习-ElementUI表单" class="headerlink" title="前端学习-ElementUI表单"></a>前端学习-ElementUI表单</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><p><strong>官网：<a href="https://element.eleme.cn/#/zh-CN/component/form">https://element.eleme.cn/#/zh-CN/component/form</a></strong></p><h2 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;FormContainer&quot;&gt;<br>    &lt;el-form :model=&quot;user&quot; :rules=&quot;rules&quot; ref=&quot;form&quot;&gt;<br>      &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; v-model=&quot;user.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; v-model=&quot;user.password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;el-button class=&quot;submit&quot; type=&quot;primary&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;<br>    &lt;/el-form&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    name:&quot;UIForm&quot;,<br>    data()&#123;<br>      return &#123;<br>        user:&#123;&#125;,<br>        rules: &#123;<br>      username: [<br>        &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;<br>      ],<br>      password: [<br>        &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;<br>      ]<br>    &#125;<br>      &#125;<br>    &#125;,<br>    methods:&#123;<br>      login() &#123;<br>    this.$refs.form.validate((valid) =&gt; &#123;<br>      if (valid) &#123;<br>        // 表单验证通过<br>        console.log(&quot;表单验证成功&quot;);<br>      &#125; else &#123;<br>        // 表单验证失败<br>        console.error(&quot;表单验证失败&quot;);<br>        return false;<br>      &#125;<br>    &#125;);<br>  &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.FormContainer &#123;<br>  width: 100vw;<br>  height: 100vh;<br>  background: #222222;<br>  position: relative;<br>  .el-form&#123;<br>    width: 500px;<br>    height: 500px;<br>    position: absolute;<br>    padding: 50px;<br>    top: 0;<br>    left: 0;<br>    right: 0;<br>    bottom: 0;<br>    margin: auto;<br>    background: #FFFFFF;<br>    border: 2px solid #00bfff;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/07/%E5%85%B6%E4%BB%96/2024-08-07/%E5%9B%BE1.png" class title="图1"><p>上述示例是一个简单的登录表单界面。但涵盖了ElementUI中表单的基本用法。</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a><font color="yellow">重点：</font></h3><ol><li><p>表单结构如上述所示，有一个<code>el-form</code>和一个或者多个<code>el-form-item</code>和按钮组成。</p></li><li><p><code>el-form</code>中<font color="yellow"><code>model</code></font>是表单数据项，当用户输入数据时，数据会更新到 <code>model</code> 中；当 <code>model</code> 更新时，表单控件的显示也会随之更新。<font color="yellow">它的作用在于记录当前表单的数据项，用于后面的表单验证。</font></p></li><li><p><code>el-form</code>中的<font color="yellow"><code>rules</code></font>是表单规则，规定了数据项需要满足哪些条件。编码规则如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-attr">username</span>: [<br>        &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入用户名&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>    ],<br>    <span class="hljs-attr">password</span>: [<br>        &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入密码&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>表单项想要使用规则需要以<code>&lt;el-form-item prop=&quot;username&quot;&gt;</code>的方式声明，<font color="yellow"><code>prop</code></font>是表单域 model 字段</p></li><li><p><font color="yellow"><code>lable</code></font>是数据项标签。标签的相关配置项可以看官方文档，</p></li><li><p><font color="yellow"><code>validate</code></font>是表单验证方法，它的原理是检查<code>el-form</code>的<code>model</code>，将<code>model</code>中的每一个字段和<code>rules</code>中的字段对应，观察是否满足规则，如果全部满足则返回true，否则返回false。如果<code>rules</code>中的字段在<code>model</code>中没有找到，也会返回false。<font color="yellow">因此<code>validate</code>表单验证是首先看数据项中是否用了规则，然后观察<code>model</code>中的数据是否满足规则，所有<code>model</code>是必须有的。</font></p></li><li><p>数据项出现提示，并不是<code>validate</code>方法，而是<font color="yellow"><code>validate</code>事件</font>，它不在乎是否有<code>model</code>数据项，而是观察数据项中的<code>v-model=username</code>是否满足规则。<font color="yellow">如果输入框没有<code>v-model=username</code>，数据是无法输入的</font>，因为输入的数据检测不到。</p></li></ol><h2 id="rules基本配置项"><a href="#rules基本配置项" class="headerlink" title="rules基本配置项"></a><code>rules</code>基本配置项</h2><ol><li><p><strong><code>required</code></strong>:</p><ul><li><strong>类型</strong>: <code>Boolean</code></li><li><strong>描述</strong>: 是否为必填项。如果设置为 <code>true</code>，字段必须有值才能通过验证。</li><li><strong>示例</strong>: <code>&#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>message</code></strong>:</p><ul><li><strong>类型</strong>: <code>String</code></li><li><strong>描述</strong>: 验证失败时显示的错误消息。</li><li><strong>示例</strong>: <code>&#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>trigger</code></strong>:</p><ul><li><strong>类型</strong>: <code>String</code> | <code>Array</code></li><li><strong>描述</strong>: 触发验证的事件。例如，<code>blur</code>（失去焦点时）、<code>change</code>（值改变时）、<code>input</code>（每次输入时）等。</li><li><strong>示例</strong>: <code>&#123; required: true, message: &#39;请输入用户名&#39;, trigger: [&#39;blur&#39;, &#39;change&#39;] &#125;</code></li></ul></li><li><p><strong><code>min</code></strong>:</p><ul><li><strong>类型</strong>: <code>Number</code></li><li><strong>描述</strong>: 对于字符串或数组，表示最小长度。对于数字，表示最小值。</li><li><strong>示例</strong>: <code>&#123; min: 3, message: &#39;用户名长度不能少于3个字符&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>max</code></strong>:</p><ul><li><strong>类型</strong>: <code>Number</code></li><li><strong>描述</strong>: 对于字符串或数组，表示最大长度。对于数字，表示最大值。</li><li><strong>示例</strong>: <code>&#123; max: 10, message: &#39;用户名长度不能超过10个字符&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>pattern</code></strong>:</p><ul><li><strong>类型</strong>: <code>RegExp</code></li><li><strong>描述</strong>: 正则表达式，用于验证字段值是否符合某种模式。</li><li><strong>示例</strong>: <code>&#123; pattern: /^[a-zA-Z0-9]&#123;6,12&#125;$/, message: &#39;密码长度为6到12位的字母或数字&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>validator</code></strong>:</p><ul><li><strong>类型</strong>: <code>Function</code></li><li><strong>描述</strong>: 自定义验证函数，用于实现更复杂的验证逻辑。函数接受 <code>rule</code>、<code>value</code> 和 <code>callback</code> 三个参数。</li><li><strong>示例</strong>:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">validator</span>: <span class="hljs-function">(<span class="hljs-params">rule, value, callback</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> &lt; <span class="hljs-number">6</span>) &#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;密码长度不能少于6个字符&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="validate方法"><a href="#validate方法" class="headerlink" title="validate方法"></a><code>validate</code>方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">form</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (valid) &#123;<br>    <span class="hljs-comment">// 表单验证通过</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;表单验证成功&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 表单验证失败</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;表单验证失败&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>valid是返回的Boolean值，如果满足规则返回true，否则返回false。</p><h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>使用<code>validator</code>可以自定义验证函数。官网中的案例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form :model=&quot;ruleForm&quot; status-icon :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;<br>  &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt;<br>    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt;<br>    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;<br>    &lt;el-input v-model.number=&quot;ruleForm.age&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item&gt;<br>    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;提交&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;resetForm(&#x27;ruleForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>&lt;/el-form&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      var checkAge = (rule, value, callback) =&gt; &#123;<br>        if (!value) &#123;<br>          return callback(new Error(&#x27;年龄不能为空&#x27;));<br>        &#125;<br>        setTimeout(() =&gt; &#123;<br>          if (!Number.isInteger(value)) &#123;<br>            callback(new Error(&#x27;请输入数字值&#x27;));<br>          &#125; else &#123;<br>            if (value &lt; 18) &#123;<br>              callback(new Error(&#x27;必须年满18岁&#x27;));<br>            &#125; else &#123;<br>              callback();<br>            &#125;<br>          &#125;<br>        &#125;, 1000);<br>      &#125;;<br>      var validatePass = (rule, value, callback) =&gt; &#123;<br>        if (value === &#x27;&#x27;) &#123;<br>          callback(new Error(&#x27;请输入密码&#x27;));<br>        &#125; else &#123;<br>          if (this.ruleForm.checkPass !== &#x27;&#x27;) &#123;<br>            this.$refs.ruleForm.validateField(&#x27;checkPass&#x27;);<br>          &#125;<br>          callback();<br>        &#125;<br>      &#125;;<br>      var validatePass2 = (rule, value, callback) =&gt; &#123;<br>        if (value === &#x27;&#x27;) &#123;<br>          callback(new Error(&#x27;请再次输入密码&#x27;));<br>        &#125; else if (value !== this.ruleForm.pass) &#123;<br>          callback(new Error(&#x27;两次输入密码不一致!&#x27;));<br>        &#125; else &#123;<br>          callback();<br>        &#125;<br>      &#125;;<br>      return &#123;<br>        ruleForm: &#123;<br>          pass: &#x27;&#x27;,<br>          checkPass: &#x27;&#x27;,<br>          age: &#x27;&#x27;<br>        &#125;,<br>        rules: &#123;<br>          pass: [<br>            &#123; validator: validatePass, trigger: &#x27;blur&#x27; &#125;<br>          ],<br>          checkPass: [<br>            &#123; validator: validatePass2, trigger: &#x27;blur&#x27; &#125;<br>          ],<br>          age: [<br>            &#123; validator: checkAge, trigger: &#x27;blur&#x27; &#125;<br>          ]<br>        &#125;<br>      &#125;;<br>    &#125;,<br>    methods: &#123;<br>      submitForm(formName) &#123;<br>        this.$refs[formName].validate((valid) =&gt; &#123;<br>          if (valid) &#123;<br>            alert(&#x27;submit!&#x27;);<br>          &#125; else &#123;<br>            console.log(&#x27;error submit!!&#x27;);<br>            return false;<br>          &#125;<br>        &#125;);<br>      &#125;,<br>      resetForm(formName) &#123;<br>        this.$refs[formName].resetFields();<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/07/%E5%85%B6%E4%BB%96/2024-08-07/%E5%9B%BE2.png" class title="图2"><p>本例还使用<font color="yellow"><code>status-icon</code>属性</font>为输入框添加了表示校验结果的反馈图标。通过自定义规则，实现确认密码的验证和文本类型的判断。</p><h2 id="官网案例"><a href="#官网案例" class="headerlink" title="官网案例"></a>官网案例</h2><h3 id="典型表单"><a href="#典型表单" class="headerlink" title="典型表单"></a>典型表单</h3><img src="/2024/08/07/%E5%85%B6%E4%BB%96/2024-08-07/%E5%9B%BE3.png" class title="图3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;80px&quot;&gt;<br>  &lt;el-form-item label=&quot;活动名称&quot;&gt;<br>    &lt;el-input v-model=&quot;form.name&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动区域&quot;&gt;<br>    &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;<br>      &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;<br>      &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;<br>    &lt;/el-select&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动时间&quot;&gt;<br>    &lt;el-col :span=&quot;11&quot;&gt;<br>      &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;form.date1&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt;<br>    &lt;/el-col&gt;<br>    &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;<br>    &lt;el-col :span=&quot;11&quot;&gt;<br>      &lt;el-time-picker placeholder=&quot;选择时间&quot; v-model=&quot;form.date2&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt;<br>    &lt;/el-col&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;即时配送&quot;&gt;<br>    &lt;el-switch v-model=&quot;form.delivery&quot;&gt;&lt;/el-switch&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动性质&quot;&gt;<br>    &lt;el-checkbox-group v-model=&quot;form.type&quot;&gt;<br>      &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>      &lt;el-checkbox label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>      &lt;el-checkbox label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>      &lt;el-checkbox label=&quot;单纯品牌曝光&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>    &lt;/el-checkbox-group&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;特殊资源&quot;&gt;<br>    &lt;el-radio-group v-model=&quot;form.resource&quot;&gt;<br>      &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;<br>      &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;<br>    &lt;/el-radio-group&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动形式&quot;&gt;<br>    &lt;el-input type=&quot;textarea&quot; v-model=&quot;form.desc&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item&gt;<br>    &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;立即创建&lt;/el-button&gt;<br>    &lt;el-button&gt;取消&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>&lt;/el-form&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      return &#123;<br>        form: &#123;<br>          name: &#x27;&#x27;,<br>          region: &#x27;&#x27;,<br>          date1: &#x27;&#x27;,<br>          date2: &#x27;&#x27;,<br>          delivery: false,<br>          type: [],<br>          resource: &#x27;&#x27;,<br>          desc: &#x27;&#x27;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    methods: &#123;<br>      onSubmit() &#123;<br>        console.log(&#x27;submit!&#x27;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="动态增减表单项"><a href="#动态增减表单项" class="headerlink" title="动态增减表单项"></a>动态增减表单项</h3><img src="/2024/08/07/%E5%85%B6%E4%BB%96/2024-08-07/%E5%9B%BE4.png" class title="图4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form :model=&quot;dynamicValidateForm&quot; ref=&quot;dynamicValidateForm&quot; label-width=&quot;100px&quot; class=&quot;demo-dynamic&quot;&gt;<br>  &lt;el-form-item<br>    prop=&quot;email&quot;<br>    label=&quot;邮箱&quot;<br>    :rules=&quot;[<br>      &#123; required: true, message: &#x27;请输入邮箱地址&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>      &#123; type: &#x27;email&#x27;, message: &#x27;请输入正确的邮箱地址&#x27;, trigger: [&#x27;blur&#x27;, &#x27;change&#x27;] &#125;<br>    ]&quot;<br>  &gt;<br>    &lt;el-input v-model=&quot;dynamicValidateForm.email&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item<br>    v-for=&quot;(domain, index) in dynamicValidateForm.domains&quot;<br>    :label=&quot;&#x27;域名&#x27; + index&quot;<br>    :key=&quot;domain.key&quot;<br>    :prop=&quot;&#x27;domains.&#x27; + index + &#x27;.value&#x27;&quot;<br>    :rules=&quot;&#123;<br>      required: true, message: &#x27;域名不能为空&#x27;, trigger: &#x27;blur&#x27;<br>    &#125;&quot;<br>  &gt;<br>    &lt;el-input v-model=&quot;domain.value&quot;&gt;&lt;/el-input&gt;&lt;el-button @click.prevent=&quot;removeDomain(domain)&quot;&gt;删除&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item&gt;<br>    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;dynamicValidateForm&#x27;)&quot;&gt;提交&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;addDomain&quot;&gt;新增域名&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;resetForm(&#x27;dynamicValidateForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>&lt;/el-form&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      return &#123;<br>        dynamicValidateForm: &#123;<br>          domains: [&#123;<br>            value: &#x27;&#x27;<br>          &#125;],<br>          email: &#x27;&#x27;<br>        &#125;<br>      &#125;;<br>    &#125;,<br>    methods: &#123;<br>      submitForm(formName) &#123;<br>        this.$refs[formName].validate((valid) =&gt; &#123;<br>          if (valid) &#123;<br>            alert(&#x27;submit!&#x27;);<br>          &#125; else &#123;<br>            console.log(&#x27;error submit!!&#x27;);<br>            return false;<br>          &#125;<br>        &#125;);<br>      &#125;,<br>      resetForm(formName) &#123;<br>        this.$refs[formName].resetFields();<br>      &#125;,<br>      removeDomain(item) &#123;<br>        var index = this.dynamicValidateForm.domains.indexOf(item)<br>        if (index !== -1) &#123;<br>          this.dynamicValidateForm.domains.splice(index, 1)<br>        &#125;<br>      &#125;,<br>      addDomain() &#123;<br>        this.dynamicValidateForm.domains.push(&#123;<br>          value: &#x27;&#x27;,<br>          key: Date.now()<br>        &#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>每日总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-CSS绘制多边形</title>
    <link href="/2024/08/06/%E5%85%B6%E4%BB%96/2024-08-06/"/>
    <url>/2024/08/06/%E5%85%B6%E4%BB%96/2024-08-06/</url>
    
    <content type="html"><![CDATA[<p>文章记录了CSS绘制多边形的方法，特别是利用border设计对话框的三角行。</p><span id="more"></span><h1 id="前端学习-CSS绘制多边形"><a href="#前端学习-CSS绘制多边形" class="headerlink" title="前端学习-CSS绘制多边形"></a>前端学习-CSS绘制多边形</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><h2 id="CSS绘制三角形"><a href="#CSS绘制三角形" class="headerlink" title="CSS绘制三角形"></a>CSS绘制三角形</h2><p>在 CSS 中绘制三角形通常是通过<font color="yellow">利用 <code>border</code> 属性的技巧来实现的</font>。这种方法利用了元素的边框设置来创建一个透明的区域，从而形成三角形的视觉效果。</p><h3 id="1-向上的三角形"><a href="#1-向上的三角形" class="headerlink" title="1. 向上的三角形"></a>1. <strong>向上的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Up Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-up</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-up&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>width</code> 和 <code>height</code> 设置为 <code>0</code>，让元素本身没有实际的宽度和高度。</li><li><code>border-left</code> 和 <code>border-right</code> 设为 <code>20px solid transparent</code>，创建透明的边框。</li><li><code>border-bottom</code> 设为 <code>20px solid blue</code>，创建底部的边框颜色，形成向上的三角形。</li></ul><h3 id="2-向下的三角形"><a href="#2-向下的三角形" class="headerlink" title="2. 向下的三角形"></a>2. <strong>向下的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Down Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-down</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-down&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>border-top</code> 设为 <code>20px solid red</code>，创建顶部的边框颜色，形成向下的三角形。</li></ul><h3 id="3-向左的三角形"><a href="#3-向左的三角形" class="headerlink" title="3. 向左的三角形"></a>3. <strong>向左的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Left Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-left</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid green;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>border-right</code> 设为 <code>20px solid green</code>，创建右侧的边框颜色，形成向左的三角形。</li></ul><h3 id="4-向右的三角形"><a href="#4-向右的三角形" class="headerlink" title="4. 向右的三角形"></a>4. <strong>向右的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Right Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-right</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="CSS绘制任意图像"><a href="#CSS绘制任意图像" class="headerlink" title="CSS绘制任意图像"></a>CSS绘制任意图像</h2><p><code>clip-path</code> 属性允许你定义一个裁剪区域，从而创建各种形状，包括多边形。常用的多边形有四边形、五边形、六边形等。利用<code>poligon()</code>函数进行裁剪。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(x1 y1, x2 y2, x3 y3, ...);<br></code></pre></td></tr></table></figure><p>绘制一个五边形：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Polygon<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.polygon</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;</span><br><span class="language-css">      <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> <span class="hljs-number">38%</span>, <span class="hljs-number">82%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">18%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0%</span> <span class="hljs-number">38%</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;polygon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/basic-shape/polygon">https://developer.mozilla.org/zh-CN/docs/Web/CSS/basic-shape/polygon</a></p></blockquote><h2 id="CSS绘制对话框实例"><a href="#CSS绘制对话框实例" class="headerlink" title="CSS绘制对话框实例"></a>CSS绘制对话框实例</h2><img src="/2024/08/06/%E5%85%B6%E4%BB%96/2024-08-06/%E5%9B%BE1.png" class title="图1"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>绘制多边形<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 图标绘制 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../favicon.ico&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 多边形绘制 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 绘制对话框 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog dialog1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>          绘制三角形样式:<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poligon&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget triangle1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget triangle2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget triangle3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 绘制多边形 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>            绘制多边形样式:<br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poligon&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget square&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget pentagon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget other&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-number">#111111</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">20%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">  <span class="hljs-selector-class">.icon</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">101</span>, <span class="hljs-number">179</span>, <span class="hljs-number">205</span>, <span class="hljs-number">0.6</span>);</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-selector-class">.img</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">    <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="language-css">    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">130px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-selector-class">.dialog</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#2e485a</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">      <span class="hljs-selector-class">.triangle1</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制三角形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">100%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.triangle2</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制三角形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">0</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">50%</span> <span class="hljs-number">100%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.triangle3</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制三角形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">100%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">100%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.pentagon</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制五边形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> <span class="hljs-number">38%</span>, <span class="hljs-number">82%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">18%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0%</span> <span class="hljs-number">38%</span>);</span><br><span class="language-css">        &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.square</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制四边形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">50%</span>,<span class="hljs-number">50%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">50%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.other</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制任意图形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">0</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">10%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">20%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">30%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">40%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">50%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">60%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">70%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">80%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">90%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">90%</span>,<span class="hljs-number">0</span> <span class="hljs-number">80%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">70%</span>,<span class="hljs-number">0</span> <span class="hljs-number">60%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">50%</span>,<span class="hljs-number">0</span> <span class="hljs-number">40%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">30%</span>,<span class="hljs-number">0</span> <span class="hljs-number">20%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">10%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.dialog1</span><span class="hljs-selector-pseudo">::before</span>&#123;</span><br><span class="language-css">      <span class="hljs-comment">/* 模仿三角形边框 */</span></span><br><span class="language-css">      <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">left</span>: -<span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.dialog1</span><span class="hljs-selector-pseudo">::after</span> &#123;</span><br><span class="language-css">      <span class="hljs-comment">/* 模仿三角形填充 */</span></span><br><span class="language-css">      <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid <span class="hljs-number">#2e485a</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">left</span>: -<span class="hljs-number">18px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.title</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">font</span>: <span class="hljs-number">700</span> <span class="hljs-number">20px</span> <span class="hljs-string">&quot;STZhongsong&quot;</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.poligon</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">70px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">      <span class="hljs-attribute">justify-content</span>: space-between;</span><br><span class="language-css">      <span class="hljs-selector-class">.widget</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端三件套</tag>
      
      <tag>每日总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-Vue组件之间的交互</title>
    <link href="/2024/08/04/%E5%85%B6%E4%BB%96/2024-08-04/"/>
    <url>/2024/08/04/%E5%85%B6%E4%BB%96/2024-08-04/</url>
    
    <content type="html"><![CDATA[<p>文章记录Vue组件之间交互的几种方式，包括父组件和子组件之间的数据传参和事件触发。</p><span id="more"></span><h1 id="前端学习-Vue组件之间的交互"><a href="#前端学习-Vue组件之间的交互" class="headerlink" title="前端学习-Vue组件之间的交互"></a>前端学习-Vue组件之间的交互</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><p>组件的<code>props</code>配置项用于接收由父组件向该组件传递的参数。<font color="yellow">数据的传递是父组件——&gt;子组件</font>。</p><p>使用方法：父组件在子组件的DOM节点中给定参数。子组件通过<code>props</code>接收参数。</p><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>:&#123;<br><span class="hljs-attr">name</span>:&#123;<br><span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">//类型</span><br><span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//必要性</span><br><span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;老王&#x27;</span> <span class="hljs-comment">//默认值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>      &lt;!-- 传递父组件的arr参数，子组件接收的变量为newArr --&gt;<br>    &lt;ChildComponent v-if=&quot;showComponent&quot; :newArr=&quot;arr&quot;&gt;&lt;/ChildComponent&gt; <br>    &lt;ChildComponent v-if=&quot;showComponent&quot; :newArr=&quot;arr&quot;&gt;&lt;/ChildComponent&gt;<br>    &lt;el-button @click=&quot;()=&gt;&#123;arr.push(data++)&#125;&quot;&gt;更改数组&lt;/el-button&gt;<br>    &#123;&#123; data &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>  data() &#123;<br>    return &#123;<br>      arr : [&quot;父组件初始数据&quot;],<br>      data : 0,<br>      showComponent : true,<br>    &#125;<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="#FFFF00">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>    &#123;&#123; arr &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props:&#123;<br>    newArr:&#123;<br>      type: Array,<br>      default: ()=&gt;[&quot;初始参数&quot;]<br>    &#125;<br>  &#125;,<br>  data()&#123;<br>    return&#123;<br>      arr:[&quot;子组件初始数据&quot;],<br>    &#125;<br>  &#125;,<br>  created()&#123;<br>    this.arr = this.newArr<br>    this.arr.push(&quot;子组件数据&quot;)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>  font-size: 30px;<br>  font-family: &quot;STZhongsong&quot;;<br>  color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/04/%E5%85%B6%E4%BB%96/2024-08-04/%E5%9B%BE1.png" class title="图1"><p><font color="yellow">注意点：</font></p><ol><li><code>props</code>接收的参数是<font color="yellow">不支持更改的</font>。如果需要改动数据，需要复制一份到<code>data</code>配置项中的变量中。例如上述<code>this.arr=this.newArr</code>。</li><li>在传递数组和对象是，<font color="yellow"><code>props</code>参数传递方式是引用传递</font>。也就是说不同子组件和父组件数组指向的是同一个数组。在上诉代码中，<code>this.arr=this.newArr</code>也是浅复制，两个子组件的<code>this.arr</code>和父组件的<code>this.arr</code>指向的都是同一个数组，所以当一个子组件更改数组数据时，会对另一个子组件的数组造成影响，因此上诉“子组件数据”字符串插入了两次。<font color="yellow">在对象和数组的复制操作中，我们需要保证是否需要进行深复制</font>。</li></ol><p>使用 <code>v-bind</code> 指令可以将父组件的数据绑定到子组件的 <code>props</code> 上。这适用于动态绑定 <code>props</code> 或传递多个 <code>props</code>。</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ChildComponent v-bind=&quot;parentProps&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br><br>export default &#123;<br>  components: &#123; ChildComponent &#125;,<br>  data() &#123;<br>    return &#123;<br>      parentProps: &#123;<br>        message: &#x27;Hello from parent&#x27;,<br>        count: 42<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    message: String,<br>    count: Number<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">注意点：</font></p><ul><li>父组件<code>parentProps</code>中的keys值需要和子组件<code>props</code>中的keys值对应起来。</li></ul><p>除了data数据，<font color="yellow">父组件可以将方法作为 <code>props</code> 传递给子组件</font>。子组件可以在其方法中调用这些 <code>props</code> 传递过来的方法。</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ChildComponent :parentMethod=&quot;handleParentMethod&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br><br>export default &#123;<br>  components: &#123; ChildComponent &#125;,<br>  methods: &#123;<br>    handleParentMethod(message) &#123;<br>      console.log(&#x27;Parent method called with message:&#x27;, message);<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;button @click=&quot;callParentMethod&quot;&gt;Call Parent Method&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    parentMethod: &#123;<br>      type: Function,<br>      required: true<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    callParentMethod() &#123;<br>      this.parentMethod(&#x27;Hello from child&#x27;);<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">注意点：</font></p><ul><li>通过方法我们可以将子组件的数据传递给父组件，实现<font color="#FFFF00">子组件——&gt;父组件</font>。</li></ul><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=66">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=66</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="mixin混入"><a href="#mixin混入" class="headerlink" title="mixin混入"></a>mixin混入</h2><p>在 Vue.js 中，<code>mixin</code> 是一种复用组件逻辑的机制。通过 <code>mixin</code>，你可以将多个组件共享的逻辑提取到一个独立的 <code>mixin</code> 对象中，然后在多个组件中使用它们。<code>mixin</code> 允许你将共享的逻辑、数据、生命周期钩子等封装在一起，以便重用。</p><p><font color="yellow">定义 Mixin：</font></p><p>一个 <code>mixin</code> 对象可以包含组件的选项，如 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>、<code>lifecycle hooks</code> 等。以下是一个 <code>mixin</code> 的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// myMixin.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myMixin = &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">mixinData</span>: <span class="hljs-string">&#x27;This is mixin data&#x27;</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">mixinMethod</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is a method from mixin&#x27;</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Mixin created hook&#x27;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="yellow"> 在组件中使用 Mixin：</font></p><p>要在组件中使用 <code>mixin</code>，你需要在组件的 <code>mixins</code> 选项中引入定义好的 <code>mixin</code> 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; mixinData &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;mixinMethod&quot;&gt;Call Mixin Method&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; myMixin &#125; from &#x27;./myMixin&#x27;;<br><br>export default &#123;<br>  mixins: [myMixin],<br>  data() &#123;<br>    return &#123;<br>      componentData: &#x27;This is component data&#x27;<br>    &#125;;<br>  &#125;,<br>  created() &#123;<br>    console.log(&#x27;Component created hook&#x27;);<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">注意点：</font></p><ol><li><strong>数据合并</strong>：<code>mixin</code> 中的 <code>data</code> 会与组件中的 <code>data</code> 合并。如果 <code>data</code> 中有同名属性，组件中的属性会覆盖 <code>mixin</code> 中的属性。</li><li><strong>方法合并</strong>：<code>mixin</code> 中的 <code>methods</code> 会与组件中的 <code>methods</code> 合并。如果 <code>methods</code> 中有同名方法，组件中的方法会覆盖 <code>mixin</code> 中的方法。</li><li><strong>生命周期钩子合并</strong>：<code>mixin</code> 中的生命周期钩子会与组件中的生命周期钩子合并。如果存在同名钩子函数，它们会被合并为一个函数，在执行时按定义的顺序依次调用。</li><li><strong>全局混入</strong>：在<code>main.js</code>中使用<code>Vue.mixin(myMixin)</code>可以实现全局混入。</li></ol><img src="/2024/08/04/%E5%85%B6%E4%BB%96/2024-08-04/%E5%9B%BE2.png" class title="图2"><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=67">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=67</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:#FFFF00">父组件 ——&gt; 子组件</strong> 。</p><h3 id="默认插槽-具名插槽"><a href="#默认插槽-具名插槽" class="headerlink" title="默认插槽 &#x2F; 具名插槽"></a>默认插槽 &#x2F; 具名插槽</h3><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;ChildComponent&gt;<br>      &lt;template slot=&quot;first&quot;&gt;<br>        &lt;div&gt;<br>          &lt;h3&gt; 插槽数据-FIRST &lt;/h3&gt;<br>        &lt;/div&gt;<br>      &lt;/template&gt;<br>      &lt;template slot=&quot;second&quot;&gt;<br>        &lt;div&gt;<br>          &lt;h3&gt; 插槽数据-SECOND &lt;/h3&gt;<br>        &lt;/div&gt;<br>      &lt;/template&gt;<br>    &lt;/ChildComponent&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>    &lt;slot name=&quot;first&quot;&gt;&lt;/slot&gt;<br>    &lt;slot name=&quot;second&quot;&gt;&lt;/slot&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>  font-size: 30px;<br>  font-family: &quot;STZhongsong&quot;;<br>  color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/04/%E5%85%B6%E4%BB%96/2024-08-04/%E5%9B%BE3.png" class title="图3"><p>在子组件中定义<code>&lt;slot name=&quot;&quot;&gt;&lt;/slot&gt;</code>插槽，在父组件可以定义HTML结构并插入到子组件中。如果只有一个插槽则无需设置name，用默认插槽即可。</p><p><font color="yellow">注意点：</font></p><ul><li>插槽结构的样式既可以在父组件中定义，也可以在子组件中定义。</li></ul><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p><span style="color:yellow">数据在子组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在子组件中，但使用数据所遍历出来的结构由父组件决定）</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>&lt;ChildComponent&gt;<br>&lt;template v-slot:default=&quot;scopeData&quot;&gt;<br>&lt;!-- 生成的是ul列表 --&gt;<br>&lt;ul&gt;<br>&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/template&gt;<br>&lt;/ChildComponent&gt;<br><br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>      &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;<br>      &lt;el-button @click=&quot;changeGames&quot;&gt;修改数组&lt;/el-button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>      //数据在子组件自身<br>      data() &#123;<br>          return &#123;<br>              games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]<br>          &#125;<br>      &#125;,<br>      methods:&#123;<br>        changeGames()&#123;<br>          this.games.push(&quot;LOL&quot;);<br>        &#125;        <br>      &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/04/%E5%85%B6%E4%BB%96/2024-08-04/%E5%9B%BE4.png" class title="图4"><p><font color="yellow">注意点：</font></p><ul><li>父组件不能直接“保持”或“保存”作用域插槽传递过来的参数，因为作用域插槽是由子组件提供的，父组件只能使用这些数据，而不能直接修改它们。</li><li>和<code>props</code>参数传参一样，当使用的参数数据变化时，会重写渲染页面。</li></ul><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=102">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=102</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>在 Vue 中，自定义事件是一种使子组件与父组件进行通信的机制。自定义事件允许子组件向父组件传递信息或通知父组件某些操作。传递方向是<font color="yellow">子组件——&gt;父组件</font></p><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:#FFFF00">事件的回调在A中</span>）。</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>&lt;ChildComponent v-on:singal=&quot;slotFunction&quot;&gt;<br>&lt;/ChildComponent&gt;<br><br>&lt;ChildComponent ref=&quot;child&quot;&gt;<br>&lt;/ChildComponent&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>methods:&#123;<br>slotFunction(params)&#123;<br>console.log(params)<br>alert(&quot;回调函数调用 &quot;+params);<br>&#125;<br>&#125;,<br>mounted()&#123;<br>this.$refs.child.$on(&quot;singal&quot;, this.slotFunction);<br>&#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>      &lt;el-button @click=&quot;triggerFunction&quot;&gt;触发信号&lt;/el-button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    methods:&#123;<br>      triggerFunction()&#123;<br>        this.$emit(&quot;singal&quot;,&quot;params&quot;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>  font-size: 30px;<br>  font-family: &quot;STZhongsong&quot;;<br>  color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="具体流程如下"><a href="#具体流程如下" class="headerlink" title="具体流程如下"></a>具体流程如下</h3><p><font color="yellow">第一步：</font>在父组件中创建回调函数，当子组件触发信号的时候，该函数被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">slotFunction</span>(<span class="hljs-params">params</span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;回调函数调用 &quot;</span>+params);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="yellow">第二步：</font>父组件为子组件绑定一个自定义事件，使子组件可以通过触发该事件而调用父组件的回调函数。有两种绑定方式。</p><ol><li><p>在父组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ChildComponent v-on:singal=&quot;slotFunction&quot;&gt;&lt;/ChildComponent&gt;<br>//或者<br>&lt;ChildComponent @singal=&quot;slotFunction&quot;&gt;&lt;/ChildComponent&gt;<br></code></pre></td></tr></table></figure></li><li><p>在父组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ChildComponent ref=&quot;child&quot;&gt;&lt;/ChildComponent&gt;<br>mounted()&#123;<br>this.$refs.child.$on(&quot;singal&quot;, this.slotFunction);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>为子组件绑定了<code>singal</code>事件，通过<code>singal</code>事件触发<code>slotFunction</code>回调函数。</p><p><font color="yellow">第三步：</font>子组件触发事件。可以传递多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>  <span class="hljs-title function_">triggerFunction</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;singal&quot;</span>,<span class="hljs-string">&quot;params&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol><li><p>当不再需要使用组件时，最好手动解绑事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.$off(<span class="hljs-string">&quot;singal&quot;</span>)<br><span class="hljs-comment">//解绑当前组件的所有事件</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.$off()<br></code></pre></td></tr></table></figure></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。没有修饰符会默认是自定义事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ChildComponent @click.native=&quot;slotFunction&quot;&gt;&lt;/ChildComponent&gt;<br></code></pre></td></tr></table></figure></li><li><p>其他的修饰符包括</p><ul><li><code>.stop</code>：调用 <code>event.stopPropagation()</code>，阻止事件冒泡。需要阻止事件从子组件冒泡到父组件时。</li><li><code>.prevent</code>：调用 <code>event.preventDefault()</code>，阻止默认行为。</li><li><code>.once</code>：事件只会触发一次。</li></ul></li><li><p>通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:yellow">要么配置在methods中</span>，<span style="color:yellow">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=80">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=80</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="全局事件"><a href="#全局事件" class="headerlink" title="全局事件"></a>全局事件</h2><p>将自定义事件扩展到能够进行<font color="yellow">任意组件间的通信</font>。</p><ol><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>......<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线，$bus就是当前应用的vm</span><br>&#125;,<br>    ......<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:#FFFF00">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;......&#125;<br>&#125;<br>......<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;xxxx&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:#FFFF00">当前组件所用到的</span>事件。</p></li></ol><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=84">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=84</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong><font color="yellow">路由中的<code>&lt;router-view ref=&quot;main&quot;&gt;&lt;/router-view&gt;</code>也是子组件，可以绑定事件。</font></strong></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>每日总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-08-02学习总结</title>
    <link href="/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/"/>
    <url>/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/</url>
    
    <content type="html"><![CDATA[<p>本文记录了一些前端学习的知识点</p><span id="more"></span><h1 id="前端学习记录"><a href="#前端学习记录" class="headerlink" title="前端学习记录"></a>前端学习记录</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><h2 id="CSS常见属性的继承性"><a href="#CSS常见属性的继承性" class="headerlink" title="CSS常见属性的继承性"></a>CSS常见属性的继承性</h2><h3 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h3><p>这些属性的值会自动从父元素继承到子元素，除非显式地为子元素设置了其他值。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>color</code></td><td>文本的颜色。</td></tr><tr><td><code>font-family</code></td><td>字体系列。</td></tr><tr><td><code>font-size</code></td><td>字体大小。</td></tr><tr><td><code>font-style</code></td><td>字体样式（如斜体）。</td></tr><tr><td><code>font-weight</code></td><td>字体粗细。</td></tr><tr><td><code>line-height</code></td><td>行高。</td></tr><tr><td><code>text-align</code></td><td>文本对齐方式。</td></tr><tr><td><code>text-indent</code></td><td>文本缩进。</td></tr><tr><td><code>text-transform</code></td><td>文本转换（如大写、小写）。</td></tr><tr><td><code>letter-spacing</code></td><td>字符间距。</td></tr><tr><td><code>word-spacing</code></td><td>单词间距。</td></tr><tr><td><code>text-shadow</code></td><td>文本阴影。</td></tr><tr><td><code>white-space</code></td><td>空白符处理。</td></tr><tr><td><code>visibility</code></td><td>元素可见性。</td></tr><tr><td><code>list-style</code></td><td>列表样式。</td></tr><tr><td><code>border-collapse</code></td><td>边框折叠方式（在表格中）。</td></tr><tr><td><code>border-spacing</code></td><td>边框间距（在表格中）。</td></tr></tbody></table><h3 id="不可继承属性"><a href="#不可继承属性" class="headerlink" title="不可继承属性"></a>不可继承属性</h3><p>这些属性不会自动从父元素继承到子元素，每个元素需要单独设置这些属性的值。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>background</code></td><td>背景颜色、背景图片等。</td></tr><tr><td><code>border</code></td><td>边框的宽度、样式和颜色。</td></tr><tr><td><code>margin</code></td><td>外边距。</td></tr><tr><td><code>padding</code></td><td>内边距。</td></tr><tr><td><font color="#FFFF00"><code>width</code></font></td><td>元素的宽度。</td></tr><tr><td><font color="yellow"><code>height</code></font></td><td>元素的高度。</td></tr><tr><td><code>position</code></td><td>元素的定位方式。</td></tr><tr><td><code>display</code></td><td>元素的显示类型（如块级、行内、隐藏等）。</td></tr><tr><td><code>overflow</code></td><td>内容溢出处理方式。</td></tr><tr><td><code>z-index</code></td><td>元素的堆叠顺序。</td></tr><tr><td><code>box-shadow</code></td><td>盒子阴影。</td></tr><tr><td><code>opacity</code></td><td>元素的不透明度。</td></tr><tr><td><code>float</code></td><td>元素的浮动方式。</td></tr><tr><td><code>clear</code></td><td>清除浮动。</td></tr><tr><td><code>flex</code></td><td>Flexbox 布局属性。</td></tr><tr><td><code>grid</code></td><td>Grid 布局属性。</td></tr><tr><td><code>transform</code></td><td>元素的变换（如旋转、缩放）。</td></tr><tr><td><code>transition</code></td><td>过渡效果。</td></tr><tr><td><code>animation</code></td><td>动画效果。</td></tr></tbody></table><h3 id="继承机制的管理"><a href="#继承机制的管理" class="headerlink" title="继承机制的管理"></a>继承机制的管理</h3><p>对于不可继承的属性，可以使用 <code>inherit</code>, <code>initial</code>, <code>unset</code> 和 <code>revert</code> 值来管理继承行为：</p><ul><li>**<code>inherit</code>**：强制子元素继承父元素的属性值。</li><li>**<code>initial</code>**：将属性值设置为其初始值。</li><li>**<code>unset</code>**：将属性值设置为其继承值或初始值，取决于属性是否继承。</li><li>**<code>revert</code>**：将属性值恢复为由用户代理（浏览器）默认样式表所定义的值。</li></ul><p><font color="#FFFF00">容器设置百分比相对长宽时，由于<code>width</code>和<code>height</code>不会继承，需要保证父容器设置了长宽。</font></p><h2 id="CSS选择器的优先级"><a href="#CSS选择器的优先级" class="headerlink" title="CSS选择器的优先级"></a>CSS选择器的优先级</h2><p><font color="#FFFF00"> 简单描述：<code>!important</code>&gt;行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器&gt;通用选择器(*)&gt;继承样式</font></p><p>详细描述：计算权重。每个选择器，都可计算出一组权重，格式为： (a,b,c)，权重相同则后来者居上。</p><ul><li>a：ID选择器和个数。</li><li>b：类、伪类、属性选择器的个数。</li><li>c：元素、伪元素选择器的个数。</li></ul><blockquote><p><a href="https://www.bilibili.com/video/BV1p84y1P7Z5/?p=86">https://www.bilibili.com/video/BV1p84y1P7Z5/?p=86</a></p><p>《CSS2笔记》 P15</p></blockquote><h2 id="媒体查询和响应式布局"><a href="#媒体查询和响应式布局" class="headerlink" title="媒体查询和响应式布局"></a>媒体查询和响应式布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> &#123;媒体类型 / 媒体特性&#125; <span class="hljs-selector-attr">[ &#123;运算符&#125; &#123;媒体类型 / 媒体特性&#125;  ]</span>&#123;<br>    CSS样式<br>&#125; <br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>) &#123; <span class="hljs-comment">/* 当媒体为屏幕且视口宽度小于等于1000px时，采用下面的样式 */</span><br>    <span class="hljs-selector-class">.el-aside</span> &#123;<br>        <span class="hljs-attribute">position</span>: fixed;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>        <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1000</span>;<br><br>        &amp;<span class="hljs-selector-class">.hide-aside</span> &#123;<br>            <span class="hljs-attribute">left</span>: -<span class="hljs-number">250px</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>all</td><td>检测所有设备</td></tr><tr><td>screen</td><td>检查电子屏幕</td></tr><tr><td>print</td><td>监测打印机</td></tr></tbody></table><h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>width</td><td>检测视口宽度</td></tr><tr><td>max-width</td><td>检测视口最大宽度</td></tr><tr><td>min-width</td><td>检测视口最小宽度</td></tr><tr><td>height&#x2F;max-height&#x2F;min-height</td><td>类似宽度</td></tr><tr><td>device-width&#x2F;max-device-width&#x2F;min-device-width</td><td>检测<font color="yellow">屏幕</font>宽度&#x2F;最大宽度&#x2F;最小宽度</td></tr><tr><td>orientation</td><td>检测视口的旋转方向（是否横屏）<br>1.<code>portrait</code>：视口处于纵向，即高度大于等于宽度。<br>2.<code>landscape</code>：视口处于横向，即宽度大于高度。</td></tr></tbody></table><p>完整列表请参考：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>and</td><td>并且</td></tr><tr><td>, 或者 or</td><td>或</td></tr><tr><td>not</td><td>非</td></tr><tr><td>only</td><td>是（加载@media后，某些低版本IE浏览器不检测媒体特性和运算符，避免混乱）</td></tr></tbody></table><blockquote><p><a href="https://www.bilibili.com/video/BV1p84y1P7Z5?p=197">https://www.bilibili.com/video/BV1p84y1P7Z5?p=197</a></p><p>《CSS3笔记》 P29</p></blockquote><h2 id="Sass编译器安装"><a href="#Sass编译器安装" class="headerlink" title="Sass编译器安装"></a>Sass编译器安装</h2><p><strong>Sass是一种CSS预处理器。</strong>Sass提供了一种更简单、更优雅的语法来描述CSS，并支持变量、混合器等功能，使CSS开发更加灵活和高效。Sass源码可以通过编译器转换成标准的CSS代码。</p><p>首次安装：首先全局安装。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install sass -g<br></code></pre></td></tr></table></figure><p>vue终端敲下面代码（电脑上之前全局安装过Sass，不需要第一步操作，直接在项目上安装依赖）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install --save-dev sass-loader<br></code></pre></td></tr></table></figure><h2 id="scoped属性和-deep-v-deep-深度选择器"><a href="#scoped属性和-deep-v-deep-深度选择器" class="headerlink" title="scoped属性和:deep(::v-deep)深度选择器"></a>scoped属性和:deep(::v-deep)深度选择器</h2><h3 id="scoped属性"><a href="#scoped属性" class="headerlink" title="scoped属性"></a>scoped属性</h3><p>vue中的<code>scoped</code>属性用来实现组件级样式封装的一个功能，它确保样式仅作用于当前组件，而不会影响到其他组件。它的渲染规则有：</p><ol><li><code>scoped</code>给当前组件中HTML的所有DOM节点添加一个相同且与其他组件不重复的<code>data属性</code>，来表示组件的唯一性。</li><li>css选择器编译后，会更改为其末尾添加当前组的data属性的属性选择器来私有化样式。</li><li>如果组件内部包含子组件，子组件作为HTML的一个DOM节点会添加data属性，但子组件的子组件不会添加属性。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          &lt;div style=&quot;color:#FFFFFF&quot;&gt; scoped原理分析 &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;el-tabs&gt;<br>      &lt;el-tab-pane label=&quot;标签1&quot;&gt;<br>        &lt;div style=&quot;color:#FFFF00&quot;&gt;标签内容&lt;/div&gt;<br>      &lt;/el-tab-pane&gt;<br>    &lt;/el-tabs&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>  .el-tabs&#123;<br>    background:#000000;<br>    border: 1px solid #FFFFFF;<br>      .el-tabs__content&#123;<br>      background-color: #FFFFFF;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/%E5%9B%BE1.png" class title="图1"><p>这个例子我们使用了<code>Element-UI</code>组件来渲染页面。<code>Element-UI</code>组件实现了很多控件功能，而每一个控件都是由一个或多个组件实现的。例如<code>el-tabs</code>标签栏，我们可以看到包含了4个组件。</p><img src="/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/%E5%9B%BE2.png" class title="图2"><p>打开控制台分析页面结构。</p><img src="/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/%E5%9B%BE3.png" class title="图3"><p><font color="yellow">根据第一条规则</font>，组件HTML的所有DOM节点都会添加相同的属性<code>data-v-1f2b5af6</code>，计算有多重div容器也会全部添加。</p><p><font color="#FFFF00">根据第三条规则</font>，ElTabs是当前组件的子组件，也会添加属性。但是TabNav、TabBar、ElTabPane是ElTabs组件的子组件，不会添加data属性。</p><img src="/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/%E5%9B%BE4.png" class title="图4"><img src="/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/%E5%9B%BE5.png" class title="图5"><p><font color="yellow">根据第二条规则</font>，<code>.container&#123;&#125;</code>选择器在经过编译以后变成了<code>.container[data-v-1f2b5af6]&#123;&#125;</code>属性选择器。<code>.container .el-tabs&#123;&#125;</code>选择器编程以后成为了<code>.container .el-tabs[data-v-1f2b5af6]</code>选择器。</p><p>那么同理，<code>.container .el-tabs .tabs__content&#123;&#125;</code>选择器编译会成为<code>.container .el-tabs .el-tabs__content[data-v-1f2b5af6]&#123;&#125;</code>。但是由于<code>el.tabs__content</code>并没有添加data属性，<font color="yellow">所以选择器不起作用，背景颜色未改变</font>。</p><p>为了解决这个问题，我们需要使用<code>:deep / ::v-deep</code>深度选择器。</p><h3 id="deep-v-deep"><a href="#deep-v-deep" class="headerlink" title=":deep / ::v-deep"></a><code>:deep / ::v-deep</code></h3><p>在 Vue.js 中，<code>:deep</code> 是一个用于穿透 <code>scoped</code> 样式封装的特殊选择器。它允许你在父组件中应用样式到子组件的内部元素，从而实现样式的深层次影响。</p><p>我们修改上述选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 原选择器 */</span><br><span class="hljs-selector-class">.el-tabs__content</span>&#123;<br>   <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFFFFF</span>;<br>&#125;<br><span class="hljs-comment">/* 更改后选择器 */</span><br>:<span class="hljs-built_in">deep</span>(.el-tabs__content)&#123;<br>   <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFFFFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/08/02/%E5%85%B6%E4%BB%96/2024-08-02/%E5%9B%BE6.png" class title="图6"><p>背景色改变，我们看到<font color="yellow"><code>.container .el-tabs .tabs__content&#123;&#125;</code>选择器编译变成了<code>.container .el-tabs[data-v-1f2b5af6] .el-tabs__content&#123;&#125;</code></font>。</p><blockquote><p><a href="https://blog.csdn.net/wgh4318/article/details/128711849">https://blog.csdn.net/wgh4318/article/details/128711849</a></p><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=69">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=69</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模-数学建模入门指南</title>
    <link href="/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/"/>
    <url>/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/</url>
    
    <content type="html"><![CDATA[<p>文章介绍数学建模的入门指南，梳理数学建模概念。</p><span id="more"></span><h1 id="数学建模入门指南"><a href="#数学建模入门指南" class="headerlink" title="数学建模入门指南"></a>数学建模入门指南</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><p>数学建模是一个将<font color="#00F7B4">现实世界的复杂问题转化成数学形式来对问题进行分析和求解的过程</font>。这个过程涉及将实际问题中的复杂因素简化为数学结构，并用数学语言描述这些因素及其相互关系。</p><blockquote><p><strong>引入经典问题：长方形（四角连线呈长方形）的椅子可以在地面上放稳吗？</strong></p></blockquote><p>这是一个现实世界的问题，数学建模的过程就是需要将其转化成数学形式进行分析和求解。主要分为以下五个步骤。</p><h2 id="建模过程"><a href="#建模过程" class="headerlink" title="建模过程"></a>建模过程</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>大家可能会想,题目不是已经给出问题了吗? 是的,但是这里的提出问题是指用数学语言去表达。</p><p>首先<font color="yellow">分析问题</font>，列出问题中涉及的变量，包括适当的单位。经过分析，我们可以用变量表示椅子的位置，用函数表示椅子四脚与地面的距离，进而用数学语言把问题表达出来.</p><p>接着<font color="yellow">模型假设</font>，我们要抛开一些非主干的问题，因此需要对问题做一些假设。模型假设是我们对问题增加的约束条件，在做模型假设是我们要考虑假设的合理性和特殊性。例如我们不能假设地面时完全水平的或是阶梯，这种假设没有意义。</p><ol><li>假设椅子的四条腿一样长，椅子腿与地面接触处抽象为一个点，，四脚的连线呈长方形。</li><li>地面高度是连续变化的，沿周围任意方向都不会出现间断 (高度突变)，即地面是连续曲面。这个假设相当于给出了椅子能放稳的必要条件。</li><li>对于椅子脚的间距和椅子腿的长度而言，地面是相对平坦的，使椅子在任何位置至少有三只脚同时着地。</li></ol><p>然后<font color="yellow">数学表达</font>，根据模型假设和涉及的变量将问题数学化。这一步通常要结合考虑我们可能会用到的模型。</p><p>我们知道，当椅脚与地面的竖直距离为零时，椅脚就着地了，而当这个距离大于零时，椅脚不着地。假设椅子的四脚记作A，B，C，D。根据假设3至少由三只脚同时着地，那么椅子在地面上移动对问题没有影响，只考虑椅子旋转的情况。因此我们假设某一时刻A，B，C着地，以AC与BD连线的交点为原点，AC为X轴建立平面直角坐标系，设OA与X轴的夹角为θ，因为长方形的旋转可代表椅子位置的改变，则旋转角度θ这一变量可表示椅子的位置。A、B两脚与地面竖直距离之和为f（θ），C、D两脚与地面竖直距离之和为g（θ），其中θ∈[0，π]。</p><img src="/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/18b98e4f898657c25044739c34870862.png" class title="图1"><p>在更多复杂的现实问题中，我们在问题分析和模型假设之前，可能还需要进行<font color="yellow">数据集处理</font>工作。例如我们希望建立模型来预测房价，需要进行一下工作：</p><ol><li>数据收集：通过各个平台收集包含多个房屋特征的数据集，例如房屋面积、卧室数量、位置、房价等。</li><li>数据清洗：收集的数据集可能存在很多问题，数据清洗的目标是处理数据中的问题，使数据质量达到可用的标准。包括<ul><li>缺失值处理：比如数据集中有些房屋的“面积”特征缺失，可以用均值、中位数或最频繁值填充缺失值，或者使用插值方法填补缺失值。</li><li>异常值处理：比如发现一些房屋的“面积”值异常大，可能是录入错误，通过统计分析（如箱线图）识别异常值，并根据业务规则决定是否删除或修正这些值。</li><li>重复数据处理：比如数据集中存在重复的房屋记录。我们要删除重复记录，以确保每个房屋只有一个数据条目。</li><li>数据标准化：房屋价格可能使用了不同的货币单位。我们要统一所有价格数据的单位，以便进行比较和分析。</li></ul></li><li>特征工程：目标是从原始数据中提取有用的信息，创建新的特征，或者转换现有特征，以提高模型的性能。<ul><li>特征提取：例如数据集中没有包含房屋的“楼层”信息，但这可能对房价有影响。可以从房屋的描述字段中提取出“楼层”信息，并作为一个新特征添加到数据集中。</li><li>特征归一化：一些特征（如房屋面积和房龄）具有不同的量纲，这可能会影响模型训练。可以对特征进行标准化或归一化，以确保所有特征在相同的尺度上。</li></ul></li></ol><p>最终房屋价格可能与房屋面积、卧室数量、位置、房价、楼层等特征因素有关，我们再列出变量和数学关系。</p><h3 id="选择建模方法"><a href="#选择建模方法" class="headerlink" title="选择建模方法"></a>选择建模方法</h3><p>选择解决问题的一个一般的求解方法。一般地，这一步需要有一定的数学建模经验和技巧。同时需要熟悉相关的文献。要求我们对常见的数学模型和算法有一定的了解。下图列出来针对不同问题的常见模型。</p><h4 id="常用模型"><a href="#常用模型" class="headerlink" title="常用模型"></a>常用模型</h4><img src="/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB.jpg" class title="图2"><p>例如回归拟合预测模型就是房价预测中常用的一种方法。它通过建立一个数学模型来描述房价与其他特征变量（房屋面积、卧室数量、位置、房价、楼层）之间的关系，从而进行预测。</p><h4 id="常用的十大算法："><a href="#常用的十大算法：" class="headerlink" title="常用的十大算法："></a>常用的十大算法：</h4><ol><li><font color="yellow">蒙特卡罗算法</font>(该算法又称随机性模拟算法，是通过计算机仿真来解决问题的算法，同时可以通过模拟可以来检验自己模型的正确性，是比赛时必用的方法)</li><li><font color="yellow">数据拟合、参数估计、插值等数据处理算法</font>(比赛中通常会遇到大量的数据需要处理，而处理数据的关键就在于这些算法，通常使用Matlab作为工具)</li><li><font color="yellow">线性规划、整数规划、多元规划、二次规划等规划类问题</font>(建模竞赛大多数问题属于最优化问题，很多时候这些问题可以用数学规划算法来描述，通常使用Lindo、Lingo软件实现)</li><li><font color="yellow">图论算法</font>(这类算法可以分为很多种，包括最短路、网络流、二分图等算法，涉及到图论的问题可以用这些方法解决需要认真准备)</li><li><font color="yellow">动态规划、回溯搜索、分治算法、分支定界等计算机算法</font>(这些算法是算法设计中比较常用的方法，很多场合可以用到竞赛中）</li><li><font color="yellow">最优化理论的三大非经典算法:模拟退火法、神经网络、遗传算法</font>(这些问题是用来解决一些较困难的最优化问题的算法，对于有些问题非常有帮助，但是算法的实现比较困难，需慎重使用)</li><li><font color="yellow">网格算法和穷举法</font>(网格算法和穷举法都是暴力搜索最优点的算法，在很多竞赛题中有应用，当重点讨论模型本身而轻视算法的时候，可以使用这种暴力方案，最好使用一些高级语言作为编程工具)</li><li><font color="yellow">一些连续离散化方法</font>(很多问题都是实际来的，数据可以是连续的，而计算机只认的是离散的数据，因此将其离散化后进行差分代替微分、求和代替积分等思想是非常重要的)</li><li><font color="yellow">数值分析算法</font>(如果在比赛中采用高级语言进行编程的话，那一些数值分析中常用的算法比如方程组求解、矩阵运算、函数积分等算法就需要额外编写库函数进行调用)</li><li><font color="yellow">图象处理算法</font>(赛题中有一类问题与图形有关，即使与图形无关，论文中也应该要不乏图片的，这些图形如何展示以及如何处理就是需要解决的问题。</li></ol><h4 id="模型和算法之间的关系"><a href="#模型和算法之间的关系" class="headerlink" title="模型和算法之间的关系"></a>模型和算法之间的关系</h4><ol><li><strong>模型使用算法来实现和优化</strong>：<ul><li><strong>实现模型</strong>：许多模型的实现依赖于算法。例如，支持向量机（SVM）模型需要通过算法来找到最优的分割超平面。</li><li><strong>优化模型</strong>：优化模型中的参数或结构通常使用算法。例如，线性回归模型通过最小二乘算法来确定回归系数。</li></ul></li><li><strong>模型定义了问题，算法提供了解决方案</strong>：<ul><li><strong>模型定义</strong>：模型描述了问题的结构和关系。它定义了要分析的变量、参数及其相互作用。</li><li><strong>算法解决</strong>：算法提供了解决模型中问题的方法和步骤。例如，决策树模型定义了分类规则，而构建决策树的算法（如ID3或C4.5）决定了如何生成树结构。</li></ul></li><li><strong>模型和算法的结合</strong>：<ul><li><strong>模型构建</strong>：在构建模型时，需要选择和设计合适的算法来实现模型的功能。例如，在机器学习中，选择模型（如神经网络）时，需要应用相应的训练算法（如反向传播算法）。</li><li><strong>模型评估和优化</strong>：模型的效果可以通过算法来评估和优化。例如，交叉验证算法可以用来评估模型的性能，超参数优化算法（如网格搜索、随机搜索）可以用来调整模型的参数。</li></ul></li></ol><h3 id="推导模型的公式"><a href="#推导模型的公式" class="headerlink" title="推导模型的公式"></a>推导模型的公式</h3><p>将第一步中得到的问题重新表达成第二步选定的建模方法所需要的形式，从而<font color="yellow">构建模型</font>，确保第一步中的变量名与第二步的一致。记下任何补充假设，这些假设是为了使第一步中描述的问题与第二步中选定的数学结构相适应而做出的。</p><p>在椅子平稳性问题中，数学模型构建：已知f（θ）和g（θ）是θ的非负连续函数，对∀θ，f（θ）•g(θ)＝0，证明：∃θ0∈[0，π]，使得f（θ0）＝g（θ0）＝0成立。</p><p>在房价预测问题中，数学模型构建：通过线性函数用于建模多个自变量 x1,x2,……xp 和一个因变量 y 之间的线性关系。</p><img src="/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/image-20240724224309134.png" class title="图3"><p>其中自变量X可以表示房屋面积、卧室数量、位置、房价、楼层等特征变量，y是房价。</p><h3 id="求解模型"><a href="#求解模型" class="headerlink" title="求解模型"></a>求解模型</h3><p>将第二步中所选方法应用于第三步得到的表达式，再求解过程中注意数学推导，确保推导过程无误且结果有意义。并采用适当的方法扩大解决问题的范围并减少计算错误。</p><p>在椅子平稳性问题中，①若f（0）＝g（0）＝0，那么结论成立。②若f（0）与g（0）不同时为零，不妨设f（0）＞0，g（0）＝0。将长方形ABCD绕点O逆时针旋转角度π后，A，B与C，D互换，但长方形ABCD在地面上所处的位置不变，由此可知，f（π）＝g（0），g（π）＝f（0）.∴f（0）＞0，g（0）＝0 → g（π）＞0，f（π）＝0。</p><p>令h（θ）＝f(θ)－g（θ），由f(θ)和g(θ)的连续性知h(θ)也是连续函数。又h（0）＝f(0)－g（0）＞0，h（π）＝f(π)－g（π）＜0，根据连续函数介值定理，必存在θ0∈（0，π）使得h（θ0）＝0，即f（θ0）＝g（θ0） ；又因为f（θ0）•g（θ0）＝0，所以f（θ0）＝g（θ0）＝0。即四只脚同时着地，稳定。</p><p>在预测房价问题中，需要是预测的房价和真实的房价的误差趋于最小，使用最小二乘法作为损失函数优化模型，即使图中Q值趋于最小。也就是当梯度为零的时候取最小值。</p><img src="/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/image-20240724225420896.png" class title="图4"><img src="/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/image-20240724225449385.png" class title="图5"><p>这一过程需要对建模工具有一定的掌握。</p><ol><li><p>统计模型：SPSS,Eviews，Stata 。</p></li><li><p>数据分析：R，数据库SQL Server，IBM，DB2</p></li><li><p>微分方程：Maple, Mathematic, MATLAB</p></li><li><p>运筹规划：Matlab，Lingo</p></li><li><p>智能算法：Matlab，R</p></li><li><p>时间序列：R，Matlab</p></li><li><p>图像处理：Matlab，C++</p></li></ol><h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><p>最终在论文中我们需要用非技术性的语言将第四步的结果重新表述，表述过程中需要避免数学符号和术语。这部分是对你整篇论文成果的总结，一定要写的有深度。除此之外，通常还要写上一些灵敏度分析，如果是统计模型的话，要有模型检验。论文通常会需要画一些图表，可以使用Matlab、R等软件来画跟数据有关的图，使用Visio或者PPT画流程图之类的图。</p><p>在椅子平稳性问题中，椅子在旋转过程中，至少存在一个点能使椅子能在不平的地面上放稳。</p><p>在预测房价问题中，根据我们推导出的模型，当已知特征变量时，能够预测房屋价格。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在建模的五步法中，整个建模需要的工作包括：</p><ol><li>数据收集：要构建有效的模型，首先需要获得相关的数据。这些数据可以来自多种渠道。</li><li>数据清理：原始数据往往包含噪声、缺失值和异常值，因此在建模之前必须对数据进行清理。数据清理的过程包括：</li><li>特征工程：特征工程是指从原始数据中提取和构造有助于模型预测的特征</li><li>模型选择与建立：根据问题的性质和数据的特点，选择合适的数学或统计模型。常见的模型类型包括：</li><li>模型求解：在模型建立之后，需要对模型进行求解、训练和验证。</li><li>模型评估：评估模型的性能是检验模型有效性的重要步骤。</li><li>问题回答：用非技术语言解释模型的预测结果和模型的原理和假设等</li></ol><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li><font color="yellow">高数、线性代数和概率论与统计基础。</font>在数学建模过程中我们要能够掌握函数的变化、极值、导数、积分等概念，对于优化问题和动态系统建模非常重要。而矩阵运算、特征值、特征向量、线性方程组等概念在处理数据、优化问题和统计分析中至关重要。同时还需要处理不确定性和随机性，涉及概率分布、期望值、方差、假设检验等问题。</li><li><font color="yellow">掌握常见模型和算法。</font>只有对常见模型和算法有一定的了解，才能在选择解决问题的一个一般的求解方法时，找到合适和模型。不一定要对模型有很深的了解，但要知道不同模型能够用在哪些问题上。</li></ul><h3 id="编程代码"><a href="#编程代码" class="headerlink" title="编程代码"></a>编程代码</h3><ul><li><strong>Matlab</strong>：交互式编程软件，将海量算法或工具进行封存，能仿真、能绘图、能求解，可直接调用。</li><li><strong>Python</strong>：主要针对机器学习算法和深度学习，以及数据分析是非常方便的。</li><li><strong>SPSS</strong>：专业的统计数据分析软件，有大量统计模型可直接使用。</li><li><strong>Lingo</strong>：交互式的线性和通用优化求解器，可以用于求解各类规划模型。</li></ul><h3 id="写作排版"><a href="#写作排版" class="headerlink" title="写作排版"></a>写作排版</h3><ul><li><strong>WORD(或WPS)</strong>:论文写作专用，并可以导成PDF格式</li><li><strong>EXCEL</strong>:分析数据、并绘制数据走势图等精美图片Mathtype:公式编辑器，用于编写各类数学公式和特殊符号</li><li><strong>Mathpix</strong>:公式提取软件，用于将其他论文的公式提取到自己论文中</li><li><strong>Checker</strong>:英文文章语言免费检查软件，可分析语法、拼写等错误</li><li><strong>LaTeX</strong>:论文排版软件，主要利用编程语言对论文进行排版</li></ul><h3 id="文献检索"><a href="#文献检索" class="headerlink" title="文献检索"></a>文献检索</h3><p>文献检索也是很重要的，数模竞赛题目往往具有一定的专业性，需要学会查到相关领域的论文并加以利用。</p><h2 id="建模比赛"><a href="#建模比赛" class="headerlink" title="建模比赛"></a>建模比赛</h2><p>只有参加比赛在实践中才能帮助我们快速提升，通过比赛熟悉从数据收集、建立模型到论文撰写的整个流程；提示文献查阅、工具使用和代码编写的能力；感受团队协作、学术讨论、全力以赴的氛围。刚开始的时候要端正好心态，不要盲目的追求获奖，以学习练兵为目标。</p><h3 id="如何组队"><a href="#如何组队" class="headerlink" title="如何组队"></a>如何组队</h3><p>建模比赛都是是三个人组队，一般来说为：一人负责编程、一人负责建模、一人负责论文。</p><p>队长通常由建模手担任，需要具备的是<strong>领导力、沟通协调能力、时间管理能力和决策能力</strong>。他不仅要掌控比赛进度，建立有效的沟通机制，合理分配各阶段的任务和时间，还要激发团队士气，综合团队意见，做出明智的决策。</p><p>建模手的首要任务深入解析题目要求，确保对问题的全面准确理解。随后需<strong>广泛搜集并研读相关领域的最新文献</strong>，提炼出关键的研究方法和理论框架。基于这些资料<strong>设计并构建数学模型</strong>，明确模型假设、参数设定及逻辑推导过程，形成模型初稿。在编程手和写作手的反馈下不断<strong>迭代优化模型</strong>，确保其既符合题目要求又便于编程实现和论文撰写。</p><p>赛前，写作手要<strong>熟悉论文写作规范</strong>，准备好论文模板和必要的写作工具（如Word、LaTeX）。根据建模手提供的模型初稿和深入分析，展开详细的论述，包括背景介绍、文献综述、模型构建、结果分析等多个部分，确保论文内容充实、逻辑严谨。在编程手完成编程工作后，将<strong>结合编程结果和模型理论</strong>，进行深入的分析和讨论，提升论文的学术价值和说服力。最后<strong>全面审查论文</strong>，修正语法错误、优化排版布局，确保论文的整洁美观。</p><p>编程要<strong>做好技术准备</strong>，赛前熟练掌握至少一种编程语言（如Python、MATLAB）并安装调试好运行环境。在明确建模手M的模型求解需求后，要<strong>迅速制定编程方案</strong>，编写高效、准确的代码来实现模型求解。在编程过程中应<strong>注重代码的可读性和可维护性</strong>，并在适当位置添加注释和输出中间结果，以便于调试和后续分析。在编程完成后，<strong>整理编程结果</strong>，并将其转化为易于理解和分析的表格、图形等形式，为写作手提供有力的数据支持。</p><h3 id="数学建模比赛"><a href="#数学建模比赛" class="headerlink" title="数学建模比赛"></a>数学建模比赛</h3><img src="/2024/07/24/%E5%85%B6%E4%BB%96/2024-07-24/ed05abae7f4a47958d3243172a469d29_%E7%9C%8B%E5%9B%BE%E7%8E%8B.png" class title="图6"><blockquote><p>图片来源：<a href="https://blog.csdn.net/weixin_61644243/article/details/136262876">https://blog.csdn.net/weixin_61644243/article/details/136262876</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>数学分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-ECharts使用（2）</title>
    <link href="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/"/>
    <url>/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/</url>
    
    <content type="html"><![CDATA[<p>文章介绍了EChats图表构建中Axis、Grid、Legend、Tooltip的常见用法。</p><span id="more"></span><h1 id="前端学习-ECharts的使用（2）"><a href="#前端学习-ECharts的使用（2）" class="headerlink" title="前端学习-ECharts的使用（2）"></a>前端学习-ECharts的使用（2）</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><p>本文以下面代码为初始状态进行分析ECharts配置项的基本使用，我们总结了常用的配置项，并尽量总结了它们之间的联系，当然在使用的时候我们还是需要结合官方的API文档和配置项文档使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> dataX=[];<br><span class="hljs-keyword">let</span> dataY1=[];<br><span class="hljs-keyword">let</span> dataY2=[];<br><span class="hljs-keyword">let</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;count&lt;<span class="hljs-number">20</span>;count++)&#123;<br>  dataX.<span class="hljs-title function_">push</span>((count+<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>());<br>  dataY2.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());<br>  dataY1.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());<br>&#125;<br><br>option=&#123;<br>  <span class="hljs-attr">textStyle</span>:&#123;<br>    <span class="hljs-attr">fontFamily</span>:<span class="hljs-string">&quot;STZhongsong&quot;</span>,<br>    <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;white&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">title</span>:&#123;<br>    <span class="hljs-attr">text</span>:<span class="hljs-string">&quot;2024-07-23&quot;</span>,<br>    <span class="hljs-attr">textStyle</span>:&#123;<br>      <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;yellow&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">subtext</span>:<span class="hljs-string">&quot;-- by Xiang&quot;</span><br>  &#125;,<br>  <span class="hljs-comment">//XY轴</span><br>  <span class="hljs-attr">xAxis</span>:&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">data</span>:dataX,<br>  &#125;,<br>  <span class="hljs-attr">yAxis</span>:[<br>    &#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>    <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>    <span class="hljs-attr">max</span>:<span class="hljs-number">2</span>,<br>    &#125;,<br>  ],<br>  <span class="hljs-comment">//数据系列</span><br>  <span class="hljs-attr">series</span>:[<br>    &#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;line1&quot;</span>,<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;line&#x27;</span>,<br>      <span class="hljs-attr">data</span>:dataY1,<br>      <span class="hljs-attr">smooth</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">areaStyle</span>:&#123;&#125;<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;line2&quot;</span>,<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;line&quot;</span>,<br>      <span class="hljs-attr">data</span>:dataY2,<br>      <span class="hljs-attr">smooth</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">areaStyle</span>:&#123;&#125;<br>    &#125;<br>  ],<br>  <span class="hljs-comment">//图例</span><br>  <span class="hljs-attr">legend</span>:&#123;<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;grey&quot;</span>,<br>    <span class="hljs-attr">data</span>:[<span class="hljs-string">&quot;line1&quot;</span>,<span class="hljs-string">&#x27;line2&#x27;</span>],<br>    <span class="hljs-attr">textStyle</span>:&#123;<br>      <span class="hljs-attr">fontSize</span>:<span class="hljs-number">20</span>,<br>      <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">//提示框</span><br>  <span class="hljs-attr">tooltip</span>:&#123;<br>    <span class="hljs-attr">trigger</span>:<span class="hljs-string">&quot;axis&quot;</span>,<br>    <span class="hljs-attr">axisPointer</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;cross&quot;</span>,<br>      <span class="hljs-attr">label</span>:&#123;<br>        <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;grey&quot;</span>,<br>        <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>      &#125;<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>得到效果图如下：</p><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE1.png" class title="图1"><h2 id="ECharts-Axis配置项"><a href="#ECharts-Axis配置项" class="headerlink" title="ECharts Axis配置项"></a>ECharts Axis配置项</h2><p><font color="yellow">Axis常用配置项的汇总如下：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>string</code></td><td>坐标轴类型：’value’（数值轴）、’category’（类目轴）、’time’（时间轴）、’log’（对数轴）。<font color="yellow">横坐标通常是用’category’，纵坐标更多使用’value’</font>。</td></tr><tr><td><code>position</code></td><td><code>string</code></td><td>坐标轴的位置：’top’、’bottom’、’left’、’right’。</td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>坐标轴的名称。</td></tr><tr><td><code>nameLocation</code></td><td><code>string</code></td><td>坐标轴名称显示位置：’start’、’middle’、’end’。</td></tr><tr><td><code>nameTextStyle</code></td><td><code>Object</code></td><td>坐标轴名称的文字样式。</td></tr><tr><td><code>nameGap</code></td><td><code>number</code></td><td>坐标轴名称与轴线之间的距离。</td></tr><tr><td><code>nameRotate</code></td><td><code>number</code></td><td>坐标轴名字旋转角度。</td></tr><tr><td><code>inverse</code></td><td><code>boolean</code></td><td>是否是反向坐标轴。</td></tr><tr><td><code>boundaryGap</code></td><td><code>boolean</code>&#x2F;<code>Array</code></td><td>类目轴中类目之间的间距或数值轴的起始和结束位置。<font color="yellow">横坐标设置boundratGap为false，则图表紧贴y坐标轴。</font></td></tr><tr><td><code>min</code></td><td><code>number</code>&#x2F;<code>string</code>&#x2F;<code>Function</code></td><td>坐标轴刻度最小值。可以设置具体值，或设置为 ‘dataMin’。</td></tr><tr><td><code>max</code></td><td><code>number</code>&#x2F;<code>string</code>&#x2F;<code>Function</code></td><td>坐标轴刻度最大值。可以设置具体值，或设置为 ‘dataMax’。</td></tr><tr><td><code>scale</code></td><td><code>boolean</code></td><td>只在数值轴中（type: ‘value’）有效，是否是脱离 0 值比例。</td></tr><tr><td><code>splitNumber</code></td><td><code>number</code></td><td>坐标轴的分割段数。</td></tr><tr><td><code>minInterval</code></td><td><code>number</code></td><td>自动计算的坐标轴最小间隔大小。</td></tr><tr><td><code>maxInterval</code></td><td><code>number</code></td><td>自动计算的坐标轴最大间隔大小。</td></tr><tr><td><code>interval</code></td><td><code>number</code></td><td>强制设置坐标轴分割间隔。</td></tr><tr><td><code>logBase</code></td><td><code>number</code></td><td>对数轴的底数，只在对数轴中（type: ‘log’）有效。</td></tr><tr><td><code>silent</code></td><td><code>boolean</code></td><td>坐标轴是否静默。<font color="yellow">当设置为 <code>true</code> 时，该元素将不响应任何交互事件。</font></td></tr><tr><td><code>triggerEvent</code></td><td><code>boolean</code></td><td>坐标轴的标签是否触发鼠标事件。</td></tr><tr><td><code>axisLine</code></td><td><code>Object</code></td><td>坐标轴轴线的相关设置。</td></tr><tr><td><code>axisTick</code></td><td><code>Object</code></td><td>坐标轴刻度相关设置。</td></tr><tr><td><code>axisLabel</code></td><td><code>Object</code></td><td>坐标轴刻度标签的相关设置。</td></tr><tr><td><code>splitLine</code></td><td><code>Object</code></td><td>坐标轴在 grid 区域中的分隔线。</td></tr><tr><td><code>splitArea</code></td><td><code>Object</code></td><td>坐标轴在 grid 区域中的分隔区域，默认不显示。</td></tr><tr><td><code>data</code></td><td><code>Array</code></td><td>类目数据，在类目轴（type: ‘category’）中有效。</td></tr><tr><td><code>axisPointer</code></td><td><code>Object</code></td><td>坐标轴指示器配置项。</td></tr><tr><td><code>zlevel</code></td><td><code>number</code></td><td>组件的所有图形的 zlevel 值。</td></tr><tr><td><code>z</code></td><td><code>number</code></td><td>组件的所有图形的 z 值。</td></tr></tbody></table><h3 id="图片翻转"><a href="#图片翻转" class="headerlink" title="图片翻转"></a>图片翻转</h3><ul><li>配置项<code>inverse</code></li></ul><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE2.png" class title="图2"><p>我们修改上述代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">yAxis</span>:[<br>    &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>        <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>        <span class="hljs-attr">max</span>:<span class="hljs-number">2</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>        <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>        <span class="hljs-attr">max</span>:<span class="hljs-number">2</span>,<br>        <span class="hljs-attr">inverse</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//反向第二条坐标轴</span><br>    &#125;<br>],<br><span class="hljs-attr">series</span>:[<br>    &#123;...&#125;,<br>    &#123;...<br>    <span class="hljs-attr">yAxisIndex</span>:<span class="hljs-number">1</span>, <span class="hljs-comment">//将数据系列二绑定在第二条坐标轴，实现系列二反转。</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="坐标旋转"><a href="#坐标旋转" class="headerlink" title="坐标旋转"></a>坐标旋转</h3><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE3.png" class title="图3"><p><font color="yellow">只需互换xAxis和yAxis即可。</font></p><h3 id="分割段设置"><a href="#分割段设置" class="headerlink" title="分割段设置"></a>分割段设置</h3><ul><li>配置项：<code>splitLine</code>、<code>interval</code>、<code>splitnumber</code></li></ul><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE4.png" class title="图4"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">xAxis</span>:&#123;<br>    <span class="hljs-attr">splitLine</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">interval</span>:<span class="hljs-number">3</span>, <span class="hljs-comment">//设置两根分割段之间的间隔</span><br>        <span class="hljs-attr">spliteNumber</span>: <span class="hljs-number">4</span>,<span class="hljs-comment">//分割段数量，与interval可能发生冲突</span><br>        <span class="hljs-attr">lineStyle</span>:&#123; <span class="hljs-comment">//样式设计</span><br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>splitArea的用法和splitLine相似。</p><h3 id="坐标轴渲染"><a href="#坐标轴渲染" class="headerlink" title="坐标轴渲染"></a>坐标轴渲染</h3><p>配置项：<code>axisTick</code>、<code>axisLine</code>、<code>axisLabel</code>、<code>name</code>、<code>nameStyle</code>、<code>nameLocation</code></p><p>坐标轴的渲染包括坐标轴刻度线、坐标轴轴线、坐标轴轴标签以及坐标轴名字的渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">xAxis</span>:&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;横坐标&quot;</span>，<br>    <span class="hljs-attr">nameLocation</span>:<span class="hljs-string">&quot;middle&quot;</span> <span class="hljs-comment">//名字位置在中间</span><br>    <span class="hljs-attr">nameGap</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">//名字与轴标签的距离</span><br>    <span class="hljs-attr">nameRotate</span>:<span class="hljs-number">45</span>, <span class="hljs-comment">//名字旋转角度</span><br>    <span class="hljs-attr">nameStyle</span>:&#123;<br>        <span class="hljs-comment">//样式</span><br>        <span class="hljs-attr">padding</span>:<span class="hljs-number">20</span>,<br>    &#125;<br>    <span class="hljs-comment">//坐标轴刻度线。</span><br>    <span class="hljs-attr">axisTick</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">inside</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//标签是否向内部</span><br>        <span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度线长度</span><br>        <span class="hljs-attr">alignWithLabel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//刻度线是否需标签对齐</span><br>        <span class="hljs-attr">inverval</span>:<span class="hljs-string">&quot;auto&quot;</span>，<span class="hljs-comment">//刻度线分布</span><br>        <span class="hljs-attr">lineStyle</span>:&#123; <span class="hljs-comment">//样式设置</span><br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;yellow&quot;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//坐标轴轴线</span><br>    <span class="hljs-attr">axisLine</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">lineStyle</span>:&#123;<br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>, <br>        &#125;<br>        <span class="hljs-attr">symbol</span>:<span class="hljs-string">&quot;arrow&quot;</span> <span class="hljs-comment">//箭头</span><br>    &#125;<br>    <span class="hljs-comment">//坐标轴轴标签</span><br>    <span class="hljs-attr">axisLabel</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">interval</span>:<span class="hljs-string">&quot;auto&quot;</span>，<span class="hljs-comment">//标签分布。</span><br>        <span class="hljs-attr">textStyle</span>:&#123;<br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE5.png" class title="图5"><p>更加详细的配置项如下：</p><p><font color="yellow"><strong><code>axisTick</code> 配置项总结表：</strong></font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示坐标轴刻度。</td></tr><tr><td><code>alignWithLabel</code></td><td><code>boolean</code></td><td>刻度线和标签对齐。仅在类目轴中有效。</td></tr><tr><td><code>interval</code></td><td><code>string</code>&#x2F;<code>number</code>&#x2F;<code>Function</code></td><td>坐标轴刻度的显示间隔，默认为 ‘auto’。</td></tr><tr><td><code>inside</code></td><td><code>boolean</code></td><td>坐标轴刻度是否朝内。</td></tr><tr><td><code>length</code></td><td><code>number</code></td><td>坐标轴刻度的长度。</td></tr><tr><td><code>lineStyle</code></td><td><code>Object</code></td><td>坐标轴刻度的样式，包括颜色、宽度、类型等。</td></tr></tbody></table><p><font color="yellow"><strong><code>axisLine</code> 配置项总结表：</strong></font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示坐标轴轴线。</td></tr><tr><td><code>onZero</code></td><td><code>boolean</code></td><td>X 轴 Y 轴相交于 0 刻度。仅在双数值轴中有效。</td></tr><tr><td><code>onZeroAxisIndex</code></td><td><code>number</code></td><td>使用的另一个坐标轴的 axisIndex。仅在双数值轴中有效。</td></tr><tr><td><code>symbol</code></td><td><code>string</code>&#x2F;<code>Array</code></td><td>轴线两头的箭头。 <code>&#39;circle&#39;</code>：圆形；<code>&#39;rect&#39;</code>：矩形；<code>&#39;roundRect&#39;</code>：圆角矩形；<code>&#39;triangle&#39;</code>：三角形；<code>&#39;diamond&#39;</code>：菱形；<code>&#39;pin&#39;</code>：图钉形状；<code>&#39;arrow&#39;</code>：箭头形状；<code>&#39;path://...&#39;</code>：自定义路径</td></tr><tr><td><code>symbolSize</code></td><td><code>Array</code></td><td>轴线两头箭头的大小。</td></tr><tr><td><code>symbolOffset</code></td><td><code>Array</code></td><td>轴线两头箭头的偏移。</td></tr><tr><td><code>lineStyle</code></td><td><code>Object</code></td><td>坐标轴线的样式，包括颜色、宽度、类型等。</td></tr></tbody></table><p><font color="yellow"><strong><code>axisLabel</code> 配置项总结表：</strong></font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示坐标轴刻度标签。</td></tr><tr><td><code>interval</code></td><td><code>string</code>&#x2F;<code>number</code>&#x2F;<code>Function</code></td><td>坐标轴刻度标签的显示间隔，默认为 ‘auto’。</td></tr><tr><td><code>inside</code></td><td><code>boolean</code></td><td>坐标轴刻度标签是否朝内。</td></tr><tr><td><code>rotate</code></td><td><code>number</code></td><td>坐标轴刻度标签的旋转角度。</td></tr><tr><td><code>margin</code></td><td><code>number</code></td><td>刻度标签与轴线之间的距离。</td></tr><tr><td><code>formatter</code></td><td><code>string</code>&#x2F;<code>Function</code></td><td>刻度标签的内容格式器。</td></tr><tr><td><code>showMinLabel</code></td><td><code>boolean</code></td><td>是否显示最小刻度标签。</td></tr><tr><td><code>showMaxLabel</code></td><td><code>boolean</code></td><td>是否显示最大刻度标签。</td></tr><tr><td><code>color</code></td><td><code>string</code></td><td>刻度标签文字的颜色。</td></tr><tr><td><code>fontStyle</code></td><td><code>string</code></td><td>刻度标签文字的字体风格。</td></tr><tr><td><code>fontWeight</code></td><td><code>string</code></td><td>刻度标签文字的字体粗细。</td></tr><tr><td><code>fontFamily</code></td><td><code>string</code></td><td>刻度标签文字的字体系列。</td></tr><tr><td><code>fontSize</code></td><td><code>number</code></td><td>刻度标签文字的字体大小。</td></tr><tr><td><code>align</code></td><td><code>string</code></td><td>刻度标签文字水平对齐方式。</td></tr><tr><td><code>verticalAlign</code></td><td><code>string</code></td><td>刻度标签文字垂直对齐方式。</td></tr><tr><td><code>lineHeight</code></td><td><code>number</code></td><td>刻度标签文字的行高。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code>&#x2F;<code>Object</code></td><td>刻度标签背景色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>刻度标签边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>刻度标签边框宽度。</td></tr><tr><td><code>borderRadius</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>刻度标签边框圆角。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>刻度标签内边距。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>刻度标签文字的阴影颜色。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>刻度标签文字的阴影模糊度。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>刻度标签文字的阴影水平偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>刻度标签文字的阴影垂直偏移。</td></tr><tr><td><code>textBorderColor</code></td><td><code>string</code></td><td>刻度标签文字的描边颜色。</td></tr><tr><td><code>textBorderWidth</code></td><td><code>number</code></td><td>刻度标签文字的描边宽度。</td></tr><tr><td><code>textShadowColor</code></td><td><code>string</code></td><td>刻度标签文字的阴影颜色。</td></tr><tr><td><code>textShadowBlur</code></td><td><code>number</code></td><td>刻度标签文字的阴影模糊度。</td></tr><tr><td><code>textShadowOffsetX</code></td><td><code>number</code></td><td>刻度标签文字的阴影水平偏移。</td></tr><tr><td><code>textShadowOffsetY</code></td><td><code>number</code></td><td>刻度标签文字的阴影垂直偏移。</td></tr></tbody></table><p><strong><font color="yellow">注意点：</font></strong></p><ol><li>axisTick和axisLabel的<code>interval</code>用于显示标签和刻度线之间的间隔。<ul><li>axisLabel默认值为<code>auto</code>，系统根据标签名自动调整标签之间的间隔。</li><li>axisLabel值为0，默认显示所有的的标签，值为n，则每隔n个数据项显示一个标签。</li><li>axisLine默认值为<code>auto</code>，系统根据标签名自动调整刻度线之间的间隔。</li><li>axisLine值为0，默认显示和标签数量相同的刻度线，值为n，则每隔n个标签显示一个刻度线。</li></ul></li><li><font color="yellow">axisLabel的<code>interval</code>只适用于<code>category</code>类别轴，如果轴是<code>value</code>，数值是连续的，则<code>interval</code>不起作用</font>。标签的数量由分割线的数量决定。通过<code>splitLine</code>样式设置分割线数量。</li><li>axisLabel的样式配置可以直接在组件元素中配置，也可以在<code>textStyle</code>在配置。</li></ol><h2 id="ECharts-Grid配置项"><a href="#ECharts-Grid配置项" class="headerlink" title="ECharts Grid配置项"></a>ECharts Grid配置项</h2><p><code>grid</code>配置项在ECharts中用于设置图表的网络布局和样式，用于控制图表的坐标轴区域。一个容器可以放置多个网格<code>grid</code>，不同网站中可以绘制不同的坐标轴。</p><p><font color="yellow">Grid常用配置项的汇总如下：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示 grid 组件。</td></tr><tr><td><code>left</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器左侧的距离，可以是百分比或者像素值。</td></tr><tr><td><code>right</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器右侧的距离，可以是百分比或者像素值。</td></tr><tr><td><code>top</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器顶部的距离，可以是百分比或者像素值。</td></tr><tr><td><code>bottom</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器底部的距离，可以是百分比或者像素值。</td></tr><tr><td><code>containLabel</code></td><td><code>boolean</code></td><td>是否包含坐标轴标签在 grid 区域内。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code>&#x2F;<code>Object</code></td><td>grid 区域的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>grid 区域的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>grid 区域的边框宽度。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>grid 区域的阴影颜色。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>grid 区域的阴影模糊度。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>grid 区域阴影的水平偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>grid 区域阴影的垂直偏移。</td></tr><tr><td><code>height</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域的高度，可以是百分比或者像素值。</td></tr><tr><td><code>width</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域的宽度，可以是百分比或者像素值。</td></tr><tr><td><code>containLabel</code></td><td><code>boolean</code></td><td>是否使 grid 区域包含坐标轴标签，避免标签被截断。</td></tr><tr><td><code>opacity</code></td><td><code>number</code></td><td>grid 区域的透明度，取值范围 0~1。</td></tr></tbody></table><h3 id="多重网格"><a href="#多重网格" class="headerlink" title="多重网格"></a>多重网格</h3><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE6.png" class title="图6"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在文章开头代码的基础上进行修改。</span><br><span class="hljs-keyword">const</span> option=&#123;<br>    <span class="hljs-attr">grid</span>:[<br>        &#123;<br>            <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//初始化为false,</span><br>            <span class="hljs-attr">left</span>:<span class="hljs-string">&quot;5%&quot;</span>,<br>            <span class="hljs-attr">right</span>:<span class="hljs-string">&quot;5%&quot;</span>,<br>            <span class="hljs-attr">containLabel</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//包含了轴标签</span><br>            <span class="hljs-attr">height</span>:<span class="hljs-string">&quot;35%&quot;</span>, <span class="hljs-comment">//网络高度</span><br>            <span class="hljs-comment">//设置网络样式，前提是show为true.</span><br>            <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.7</span>, <span class="hljs-comment">//透明度</span><br>            <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;yellow&quot;</span>,<br>            <span class="hljs-attr">shadowBlur</span>: <span class="hljs-number">200</span>, <span class="hljs-comment">//阴影模糊程度</span><br>            <span class="hljs-attr">shadowColor</span>: <span class="hljs-string">&quot;yellow&quot;</span>,<br>            <span class="hljs-attr">shadomOffsetX</span>:<span class="hljs-number">0</span>, <span class="hljs-comment">//阴影偏移</span><br>            <span class="hljs-attr">shadomOffsetY</span>:<span class="hljs-number">0</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">//网络二</span><br>            <span class="hljs-attr">show</span>:<span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">left</span>:<span class="hljs-string">&quot;5%&quot;</span>,<br>            <span class="hljs-attr">right</span>:<span class="hljs-string">&quot;5%&quot;</span><br>            <span class="hljs-attr">containLabel</span>:<span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">top</span>:<span class="hljs-string">&quot;50%&quot;</span>,<br>            <span class="hljs-attr">height</span>:<span class="hljs-string">&quot;35%&quot;</span><br>        &#125;<br>    ],<br>    <span class="hljs-comment">//XY轴</span><br>  <span class="hljs-attr">xAxis</span>:[&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">data</span>:dataX,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">gridIndex</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">//绑定网络二</span><br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">data</span>:dataX,<br>    <span class="hljs-attr">position</span>:<span class="hljs-string">&quot;top&quot;</span>,<br>  &#125;<br>  ],<br>  <span class="hljs-attr">yAxis</span>:[&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>    <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>    <span class="hljs-attr">max</span>:<span class="hljs-number">1</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>      <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>      <span class="hljs-attr">max</span>:<span class="hljs-number">1</span>,<br>      <span class="hljs-attr">inverse</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//坐标反转</span><br>      <span class="hljs-attr">gridIndex</span>:<span class="hljs-number">1</span>, <span class="hljs-comment">//绑定网络二</span><br>    &#125;<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ECharts图表元素的位置调整"><a href="#ECharts图表元素的位置调整" class="headerlink" title="ECharts图表元素的位置调整"></a>ECharts图表元素的位置调整</h2><p>如<code>grid</code>的位置调整一样，<font color="yellow">ECharts大部分图表元素都是通过<code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code>四个配置项来调整组件元素在图表或者网络中的位置。</font>也就是元素上下左右的间距。</p><p>配置项的值类型有：</p><ul><li><code>number</code>：以像素为单位的绝对值。<code>top=20</code>即20px像素。</li><li><code>string</code>：父容器高度或者宽度的百分比。<code>top=&quot;20%&quot;</code>即相对于父容器宽度的20%大小。</li><li><code>auto</code>：自动计算位置，通常在响应式布局中使用。<code>top=&quot;auto&quot;</code>。</li><li><code>center</code>：将元素垂直居中（在某些配置中支持）。</li></ul><h2 id="ECharts-Label配置项"><a href="#ECharts-Label配置项" class="headerlink" title="ECharts Label配置项"></a>ECharts Label配置项</h2><p>ECharts很多元素都有是有标签或者说类似文本框属性，例如轴标签、legend标签、title标签，因此它们有很多通用的配置项。而在<code>series.label</code>和<code>axis.axisLabel</code>就有Label配置项，基本会涵盖所有的配置项。</p><p><font color="yellow">ECharts Label 配置项总结表</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示标签。</td></tr><tr><td><code>position</code></td><td><code>string</code></td><td>标签的位置，支持 <code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>、<code>inside</code>、<code>insideLeft</code>、<code>insideRight</code>、<code>insideTop</code>、<code>insideBottom</code>。<font color="yellow">在series中起作用</font>。</td></tr><tr><td><code>formatter</code></td><td><code>string</code>&#x2F;<code>Function</code></td><td>标签内容格式器，可以是字符串模板或者回调函数。</td></tr><tr><td><code>color</code></td><td><code>string</code></td><td>标签文字颜色。</td></tr><tr><td><code>fontStyle</code></td><td><code>string</code></td><td>标签文字风格，例如 <code>&#39;normal&#39;</code>、<code>&#39;italic&#39;</code>、<code>&#39;oblique&#39;</code>。</td></tr><tr><td><code>fontWeight</code></td><td><code>string</code></td><td>标签文字粗细，例如 <code>&#39;normal&#39;</code>、<code>&#39;bold&#39;</code>。</td></tr><tr><td><code>fontFamily</code></td><td><code>string</code></td><td>标签文字字体，例如 <code>&#39;sans-serif&#39;</code>、<code>&#39;serif&#39;</code>。</td></tr><tr><td><code>fontSize</code></td><td><code>number</code></td><td>标签文字大小。</td></tr><tr><td><code>lineHeight</code></td><td><code>number</code></td><td>标签文字行高。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code></td><td>标签的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>标签的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>标签的边框宽度。</td></tr><tr><td><code>borderRadius</code></td><td><code>number</code></td><td>标签的边框圆角。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>标签的内边距。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>标签的阴影颜色。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>标签的阴影模糊度。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>标签阴影的水平偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>标签阴影的垂直偏移。</td></tr></tbody></table><p>可以看到这些配置项几乎在<code>grid</code>中都存在，在后面我们会看到很多元素都具备这些配置项。</p><h2 id="ECharts-Legend配置项"><a href="#ECharts-Legend配置项" class="headerlink" title="ECharts Legend配置项"></a>ECharts Legend配置项</h2><p><font color="yellow">Legend 常用属性总结表：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示图例，默认为 <code>true</code>。</td></tr><tr><td><code>type</code></td><td><code>string</code></td><td>图例类型，可选 <code>&#39;plain&#39;</code>（普通图例）或 <code>&#39;scroll&#39;</code>（可滚动图例）。</td></tr><tr><td><code>data</code></td><td><code>Array</code></td><td>图例的数据项，可以是字符串数组或对象数组，每个字符串或对象代表一个系列。</td></tr><tr><td><code>selected</code></td><td><code>Object</code></td><td>图例选中状态，用于控制哪些系列被选中（显示）或未选中（隐藏）。</td></tr><tr><td><code>orient</code></td><td><code>string</code></td><td>图例的布局朝向，可选 <code>&#39;horizontal&#39;</code>（水平）或 <code>&#39;vertical&#39;</code>（垂直）。</td></tr><tr><td><code>left</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器左侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>right</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器右侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>top</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器上侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>bottom</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器下侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>align</code></td><td><code>string</code></td><td>图例标记和文本的对齐方式，可选 <code>&#39;auto&#39;</code>，<code>&#39;left&#39;</code>，<code>&#39;right&#39;</code>。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>图例的内边距，单位为像素。可以是单个值或数组（分别表示上、右、下、左的内边距）。</td></tr><tr><td><code>itemGap</code></td><td><code>number</code></td><td>图例项之间的间隔，单位为像素。</td></tr><tr><td><code>itemWidth</code></td><td><code>number</code></td><td>图例标记的宽度，单位为像素。</td></tr><tr><td><code>itemHeight</code></td><td><code>number</code></td><td>图例标记的高度，单位为像素。</td></tr><tr><td><code>textStyle</code></td><td><code>Object</code></td><td>图例文本的样式，包括颜色、字体、大小等。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code></td><td>图例的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>图例的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>图例的边框线宽。</td></tr><tr><td><code>borderRadius</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>图例的边框圆角，可以是单个值或数组（分别表示左上、右上、右下、左下的圆角半径）。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>图例的阴影模糊大小。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>图例的阴影颜色。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>图例的阴影 X 偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>图例的阴影 Y 偏移。</td></tr><tr><td><code>formatter</code></td><td><code>Function</code>&#x2F;<code>string</code></td><td>用于格式化图例文本，支持字符串模板和回调函数。</td></tr><tr><td><code>selectedMode</code></td><td><code>boolean</code>&#x2F;<code>string</code></td><td>图例选择的模式，默认为 <code>true</code>。可选 <code>&#39;single&#39;</code> 或 <code>&#39;multiple&#39;</code>。</td></tr><tr><td><code>inactiveColor</code></td><td><code>string</code></td><td>图例关闭时的颜色。</td></tr><tr><td><code>tooltip</code></td><td><code>Object</code></td><td>图例的 tooltip 配置项。</td></tr></tbody></table><p>大部分配置项和<code>grid</code>是相似的。</p><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE7.png" class title="图7"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在文章开头代码的基础上进行修改。</span><br><span class="hljs-comment">//首先将数据系列复制至5份。</span><br><span class="hljs-keyword">const</span> option = &#123;<br>  <span class="hljs-comment">//图例</span><br>  <span class="hljs-attr">legend</span>:&#123;<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;grey&quot;</span>,<br>    <span class="hljs-attr">textStyle</span>:&#123;<br>      <span class="hljs-attr">fontSize</span>:<span class="hljs-number">20</span>,<br>      <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>    &#125;,<br>    <br>    <span class="hljs-comment">//图例的配置项</span><br>    <span class="hljs-attr">orient</span>:<span class="hljs-string">&quot;horizontal&quot;</span>, <span class="hljs-comment">//水平或者垂直分布</span><br>    <span class="hljs-attr">padding</span>:<span class="hljs-number">10</span>,<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-comment">//滚动图例</span><br>    <span class="hljs-attr">left</span>:<span class="hljs-string">&quot;70%&quot;</span>,<br>    <span class="hljs-attr">align</span>:<span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-comment">//对齐方式</span><br>    <span class="hljs-attr">itemWidth</span>:<span class="hljs-number">50</span>, <span class="hljs-comment">//图例标记的样式修改。</span><br>    <span class="hljs-attr">itemHeight</span>:<span class="hljs-number">30</span>,<br>    <span class="hljs-attr">selected</span>:&#123; <span class="hljs-comment">//初始化哪些系列被选中。 </span><br>      <span class="hljs-string">&quot;line1&quot;</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&quot;line2&quot;</span>:<span class="hljs-literal">false</span>,<br>      <span class="hljs-string">&quot;line3&quot;</span>:<span class="hljs-literal">false</span>,<br>      <span class="hljs-string">&quot;line4&quot;</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&quot;line5&quot;</span>:<span class="hljs-literal">false</span>,<br>    &#125;,<br>    <span class="hljs-attr">selectedMode</span>:<span class="hljs-string">&quot;single&quot;</span>, <span class="hljs-comment">//single表示最多只能有一个被选中。</span><br>    <span class="hljs-attr">tooltip</span>:&#123; <span class="hljs-comment">//图例小型的提示框</span><br>      <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ECharts-Tooltip配置项"><a href="#ECharts-Tooltip配置项" class="headerlink" title="ECharts Tooltip配置项"></a>ECharts Tooltip配置项</h2><p><font color="yellow">ECharts Tooltip 配置项总结表：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示 tooltip。</td></tr><tr><td><code>trigger</code></td><td><code>string</code></td><td>触发类型，支持 ‘item’（数据项触发）、’axis’（坐标轴触发）、’none’（不显示）。</td></tr><tr><td><code>triggerOn</code></td><td><code>string</code></td><td>触发条件，支持 ‘mousemove’（鼠标移动）、’click’（点击）、’mousemove</td></tr><tr><td><code>axisPointer</code></td><td><code>Object</code></td><td>坐标轴指示器配置项。</td></tr><tr><td><code>formatter</code></td><td><code>string</code>&#x2F;<code>Function</code></td><td>提示框内容格式器。可以是字符串模板或者回调函数。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code>&#x2F;<code>Object</code></td><td>提示框的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>提示框的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>提示框的边框宽度。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>提示框的内边距。</td></tr><tr><td><code>textStyle</code></td><td><code>Object</code></td><td>提示框的文字样式配置项，包括颜色、字体大小、字体粗细等。</td></tr><tr><td><code>extraCssText</code></td><td><code>string</code></td><td>自定义的 CSS 样式，支持全局 CSS 属性。</td></tr><tr><td><code>transitionDuration</code></td><td><code>number</code></td><td>动画过渡时间，单位为秒。</td></tr><tr><td><code>confine</code></td><td><code>boolean</code></td><td>是否将提示框限制在图表区域内。</td></tr><tr><td><code>enterable</code></td><td><code>boolean</code></td><td>是否允许鼠标进入 tooltip 区域。</td></tr><tr><td><code>showContent</code></td><td><code>boolean</code></td><td>是否显示 tooltip 内容。</td></tr></tbody></table><p>根据<a href="https://cxdlogver.github.io/2024/07/22/2024-07-22/"><strong>ECharts使用（1)</strong></a>中的第一个例子，我们只要理解<code>tooltip</code>提示框和<code>axisPointer</code>轴标签指示器在图表中位置，就很好理解配置项的内容。</p><p><code>tooltip</code>是一个指示框，用于显示坐标轴某一个点的坐标信息。根据<code>trigger</code>有两种触发模式。</p><ul><li><code>item</code>数据项触发：当鼠标指到数据系列的数据项时，才出现提示框，并给出数据点信息。</li><li><code>axis</code>坐标轴触发：当鼠标指在坐标轴的任意一个位置时，都会出现提示框，给出与鼠标当前位置最近的所有数据项信息。</li></ul><p><code>triggerOn</code>触发条件，<code>click</code>表示只有点击时才出现提示框，<code>mousemove</code>鼠标移到时就出现提示框。默认是<code>mousemove</code>。</p><p><code>tooltip</code>是一个文本框，因此相关的渲染以及<code>textStyle</code>配置都有，用于样式的配置。</p><p><code>axisPointer</code>是呈现在坐标轴上的轴标签指示器，声明它则<code>tooltip</code>默认<code>trigger:axis</code>。它作为标签，有<code>label</code>配置，在<code>label</code>中有标签的相关的渲染以及<code>textStyle</code>配置，和legend等元素类似。因此渲染不再做介绍。</p><p><code>axisPointer</code>的触发类型<code>type</code>有三种：</p><ul><li><code>line</code>：只有一条垂直于X轴的线。</li><li><code>cross</code>：有两条相互垂直的线。</li><li><code>shadow</code>:用一块阴影矩形代替垂直于X轴的线。</li></ul><img src="/2024/07/23/%E5%85%B6%E4%BB%96/2024-07-23/%E5%9B%BE8.png" class title="图8"><p><font color="yellow">对应的有<code>crossStyle</code>、<code>lineStyle</code>、<code>shadowStyle</code>配置项进行渲染。</font></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>EChars</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
