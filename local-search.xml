<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>8.前端页面跳转</title>
    <link href="/2025/12/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    <url>/2025/12/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/8-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是<code>SPA</code>?</li><li><code>Hash</code>跳转和<code>History</code>跳转的区别是什么？</li><li>浏览器 History 与事件的总时间?</li></ol><span id="more"></span><h2 id="前端页面跳转"><a href="#前端页面跳转" class="headerlink" title="前端页面跳转"></a>前端页面跳转</h2><h3 id="1-SPA（单页应用）"><a href="#1-SPA（单页应用）" class="headerlink" title="1. SPA（单页应用）"></a>1. SPA（单页应用）</h3><p>SPA 的核心思想不是“页面只有一页”，而是：</p><blockquote><p><strong>整个应用生命周期中，浏览器只加载一次 HTML 文档，之后的“页面切换”不再由浏览器完成，而是由前端 JavaScript 接管。</strong></p></blockquote><p><strong>应用周期：</strong>从浏览器首次加载并执行应用入口代码开始，到当前文档被销毁为止，前端应用在同一 HTML 文档内持续运行的整个时间段。</p><p>只要发生<strong>文档级导航</strong>，应用周期立即结束：</p><ul><li>刷新页面（F5）</li><li>地址栏输入新 URL 回车</li><li>跳转到另一个站点</li><li>当前 tab 关闭</li></ul><p>结束意味着：</p><ul><li>HTML 被销毁</li><li>JS 上下文清空</li><li>所有 Router &#x2F; Store &#x2F; 组件全部消失</li></ul><hr><p><strong>一、先从“传统网页”说起</strong></p><p>在传统 Web（也叫 MPA，多页应用）中：</p><ol><li>每次点击链接或提交表单</li><li>浏览器都会发起一次新的 HTTP 请求</li><li>服务器返回一个新的 HTML 文档</li><li>浏览器销毁旧页面，重新解析 HTML、CSS、JS</li><li>页面重新渲染</li></ol><p>也就是说：</p><ul><li><strong>页面跳转 &#x3D; 浏览器行为</strong></li><li><strong>页面内容 &#x3D; 服务器渲染结果</strong></li><li>每一次跳转，都是一次“文档级刷新”</li></ul><p><strong>二、SPA 的根本改变是什么</strong></p><p>SPA 把这套逻辑彻底反过来了。</p><p>在 SPA 中：</p><ol><li>浏览器第一次访问站点</li><li>服务器返回 <strong>一个基础 HTML（通常是 index.html）</strong></li><li>浏览器加载并执行大量 JS</li><li>之后的所有“页面切换”：<ul><li><strong>不再请求新的 HTML</strong></li><li><strong>不刷新页面</strong></li><li>只通过 JS 改变视图内容</li></ul></li></ol><p>也就是说：</p><ul><li>浏览器只负责 <strong>加载一次壳</strong></li><li>前端 JS 负责 <strong>整个应用运行期的页面管理</strong></li></ul><p><strong>三、为什么叫“单页”，但却能有很多页面</strong></p><p>SPA 中常见的现象是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">/home<br>/user/123<br>/settings<br></code></pre></td></tr></table></figure><p>看起来像多个页面，但实际上：</p><ul><li>这些 URL <strong>并不对应多个 HTML 文件</strong></li><li>它们只是：<ul><li>同一个 HTML</li><li>在不同 URL 状态下</li><li>渲染不同的组件树</li></ul></li></ul><p>“单页”指的是：</p><blockquote><p><strong>HTML 文档层面是单一的</strong></p><p>而不是“视觉上只能有一个界面”</p></blockquote><p><strong>四、SPA 中“页面切换”到底发生了什么</strong></p><p>以 Vue SPA 为例，一次路由切换本质上是：</p><ol><li>URL 发生变化（hash 或 history）</li><li>Vue Router 监听到变化</li><li>Router 解析当前路径</li><li>匹配到某个路由规则</li><li>决定哪些组件要挂载 &#x2F; 卸载</li><li>Vue 更新虚拟 DOM</li><li>局部 DOM 发生变化</li></ol><p><strong>整个过程没有浏览器级刷新</strong>。</p><p><strong>五、SPA 必须依赖哪些关键能力</strong></p><p>SPA 并不是凭空出现的，它依赖三类浏览器能力：</p><ol><li>JavaScript 长时间运行</li></ol><p>JS 不再是“点一下执行一下”，而是：</p><ul><li>应用启动即常驻</li><li>控制状态、路由、渲染、交互</li></ul><ol start="2"><li>浏览器 URL 可被“劫持解释”</li></ol><p>浏览器允许：</p><ul><li>hash 不触发刷新</li><li>History API 修改地址栏不刷新</li></ul><p>这使得：</p><ul><li>URL 可以作为“状态表达”</li><li>但页面不会重载</li></ul><ol start="3"><li>DOM 可被 JS 动态重构</li></ol><p>SPA 的页面不是 HTML 写死的，而是：</p><ul><li>数据 → 状态 → 组件 → DOM</li><li>DOM 是 JS 计算出来的结果</li></ul><h3 id="2-Hash和History"><a href="#2-Hash和History" class="headerlink" title="2. Hash和History"></a>2. <code>Hash</code>和<code>History</code></h3><p><strong>从浏览器拿到 URL 开始说起:</strong></p><p>无论你输入的是：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">https:</span>//example.com/<span class="hljs-meta">#/user</span><br></code></pre></td></tr></table></figure><p>还是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//example.com/user</span><br></code></pre></td></tr></table></figure><p>浏览器做的第一件事都是<strong>解析 URL</strong>，拆成固定的结构：</p><ul><li>scheme（协议）</li><li>host（域名）</li><li>port（端口）</li><li>path</li><li>query</li><li>fragment（也就是 hash）</li></ul><p>这是标准化行为，不依赖前端框架。</p><p>接下来浏览器要做一个非常关键的判断：</p><blockquote><p><strong>“这次 URL 变化，是否需要重新请求文档？”</strong></p></blockquote><p>这个判断，几乎完全由 <strong>path &#x2F; query &#x2F; fragment 是否变化</strong> 决定。</p><hr><p><strong>为什么 hash 永远不会触发请求:</strong></p><p>浏览器在网络层有一个硬性规则：</p><blockquote><p><strong>fragment 不参与 HTTP 请求</strong></p></blockquote><p>也就是说，URL 在真正发往服务器之前，浏览器会直接把 <code>#</code> 后面的内容丢弃。</p><p>例如你访问：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/app/</span><span class="hljs-comment">#/user?tab=1</span><br></code></pre></td></tr></table></figure><p>浏览器在网络层看到的是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/app/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br></code></pre></td></tr></table></figure><p>服务器永远不知道你写了 <code>#/user?tab=1</code>。</p><p>这不是 Vue Router 的设计，而是 <strong>HTTP + URL 规范</strong>。</p><hr><p><strong>hash 变化为什么不刷新页面</strong></p><p>当浏览器发现：</p><ul><li>scheme 没变</li><li>host 没变</li><li>path 没变</li><li>query 没变</li><li><strong>只变了 fragment</strong></li></ul><p>浏览器会把这次跳转判定为：</p><blockquote><p><strong>同一文档内的导航（same-document navigation）</strong></p></blockquote><p>同文档导航意味着：</p><ul><li>不重新请求 HTML</li><li>不重新解析 DOM</li><li>不重新执行 JS</li><li>仅更新地址栏</li><li>更新历史记录</li></ul><p>这是 hash 能被 SPA 利用的核心前提。</p><hr><p><strong>浏览器对 hash 的“原生职责”</strong></p><p>在 SPA 出现之前，hash 就已经存在了，它本来就有三层语义。</p><p>第一层语义是<strong>文档锚点</strong>。<br> 如果 hash 对应一个 DOM 元素的 <code>id</code> 或 <code>name</code>，浏览器会自动滚动到该位置。这是 HTML 规范级行为，不需要 JS 参与。</p><p>第二层语义是<strong>状态标记</strong>。<br> hash 的变化不会触发请求，但会反映在地址栏中，因此它天然适合作为“客户端状态”的外显形式。SPA 正是利用这一点，把 <code>#/user/123</code> 当作“当前视图状态”。</p><p>第三层语义是<strong>历史记录节点</strong>。<br> 即使只是改 hash，浏览器也会新增一条 history entry，因此 back &#x2F; forward 都是可用的。</p><p>当 fragment 变化时，浏览器会在内部完成三件事：</p><ol><li>更新地址栏</li><li>写入 history</li><li>在当前执行栈清空后，派发 <code>hashchange</code> 事件</li></ol><p>Vue Router 的 hash 模式，本质上就是：</p><ul><li>修改 <code>location.hash</code></li><li>监听 <code>hashchange</code></li><li>根据新的 hash 做路由匹配</li><li>更新组件树</li></ul><p>Router 并没有“控制浏览器”，只是<strong>利用浏览器已经定义好的行为</strong>。</p><hr><p><strong>History 模式的本质完全不同</strong></p><p>History 模式下，URL 变化的是 <strong>path &#x2F; query</strong>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>example.com<span class="hljs-regexp">/user/</span><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>在浏览器看来，这是一次<strong>真正的资源路径变化</strong>。</p><p>因此如果你直接刷新页面，浏览器一定会发请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/user/123</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br></code></pre></td></tr></table></figure><p>如果服务器没有对应路由，就一定会 404。</p><p>这也是为什么 History 模式必须有“服务器兜底”。服务器兜底的核心逻辑不是“帮前端跳转”，而是：</p><blockquote><p><strong>无论请求什么路径，只要是前端路由，都返回同一个 index.html</strong></p></blockquote><p>例如 Nginx：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>  <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样浏览器在访问 <code>/user/123</code> 时：</p><ul><li>URL 不变</li><li>实际拿到的是 index.html</li><li>前端 JS 启动后，再根据 URL 决定渲染什么组件</li></ul><hr><p><strong>Vue Router 在 history 模式下到底做了什么</strong></p><p>当页面首次加载时，流程是这样的：</p><ol><li>浏览器请求 <code>/user/123</code></li><li>服务器返回 index.html</li><li>浏览器解析 HTML，加载 JS</li><li>Vue 应用启动</li><li>Vue Router 读取当前浏览器地址：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">location</span>.pathname // &quot;/user/123&quot;<br><span class="hljs-keyword">location</span>.<span class="hljs-keyword">search</span>   // &quot;&quot;<br><span class="hljs-keyword">location</span>.hash     // &quot;&quot;<br></code></pre></td></tr></table></figure><ol><li>Router 把 pathname 当作“当前路由”</li><li>做路由匹配</li><li><code>&lt;router-view&gt;</code> 渲染对应组件</li></ol><p>注意一个关键点：</p><blockquote><p><strong>history 模式下，Router 并不会“跳转”</strong></p><p>它只是“读取当前 URL，然后解释它”</p></blockquote><p>在页面已经加载完成之后，Vue Router 切换路由时会调用：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">history.pushState(<span class="hljs-keyword">state</span>, &#x27;&#x27;, &#x27;/<span class="hljs-keyword">user</span>/<span class="hljs-number">456</span>&#x27;)<br></code></pre></td></tr></table></figure><p>浏览器对 pushState 的规则是：</p><ul><li>修改地址栏</li><li>写入 history</li><li><strong>不发请求</strong></li><li><strong>不刷新页面</strong></li><li>只在 back &#x2F; forward 时触发 <code>popstate</code></li></ul><p>Router 正是通过监听 <code>popstate</code>，来处理浏览器前进 &#x2F; 后退。</p><h3 id="3-浏览器-History-与事件"><a href="#3-浏览器-History-与事件" class="headerlink" title="3. 浏览器 History 与事件"></a>3. 浏览器 History 与事件</h3><table><thead><tr><th>行为</th><th>URL 是否改变</th><th>是否写入 history</th><th>是否触发 <code>hashchange</code></th><th>是否触发 <code>popstate</code></th><th>是否发请求</th></tr></thead><tbody><tr><td><code>location.hash = &#39;#a&#39;</code></td><td>是（hash）</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>点击 <code>&lt;a href=&quot;#a&quot;&gt;</code></td><td>是（hash）</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>hash 导致浏览器后退</td><td>是（hash）</td><td>指针切换</td><td>是</td><td>否</td><td>否</td></tr><tr><td><code>history.pushState()</code></td><td>是（path&#x2F;query）</td><td>是</td><td>否</td><td>否</td><td>否</td></tr><tr><td><code>history.replaceState()</code></td><td>是（path&#x2F;query）</td><td>是（替换）</td><td>否</td><td>否</td><td>否</td></tr><tr><td>浏览器后退 &#x2F; 前进</td><td>是</td><td>指针切换</td><td>视情况</td><td>是</td><td>否</td></tr><tr><td><code>history.back()</code></td><td>是</td><td>指针切换</td><td>视情况</td><td>是</td><td>否</td></tr><tr><td>地址栏回车</td><td>是</td><td>新导航</td><td>否</td><td>否</td><td>是</td></tr><tr><td>刷新页面</td><td>否</td><td>不变</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><p><strong>为什么 hash 会写 history，但不触发 popstate</strong></p><p>hash 的行为本质</p><p>当你修改 hash 时，浏览器做的是：</p><ol><li>在当前 history entry <strong>后面新增一个 entry</strong></li><li>当前指针移动到新 entry</li><li>触发 <code>hashchange</code></li></ol><p>这一步<strong>不是在“激活已有 entry”</strong>，而是在<strong>创建新 entry</strong>。</p><p>popstate 的唯一触发条件</p><blockquote><p><strong>popstate 只在“激活已有 history entry”时触发</strong></p></blockquote><p>也就是：</p><ul><li>从 entry C → 回到 entry B</li><li>或从 entry B → 前进到 entry C</li></ul><p>而不是“新建 entry”。</p><hr><p>为什么 hash 后退也不触发 popstate</p><p>即便是：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">/#a → /#b → /#c<br></code></pre></td></tr></table></figure><p>后退到 <code>/#b</code>：</p><ul><li>浏览器认为：这是 <strong>hash 导航体系</strong></li><li>事件仍然归类给 <code>hashchange</code></li><li><strong>popstate 仍然不触发</strong></li></ul><p>这是规范中的<strong>刻意分工</strong>，不是 bug。</p><hr><p>pushState 为什么“什么都不触发”</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">history</span><span class="hljs-selector-class">.pushState</span>(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/user/1&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>不触发 <code>popstate</code></li><li>不触发 <code>hashchange</code></li><li>不刷新页面</li><li>只改 URL + history</li></ul><p>这就是为什么：</p><p><strong>Router 在调用 pushState 前，必须自己先更新内部状态</strong></p><hr><p><strong>浏览器后退时，事件是怎么分流的</strong></p><p>情况 A：history 模式（path&#x2F;query 变化）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/user/</span><span class="hljs-number">1</span> → <span class="hljs-regexp">/user/</span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>后退：</p><ul><li>激活已有 history entry</li><li>触发 <code>popstate</code></li><li>Router 监听它，同步状态</li></ul><p>情况 B：hash 模式</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">/#a → /#b → /#c<br></code></pre></td></tr></table></figure><p>后退：</p><ul><li>hash 变化</li><li>触发 <code>hashchange</code></li><li><strong>不触发 popstate</strong></li></ul><p>Router hash 模式监听的是 <code>hashchange</code>，不是 <code>popstate</code>。</p><hr><p>直接记下面这四条：</p><ol><li><strong>hash 变化：写 history，永远走 <code>hashchange</code></strong></li><li><strong>pushState：写 history，但不触发任何事件</strong></li><li><strong>popstate：只在激活已有 history entry 时触发</strong></li><li><strong>事件不是“history 改了就触发”，而是“谁改的，走谁的事件”</strong></li></ol><p>映射回 Vue Router</p><table><thead><tr><th>Router 模式</th><th>路由状态放哪</th><th>监听事件</th><th>触发场景</th></tr></thead><tbody><tr><td>hash</td><td>fragment</td><td><code>hashchange</code></td><td>hash 改变 &#x2F; hash 后退</td></tr><tr><td>history</td><td>history entry</td><td><code>popstate</code></td><td>浏览器前进 &#x2F; 后退</td></tr></tbody></table><p>而在 <strong><code>router.push()</code> &#x2F; <code>router.replace()</code></strong> 时：</p><ul><li><strong>两种模式都不靠浏览器事件</strong></li><li>都是 Router <strong>主动更新内部响应式状态</strong></li><li>事件只用于“用户绕过 Router 的行为”</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.前端事件机制（event）</title>
    <link href="/2025/12/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/7-%E5%89%8D%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88event%EF%BC%89/"/>
    <url>/2025/12/24/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/7-%E5%89%8D%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88event%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ol><li>如何描述JavaScript DOM？</li><li>如何描述JavaScript的事件？</li><li>JS事件绑定方式有哪些，事件对象是什么，它的常用属性有哪些？</li><li>如何理解事件冒泡和事件委托？</li><li>如何自定义一个JS事件？</li><li>如何描述Vue的事件监听机制？</li></ol><span id="more"></span><h2 id="前端的事件机制（event"><a href="#前端的事件机制（event" class="headerlink" title="前端的事件机制（event)"></a>前端的事件机制（event)</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#JavaScript-DOM">JavaScript DOM &#x2F; event</a></p></blockquote><h3 id="1-JavaScript-DOM"><a href="#1-JavaScript-DOM" class="headerlink" title="1. JavaScript DOM"></a>1. JavaScript DOM</h3><p>DOM（Document Object Model，文档对象模型）是 <strong>Web API 的一部分</strong>，用于将 HTML 页面以一种<strong>树形结构</strong>的方式抽象成对象模型。简单来说，DOM 会把整个页面结构“对象化”，页面中的<strong>标签、文本、注释等都会被表示为节点（Node）</strong>，共同组成一棵 DOM 树。</p><p>在 DOM 中，**<code>document</code> 对象表示整个页面**，它是 JavaScript 访问和操作页面的入口。浏览器会将 HTML 文档解析后，封装成一个 <code>document</code> 对象，通过它可以获取页面中的任意节点，同时也可以访问页面的 URL、域名等信息。</p><p>通过 <code>document</code> 对象，可以使用多种方式获取页面中的元素节点，例如：</p><ul><li><code>getElementById</code></li><li><code>getElementsByClassName</code></li><li><code>getElementsByTagName</code></li><li><code>querySelector</code> &#x2F; <code>querySelectorAll</code></li></ul><p>这些方法最终都会返回<strong>一个节点或节点集合（元素对象）</strong>。</p><p>每一个元素对象在 DOM 树中都对应一个节点，它既是树结构中的一个成员，也可以作为操作起点，对与之相关的其他节点进行操作。例如，可以获取其父节点、子节点、兄弟节点，也可以在 DOM 树中插入新节点或删除已有节点。</p><p>除了结构操作之外，DOM 还支持对节点内容和表现形式的修改，包括但不限于：</p><ul><li>修改文本内容</li><li>修改属性</li><li>修改样式</li><li>动态增删节点</li></ul><p>其中，<strong>事件机制是 DOM 设计的核心功能之一</strong>。DOM 的设计初衷就是让网页能够与用户产生动态交互，而这种交互正是通过事件系统实现的。通过为元素绑定事件监听器，JavaScript 可以在用户点击、输入、滚动等操作发生时执行相应的逻辑，从而实现页面的动态行为。</p><h3 id="2-JavaScript-Event"><a href="#2-JavaScript-Event" class="headerlink" title="2. JavaScript Event"></a>2. JavaScript Event</h3><p>在 JavaScript 中，事件通过<strong>绑定回调函数</strong>来处理用户的各种操作。当用户在页面上进行点击、输入、移动鼠标等行为时，浏览器会触发相应的事件；一旦事件被触发，与之绑定的<strong>事件监听器</strong>就会调用对应的<strong>回调函数</strong>。因此，事件回调函数也常被称为<strong>事件处理函数或事件响应函数</strong>。</p><h4 id="【事件的绑定方式】"><a href="#【事件的绑定方式】" class="headerlink" title="【事件的绑定方式】"></a>【事件的绑定方式】</h4><p>JavaScript 中常见的事件绑定方式主要有三种：</p><ol><li><p><strong>通过 HTML 标签的事件属性</strong>（不推荐）</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;handleClick()&quot;</span>&gt;点击&lt;/<span class="hljs-keyword">button</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>通过元素对象的事件属性</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">element.onclick</span> = function () &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>通过 <code>addEventListener</code> 绑定事件监听器（推荐）</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">element.addEventListener(<span class="hljs-symbol">&#x27;click</span>&#x27;, <span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;&#125;);<br></code></pre></td></tr></table></figure></li></ol><p>其中，<code>addEventListener</code> 是最灵活、最规范的方式，支持多个监听器、事件捕获与冒泡控制。</p><h4 id="【事件对象（Event-Object）】"><a href="#【事件对象（Event-Object）】" class="headerlink" title="【事件对象（Event Object）】"></a>【事件对象（Event Object）】</h4><p>当事件触发时，浏览器会自动向事件回调函数传入一个参数，这个参数就是<strong>事件对象（event）</strong>。事件对象中包含了与当前事件相关的各种信息。</p><p><code>Event</code> 是所有事件对象的基类，在此基础上派生出多种具体事件类型，例如：</p><ul><li><code>MouseEvent</code>：处理鼠标事件（点击、移动、坐标等）</li><li><code>KeyboardEvent</code>：处理键盘事件（按键、键值等）</li><li><code>InputEvent</code>：处理输入相关事件</li></ul><p>常用的事件对象属性包括：</p><ul><li><code>event.type</code>：事件类型</li><li><code>event.target</code>：触发事件的元素</li><li><code>event.currentTarget</code>：当前绑定事件的元素</li><li><code>event.bubbles</code>：是否支持冒泡</li><li><code>event.cancelable</code>：是否可以取消默认行为</li><li><code>event.timeStamp</code>：事件发生的时间</li></ul><h4 id="【事件传播机制】"><a href="#【事件传播机制】" class="headerlink" title="【事件传播机制】"></a>【事件传播机制】</h4><p>要理解事件冒泡和事件委托，首先需要了解<strong>事件传播的三个阶段</strong>：</p><ol><li><strong>捕获阶段</strong><br>事件从 <code>window</code> 开始，沿着 DOM 树向下传播，直到目标元素。在这一阶段，默认情况下不会触发事件监听器。</li><li><strong>目标阶段</strong><br>事件到达目标元素，在目标元素上触发对应的事件监听器。</li><li><strong>冒泡阶段</strong><br>事件从目标元素开始，沿着 DOM 树向上传播，直到 <code>document</code>，依次触发祖先元素上绑定的事件监听器（如果存在）。</li></ol><p>这是“已确定 target 的情况下”才存在的传播路径，</p><h4 id="【事件冒泡与事件委托】"><a href="#【事件冒泡与事件委托】" class="headerlink" title="【事件冒泡与事件委托】"></a>【事件冒泡与事件委托】</h4><p>事件冒泡的一个重要作用是实现<strong>事件委托</strong>。</p><p>事件委托的核心思想是：</p><blockquote><p>如果父元素和其多个子元素需要处理同一类事件，可以只在父元素上绑定一次事件监听器，利用事件冒泡统一处理。</p></blockquote><p>例如，在一个包含多个子元素的大容器中，如果希望监听鼠标移动事件：</p><ul><li>鼠标移动时，事件会先在目标子元素上触发</li><li>随后通过冒泡传播到父元素</li><li>父元素即可统一处理该事件</li></ul><p>这样做的好处是：</p><ul><li>不需要为每个子元素单独绑定事件</li><li>减少代码量</li><li>降低逻辑复杂度</li><li><strong>对动态新增的子元素同样有效</strong></li></ul><p>当然，并不是所有事件都适合冒泡。如果某些事件<strong>不希望被祖先元素接收到</strong>，可以通过关闭冒泡或阻止传播来控制。</p><h3 id="3-自定义一个JS事件"><a href="#3-自定义一个JS事件" class="headerlink" title="3. 自定义一个JS事件"></a>3. 自定义一个JS事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;outer&quot;</span> style=<span class="hljs-string">&quot;padding:20px;border:2px solid #999;&quot;</span>&gt;<br>  outer<br>  &lt;div id=<span class="hljs-string">&quot;inner&quot;</span> style=<span class="hljs-string">&quot;margin-top:10px;padding:20px;border:2px solid #666;&quot;</span>&gt;<br>    inner<br>    &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;dispatch&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> outer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;outer&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> inner = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;inner&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 打印工具：你能一眼看到 target/currentTarget 以及处于哪个阶段</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">tag</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> phaseMap = &#123; <span class="hljs-number">1</span>: <span class="hljs-string">&quot;capture&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;bubble&quot;</span> &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-string">`[<span class="hljs-subst">$&#123;tag&#125;</span>] phase=<span class="hljs-subst">$&#123;phaseMap[e.eventPhase]&#125;</span> `</span> +</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-string">`target=#<span class="hljs-subst">$&#123;e.target.id&#125;</span> currentTarget=#<span class="hljs-subst">$&#123;e.currentTarget.id&#125;</span> `</span> +</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-string">`detail=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(e.detail)&#125;</span>`</span></span></span><br><span class="language-javascript"><span class="language-xml">      );</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 1) 监听器：捕获阶段</span></span></span><br><span class="language-javascript"><span class="language-xml">  outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer CAPTURE&quot;</span>), <span class="hljs-literal">true</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  inner.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inner CAPTURE&quot;</span>), <span class="hljs-literal">true</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 这里的 true 表示：监听器在「事件捕获阶段」执行。</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 2) 监听器：冒泡阶段（默认 false）</span></span></span><br><span class="language-javascript"><span class="language-xml">  outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer BUBBLE&quot;</span>));</span></span><br><span class="language-javascript"><span class="language-xml">  inner.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;inner BUBBLE&quot;</span>));</span></span><br><span class="language-javascript"><span class="language-xml">  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, <span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;btn BUBBLE&quot;</span>));</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 3) 点击按钮：创建并派发自定义事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> ev = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&quot;num-threshold&quot;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">detail</span>: &#123; <span class="hljs-attr">num</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">threshold</span>: <span class="hljs-number">5</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 允许冒泡（否则只有目标阶段）</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 允许 preventDefault（自定义事件通常用不到，但可演示）</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---- dispatch start ----&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    btn.<span class="hljs-title function_">dispatchEvent</span>(ev); <span class="hljs-comment">// 派发到目标：btn</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;---- dispatch end ----&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>当你点按钮后，控制台会按顺序输出类似：</p><ol><li><code>outer CAPTURE</code>（捕获，从外到内）</li><li><code>inner CAPTURE</code></li><li><code>btn BUBBLE</code>（目标阶段：监听器会以 target 触发；eventPhase 显示 target）</li><li><code>inner BUBBLE</code>（冒泡，从内到外）</li><li><code>outer BUBBLE</code></li></ol><p>这里最关键的是两点：</p><ul><li><strong><code>event.target</code> 永远是事件真正发生&#x2F;派发的目标（btn）</strong></li><li><strong><code>event.currentTarget</code> 是当前正在执行监听器的那个元素（outer&#x2F;inner&#x2F;btn 会变化）</strong></li></ul><hr><p>把它和“派发&#x2F;监听器过程”对应起来（你要的主线）</p><ol><li>创建事件对象(CustomEvent是DOM Level 3 Events 标准的一部分，就叫自定义事件）</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;num-threshold&quot;</span>, &#123; detail, bubbles &#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>绑定监听器</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addEventListener</span><span class="hljs-params">(<span class="hljs-string">&quot;num-threshold&quot;</span>, handler, useCapture?)</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>派发事件（关键动作）</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">btn.dispatchEvent(<span class="hljs-built_in">ev</span>)<br></code></pre></td></tr></table></figure><p>一旦派发，浏览器就会根据 DOM 树生成路径，并按阶段执行监听器：</p><ul><li><strong>捕获阶段</strong>：window → … → outer → inner</li><li><strong>目标阶段</strong>：btn</li><li><strong>冒泡阶段</strong>：inner → outer → … → document（前提：<code>bubbles: true</code>）</li></ul><h3 id="4-Vue-事件监听机制"><a href="#4-Vue-事件监听机制" class="headerlink" title="4. Vue 事件监听机制"></a>4. Vue 事件监听机制</h3><p>Vue 的事件系统并不是一套“新的事件模型”，而是<strong>对原生 DOM 事件机制的封装与语法抽象</strong>。<br> 其核心目标是：<strong>在不改变事件本质的前提下，降低事件绑定、传播控制和逻辑组织的复杂度</strong>。</p><h4 id="【Vue-中的事件监听方式】"><a href="#【Vue-中的事件监听方式】" class="headerlink" title="【Vue 中的事件监听方式】"></a>【Vue 中的事件监听方式】</h4><p>Vue 使用 <code>v-on</code> 指令（简写为 <code>@</code>）来监听事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button @click=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;点击&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>从本质上看，这一写法等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handleClick);<br></code></pre></td></tr></table></figure><p>不同之处在于：</p><ul><li>事件绑定由 Vue 在 <strong>组件挂载阶段</strong> 自动完成</li><li>回调函数默认绑定到当前组件实例（<code>this</code> 指向组件）</li></ul><h4 id="【Vue-事件与原生-JS-事件】"><a href="#【Vue-事件与原生-JS-事件】" class="headerlink" title="【Vue 事件与原生 JS 事件】"></a>【Vue 事件与原生 JS 事件】</h4><blockquote><p>Vue 事件 ≠ 自定义事件系统</p><p>Vue 事件 &#x3D; 原生 DOM 事件 + 语法层封装</p></blockquote><p>具体体现在：</p><ol><li><p><strong>事件触发来源</strong></p><ul><li>Vue 的 DOM 事件最终仍由浏览器触发</li><li>Vue 不接管浏览器的事件派发过程</li></ul></li><li><p><strong>事件对象</strong></p><ul><li>Vue 事件回调中接收到的 <code>$event</code> 本质就是原生 <code>Event</code> 对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick($event)&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Event</span>); <span class="hljs-comment">// true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>事件传播机制</strong></p><ul><li>捕获 → 目标 → 冒泡</li><li>完全遵循 DOM 标准事件流</li></ul></li></ol><p>从 JS 视角看，Vue 事件修饰符本质是：<strong>把“事件控制逻辑”从回调函数中前移到模板声明层</strong></p><p>对比：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原生 JS</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>();<br>  e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;<br>&lt;!-- <span class="hljs-title class_">Vue</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>带来的好处：</p><ul><li>事件行为一眼可见</li><li>减少样板代码</li><li>事件控制语义化</li><li>更利于模板阅读与维护</li></ul><p>Vue 事件 vs JS 事件对照总结</p><table><thead><tr><th>对比点</th><th>原生 JS 事件</th><th>Vue DOM 事件</th></tr></thead><tbody><tr><td>触发来源</td><td>浏览器</td><td>浏览器</td></tr><tr><td>事件对象</td><td>Event</td><td>Event（$event）</td></tr><tr><td>传播机制</td><td>捕获&#x2F;冒泡</td><td>完全一致</td></tr><tr><td>绑定方式</td><td>addEventListener</td><td>v-on &#x2F; @</td></tr><tr><td>事件控制</td><td>手动调用 API</td><td>修饰符声明</td></tr><tr><td>组件通信</td><td>不支持</td><td><code>$emit</code></td></tr></tbody></table><h4 id="【Vue-事件修饰符】"><a href="#【Vue-事件修饰符】" class="headerlink" title="【Vue 事件修饰符】"></a>【Vue 事件修饰符】</h4><p>事件修饰符是 Vue 对<strong>事件传播控制与默认行为控制</strong>的语法级抽象。</p><p> <code>.stop</code> —— 阻止冒泡</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;button @click.stop=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;点击&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>等价原生写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>.prevent</code> —— 阻止默认行为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;#&quot;</span> @click.<span class="hljs-attribute">prevent</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;链接&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>等价原生写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">e.<span class="hljs-title function_">preventDefault</span>();<br></code></pre></td></tr></table></figure><p><code>.stop.prevent</code> —— 组合修饰符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;form @submit.<span class="hljs-property">stop</span>.<span class="hljs-property">prevent</span>=<span class="hljs-string">&quot;submitForm&quot;</span>&gt;&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">e.<span class="hljs-title function_">stopPropagation</span>();<br>e.<span class="hljs-title function_">preventDefault</span>();<br></code></pre></td></tr></table></figure><p><code>.capture</code> —— 捕获阶段监听</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> @click.capture=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handler, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>这与 JS 中 <code>addEventListener(type, handler, true)</code> 的含义完全一致。</p><p><code>.once</code> —— 只执行一次</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>等价原生写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, handler, &#123; <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><p><code>.self</code> —— 只响应自身触发</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">&lt;<span class="hljs-keyword">div</span> @click.<span class="hljs-symbol">self</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>逻辑等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> === e.<span class="hljs-property">currentTarget</span>) &#123;<br>  <span class="hljs-title function_">handleClick</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>常用于防止事件委托误触。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.JS的函数问题</title>
    <link href="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/6-JS%E7%9A%84%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/6-JS%E7%9A%84%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是立即执行函数？</li><li>什么是闭包？</li><li>函数中的<code>this</code>指向？</li></ol><span id="more"></span><h2 id="JS的函数问题"><a href="#JS的函数问题" class="headerlink" title="JS的函数问题"></a>JS的函数问题</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#JavaScript%E5%87%BD%E6%95%B0">JavaScript基础 - 相</a></p></blockquote><h3 id="1-立即执行函数（IIFE）"><a href="#1-立即执行函数（IIFE）" class="headerlink" title="1.立即执行函数（IIFE）"></a>1.立即执行函数（IIFE）</h3><p>在 JavaScript 模块化机制尚未完善之前，<strong>立即执行函数</strong>是一种常用的封装手段，用来避免变量污染全局作用域。其核心思想是：<strong>创建一个只执行一次的私有作用域，把变量和方法包裹在里面</strong>。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>() &#123;&#125;)();<br></code></pre></td></tr></table></figure><p>立即执行函数（Immediately Invoked Function Expression，IIFE）本质上是一个<strong>函数表达式</strong>。通过外层括号将函数声明转换为表达式后，紧随其后的 <code>()</code> 会使其在定义后立刻执行。由于它是表达式，因此<strong>可以有返回值</strong>，并将结果赋给变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;,<br>    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>      count = <span class="hljs-number">0</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reset&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这段代码中，IIFE 只执行一次，创建了一个私有作用域，变量 <code>count</code> 只存在于该作用域内部。函数执行完成后返回一个对象，并赋值给 <code>Counter</code>。从外部只能通过 <code>increment</code> 和 <code>reset</code> 这两个方法操作 <code>count</code>，而无法直接访问或修改它，从而实现了<strong>模块化封装</strong>。</p><p>这种写法在行为上与使用 <code>class</code> 封装私有状态非常相似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  #count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#count);<br>  &#125;<br><br>  <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#count = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reset&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br></code></pre></td></tr></table></figure><p>二者都实现了“内部状态私有、对外只暴露接口”的效果，只是 IIFE 依赖函数作用域，而 <code>class</code> 由语言层面提供私有字段支持。</p><h3 id="2-闭包（Closure）"><a href="#2-闭包（Closure）" class="headerlink" title="2.闭包（Closure）"></a>2.闭包（Closure）</h3><p>在上述例子中，<code>count</code> 并没有随着 IIFE 的执行结束而被销毁，<code>increment</code> 和 <code>reset</code> 仍然可以持续访问它。这正是<strong>闭包</strong>的体现。</p><p>闭包的本质是：<strong>函数可以访问其定义时的词法作用域，即使该函数在其定义作用域之外被调用</strong>。只要某个内部变量仍然被外部函数引用，JavaScript 引擎就不会回收对应的作用域。</p><p>在 <code>Counter</code> 示例中，<code>increment</code> 和 <code>reset</code> 方法都引用了 <code>count</code>，因此该变量会被长期保留在内存中，但对外部代码不可见。这使得 <code>count</code> 成为一种“私有状态”，只能通过受控的方式被修改。</p><p>如果从类的角度类比理解，可以认为：<strong>类的方法可以访问私有字段，而实例对象本身不能直接访问这些字段</strong>。闭包在函数层面实现了类似的封装能力，是 JavaScript 早期实现私有变量和模块化的核心机制。</p><blockquote><p>立即执行函数用于<strong>创建独立作用域并封装模块</strong>，而闭包则保证了<strong>该作用域在函数执行结束后仍能被安全地访问和维护</strong>。二者结合，构成了 JavaScript 在模块化与私有变量出现之前最重要的设计模式之一。</p></blockquote><h3 id="3-this"><a href="#3-this" class="headerlink" title="3.this"></a>3.<code>this</code></h3><p><code>this</code> 并不是 JavaScript 的语法关键字参数，而是<strong>函数在执行时由调用方式动态确定的隐含参数</strong>。理解 <code>this</code> 的关键，不在于“它是什么”，而在于<strong>函数是“如何被调用的”</strong>。</p><p>（1）普通函数与箭头函数中的 <code>this</code></p><p>对于<strong>普通函数</strong>来说，<code>this</code> 的指向取决于调用者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-title function_">fn</span>();   <span class="hljs-comment">// this 指向 obj</span><br><span class="hljs-title function_">fn</span>();       <span class="hljs-comment">// this 指向全局对象（或 strict mode 下为 undefined）</span><br></code></pre></td></tr></table></figure><p>可以理解为：</p><p>普通函数在执行时，会被隐式地传入一个 <code>this</code> 参数。</p><p>而<strong>箭头函数完全不同</strong>：</p><ul><li>箭头函数<strong>没有自己的 <code>this</code></strong></li><li>它的 <code>this</code> 在<strong>定义时就已经确定</strong></li><li>永远指向<strong>定义时所在词法作用域的 <code>this</code></strong></li><li>之后<strong>无法再被改变</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的 <code>this</code> **不指向 <code>obj</code>**，而是指向外层作用域的 <code>this</code>。</p><hr><p>（2）箭头函数与 <code>arguments</code> &#x2F; <code>call</code> &#x2F; <code>apply</code> &#x2F; <code>bind</code></p><p>由于箭头函数没有自己的执行上下文，它也自然：</p><ul><li>没有 <code>arguments</code></li><li>不能通过 <code>call</code> &#x2F; <code>apply</code> &#x2F; <code>bind</code> 修改 <code>this</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//  ReferenceError</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而普通函数则可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>（3）<code>call</code>、<code>apply</code>、<code>bind</code> 的作用与区别</p><p><code>call</code>、<code>apply</code>、<code>bind</code> 都用于<strong>显式指定函数执行时的 <code>this</code> 指向</strong>，区别在于<strong>是否立即执行</strong>以及<strong>参数传递方式</strong>。</p><table><thead><tr><th>方法</th><th>作用</th><th>是否立即执行</th><th>参数形式</th></tr></thead><tbody><tr><td><code>call</code></td><td>改变 <code>this</code> 并执行函数</td><td>是</td><td>逐个参数</td></tr><tr><td><code>apply</code></td><td>改变 <code>this</code> 并执行函数</td><td>是</td><td>数组参数</td></tr><tr><td><code>bind</code></td><td>改变 <code>this</code>，返回新函数</td><td>否</td><td>逐个参数</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fn.<span class="hljs-title function_">call</span>(obj, a, b);<br>fn.<span class="hljs-title function_">apply</span>(obj, [a, b]);<br><span class="hljs-keyword">const</span> newFn = fn.<span class="hljs-title function_">bind</span>(obj, a);<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><p><code>apply</code> 中传入的数组，会被<strong>拆解为多个独立参数</strong>，其行为与 ES6 的展开运算符 <code>...arr</code> 等价。</p><hr><p>（4）类中方法、函数表达式与箭头函数的区别</p><p>在 <code>class</code> 中，方法的定义方式会影响它们的存储位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;          <span class="hljs-comment">// 方法</span><br>  bar = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">// 函数表达式</span><br>  baz = <span class="hljs-function">() =&gt;</span> &#123;&#125;      <span class="hljs-comment">// 箭头函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>foo</code>：定义在 <strong>原型对象（prototype）</strong> 上</li><li><code>bar</code>：作为实例属性存在（每个实例一份）</li><li><code>baz</code>：也是实例属性，且 <strong><code>this</code> 固定为实例</strong></li></ul><p>因此：</p><ul><li><strong>箭头函数不会出现在原型链上</strong></li><li>每个实例都会单独创建一份箭头函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.Vue基本原理</title>
    <link href="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ol><li>如何描述Vue采用的MVVM框架？</li><li>如何描述Vue2的响应式原理 （流程&#x2F;数据劫持原理）？</li><li>如何描述Vue3的响应式原理 （与Vue2差异 &#x2F; Proxy &#x2F; Reflect)？</li><li>数据代理的思想？</li></ol><span id="more"></span><h2 id="Vue的基本原理"><a href="#Vue的基本原理" class="headerlink" title="Vue的基本原理"></a>Vue的基本原理</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=145">145_尚硅谷Vue3技术_回顾Vue2的响应式原理_哔哩哔哩_bilibili</a></p></blockquote><h3 id="1-MVVM框架"><a href="#1-MVVM框架" class="headerlink" title="1.MVVM框架"></a>1.MVVM框架</h3><img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251217223808740.png" class title="image-20251217223808740"><p>根据MVVM库的特点：</p><p>MVVM（Model–View–ViewModel）是一种通过 <strong>ViewModel</strong> 作为中介，实现 <strong>View 与 Model 双向同步</strong> 的设计模式。</p><ul><li><strong>Model</strong>：数据层，负责数据状态与业务逻辑</li><li><strong>View</strong>：视图层，负责页面展示</li><li><strong>ViewModel</strong>：连接 View 和 Model，负责数据同步与视图更新</li></ul><p><strong>在 Vue 中的具体对应</strong></p><ul><li><strong>View</strong>：HTML 模板（如 <code>&lt;input&gt;</code>、<code>&#123;&#123; value &#125;&#125;</code>）</li><li><strong>Model</strong>：<code>data</code> 中定义的数据对象</li><li><strong>ViewModel</strong>：<code>vm = new Vue(&#123;...&#125;)</code> 创建的 Vue 实例</li></ul><p>先举一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div id=&#x27;root&#x27;&gt;<br>        &lt;input v-model=&quot;value&quot;&gt;<br>        &lt;p&gt;value的值为 &#123;&#123;value&#125;&#125; &lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el:&quot;#root&quot;,<br>        data:&#123;<br>            value:123<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在上面这个示例中，当我们在浏览器浏览器输入框修改value的值时，data中的value会同步修改。这是从<code>view-&gt;model</code>的过程。当data的value一旦被修改，页面就要重新渲染，那么<code>&lt;p&gt;</code>中的模板语句被修改。这是<code>model-&gt;view</code>的过程。</p><h4 id="【view-model】"><a href="#【view-model】" class="headerlink" title="【view-&gt;model】"></a>【<code>view-&gt;model</code>】</h4><p>当用户在输入框中输入内容时：</p><ol><li>用户操作视图（View）</li><li><strong>DOM 事件触发</strong>（如 <code>input</code> 事件）</li><li>事件回调中修改 <code>data.value</code></li><li>数据更新完成（Model 被修改）</li></ol><p>关键结论</p><ul><li>这一过程本质是 <strong>DOM 事件监听 + 回调赋值</strong></li><li>属于 <strong>浏览器 + JavaScript 的原生机制</strong></li><li><strong>不是 Vue 响应式原理的内容</strong></li></ul><p>Vue 在这里只是：</p><ul><li>通过<font color="#409eff"><strong>数据绑定</strong></font><code>Data Bingdings</code>，自动绑定了事件，省去了手写监听与赋值的代码</li></ul><h4 id="【model-view】"><a href="#【model-view】" class="headerlink" title="【model-&gt;view】"></a>【<code>model-&gt;view</code>】</h4><p>当 <code>data.value</code> 被修改后，页面中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>value 的值为 &#123;&#123; value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>能够自动更新，这一过程才是 <strong>Vue 响应式系统真正解决的问题</strong>。</p><ul><li>Vue 在初始化时，对 <code>data</code> 中的数据进行了 <strong><font color="#409eff">数据劫持</font></strong></li><li>每个被使用到的数据，都通过 <font color="#409eff"><strong>发布者–订阅者模式</strong></font> 与对应的视图更新逻辑建立了关联</li><li>当数据发生变化时：<ul><li>Vue 内部触发对应的 <strong>更新通知</strong></li><li>相关的视图更新函数被执行</li><li>页面完成重新渲染</li></ul></li></ul><p><strong>用一句话高度总结</strong></p><p>Vue 的双向数据绑定并不是一个统一机制，而是：</p><ul><li><strong>view → model</strong>：通过 DOM 事件监听实现（JS 原生机制）</li><li><strong>model → view</strong>：通过数据劫持 + 发布订阅机制实现（Vue 响应式系统核心）</li></ul><h3 id="2-Vue的响应式原理"><a href="#2-Vue的响应式原理" class="headerlink" title="2.Vue的响应式原理"></a>2.Vue的响应式原理</h3><p>Vue 的响应式原理，本质上是：<strong>数据劫持负责“感知变化”，发布–订阅机制负责“通知变化”</strong>两者配合，实现 <code>model → view</code> 的自动更新。</p><ul><li>数据劫持是指：通过拦截数据的读取（get）和修改（set）操作，使系统在数据被访问或变更时能够感知到这一行为，并触发相应的依赖收集或更新逻辑。</li><li>发布者–订阅者模式： 简单来说，就是发布者发布信号（数据变化），订阅者当信号绑定到自己的方法上。当信号被触发，所有绑定了信号的订阅者都执行，和Qt中的信号与槽机制很像。</li></ul><p>当响应式数据发生变化时，数据修改行为会被拦截并感知，随后由依赖系统通知所有依赖该数据的订阅者，订阅者执行各自的更新函数，从而驱动相关视图重新渲染。</p><p>Vue2响应式原理的流程图如下：</p><img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251218021138928.png" class title="image-20251218021138928"><p>核心代码(先不看，直接看流程)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-title function_">defineReactive</span>(obj, key, obj[key]));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Observer: 负责把对象的属性转为 getter/setter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(val); <span class="hljs-comment">// 递归处理嵌套对象</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        dep.<span class="hljs-title function_">depend</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>        val = newVal;<br>        <span class="hljs-title function_">observe</span>(newVal); <span class="hljs-comment">// 如果赋值对象，继续劫持</span><br>        <span class="hljs-comment">// 通知更新</span><br>        dep.<span class="hljs-title function_">notify</span>();<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// Dep: 管理依赖的容器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">watcher</span> =&gt;</span> watcher.<span class="hljs-title function_">update</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Watcher: 观察者，依赖更新时执行回调</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 设置当前 watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);  <span class="hljs-comment">// 执行取值，会触发数据的 getter</span><br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空，防止污染</span><br>  &#125;<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上述例子为示例，完整流程如下：</p><h4 id="【第一阶段：初始化】"><a href="#【第一阶段：初始化】" class="headerlink" title="【第一阶段：初始化】"></a>【第一阶段：初始化】</h4><p>第 0 步：在页面渲染之前初始化数据劫持</p><p>在实例化 Vue 时，Vue 会遍历 <code>data</code> 对象中的所有属性，并使用 <code>Object.defineProperty</code> 给每个属性添加 getter 和 setter，当属性被访问，调用<code>getter</code>方法， 当属性被修改，调用<code>setter</code>方法， 具体细节见下一节。</p><p>第 1 步：Compile 解析模板</p><p>以模板为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Compile 在解析模板时，会分别处理不同类型的绑定。</p><hr><p>第 2 步：处理 <code>v-model</code>（双通道中的 view → model）</p><p>Compile 遇到：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它会做两件事，这就使<strong>数据绑定</strong>，也是<code>v-model</code>的原理。</p><p>（1）初始化视图（数据 → 视图）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-property">value</span> = vm.<span class="hljs-property">msg</span>;<br></code></pre></td></tr></table></figure><p>（2）绑定 DOM 事件（视图 → 数据）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  vm.<span class="hljs-property">msg</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这一过程的性质：</p><ul><li>属于 DOM 事件监听</li><li>属于 JavaScript 原生机制</li><li><strong>不属于 Vue 响应式核心</strong></li></ul><p>到此为止：</p><ul><li>view → model 的通道已建立</li><li>只是“赋值”，还没有响应式更新</li></ul><hr><p>第 3 步：Compile 处理插值表达式</p><p>Compile 遇到：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>此时 Compile 明确两件事：</p><ol><li>这个 DOM 节点 <strong>依赖 <code>msg</code></strong></li><li>当 <code>msg</code> 变化时，<strong>应该如何更新 DOM</strong></li></ol><p>于是 Compile 生成一个<strong>更新函数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateText</span>(<span class="hljs-params"></span>) &#123;<br>  node.<span class="hljs-property">textContent</span> = vm.<span class="hljs-property">msg</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>这是一个普通的 JS 函数</li><li>它不是 DOM 事件</li><li>它只是“更新逻辑的描述”</li></ul><hr><p>第 4 步：Compile 创建 Watcher</p><p>Compile 将更新函数交给 Watcher：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, <span class="hljs-string">&#x27;msg&#x27;</span>, updateText);<br></code></pre></td></tr></table></figure><p>此时：</p><ul><li>Watcher 内部保存了更新函数</li><li>Watcher 尚未执行更新</li><li>Watcher 需要和数据建立关系</li></ul><hr><p>第 5 步：Watcher 实例化时完成依赖收集</p><p>在 Watcher 构造过程中，会发生一次关键操作，参考<strong>核心代码</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher;<br>vm.<span class="hljs-property">msg</span>;        <span class="hljs-comment">// 触发 getter</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>结果是：</p><ul><li><code>msg</code> 的 getter 被触发</li><li><code>msg</code> 对应的 Dep 发现当前存在 Dep.target</li><li>Dep 将该 Watcher 收集为自己的订阅者</li></ul><p>到此为止：</p><ul><li>数据知道“谁依赖我”</li><li>Watcher 知道“我依赖哪个数据”</li><li>依赖关系建立完成</li><li>页面尚未发生变化</li></ul><p>注意：</p><ul><li>每个数据都有一个Dep容器</li><li>Dep容器存储所有以该数据相关的Watcher</li><li>一个DOM节点 * 一个数据 &#x3D;  一个Watcher， DOM节点是订阅者，<code>msg</code>是发布者， <code>msg</code>修改触发信号， 也就是发布者-订阅者机制已经建立。</li></ul><h4 id="【第二阶段：运行时】"><a href="#【第二阶段：运行时】" class="headerlink" title="【第二阶段：运行时】"></a>【第二阶段：运行时】</h4><p>第 6 步：数据发生变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;world&#x27;</span>;<br></code></pre></td></tr></table></figure><p>触发 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>  dep.<span class="hljs-title function_">notify</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>第 7 步：Dep 通知所有 Watcher</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">dep.<span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>  watchers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.<span class="hljs-title function_">update</span>());<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>第 8 步：Watcher 执行更新逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>();   <span class="hljs-comment">// 执行 Compile 创建的更新函数</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>第 9 步：视图更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-property">textContent</span> = vm.<span class="hljs-property">msg</span>;<br></code></pre></td></tr></table></figure><p>视图更新会重新触发属性的<code>getter</code>方法，检测 Watcher 是否已经在 dep 中不会重复添加。</p><p>完整流程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">【初始化阶段】<br>Compile<br>  ↓<br>生成 DOM 更新函数<br>  ↓<br>创建 Watcher<br>  ↓<br>Watcher 读取数据<br>  ↓<br>数据 <span class="hljs-keyword">getter</span> 收集 Watcher 到 Dep<br><br>【运行阶段】<br>数据被修改<br>  ↓<br><span class="hljs-keyword">setter</span> 触发<br>  ↓<br>dep.notify()<br>  ↓<br>watcher.update()<br>  ↓<br>执行更新函数<br>  ↓<br>视图更新<br></code></pre></td></tr></table></figure><h4 id="【数据劫持】"><a href="#【数据劫持】" class="headerlink" title="【数据劫持】"></a>【数据劫持】</h4><p>我们分析Vue2中数据劫持的机制。</p><p><strong><code>Object.defineProperty</code></strong></p><p>在了解数据响应式的原理之前，我们先熟悉<code>Object.defineProperty</code>方法。</p><p><code>Object.defineProperty(obj, prop, descriptor)</code>是JS中用于为对象添加属性的方法。</p><ul><li><strong>obj</strong>：要定义属性的对象</li><li><strong>prop</strong>：要定义的属性名</li><li><strong>descriptor</strong>：属性描述符（决定属性的行为）</li></ul><p><strong>属性描述符分类两大类</strong></p><ol><li>数据描述符</li></ol><p>用于直接定义一个普通属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 是否可以修改</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 是否可以枚举（for...in / Object.keys）</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 是否可以删除或重新定义</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>value</code>：属性值</li><li><code>writable</code>：能否修改</li><li><code>enumerable</code>：能否枚举</li><li><code>configurable</code>：能否删除或重新定义属性</li></ul><ol start="2"><li>存取描述符</li></ol><p>通过 getter 和 setter 控制属性访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;&#125;;<br><span class="hljs-keyword">let</span> ageValue = <span class="hljs-number">20</span>;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&quot;age&quot;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getter 被调用&quot;</span>);<br>    <span class="hljs-keyword">return</span> ageValue;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setter 被调用:&quot;</span>, newVal);<br>    ageValue = newVal;<br>  &#125;,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// getter 被调用 -&gt; 20</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;         <span class="hljs-comment">// setter 被调用: 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// getter 被调用 -&gt; 30</span><br></code></pre></td></tr></table></figure><p>对于Vue的<code>data</code>对象，创建一个Observe对象，<code>data</code>中的所有属性都会在Observe上创建，并且有<code>getter</code>和<code>setter</code>方法。将<code>vm._data = obs</code>，这样当数据修改时，调用的是<code>observe</code>的方法，由<code>observe</code>修改<code>data</code>的属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, key, obj[key]));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Observer: 负责把对象的属性转为 getter/setter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(val); <span class="hljs-comment">// 递归处理嵌套对象</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>        val = newVal;<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br><br>obs = <span class="hljs-keyword">new</span> <span class="hljs-title function_">observe</span>(data)<br><span class="hljs-keyword">let</span> vm = &#123;&#125;<br>vm.<span class="hljs-property">_data</span> = data = obs<br></code></pre></td></tr></table></figure><h4 id="【局限性】"><a href="#【局限性】" class="headerlink" title="【局限性】"></a>【局限性】</h4><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=34">034_尚硅谷Vue技术_Vue监测数据的原理_对象_哔哩哔哩_bilibili</a></p></blockquote><ol><li><p><strong>不能监听对象属性的新增&#x2F;删除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;);<br>obj.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 没有劫持到</span><br></code></pre></td></tr></table></figure><p>需要 <code>Vue.set(obj, &#39;b&#39;, 2)</code> 来实现。</p></li><li><p><strong>不能监听数组下标变化</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;  <span class="hljs-comment">// Vue2 监听不到</span><br></code></pre></td></tr></table></figure><p>两者都是由于没有<code>setter</code>和<code>getter</code>方法，无法进行数据劫持。通过以下方式可以解决</p><ul><li><code>this.$set() / Vue.set()</code></li><li><code>this.$delete() / Vue.delete()</code></li><li>使用<code>push, pop, shift, unshift, splice</code></li></ul></li><li><p><strong>初始化时需要递归遍历</strong></p></li></ol><ul><li>Vue2 会在初始化时递归调用 <code>defineProperty</code> 劫持所有属性，这对深层嵌套对象性能不好。</li></ul><h3 id="3-Vue3的响应式原理"><a href="#3-Vue3的响应式原理" class="headerlink" title="3.Vue3的响应式原理"></a>3.Vue3的响应式原理</h3><p>首先明确 Vue3 和 Vue2 在<strong>思想层面完全一致</strong>：</p><ul><li>数据劫持（拦截 get &#x2F; set）</li><li>依赖收集</li><li>依赖触发更新（发布–订阅思想）</li></ul><p>但是调用的方法和API不同。但不再有 <strong>Observer &#x2F; Dep &#x2F; Watcher</strong> 这些类名；它们被 <strong>Proxy + Map&#x2F;Set + effect 函数</strong> 替代</p><p>Vue 3 使用 Proxy 对对象进行代理拦截：在读取属性时通过 track 完成依赖收集；在修改属性时通过 trigger 触发依赖更新。与 Vue 2 逐属性 defineProperty 不同，Proxy 天然支持新增&#x2F;删除属性以及更多操作类型，并可采用惰性代理降低初始化成本。</p><h4 id="【第一阶段：初始化】-1"><a href="#【第一阶段：初始化】-1" class="headerlink" title="【第一阶段：初始化】"></a>【第一阶段：初始化】</h4><p>第 0 步：在首次渲染之前完成“响应式包装”（Proxy）</p><p>Vue 3 中不再是“遍历 data 每个属性 defineProperty”，而是：</p><ul><li><code>reactive(data)</code> 返回一个 Proxy</li><li>Proxy 在 <strong>get &#x2F; set</strong> 时拦截并执行 <code>track / trigger</code>， <code>track</code>是依赖收集，<code>trigger</code>是依赖触发。</li></ul><p>示意：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>这一步一定发生在首次渲染之前，否则 render 读取数据时无法 track 依赖。</p><hr><p>第 1 步：模板被编译为 render（概念上对应 Compile 解析）</p><p>Vue 3 的 render 大致可以抽象成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 读取 state.msg（会触发 Proxy.get -&gt; track）</span><br>  input.<span class="hljs-property">value</span> = state.<span class="hljs-property">msg</span>;<br>  p.<span class="hljs-property">textContent</span> = state.<span class="hljs-property">msg</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>真实 Vue 会生成 VNode 并 patch，但不影响响应式因果链。</p><hr><p>第 2 步：处理 <code>v-model</code>（view → model 仍然是 DOM 事件）</p><ul><li>DOM 事件监听属于 JS 原生机制</li><li>Vue 只是在框架层帮你组织好“监听 + 赋值”</li></ul><p>等价示意：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  state.<span class="hljs-property">msg</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">// Proxy.set -&gt; trigger</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>到此为止：</p><ul><li>view → model 通道建立</li><li>但响应式更新链路要靠下面的 effect 才能自动跑起来</li></ul><hr><p>第 3 步：创建渲染 effect（等价于 Vue 2 的“创建渲染 Watcher”）</p><p>Vue 3 中对应的是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 首次执行：读取 state.msg -&gt; track 收集依赖</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>这一句是 Vue 3 运行时的关键点：</p><ul><li>effect 首次执行 render</li><li>render 内部读取 <code>state.msg</code></li><li>触发 <code>Proxy.get</code> → <code>track(target, &#39;msg&#39;)</code></li><li>把当前 effect 记录到依赖图 <code>targetMap</code> 的对应集合里</li></ul><p>到此为止：</p><ul><li>依赖关系已建立</li><li><strong>effect 是“订阅者&#x2F;更新单元”</strong></li><li><code>state.msg</code> 的依赖集合里已经有这个 effect</li></ul><hr><h4 id="【第二阶段：运行时】-1"><a href="#【第二阶段：运行时】-1" class="headerlink" title="【第二阶段：运行时】"></a>【第二阶段：运行时】</h4><p>第 4 步：数据发生变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">state.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;world&#x27;</span>;<br></code></pre></td></tr></table></figure><p>触发：</p><ul><li><code>Proxy.set</code></li><li>进而 <code>trigger(target, &#39;msg&#39;)</code></li></ul><hr><p>第 5 步：trigger 通知所有依赖该属性的 effect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dep.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">eff</span> =&gt;</span> <span class="hljs-title function_">eff</span>());<br></code></pre></td></tr></table></figure><p>这一步等价于 Vue 2 的：</p><ul><li><code>dep.notify() -&gt; watcher.update()</code></li></ul><hr><p>第 6 步：effect 重新执行 render，完成视图更新</p><p>effect 再次执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 再次读取 state.msg</span><br></code></pre></td></tr></table></figure><p>因此：</p><ul><li>视图更新会再次触发 <code>Proxy.get</code></li><li>会再次走到 <code>track</code></li><li>但依赖集合是 <code>Set</code>，不会重复添加同一个 effect</li></ul><p>结论：</p><ul><li><strong>getter（Proxy.get）会重复触发</strong></li><li><strong>effect 不会重新创建，只会重复执行</strong></li><li><strong>依赖不会重复收集（Set 去重）</strong></li></ul><hr><p>完整流程（Vue 3 文字版固化）</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf">【初始化阶段】<br>reactive(data) 创建 Proxy<br>  ↓<br>编译得到 render（概念上）<br>  ↓<br>effect(() =&gt; render())  首次执行 render<br>  ↓<br>render 读取 <span class="hljs-keyword">state</span>.msg<br>  ↓<br>Proxy.get -&gt; track 收集 effect 到依赖图<br><br>【运行阶段】<br><span class="hljs-keyword">state</span>.msg 被修改<br>  ↓<br>Proxy.<span class="hljs-built_in">set</span> -&gt; trigger<br>  ↓<br>trigger 找到依赖该 key 的 effects<br>  ↓<br>重新执行 effect（不会重新创建）<br>  ↓<br>render 再次执行 -&gt; 视图更新<br></code></pre></td></tr></table></figure><h4 id="【Proxy和Reflect】"><a href="#【Proxy和Reflect】" class="headerlink" title="【Proxy和Reflect】"></a>【<code>Proxy</code>和<code>Reflect</code>】</h4><p><code>Proxy</code>和<code>Reflect</code>是ES6新增的属性。</p><p>调用 <code>reactive(state)</code>时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> &#125; &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>此时发生的事情是：</p><ul><li>创建了 <strong>state 的 Proxy</strong></li><li>内部对象 <code>a</code>、<code>b</code>、<code>c</code> 还是普通对象</li></ul><p>Vue 3 不会在创建 <code>reactive</code> 时就递归地把所有嵌套对象都变成响应式，而是在“第一次访问某个嵌套对象时”，才对它进行 <code>reactive</code> 包装。</p><p><strong>Proxy</strong> 用来创建对象的代理，可以拦截对对象的各种操作。</p><p>基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure><ul><li><strong>target</strong>：原始对象</li><li><strong>handler</strong>：一个对象，定义拦截操作（trap）</li></ul><p>常用 trap：</p><table><thead><tr><th>trap</th><th>作用</th></tr></thead><tbody><tr><td>get</td><td>读取属性时触发</td></tr><tr><td>set</td><td>修改属性时触发</td></tr><tr><td>deleteProperty</td><td>删除属性时触发</td></tr><tr><td>has</td><td><code>key in obj</code> 时触发</td></tr><tr><td>ownKeys</td><td><code>Object.keys</code> &#x2F; <code>for...in</code> 时触发</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取属性 <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置属性 <span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    target[key] = value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;);<br><br>proxyObj.<span class="hljs-property">a</span>;      <span class="hljs-comment">// 读取属性 a</span><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">20</span>; <span class="hljs-comment">// 设置属性 a = 20</span><br></code></pre></td></tr></table></figure><p><strong>Reflect</strong> 提供与对象操作对应的方法，是一种原生的操作封装。它的目的是 <strong>用函数形式实现对象的默认行为</strong>，可以和 Proxy 的 handler 配合使用。</p><p>常用方法</p><table><thead><tr><th>方法</th><th>对应操作</th></tr></thead><tbody><tr><td>Reflect.get(target, key, receiver)</td><td>对象读取属性</td></tr><tr><td>Reflect.set(target, key, value, receiver)</td><td>对象设置属性</td></tr><tr><td>Reflect.deleteProperty(target, key)</td><td>删除属性</td></tr><tr><td>Reflect.has(target, key)</td><td><code>key in obj</code></td></tr><tr><td>Reflect.ownKeys(target)</td><td><code>Object.keys</code> &#x2F; <code>Object.getOwnPropertyNames</code></td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取 <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver); <span class="hljs-comment">// 默认行为</span><br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`修改 <span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver); <span class="hljs-comment">// 默认行为</span><br>  &#125;<br>&#125;);<br><br>proxyObj.<span class="hljs-property">a</span>;      <span class="hljs-comment">// 读取 a</span><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 修改 a = 100</span><br></code></pre></td></tr></table></figure><p>使用 Reflect 的好处：将Object,Function所有的操作<strong>统一到了一个对象下面</strong> ，<strong>也统一了操作方式</strong> 。 优化了一些报错，相比于Object代码健壮性更强。</p><blockquote><p><strong>整体描述</strong></p></blockquote><p>Vue 是基于 MVVM 架构实现的渐进式前端框架，其中 Model 负责保存数据和业务状态，View 是模板和最终的 DOM，ViewModel 即 Vue 实例负责把二者连接起来并实现数据与视图的双向绑定。框架通过响应式系统把数据的读写和视图更新耦合起来：在 Vue2 中，框架在初始化时会递归遍历 <code>data</code>，对每个属性使用 <code>Object.defineProperty</code> 设置 getter 和 setter；在组件渲染阶段执行渲染函数时，读取响应式属性会触发 getter，getter 中利用一个全局指针（<code>Dep.target</code>）将当前正在执行的 Watcher（渲染 Watcher、computed 的惰性 Watcher，或用户通过 <code>watch</code>&#x2F;<code>$watch</code> 创建的 Watcher）加入该属性对应的依赖管理器 Dep，从而建立“属性 → 订阅者（Watcher）”的关系；当属性被修改时，setter 被触发，调用 Dep.notify 通知所有依赖该属性的 Watcher 去更新。视图到数据的反向链路由模板编译时产生的指令完成，例如 <code>v-model</code> 实际上会编译为 <code>:value=&quot;xxx&quot;</code> 与 <code>@input=&quot;xxx = $event.target.value&quot;</code>，用户输入触发事件处理器写回数据，写回数据触发 setter，再通过依赖链更新视图。Vue2 中对数组采用覆盖变异方法（如重写 <code>push</code>、<code>splice</code>）来拦截变更，但不能检测通过下标直接赋值或新增&#x2F;删除对象属性（需要 <code>Vue.set</code>&#x2F;<code>Vue.delete</code>），且初始化时对深层对象的递归劫持开销较大。</p><p>为了解决这些局限，Vue3 将响应式内核替换为 <code>Proxy</code> + <code>Reflect</code> 的实现：<code>reactive</code> 返回一个 Proxy，<code>get</code>&#x2F;<code>set</code>&#x2F;<code>deleteProperty</code> 等拦截器配合 <code>track</code>&#x2F;<code>trigger</code> 在内部维护依赖映射结构 <code>targetMap</code>（WeakMap → Map（key → Set(effects)））；当一个 effect（等价于 Vue2 的 Watcher）在执行时读取属性会被 <code>track</code> 收集为依赖，写操作或删除操作会通过 <code>trigger</code> 找到相关 effect 并重新执行。Proxy 的优点是能拦截属性新增与删除、数组下标与长度变化，并且采用按需（懒）代理嵌套对象以减少初始化开销，从而使得对数组和新增属性的监测更自然、性能更优。</p><p>视图更新层面，模板在构建阶段被编译为渲染函数（render），渲染函数执行生成虚拟 DOM（VNode）；响应式变化触发渲染 Watcher &#x2F; effect 重新执行渲染函数产生新的 VNode，框架通过虚拟 DOM 的 diff 算法比较新旧 VNode 并以最小化的方式 patch 到真实 DOM。为了提高并发修改的性能，Vue 会把多个同步的数据修改合并为一次异步批量更新（维护更新队列并使用微任务&#x2F;<code>nextTick</code> 调度），Vue3 在 diff 的子节点重排上用 keyed 优化和最长递增子序列（LIS）等策略进一步减少 DOM 移动。</p><p>总之，Vue 的关键是把数据变动的“通知”链和视图的“渲染”链通过依赖收集连接起来：Vue2 用 <code>Object.defineProperty</code> + Dep&#x2F;Watcher 实现，存在新增&#x2F;数组索引检测等局限；Vue3 用 <code>Proxy</code> + <code>track/trigger</code>（基于 WeakMap→Map→Set 的依赖表）解决这些问题并带来性能与语义上的改进；而 <code>v-model</code>、computed、watch、渲染队列与虚拟 DOM 则是建立在这套响应式核心之上的常用抽象。</p><h3 id="4-数据代理"><a href="#4-数据代理" class="headerlink" title="4.数据代理"></a>4.数据代理</h3><p>创建一个简单的vue实例时：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>初识Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入Vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示。</span></span><br><span class="language-javascript"><span class="hljs-comment">//创建Vue实例</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#demo&#x27;</span>, <span class="hljs-comment">//el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。</span></span><br><span class="language-javascript"><span class="hljs-attr">data</span>:&#123; <span class="hljs-comment">//data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。</span></span><br><span class="language-javascript"><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;atguigu&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;北京&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在命令行终端中，可以通过<code>vm.name</code>和<code>vm.address</code>来访问数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">name</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">name</span><br>vm.<span class="hljs-property">address</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">address</span><br></code></pre></td></tr></table></figure><ul><li>当修改<code>vm.name</code>时，<code>vm._data.name</code>会同步修改。</li></ul><h4 id="理解数据代理"><a href="#理解数据代理" class="headerlink" title="理解数据代理"></a>理解数据代理</h4><p>在前面我们说VMMV的 Model 实际上就是<code>data</code>属性中是数据，当我们创建一个vue的实例对象的时候。Vue会帮我们将数据进行一些处理。</p><ul><li>首先将数据从<code>data</code>中取出放到<code>_data</code>中，并进行数据劫持的相关操作（后面提到）</li><li>将数据从<code>_data</code>中复制了一份在<code>vm</code>实例对象上，对 <code>vm</code> 实例的属性访问，转发到 <code>vm._data</code> 上。<strong>（数据代理）</strong></li></ul><img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20250903140313714.png" class title="image-20250903140313714"><blockquote><p>要注意的是，数据代理的作用是减少代码量，让开发体验更好。与响应式没有关系。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">addr</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">addr</span> === vm.<span class="hljs-property">data</span>.<span class="hljs-property">addr</span> ( === vm.<span class="hljs-property">observe</span>.<span class="hljs-property">addr</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3快速上手</title>
    <link href="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <url>/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>在尚硅谷Vue3学习笔记基础上整理，核心语法 &#x2F; 路由 &#x2F; pinia &#x2F; 组件通信</p><span id="more"></span><blockquote><p>TS教程：<a href="https://www.tslang.cn/docs/home.html">文档简介 · TypeScript中文网 · TypeScript——JavaScript的超集 (tslang.cn)</a></p><p>Vite教程：<a href="https://cn.vitejs.dev/config/">配置 Vite | Vite 官方中文文档 (vitejs.dev)</a></p><p>Vue教程：<a href="https://cn.vuejs.org/api/">API 参考 | Vue.js (vuejs.org)</a></p><p>Vue-Route教程：<a href="https://router.vuejs.org/zh/">Vue Router | Vue.js 的官方路由 (vuejs.org)</a></p><p><a href="https://www.bilibili.com/video/BV1Za4y1r7KE?spm_id_from=333.788.recommend_more_video.0&trackid=web_related_0.router-related-2206146-7vfnq.1765979057313.173&vd_source=ff414aaf189e3a685358d2a984fd4742">尚硅谷Vue3入门到实战，最新版vue3+TypeScript前端开发教程_哔哩哔哩_bilibili</a></p></blockquote><h1 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1. Vue3简介"></a>1. Vue3简介</h1><ul><li><p>2020年9月18日，<code>Vue.js</code>发布版<code>3.0</code>版本，代号：<code>One Piece</code>（n</p></li><li><p>经历了：<a href="https://github.com/vuejs/core/commits/main">4800+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">40+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/core/graphs/contributors">300+贡献者</a></p></li><li><p>官方发版地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs&#x2F;core</a></p></li><li><p>截止2023年10月，最新的公开版本为：<code>3.3.4</code></p><img src="/2025/12/17/前端学习/Vue3快速上手/1695089947298-161c1b47-eb86-42fb-b1f8-d6a4fcab8ee2-1765979249041-3.png" alt="image.png" style="zoom:30%;"></li></ul><h2 id="1-1-【性能的提升】"><a href="#1-1-【性能的提升】" class="headerlink" title="1.1. 【性能的提升】"></a>1.1. 【性能的提升】</h2><ul><li>打包大小减少<code>41%</code>。</li><li>初次渲染快<code>55%</code>, 更新渲染快<code>133%</code>。</li><li>内存减少<code>54%</code>。</li></ul><h2 id="1-2-【-源码的升级】"><a href="#1-2-【-源码的升级】" class="headerlink" title="1.2.【 源码的升级】"></a>1.2.【 源码的升级】</h2><ul><li><p>使用<code>Proxy</code>代替<code>defineProperty</code>实现响应式。</p></li><li><p>重写虚拟<code>DOM</code>的实现和<code>Tree-Shaking</code>。</p></li></ul><h2 id="1-3-【拥抱TypeScript】"><a href="#1-3-【拥抱TypeScript】" class="headerlink" title="1.3. 【拥抱TypeScript】"></a>1.3. 【拥抱TypeScript】</h2><ul><li><code>Vue3</code>可以更好的支持<code>TypeScript</code>。</li></ul><h2 id="1-4-【新的特性】"><a href="#1-4-【新的特性】" class="headerlink" title="1.4. 【新的特性】"></a>1.4. 【新的特性】</h2><ol><li><p><code>Composition API</code>（组合<code>API</code>）：</p><ul><li><p><code>setup</code></p></li><li><p><code>ref</code>与<code>reactive</code></p></li><li><p><code>computed</code>与<code>watch</code></p><p>……</p></li></ul></li><li><p>新的内置组件：</p><ul><li><p><code>Fragment</code></p></li><li><p><code>Teleport</code></p></li><li><p><code>Suspense</code></p><p>……</p></li></ul></li><li><p>其他改变：</p><ul><li><p>新的生命周期钩子</p></li><li><p><code>data</code> 选项应始终被声明为一个函数</p></li><li><p>移除<code>keyCode</code>支持作为<code> v-on</code> 的修饰符</p><p>……</p></li></ul></li></ol><h1 id="2-创建Vue3工程"><a href="#2-创建Vue3工程" class="headerlink" title="2. 创建Vue3工程"></a>2. 创建Vue3工程</h1><h2 id="2-1-【基于-vue-cli-创建】"><a href="#2-1-【基于-vue-cli-创建】" class="headerlink" title="2.1. 【基于 vue-cli 创建】"></a>2.1. 【基于 vue-cli 创建】</h2><p>点击查看<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">官方文档</a></p><blockquote><p>备注：目前<code>vue-cli</code>已处于维护模式，官方推荐基于 <code>Vite</code> 创建项目。</p></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span><br>vue <span class="hljs-literal">--version</span><br><br><span class="hljs-comment">## 安装或者升级你的@vue/cli </span><br>npm install <span class="hljs-literal">-g</span> @vue/<span class="hljs-built_in">cli</span><br><br><span class="hljs-comment">## 执行创建命令</span><br>vue create vue_test<br><br><span class="hljs-comment">##  随后选择3.x</span><br><span class="hljs-comment">##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)</span><br><span class="hljs-comment">##  &gt; 3.x</span><br><span class="hljs-comment">##    2.x</span><br><br><span class="hljs-comment">## 启动</span><br><span class="hljs-built_in">cd</span> vue_test<br>npm run serve<br></code></pre></td></tr></table></figure><hr><h2 id="2-2-【基于-vite-创建】-推荐"><a href="#2-2-【基于-vite-创建】-推荐" class="headerlink" title="2.2. 【基于 vite 创建】(推荐)"></a>2.2. 【基于 vite 创建】(推荐)</h2><p><code>vite</code> 是新一代前端构建工具，官网地址：<a href="https://vitejs.cn/">https://vitejs.cn</a>，<code>vite</code>的优势如下：</p><ul><li>轻量快速的热重载（<code>HMR</code>），能实现极速的服务启动。</li><li>对 <code>TypeScript</code>、<code>JSX</code>、<code>CSS</code> 等支持开箱即用。</li><li>真正的按需编译，不再等待整个应用编译完成。</li><li><code>webpack</code>构建 与 <code>vite</code>构建对比图如下：<br><img src="/2025/12/17/前端学习/Vue3快速上手/.." alt="webpack构建" title="webpack构建" style="zoom:20%;box-shadow:0 0 10px black"><img src="/2025/12/17/前端学习/Vue3快速上手/1683167204081-582dc237-72bc-499e-9589-2cdfd452e62f-1765979249041-4.png" alt="vite构建" title="vite构建" style="zoom: 20%;box-shadow:0 0 10px black"></li></ul><ul><li>具体操作如下（点击查看<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">官方文档</a>）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">## 1.创建命令</span><br>npm create vue@latest<br><br><span class="hljs-comment">## 2.具体配置</span><br><span class="hljs-comment">## 配置项目名称</span><br>√ Project name: vue3_test<br><span class="hljs-comment">## 是否添加TypeScript支持</span><br>√ Add TypeScript?  Yes<br><span class="hljs-comment">## 是否添加JSX支持</span><br>√ Add JSX Support?  No<br><span class="hljs-comment">## 是否添加路由环境</span><br>√ Add Vue Router <span class="hljs-keyword">for</span> Single Page Application development?  No<br><span class="hljs-comment">## 是否添加pinia环境</span><br>√ Add Pinia <span class="hljs-keyword">for</span> state management?  No<br><span class="hljs-comment">## 是否添加单元测试</span><br>√ Add Vitest <span class="hljs-keyword">for</span> Unit Testing?  No<br><span class="hljs-comment">## 是否添加端到端测试方案</span><br>√ Add an <span class="hljs-keyword">End</span><span class="hljs-literal">-to-End</span> Testing Solution? » No<br><span class="hljs-comment">## 是否添加ESLint语法检查</span><br>√ Add ESLint <span class="hljs-keyword">for</span> code quality?  Yes<br><span class="hljs-comment">## 是否添加Prettiert代码格式化</span><br>√ Add Prettier <span class="hljs-keyword">for</span> code formatting?  No<br></code></pre></td></tr></table></figure><p>自己动手编写一个App组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;app&quot;&gt;<br>    &lt;h1&gt;你好啊！&lt;/h1&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;App&#x27; //组件名<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>  .app &#123;<br>    background-color: #ddd;<br>    box-shadow: 0 0 10px;<br>    border-radius: 10px;<br>    padding: 20px;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>安装官方推荐的<code>vscode</code>插件：</p><img src="/2025/12/17/前端学习/Vue3快速上手/volar-1765979249041-6.png" alt="Snipaste_2023-10-08_20-46-34" style="zoom:50%;"> <img src="/2025/12/17/前端学习/Vue3快速上手/image-20231218085906380-1765979249041-8.png" alt="image-20231218085906380" style="zoom:42%;"> <p>总结：</p><ul><li><code>Vite</code> 项目中，<code>index.html</code> 是项目的入口文件，在项目最外层。</li><li>加载<code>index.html</code>后，<code>Vite</code> 解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;</code> 指向的<code>JavaScript</code>。</li><li><code>Vue3</code>**中是通过 **<code>createApp</code> 函数创建一个应用实例。</li></ul><h2 id="2-3-【一个简单的效果】"><a href="#2-3-【一个简单的效果】" class="headerlink" title="2.3. 【一个简单的效果】"></a>2.3. 【一个简单的效果】</h2><p><code>Vue3</code>向下兼容<code>Vue2</code>语法，且<code>Vue3</code>中的模板中可以没有根标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;App&#x27;,<br>    data() &#123;<br>      return &#123;<br>        name:&#x27;张三&#x27;,<br>        age:18,<br>        tel:&#x27;13888888888&#x27;<br>      &#125;<br>    &#125;,<br>    methods:&#123;<br>      changeName()&#123;<br>        this.name = &#x27;zhang-san&#x27;<br>      &#125;,<br>      changeAge()&#123;<br>        this.age += 1<br>      &#125;,<br>      showTel()&#123;<br>        alert(this.tel)<br>      &#125;<br>    &#125;,<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h1 id="3-Vue3核心语法"><a href="#3-Vue3核心语法" class="headerlink" title="3. Vue3核心语法"></a>3. Vue3核心语法</h1><h2 id="3-1-【OptionsAPI-与-CompositionAPI】"><a href="#3-1-【OptionsAPI-与-CompositionAPI】" class="headerlink" title="3.1.  【OptionsAPI 与 CompositionAPI】"></a>3.1.  【OptionsAPI 与 CompositionAPI】</h2><ul><li><code>Vue2</code>的<code>API</code>设计是<code>Options</code>（配置）风格的。</li><li><code>Vue3</code>的<code>API</code>设计是<code>Composition</code>（组合）风格的。</li></ul><h3 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h3><p><code>Options</code>类型的 <code>API</code>，数据、方法、计算属性等，是分散在：<code>data</code>、<code>methods</code>、<code>computed</code>中的，若想新增或者修改一个需求，就需要分别修改：<code>data</code>、<code>methods</code>、<code>computed</code>，不便于维护和复用。</p><p><img src="/2025/12/17/前端学习/Vue3快速上手/.." alt="1.gif" style="zoom:70%;border-radius:20px"><img src="/2025/12/17/前端学习/Vue3快速上手/1696662200734-1bad8249-d7a2-423e-a3c3-ab4c110628be-1765979249041-9.gif" alt="2.gif" style="zoom:70%;border-radius:20px"></p><h3 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h3><p>可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。</p><p><img src="/2025/12/17/前端学习/Vue3快速上手/1696662249851-db6403a1-acb5-481a-88e0-e1e34d2ef53a-1765979249041-10.gif" alt="3.gif" style="height:300px;border-radius:10px"><img src="/2025/12/17/前端学习/Vue3快速上手/.." alt="4.gif" style="height:300px;border-radius:10px"></p><blockquote><p>说明：以上四张动图原创作者：大帅老猿</p></blockquote><h2 id="3-2-【拉开序幕的-setup】"><a href="#3-2-【拉开序幕的-setup】" class="headerlink" title="3.2. 【拉开序幕的 setup】"></a>3.2. 【拉开序幕的 setup】</h2><h3 id="setup-概述"><a href="#setup-概述" class="headerlink" title="setup 概述"></a>setup 概述</h3><p><code>setup</code>是<code>Vue3</code>中一个新的配置项，值是一个函数，它是 <code>Composition API</code> <strong>“表演的舞台</strong>_<strong>”</strong>_，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在<code>setup</code>中。</p><p>特点如下：</p><ul><li><code>setup</code>函数返回的对象中的内容，可直接在模板中使用。</li><li><code>setup</code>中访问<code>this</code>是<code>undefined</code>。</li><li><code>setup</code>函数会在<code>beforeCreate</code>之前调用，它是“领先”所有钩子执行的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;Person&#x27;,<br>    setup()&#123;<br>      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）<br>      let name = &#x27;张三&#x27;<br>      let age = 18<br>      let tel = &#x27;13888888888&#x27;<br><br>      // 方法，原来写在methods中<br>      function changeName()&#123;<br>        name = &#x27;zhang-san&#x27; //注意：此时这么修改name页面是不变化的<br>        console.log(name)<br>      &#125;<br>      function changeAge()&#123;<br>        age += 1 //注意：此时这么修改age页面是不变化的<br>        console.log(age)<br>      &#125;<br>      function showTel()&#123;<br>        alert(tel)<br>      &#125;<br><br>      // 返回一个对象，对象中的内容，模板中可以直接使用<br>      return &#123;name,age,tel,changeName,changeAge,showTel&#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="setup-的返回值"><a href="#setup-的返回值" class="headerlink" title="setup 的返回值"></a>setup 的返回值</h3><ul><li>若返回一个<strong>对象</strong>：则对象中的：属性、方法等，在模板中均可以直接使用<strong>（重点关注）。</strong></li><li>若返回一个<strong>函数</strong>：则可以自定义渲染内容（基本不用），代码如下：</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span> <span class="hljs-string">&#x27;你好啊！&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="setup-与-Options-API-的关系"><a href="#setup-与-Options-API-的关系" class="headerlink" title="setup 与 Options API 的关系"></a>setup 与 Options API 的关系</h3><ul><li><code>Vue2</code> 的配置（<code>data</code>、<code>methos</code>……）中<strong>可以访问到</strong> <code>setup</code>中的属性、方法。</li><li>但在<code>setup</code>中<strong>不能访问到</strong><code>Vue2</code>的配置（<code>data</code>、<code>methos</code>……）。</li><li>如果与<code>Vue2</code>冲突，则<code>setup</code>优先。</li></ul><h3 id="setup-语法糖"><a href="#setup-语法糖" class="headerlink" title="setup 语法糖"></a>setup 语法糖</h3><p><code>setup</code>函数有一个语法糖，这个语法糖，可以让我们把<code>setup</code>独立出去，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  export default &#123;<br>    name:&#x27;Person&#x27;,<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;!-- 下面的写法是setup语法糖 --&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  console.log(this) //undefined<br>  <br>  // 数据（注意：此时的name、age、tel都不是响应式数据）<br>  let name = &#x27;张三&#x27;<br>  let age = 18<br>  let tel = &#x27;13888888888&#x27;<br><br>  // 方法<br>  function changName()&#123;<br>    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的<br>  &#125;<br>  function changAge()&#123;<br>    console.log(age)<br>    age += 1 //注意：此时这么修改age页面是不变化的<br>  &#125;<br>  function showTel()&#123;<br>    alert(tel)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>扩展：上述代码，还需要编写一个不写<code>setup</code>的<code>script</code>标签，去指定组件名字，比较麻烦，我们可以借助<code>vite</code>中的插件简化</p><ol><li>第一步：<code>npm i vite-plugin- vue-setup-extend -D</code></li><li>第二步：<code>vite.config.ts</code></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueSetupExtend</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-vue-setup-extend&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [ <span class="hljs-title class_">VueSetupExtend</span>() ]<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>第三步：<code>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</code></li></ol><h2 id="3-3-【ref-创建：基本类型的响应式数据】"><a href="#3-3-【ref-创建：基本类型的响应式数据】" class="headerlink" title="3.3. 【ref 创建：基本类型的响应式数据】"></a>3.3. 【ref 创建：基本类型的响应式数据】</h2><ul><li><strong>作用：</strong>定义响应式变量。</li><li><strong>语法：</strong><code>let xxx = ref(初始值)</code>。</li><li><strong>返回值：</strong>一个<code>RefImpl</code>的实例对象，简称<code>ref对象</code>或<code>ref</code>，<code>ref</code>对象的<code>value</code><strong>属性是响应式的</strong>。</li><li><strong>注意点：</strong><ul><li><code>JS</code>中操作数据需要：<code>xxx.value</code>，但模板中不需要<code>.value</code>，直接使用即可。</li><li>对于<code>let name = ref(&#39;张三&#39;)</code>来说，<code>name</code>不是响应式的，<code>name.value</code>是响应式的。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;<br>    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;<br>  import &#123;ref&#125; from &#x27;vue&#x27;<br>  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。<br>  let name = ref(&#x27;张三&#x27;)<br>  let age = ref(18)<br>  // tel就是一个普通的字符串，不是响应式的<br>  let tel = &#x27;13888888888&#x27;<br><br>  function changeName()&#123;<br>    // JS中操作ref对象时候需要.value<br>    name.value = &#x27;李四&#x27;<br>    console.log(name.value)<br><br>    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。<br>    // name = ref(&#x27;zhang-san&#x27;)<br>  &#125;<br>  function changeAge()&#123;<br>    // JS中操作ref对象时候需要.value<br>    age.value += 1 <br>    console.log(age.value)<br>  &#125;<br>  function showTel()&#123;<br>    alert(tel)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-4-【reactive-创建：对象类型的响应式数据】"><a href="#3-4-【reactive-创建：对象类型的响应式数据】" class="headerlink" title="3.4. 【reactive 创建：对象类型的响应式数据】"></a>3.4. 【reactive 创建：对象类型的响应式数据】</h2><ul><li><strong>作用：</strong>定义一个<strong>响应式对象</strong>（基本类型不要用它，要用<code>ref</code>，否则报错）</li><li><strong>语法：</strong><code>let 响应式对象= reactive(源对象)</code>。</li><li><strong>返回值：</strong>一个<code>Proxy</code>的实例对象，简称：响应式对象。</li><li><strong>注意点：</strong><code>reactive</code>定义的响应式数据是“深层次”的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;<br>    &lt;h2&gt;游戏列表：&lt;/h2&gt;<br>    &lt;ul&gt;<br>      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;<br>    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;<br>    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>import &#123; reactive &#125; from &#x27;vue&#x27;<br><br>// 数据<br>let car = reactive(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)<br>let games = reactive([<br>  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;<br>])<br>let obj = reactive(&#123;<br>  a:&#123;<br>    b:&#123;<br>      c:&#123;<br>        d:666<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br>function changeCarPrice() &#123;<br>  car.price += 10<br>&#125;<br>function changeFirstGame() &#123;<br>  games[0].name = &#x27;流星蝴蝶剑&#x27;<br>&#125;<br>function test()&#123;<br>  obj.a.b.c.d = 999<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-5-【ref-创建：对象类型的响应式数据】"><a href="#3-5-【ref-创建：对象类型的响应式数据】" class="headerlink" title="3.5. 【ref 创建：对象类型的响应式数据】"></a>3.5. 【ref 创建：对象类型的响应式数据】</h2><ul><li>其实<code>ref</code>接收的数据可以是：<strong>基本类型</strong>、<strong>对象类型</strong>。</li><li>若<code>ref</code>接收的是对象类型，内部其实也是调用了<code>reactive</code>函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;<br>    &lt;h2&gt;游戏列表：&lt;/h2&gt;<br>    &lt;ul&gt;<br>      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>    &lt;/ul&gt;<br>    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;<br>    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;<br>    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>  <br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>// 数据<br>let car = ref(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)<br>let games = ref([<br>  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,<br>  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;<br>])<br>let obj = ref(&#123;<br>  a:&#123;<br>    b:&#123;<br>      c:&#123;<br>        d:666<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br>console.log(car)<br><br>function changeCarPrice() &#123;<br>  car.value.price += 10<br>&#125;<br>function changeFirstGame() &#123;<br>  games.value[0].name = &#x27;流星蝴蝶剑&#x27;<br>&#125;<br>function test()&#123;<br>  obj.value.a.b.c.d = 999<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-6-【ref-对比-reactive】"><a href="#3-6-【ref-对比-reactive】" class="headerlink" title="3.6. 【ref 对比 reactive】"></a>3.6. 【ref 对比 reactive】</h2><p>宏观角度看：</p><blockquote><ol><li><p><code>ref</code>用来定义：<strong>基本类型数据</strong>、<strong>对象类型数据</strong>；</p></li><li><p><code>reactive</code>用来定义：<strong>对象类型数据</strong>。</p></li></ol></blockquote><ul><li>区别：</li></ul><blockquote><ol><li><p><code>ref</code>创建的变量必须使用<code>.value</code>（可以使用<code>volar</code>插件自动添加<code>.value</code>）。</p><img src="/2025/12/17/前端学习/Vue3快速上手/自动补充value-1765979249042-12.png" alt="自动补充value" style="zoom:50%;border-radius:20px"> </li><li><p><code>reactive</code>重新分配一个新对象，会<strong>失去</strong>响应式（可以使用<code>Object.assign</code>去整体替换）。 </p></li><li><p><code>ref</code>可以给value直接分配一个新对象。</p></li></ol></blockquote><ul><li>使用原则：</li></ul><blockquote><ol><li>若需要一个基本类型的响应式数据，必须使用<code>ref</code>。</li><li>若需要一个响应式对象，层级不深，<code>ref</code>、<code>reactive</code>都可以。</li><li>若需要一个响应式对象，且层级较深，推荐使用<code>reactive</code>。</li></ol></blockquote><h2 id="3-7-【toRefs-与-toRef】"><a href="#3-7-【toRefs-与-toRef】" class="headerlink" title="3.7. 【toRefs 与 toRef】"></a>3.7. 【toRefs 与 toRef】</h2><ul><li>作用：将一个响应式对象中的每一个属性，转换为<code>ref</code>对象。</li><li>备注：<code>toRefs</code>与<code>toRef</code>功能一致，但<code>toRefs</code>可以批量转换。</li><li>语法如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;性别：&#123;&#123;person.gender&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changeGender&quot;&gt;修改性别&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,reactive,toRefs,toRef&#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let person = reactive(&#123;name:&#x27;张三&#x27;, age:18, gender:&#x27;男&#x27;&#125;)<br><br>  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力<br>  let &#123;name,gender&#125; =  toRefs(person)<br><br>  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力<br>  let age = toRef(person,&#x27;age&#x27;)<br><br>  // 方法<br>  function changeName()&#123;<br>    name.value += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    age.value += 1<br>  &#125;<br>  function changeGender()&#123;<br>    gender.value = &#x27;女&#x27;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-8-【computed】"><a href="#3-8-【computed】" class="headerlink" title="3.8. 【computed】"></a>3.8. 【computed】</h2><p>作用：根据已有数据计算出新数据（和<code>Vue2</code>中的<code>computed</code>作用一致）。</p><img src="/2025/12/17/前端学习/Vue3快速上手/computed-1765979249042-13.gif" style="zoom:20%;">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;<br>    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;<br>    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;<br>    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;<br>  import &#123;ref,computed&#125; from &#x27;vue&#x27;<br><br>  let firstName = ref(&#x27;zhang&#x27;)<br>  let lastName = ref(&#x27;san&#x27;)<br><br>  // 计算属性——只读取，不修改<br>  /* let fullName = computed(()=&gt;&#123;<br>    return firstName.value + &#x27;-&#x27; + lastName.value<br>  &#125;) */<br><br><br>  // 计算属性——既读取又修改<br>  let fullName = computed(&#123;<br>    // 读取<br>    get()&#123;<br>      return firstName.value + &#x27;-&#x27; + lastName.value<br>    &#125;,<br>    // 修改<br>    set(val)&#123;<br>      console.log(&#x27;有人修改了fullName&#x27;,val)<br>      firstName.value = val.split(&#x27;-&#x27;)[0]<br>      lastName.value = val.split(&#x27;-&#x27;)[1]<br>    &#125;<br>  &#125;)<br><br>  function changeFullName()&#123;<br>    fullName.value = &#x27;li-si&#x27;<br>  &#125; <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-9-【watch】"><a href="#3-9-【watch】" class="headerlink" title="3.9.【watch】"></a>3.9.【watch】</h2><ul><li>作用：监视数据的变化（和<code>Vue2</code>中的<code>watch</code>作用一致）</li><li>特点：<code>Vue3</code>中的<code>watch</code>只能监视以下<strong>四种数据</strong>：</li></ul><blockquote><ol><li><code>ref</code>定义的数据。</li><li><code>reactive</code>定义的数据。</li><li>函数返回一个值（<code>getter</code>函数）。</li><li>一个包含上述内容的数组。</li></ol></blockquote><p>我们在<code>Vue3</code>中使用<code>watch</code>的时候，通常会遇到以下几种情况：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="* 情况一"></a>* 情况一</h3><p>监视<code>ref</code>定义的【基本类型】数据：直接写数据名即可，监视的是其<code>value</code>值的改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况一：监视【ref】定义的【基本类型】数据&lt;/h1&gt;<br>    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,watch&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let sum = ref(0)<br>  // 方法<br>  function changeSum()&#123;<br>    sum.value += 1<br>  &#125;<br>  // 监视，情况一：监视【ref】定义的【基本类型】数据<br>  const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)<br>    if(newValue &gt;= 10)&#123;<br>      stopWatch()<br>    &#125;<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>water</code>的返回值是用于<strong>结束监视</strong>的函数。</p><h3 id="情况二"><a href="#情况二" class="headerlink" title="* 情况二"></a>* 情况二</h3><p>监视<code>ref</code>定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p><blockquote><p>注意：</p><ul><li><p>若修改的是<code>ref</code>定义的对象中的属性，<code>newValue</code> 和 <code>oldValue</code> 都是新值，因为它们是同一个对象。</p></li><li><p>若修改整个<code>ref</code>定义的对象，<code>newValue</code> 是新值， <code>oldValue</code> 是旧值，因为不是同一个对象了。</p></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况二：监视【ref】定义的【对象类型】数据&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,watch&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let person = ref(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.value.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.value.age += 1<br>  &#125;<br>  function changePerson()&#123;<br>    person.value = &#123;name:&#x27;李四&#x27;,age:90&#125;<br>  &#125;<br>  /* <br>    监视，情况二：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视<br>    watch的第一个参数是：被监视的数据<br>    watch的第二个参数是：监视的回调<br>    watch的第三个参数是：配置对象（deep、immediate等等.....） <br>  */<br>  watch(person,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person变化了&#x27;,newValue,oldValue)<br>  &#125;,&#123;deep:true&#125;)<br>  <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="情况三"><a href="#情况三" class="headerlink" title="*  情况三"></a>*  情况三</h3><p>监视<code>reactive</code>定义的【对象类型】数据，且默认开启了深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况三：监视【reactive】定义的【对象类型】数据&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;<br>    &lt;hr&gt;<br>    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;test&quot;&gt;修改obj.a.b.c&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;reactive,watch&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let person = reactive(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18<br>  &#125;)<br>  let obj = reactive(&#123;<br>    a:&#123;<br>      b:&#123;<br>        c:666<br>      &#125;<br>    &#125;<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.age += 1<br>  &#125;<br>  function changePerson()&#123;<br>    Object.assign(person,&#123;name:&#x27;李四&#x27;,age:80&#125;)<br>  &#125;<br>  function test()&#123;<br>    obj.a.b.c = 888<br>  &#125;<br><br>  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的<br>  watch(person,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person变化了&#x27;,newValue,oldValue)<br>  &#125;)<br>  watch(obj,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;Obj变化了&#x27;,newValue,oldValue)<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="情况四"><a href="#情况四" class="headerlink" title="* 情况四"></a>* 情况四</h3><p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p><ol><li>若该属性值<strong>不是</strong>【对象类型】，需要写成函数形式。</li><li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，建议写成函数。</li></ol><p><strong>结论</strong>：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;reactive,watch&#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let person = reactive(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18,<br>    car:&#123;<br>      c1:&#x27;奔驰&#x27;,<br>      c2:&#x27;宝马&#x27;<br>    &#125;<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.age += 1<br>  &#125;<br>  function changeC1()&#123;<br>    person.car.c1 = &#x27;奥迪&#x27;<br>  &#125;<br>  function changeC2()&#123;<br>    person.car.c2 = &#x27;大众&#x27;<br>  &#125;<br>  function changeCar()&#123;<br>    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;<br>  &#125;<br><br>  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式<br>  /* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)<br>  &#125;) */<br><br>  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数<br>  watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)<br>  &#125;,&#123;deep:true&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="情况五"><a href="#情况五" class="headerlink" title="* 情况五"></a>* 情况五</h3><p>监视上述的多个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;情况五：监视上述的多个数据&lt;/h1&gt;<br>    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;<br>    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;<br>    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;<br>    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;reactive,watch&#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let person = reactive(&#123;<br>    name:&#x27;张三&#x27;,<br>    age:18,<br>    car:&#123;<br>      c1:&#x27;奔驰&#x27;,<br>      c2:&#x27;宝马&#x27;<br>    &#125;<br>  &#125;)<br>  // 方法<br>  function changeName()&#123;<br>    person.name += &#x27;~&#x27;<br>  &#125;<br>  function changeAge()&#123;<br>    person.age += 1<br>  &#125;<br>  function changeC1()&#123;<br>    person.car.c1 = &#x27;奥迪&#x27;<br>  &#125;<br>  function changeC2()&#123;<br>    person.car.c2 = &#x27;大众&#x27;<br>  &#125;<br>  function changeCar()&#123;<br>    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;<br>  &#125;<br><br>  // 监视，情况五：监视上述的多个数据<br>  watch([()=&gt;person.name,person.car],(newValue,oldValue)=&gt;&#123;<br>    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)<br>  &#125;,&#123;deep:true&#125;)<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-10-【watchEffect】"><a href="#3-10-【watchEffect】" class="headerlink" title="3.10. 【watchEffect】"></a>3.10. 【watchEffect】</h2><ul><li><p>官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</p></li><li><p><code>watch</code>对比<code>watchEffect</code></p><blockquote><ol><li><p>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</p></li><li><p><code>watch</code>：要明确指出监视的数据</p></li><li><p><code>watchEffect</code>：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。</p></li></ol></blockquote></li><li><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1&gt;需求：水温达到50℃，或水位达到20cm，则联系服务器&lt;/h1&gt;<br>    &lt;h2 id=&quot;demo&quot;&gt;水温：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;<br>    &lt;h2&gt;水位：&#123;&#123;height&#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changePrice&quot;&gt;水温+1&lt;/button&gt;<br>    &lt;button @click=&quot;changeSum&quot;&gt;水位+10&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,watch,watchEffect&#125; from &#x27;vue&#x27;<br>  // 数据<br>  let temp = ref(0)<br>  let height = ref(0)<br><br>  // 方法<br>  function changePrice()&#123;<br>    temp.value += 10<br>  &#125;<br>  function changeSum()&#123;<br>    height.value += 1<br>  &#125;<br><br>  // 用watch实现，需要明确的指出要监视：temp、height<br>  watch([temp,height],(value)=&gt;&#123;<br>    // 从value中获取最新的temp值、height值<br>    const [newTemp,newHeight] = value<br>    // 室温达到50℃，或水位达到20cm，立刻联系服务器<br>    if(newTemp &gt;= 50 || newHeight &gt;= 20)&#123;<br>      console.log(&#x27;联系服务器&#x27;)<br>    &#125;<br>  &#125;)<br><br>  // 用watchEffect实现，不用<br>  const stopWtach = watchEffect(()=&gt;&#123;<br>    // 室温达到50℃，或水位达到20cm，立刻联系服务器<br>    if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;<br>      console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)<br>      console.log(&#x27;联系服务器&#x27;)<br>    &#125;<br>    // 水温达到100，或水位达到50，取消监视<br>    if(temp.value === 100 || height.value === 50)&#123;<br>      console.log(&#x27;清理了&#x27;)<br>      stopWtach()<br>    &#125;<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-11-【标签的-ref-属性】"><a href="#3-11-【标签的-ref-属性】" class="headerlink" title="3.11. 【标签的 ref 属性】"></a>3.11. 【标签的 ref 属性】</h2><p>作用：用于注册模板引用。</p><blockquote><ul><li><p>用在普通<code>DOM</code>标签上，获取的是<code>DOM</code>节点。</p></li><li><p>用在组件标签上，获取的是组件实例对象。</p></li></ul></blockquote><p>用在普通<code>DOM</code>标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h1 ref=&quot;title1&quot;&gt;尚硅谷&lt;/h1&gt;<br>    &lt;h2 ref=&quot;title2&quot;&gt;前端&lt;/h2&gt;<br>    &lt;h3 ref=&quot;title3&quot;&gt;Vue&lt;/h3&gt;<br>    &lt;input type=&quot;text&quot; ref=&quot;inpt&quot;&gt; &lt;br&gt;&lt;br&gt;<br>    &lt;button @click=&quot;showLog&quot;&gt;点我打印内容&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref&#125; from &#x27;vue&#x27;<br><br>  let title1 = ref()<br>  let title2 = ref()<br>  let title3 = ref()<br><br>  function showLog()&#123;<br>    // 通过id获取元素<br>    const t1 = document.getElementById(&#x27;title1&#x27;)<br>    // 打印内容<br>    console.log((t1 as HTMLElement).innerText)<br>    console.log((&lt;HTMLElement&gt;t1).innerText)<br>    console.log(t1?.innerText)<br>    <br>/************************************/<br><br>    // 通过ref获取元素<br>    console.log(title1.value)<br>    console.log(title2.value)<br>    console.log(title3.value)<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>用在组件标签上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 父组件App.vue --&gt;<br>&lt;template&gt;<br>  &lt;Person ref=&quot;ren&quot;/&gt;<br>  &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;<br>  import Person from &#x27;./components/Person.vue&#x27;<br>  import &#123;ref&#125; from &#x27;vue&#x27;<br><br>  let ren = ref()<br><br>  function test()&#123;<br>    console.log(ren.value.name)<br>    console.log(ren.value.age)<br>  &#125;<br>&lt;/script&gt;<br><br><br>&lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --&gt;<br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123;ref,defineExpose&#125; from &#x27;vue&#x27;<br>// 数据<br>  let name = ref(&#x27;张三&#x27;)<br>  let age = ref(18)<br>  /****************************/<br>  /****************************/<br>  // 使用defineExpose将组件中的数据交给外部<br>  defineExpose(&#123;name,age&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="3-12-【props】"><a href="#3-12-【props】" class="headerlink" title="3.12. 【props】"></a>3.12. 【props】</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个接口，限制每个Person对象的格式</span><br><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">PersonInter</span> &#123;<br><span class="hljs-attr">id</span>:string,<br><span class="hljs-attr">name</span>:string,<br><span class="hljs-attr">age</span>:number<br>&#125;<br><br><span class="hljs-comment">// 定义一个自定义类型Persons</span><br><span class="hljs-keyword">export</span> type <span class="hljs-title class_">Persons</span> = <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">PersonInter</span>&gt;<br></code></pre></td></tr></table></figure><p><code>App.vue</code>中代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;Person :list=&quot;persons&quot;/&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;<br>import Person from &#x27;./components/Person.vue&#x27;<br>import &#123;reactive&#125; from &#x27;vue&#x27;<br>import &#123;type Persons&#125; from &#x27;./types&#x27;<br><br>let person:PersonInter = &#123;<br>  id:&#x27;e98219e11&#x27;, name:&#x27;qq&#x27;, age:17 <br>&#125;<br>let persons = reactive&lt;Persons&gt;([<br>&#123;id:&#x27;e98219e12&#x27;,name:&#x27;张三&#x27;,age:18&#125;,<br>&#123;id:&#x27;e98219e13&#x27;,name:&#x27;李四&#x27;,age:19&#125;,<br> &#123;id:&#x27;e98219e14&#x27;,name:&#x27;王五&#x27;,age:20&#125;<br>])<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p><code>Person.vue</code>中代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Vue">&lt;template&gt;<br>&lt;div class=&quot;person&quot;&gt;<br>&lt;ul&gt;<br>&lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;<br>  &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;<br>&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>import &#123;defineProps&#125; from &#x27;vue&#x27;<br>import &#123;type PersonInter&#125; from &#x27;@/types&#x27;<br><br>// 第一种写法：仅接收<br>// const props = defineProps([&#x27;list&#x27;])<br><br>// 第二种写法：接收+限制类型<br>// defineProps&lt;&#123;list:Persons&#125;&gt;()<br><br>// 第三种写法：接收+限制类型+指定默认值+限制必要性<br>let props = withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;<br>list:()=&gt;[&#123;id:&#x27;asdasg01&#x27;,name:&#x27;小猪佩奇&#x27;,age:18&#125;]<br>&#125;)<br>console.log(props)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3-13-【生命周期】"><a href="#3-13-【生命周期】" class="headerlink" title="3.13. 【生命周期】"></a>3.13. 【生命周期】</h2><ul><li><p>概念：<code>Vue</code>组件实例在创建时要经历一系列的初始化步骤，在此过程中<code>Vue</code>会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子</p></li><li><p>规律：</p><blockquote><p>生命周期整体分为四个阶段，分别是：<strong>创建、挂载、更新、销毁</strong>，每个阶段都有两个钩子，一前一后。</p></blockquote></li><li><p><code>Vue2</code>的生命周期</p><blockquote><p>创建阶段：<code>beforeCreate</code>、<code>created</code></p><p>挂载阶段：<code>beforeMount</code>、<code>mounted</code></p><p>更新阶段：<code>beforeUpdate</code>、<code>updated</code></p><p>销毁阶段：<code>beforeDestroy</code>、<code>destroyed</code></p></blockquote></li><li><p><code>Vue3</code>的生命周期</p><blockquote><p>创建阶段：<code>setup</code></p><p>挂载阶段：<code>onBeforeMount</code>、<code>onMounted</code></p><p>更新阶段：<code>onBeforeUpdate</code>、<code>onUpdated</code></p><p>卸载阶段：<code>onBeforeUnmount</code>、<code>onUnmounted</code></p></blockquote></li><li><p>常用的钩子：<code>onMounted</code>(挂载完毕)、<code>onUpdated</code>(更新完毕)、<code>onBeforeUnmount</code>(卸载之前)</p></li><li><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;person&quot;&gt;<br>    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;<br>    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;!-- vue3写法 --&gt;<br>&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;<br>  import &#123; <br>    ref, <br>    onBeforeMount, <br>    onMounted, <br>    onBeforeUpdate, <br>    onUpdated, <br>    onBeforeUnmount, <br>    onUnmounted <br>  &#125; from &#x27;vue&#x27;<br><br>  // 数据<br>  let sum = ref(0)<br>  // 方法<br>  function changeSum() &#123;<br>    sum.value += 1<br>  &#125;<br>  console.log(&#x27;setup&#x27;)<br>  // 生命周期钩子<br>  onBeforeMount(()=&gt;&#123;<br>    console.log(&#x27;挂载之前&#x27;)<br>  &#125;)<br>  onMounted(()=&gt;&#123;<br>    console.log(&#x27;挂载完毕&#x27;)<br>  &#125;)<br>  onBeforeUpdate(()=&gt;&#123;<br>    console.log(&#x27;更新之前&#x27;)<br>  &#125;)<br>  onUpdated(()=&gt;&#123;<br>    console.log(&#x27;更新完毕&#x27;)<br>  &#125;)<br>  onBeforeUnmount(()=&gt;&#123;<br>    console.log(&#x27;卸载之前&#x27;)<br>  &#125;)<br>  onUnmounted(()=&gt;&#123;<br>    console.log(&#x27;卸载完毕&#x27;)<br>  &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-14-【自定义hook】"><a href="#3-14-【自定义hook】" class="headerlink" title="3.14. 【自定义hook】"></a>3.14. 【自定义hook】</h2><ul><li><p>什么是<code>hook</code>？—— 本质是一个函数，把<code>setup</code>函数中使用的<code>Composition API</code>进行了封装，类似于<code>vue2.x</code>中的<code>mixin</code>。</p></li><li><p>自定义<code>hook</code>的优势：复用代码, 让<code>setup</code>中的逻辑更清楚易懂。</p></li></ul><p>示例代码：</p><ul><li><p><code>useSum.ts</code>中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;ref,onMounted&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    sum.<span class="hljs-property">value</span> += <span class="hljs-number">1</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">decrement</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    sum.<span class="hljs-property">value</span> -= <span class="hljs-number">1</span><br>  &#125;<br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">increment</span>()<br>  &#125;)<br><br>  <span class="hljs-comment">//向外部暴露数据</span><br>  <span class="hljs-keyword">return</span> &#123;sum,increment,decrement&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>useDog.ts</code>中内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;reactive,onMounted&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> axios,&#123;<span class="hljs-title class_">AxiosError</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> dogList = reactive&lt;string[]&gt;([])<br><br>  <span class="hljs-comment">// 方法</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDog</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 发请求</span><br>      <span class="hljs-keyword">let</span> &#123;data&#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;</span>)<br>      <span class="hljs-comment">// 维护数据</span><br>      dogList.<span class="hljs-title function_">push</span>(data.<span class="hljs-property">message</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-comment">// 处理错误</span><br>      <span class="hljs-keyword">const</span> err = &lt;<span class="hljs-title class_">AxiosError</span>&gt;error<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">message</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 挂载钩子</span><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-title function_">getDog</span>()<br>  &#125;)<br><br>  <span class="hljs-comment">//向外部暴露数据</span><br>  <span class="hljs-keyword">return</span> &#123;dogList,getDog&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>组件中具体使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;点我+1&lt;/button&gt;<br>  &lt;button @click=&quot;decrement&quot;&gt;点我-1&lt;/button&gt;<br>  &lt;hr&gt;<br>  &lt;img v-for=&quot;(u,index) in dogList.urlList&quot; :key=&quot;index&quot; :src=&quot;(u as string)&quot;&gt; <br>  &lt;span v-show=&quot;dogList.isLoading&quot;&gt;加载中......&lt;/span&gt;&lt;br&gt;<br>  &lt;button @click=&quot;getDog&quot;&gt;再来一只狗&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot;&gt;<br>  import &#123;defineComponent&#125; from &#x27;vue&#x27;<br><br>  export default defineComponent(&#123;<br>    name:&#x27;App&#x27;,<br>  &#125;)<br>&lt;/script&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>  import useSum from &#x27;./hooks/useSum&#x27;<br>  import useDog from &#x27;./hooks/useDog&#x27;<br><br>  let &#123;sum,increment,decrement&#125; = useSum()<br>  let &#123;dogList,getDog&#125; = useDog()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h1><h2 id="4-1-【对路由的理解】"><a href="#4-1-【对路由的理解】" class="headerlink" title="4.1. 【对路由的理解】"></a>4.1. 【对路由的理解】</h2><img src="/2025/12/17/前端学习/Vue3快速上手/image-20231018144351536-1765979249042-14.png" alt="image-20231018144351536" style="zoom:20%;border-radius:40px"> <h2 id="4-2-【基本切换效果】"><a href="#4-2-【基本切换效果】" class="headerlink" title="4.2. 【基本切换效果】"></a>4.2. 【基本切换效果】</h2><ul><li><p><code>Vue3</code>中要使用<code>vue-router</code>的最新版本，目前是<code>4</code>版本。</p></li><li><p>路由配置文件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">News</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/News.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/About.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>&#125;<br>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>main.ts</code>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index&#x27;</span><br>app.<span class="hljs-title function_">use</span>(router)<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>App.vue</code>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;app&quot;&gt;<br>    &lt;h2 class=&quot;title&quot;&gt;Vue路由测试&lt;/h2&gt;<br>    &lt;!-- 导航区 --&gt;<br>    &lt;div class=&quot;navigate&quot;&gt;<br>      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;<br>      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt;<br>      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt;<br>    &lt;/div&gt;<br>    &lt;!-- 展示区 --&gt;<br>    &lt;div class=&quot;main-content&quot;&gt;<br>      &lt;RouterView&gt;&lt;/RouterView&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;<br>  import &#123;RouterLink,RouterView&#125; from &#x27;vue-router&#x27;  <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-3-【两个注意点】"><a href="#4-3-【两个注意点】" class="headerlink" title="4.3. 【两个注意点】"></a>4.3. 【两个注意点】</h2><blockquote><ol><li><p>路由组件通常存放在<code>pages</code> 或 <code>views</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p></li><li><p>通过点击导航，视觉效果上“消失” 了的路由组件，默认是被<strong>卸载</strong>掉的，需要的时候再去<strong>挂载</strong>。</p></li></ol></blockquote><h2 id="4-4-【路由器工作模式】"><a href="#4-4-【路由器工作模式】" class="headerlink" title="4.4.【路由器工作模式】"></a>4.4.【路由器工作模式】</h2><ol><li><p><code>history</code>模式</p><blockquote><p>优点：<code>URL</code>更加美观，不带有<code>#</code>，更接近传统的网站<code>URL</code>。</p><p>缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有<code>404</code>错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(), <span class="hljs-comment">//history模式</span><br><span class="hljs-comment">/******/</span><br>&#125;)<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>hash</code>模式</p><blockquote><p>优点：兼容性更好，因为不需要服务器端处理路径。</p><p>缺点：<code>URL</code>带有<code>#</code>不太美观，且在<code>SEO</code>优化方面相对较差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br><span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHashHistory</span>(), <span class="hljs-comment">//hash模式</span><br><span class="hljs-comment">/******/</span><br>&#125;)<br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="4-5-【to的两种写法】"><a href="#4-5-【to的两种写法】" class="headerlink" title="4.5. 【to的两种写法】"></a>4.5. 【to的两种写法】</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 第一种：to的字符串写法 --&gt;<br>&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;<br><br>&lt;!-- 第二种：to的对象写法 --&gt;<br>&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><h2 id="4-6-【命名路由】"><a href="#4-6-【命名路由】" class="headerlink" title="4.6. 【命名路由】"></a>4.6. 【命名路由】</h2><p>作用：可以简化路由跳转及传参（后面就讲）。</p><p>给路由规则命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">routes</span>:[<br>  &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zhuye&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xinwen&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/news&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;guanyu&#x27;</span>,<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>    <span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>跳转路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;<br>&lt;router-link to=&quot;/news/detail&quot;&gt;跳转&lt;/router-link&gt;<br><br>&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;<br>&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><h2 id="4-7-【嵌套路由】"><a href="#4-7-【嵌套路由】" class="headerlink" title="4.7. 【嵌套路由】"></a>4.7. 【嵌套路由】</h2><ol><li><p>编写<code>News</code>的子路由：<code>Detail.vue</code></p></li><li><p>配置路由规则，使用<code>children</code>配置项：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br><span class="hljs-attr">routes</span>:[<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zhuye&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/home&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Home</span><br>&#125;,<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xinwen&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/news&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">News</span>,<br><span class="hljs-attr">children</span>:[<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiang&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span><br>&#125;<br>]<br>&#125;,<br>&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;guanyu&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/about&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">About</span><br>&#125;<br>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li><li><p>跳转路由（记得要加完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to=&quot;/news/detail&quot;&gt;xxxx&lt;/router-link&gt;<br>&lt;!-- 或 --&gt;<br>&lt;router-link :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;xxxx&lt;/router-link&gt;<br></code></pre></td></tr></table></figure></li><li><p>记得去<code>Home</code>组件中预留一个<code>&lt;router-view&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;news&quot;&gt;<br>    &lt;nav class=&quot;news-list&quot;&gt;<br>      &lt;RouterLink v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot; :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;<br>        &#123;&#123;news.name&#125;&#125;<br>      &lt;/RouterLink&gt;<br>    &lt;/nav&gt;<br>    &lt;div class=&quot;news-detail&quot;&gt;<br>      &lt;RouterView/&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-8-【路由传参】"><a href="#4-8-【路由传参】" class="headerlink" title="4.8. 【路由传参】"></a>4.8. 【路由传参】</h2><h3 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;<br>&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;<br>跳转<br>&lt;/router-link&gt;<br><br>&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;<br>&lt;RouterLink <br>  :to=&quot;&#123;<br>    //name:&#x27;xiang&#x27;, //用name也可以跳转<br>    path:&#x27;/news/detail&#x27;,<br>    query:&#123;<br>      id:news.id,<br>      title:news.title,<br>      content:news.content<br>    &#125;<br>  &#125;&quot;<br>&gt;<br>  &#123;&#123;news.title&#125;&#125;<br>&lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useRoute&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-comment">// 打印query参数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">query</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><ol><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;<br>&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;<br><br>&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;<br>&lt;RouterLink <br>  :to=&quot;&#123;<br>    name:&#x27;xiang&#x27;, //用name跳转<br>    params:&#123;<br>      id:news.id,<br>      title:news.title,<br>      content:news.title<br>    &#125;<br>  &#125;&quot;<br>&gt;<br>  &#123;&#123;news.title&#125;&#125;<br>&lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useRoute&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-comment">// 打印params参数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">params</span>)<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>备注1：传递<code>params</code>参数时，若使用<code>to</code>的对象写法，必须使用<code>name</code>配置项，不能用<code>path</code>。</p><p>备注2：传递<code>params</code>参数时，需要提前在规则中占位。</p></blockquote><h2 id="4-9-【路由的props配置】"><a href="#4-9-【路由的props配置】" class="headerlink" title="4.9. 【路由的props配置】"></a>4.9. 【路由的props配置】</h2><p>作用：让路由组件更方便的收到参数（可以将路由参数作为<code>props</code>传给组件）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiang&#x27;</span>,<br><span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;detail/:id/:title/:content&#x27;</span>,<br><span class="hljs-attr">component</span>:<span class="hljs-title class_">Detail</span>,<br><br>  <span class="hljs-comment">// props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件</span><br>  <span class="hljs-comment">// props:&#123;a:1,b:2,c:3&#125;, </span><br><br>  <span class="hljs-comment">// props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件</span><br>  <span class="hljs-comment">// props:true</span><br>  <br>  <span class="hljs-comment">// props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件</span><br><span class="hljs-title function_">props</span>(<span class="hljs-params">route</span>)&#123;<br>  <span class="hljs-keyword">return</span> route.<span class="hljs-property">query</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-【-replace属性】"><a href="#4-10-【-replace属性】" class="headerlink" title="4.10. 【 replace属性】"></a>4.10. 【 replace属性】</h2><ol><li><p>作用：控制路由跳转时操作浏览器历史记录的模式。</p></li><li><p>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>：</p><ul><li><code>push</code>是追加历史记录（默认值）。</li><li><code>replace</code>是替换当前记录。</li></ul></li><li><p>开启<code>replace</code>模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;RouterLink replace .......&gt;News&lt;/RouterLink&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-11-【编程式导航】"><a href="#4-11-【编程式导航】" class="headerlink" title="4.11. 【编程式导航】"></a>4.11. 【编程式导航】</h2><p>路由组件的两个重要的属性：<code>$route</code>和<code>$router</code>变成了两个<code>hooks</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;useRoute,useRouter&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()<br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">query</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(route.<span class="hljs-property">parmas</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(router.<span class="hljs-property">push</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(router.<span class="hljs-property">replace</span>)<br></code></pre></td></tr></table></figure><h2 id="4-12-【重定向】"><a href="#4-12-【重定向】" class="headerlink" title="4.12. 【重定向】"></a>4.12. 【重定向】</h2><ol><li><p>作用：将特定的路径，重新定向到已有路由。</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/about&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="5-pinia"><a href="#5-pinia" class="headerlink" title="5. pinia"></a>5. pinia</h1><h2 id="5-1【准备一个效果】"><a href="#5-1【准备一个效果】" class="headerlink" title="5.1【准备一个效果】"></a>5.1【准备一个效果】</h2><img src="/2025/12/17/前端学习/Vue3快速上手/pinia_example-1765979249042-15.gif" alt="pinia_example" style="zoom:30%;border:3px solid"> <h2 id="5-2【搭建-pinia-环境】"><a href="#5-2【搭建-pinia-环境】" class="headerlink" title="5.2【搭建 pinia 环境】"></a>5.2【搭建 pinia 环境】</h2><p>第一步：<code>npm install pinia</code></p><p>第二步：操作<code>src/main.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">/* 引入createPinia，用于创建pinia */</span><br><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">/* 创建pinia */</span><br><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><br><span class="hljs-comment">/* 使用插件 */</span>&#123;&#125;<br>app.<span class="hljs-title function_">use</span>(pinia)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>此时开发者工具中已经有了<code>pinia</code>选项</p><img src="/2025/12/17/前端学习/Vue3快速上手/1684309952481-c67f67f9-d1a3-4d69-8bd6-2b381e003f31.png" style="zoom:80%;border:1px solid black;border-radius:10px"><h2 id="5-3【存储-读取数据】"><a href="#5-3【存储-读取数据】" class="headerlink" title="5.3【存储+读取数据】"></a>5.3【存储+读取数据】</h2><ol><li><p><code>Store</code>是一个保存：<strong>状态</strong>、<strong>业务逻辑</strong> 的实体，每个组件都可以<strong>读取</strong>、<strong>写入</strong>它。</p></li><li><p>它有三个概念：<code>state</code>、<code>getter</code>、<code>action</code>，相当于组件中的： <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</p></li><li><p>具体编码：<code>src/store/count.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 引入defineStore用于创建store</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">// 定义并暴露一个store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCountStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;count&#x27;</span>,&#123;<br>  <span class="hljs-comment">// 动作</span><br>  <span class="hljs-attr">actions</span>:&#123;&#125;,<br>  <span class="hljs-comment">// 状态</span><br>  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">sum</span>:<span class="hljs-number">6</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-attr">getters</span>:&#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>具体编码：<code>src/store/talk.ts</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入defineStore用于创建store</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">// 定义并暴露一个store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTalkStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;talk&#x27;</span>,&#123;<br>  <span class="hljs-comment">// 动作</span><br>  <span class="hljs-attr">actions</span>:&#123;&#125;,<br>  <span class="hljs-comment">// 状态</span><br>  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">talkList</span>:[<br>        &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;yuysada01&#x27;</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span>&#125;,<br>     &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;yuysada02&#x27;</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span>&#125;,<br>        &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;yuysada03&#x27;</span>,<span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span>&#125;<br>      ]<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-attr">getters</span>:&#123;&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中使用<code>state</code>中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;当前求和为：&#123;&#123; sumStore.sum &#125;&#125;&lt;/h2&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;<br>  // 引入对应的useXxxxxStore<br>  import &#123;useSumStore&#125; from &#x27;@/store/sum&#x27;<br>  <br>  // 调用useXxxxxStore得到对应的store<br>  const sumStore = useSumStore()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;ul&gt;<br>    &lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&gt;<br>      &#123;&#123; talk.content &#125;&#125;<br>    &lt;/li&gt;<br>  &lt;/ul&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;<br>  import axios from &#x27;axios&#x27;<br>  import &#123;useTalkStore&#125; from &#x27;@/store/talk&#x27;<br><br>  const talkStore = useTalkStore()<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-4-【修改数据】-三种方式"><a href="#5-4-【修改数据】-三种方式" class="headerlink" title="5.4.【修改数据】(三种方式)"></a>5.4.【修改数据】(三种方式)</h2><ol><li><p>第一种修改方式，直接修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">countStore.<span class="hljs-property">sum</span> = <span class="hljs-number">666</span><br></code></pre></td></tr></table></figure></li><li><p>第二种修改方式：批量修改</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts">countStore.$patch(&#123;<br>  <span class="hljs-attr">sum</span>:<span class="hljs-number">999</span>,<br>  <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;atguigu&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>第三种修改方式：借助<code>action</code>修改（<code>action</code>中可以编写一些业务逻辑）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCountStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;count&#x27;</span>, &#123;<br>  <span class="hljs-comment">/*************/</span><br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-comment">//加</span><br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">value:number</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> &lt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-comment">//操作countStore中的sum</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> += value<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">//减</span><br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params">value:number</span>)&#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> -= value<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">/*************/</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中调用<code>action</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用countStore</span><br><span class="hljs-keyword">const</span> countStore = <span class="hljs-title function_">useCountStore</span>()<br><br><span class="hljs-comment">// 调用对应action</span><br>countStore.<span class="hljs-title function_">incrementOdd</span>(n.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-5-【storeToRefs】"><a href="#5-5-【storeToRefs】" class="headerlink" title="5.5.【storeToRefs】"></a>5.5.【storeToRefs】</h2><ul><li>借助<code>storeToRefs</code>将<code>store</code>中的数据转为<code>ref</code>对象，方便在模板中使用。</li><li>注意：<code>pinia</code>提供的<code>storeToRefs</code>只会将数据做转换，而<code>Vue</code>的<code>toRefs</code>会转换<code>store</code>中数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;count&quot;&gt;<br>&lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;<br>  import &#123; useCountStore &#125; from &#x27;@/store/count&#x27;<br>  /* 引入storeToRefs */<br>  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;<br><br>/* 得到countStore */<br>  const countStore = useCountStore()<br>  /* 使用storeToRefs转换countStore，随后解构 */<br>  const &#123;sum&#125; = storeToRefs(countStore)<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h2 id="5-6-【getters】"><a href="#5-6-【getters】" class="headerlink" title="5.6.【getters】"></a>5.6.【getters】</h2><ol><li><p>概念：当<code>state</code>中的数据，需要经过处理后再使用时，可以使用<code>getters</code>配置。</p></li><li><p>追加<code>getters</code>配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入defineStore用于创建store</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-comment">// 定义并暴露一个store</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCountStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;count&#x27;</span>,&#123;<br>  <span class="hljs-comment">// 动作</span><br>  <span class="hljs-attr">actions</span>:&#123;<br>    <span class="hljs-comment">/************/</span><br>  &#125;,<br>  <span class="hljs-comment">// 状态</span><br>  <span class="hljs-title function_">state</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">sum</span>:<span class="hljs-number">1</span>,<br>      <span class="hljs-attr">school</span>:<span class="hljs-string">&#x27;atguigu&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 计算</span><br>  <span class="hljs-attr">getters</span>:&#123;<br>    <span class="hljs-attr">bigSum</span>:(state):<span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> state.<span class="hljs-property">sum</span> *<span class="hljs-number">10</span>,<br>    <span class="hljs-title function_">upperSchool</span>():string&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>. school.<span class="hljs-title function_">toUpperCase</span>()<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>组件中读取数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;increment,decrement&#125; = countStore<br><span class="hljs-keyword">let</span> &#123;sum,school,bigSum,upperSchool&#125; = <span class="hljs-title function_">storeToRefs</span>(countStore)<br></code></pre></td></tr></table></figure></li></ol><h2 id="5-7-【-subscribe】"><a href="#5-7-【-subscribe】" class="headerlink" title="5.7.【$subscribe】"></a>5.7.【$subscribe】</h2><p>通过 store 的 <code>$subscribe()</code> 方法侦听 <code>state</code> 及其变化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts">talkStore.$subscribe(<span class="hljs-function">(<span class="hljs-params">mutate,state</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LoveTalk&#x27;</span>,mutate,state)<br>  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;talk&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(talkList.<span class="hljs-property">value</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="5-8-【store组合式写法】"><a href="#5-8-【store组合式写法】" class="headerlink" title="5.8. 【store组合式写法】"></a>5.8. 【store组合式写法】</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> &#123;nanoid&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nanoid&#x27;</span><br><span class="hljs-keyword">import</span> &#123;reactive&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useTalkStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;talk&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// talkList就是state</span><br>  <span class="hljs-keyword">const</span> talkList = <span class="hljs-title function_">reactive</span>(<br>    <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;talkList&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>) || []<br>  )<br><br>  <span class="hljs-comment">// getATalk函数相当于action</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getATalk</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 发请求，下面这行的写法是：连续解构赋值+重命名</span><br>    <span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">data</span>:&#123;<span class="hljs-attr">content</span>:title&#125;&#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;</span>)<br>    <span class="hljs-comment">// 把请求回来的字符串，包装成一个对象</span><br>    <span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">id</span>:<span class="hljs-title function_">nanoid</span>(),title&#125;<br>    <span class="hljs-comment">// 放到数组中</span><br>    talkList.<span class="hljs-title function_">unshift</span>(obj)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;talkList,getATalk&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="6-组件通信"><a href="#6-组件通信" class="headerlink" title="6. 组件通信"></a>6. 组件通信</h1><p><strong><code>Vue3</code>组件通信和<code>Vue2</code>的区别：</strong></p><ul><li>移出事件总线，使用<code>mitt</code>代替。</li></ul><ul><li><code>vuex</code>换成了<code>pinia</code>。</li><li>把<code>.sync</code>优化到了<code>v-model</code>里面了。</li><li>把<code>$listeners</code>所有的东西，合并到<code>$attrs</code>中了。</li><li><code>$children</code>被砍掉了。</li></ul><p><strong>常见搭配形式：</strong></p><img src="/2025/12/17/前端学习/Vue3快速上手/image-20231119185900990-1765979249042-16.png" alt="image-20231119185900990" style="zoom:60%;"> <h2 id="6-1-【props】"><a href="#6-1-【props】" class="headerlink" title="6.1. 【props】"></a>6.1. 【props】</h2><p>概述：<code>props</code>是使用频率最高的一种通信方式，常用与 ：<strong>父 ↔ 子</strong>。</p><ul><li>若 <strong>父传子</strong>：属性值是<strong>非函数</strong>。</li><li>若 <strong>子传父</strong>：属性值是<strong>函数</strong>。</li></ul><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    &lt;h3&gt;父组件，&lt;/h3&gt;<br>&lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;<br>&lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot;/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;<br>import Child from &#x27;./Child.vue&#x27;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>// 数据<br>const car = ref(&#x27;奔驰&#x27;)<br>const toy = ref()<br>// 方法<br>function getToy(value:string)&#123;<br>toy.value = value<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child&quot;&gt;<br>    &lt;h3&gt;子组件&lt;/h3&gt;<br>&lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>&lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>const toy = ref(&#x27;奥特曼&#x27;)<br><br>defineProps([&#x27;car&#x27;,&#x27;getToy&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="6-2-【自定义事件】"><a href="#6-2-【自定义事件】" class="headerlink" title="6.2. 【自定义事件】"></a>6.2. 【自定义事件】</h2><ol><li>概述：自定义事件常用于：<strong>子 &#x3D;&gt; 父。</strong></li><li>注意区分好：原生事件、自定义事件。</li></ol><ul><li>原生事件：<ul><li>事件名是特定的（<code>click</code>、<code>mosueenter</code>等等）</li><li>事件对象<code>$event</code>: 是包含事件相关信息的对象（<code>pageX</code>、<code>pageY</code>、<code>target</code>、<code>keyCode</code>）</li></ul></li><li>自定义事件：<ul><li>事件名是任意名称</li><li><strong style="color:red">事件对象<code>$event</code>: 是调用<code>emit</code>时所提供的数据，可以是任意类型！！！</strong></li></ul></li></ul><ol start="3"><li><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> @<span class="hljs-attr">send-toy</span>=<span class="hljs-string">&quot;toy = $event&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toy = $event&quot;</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子组件中，触发事件：</span><br><span class="hljs-keyword">let</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;send-toy&#x27;</span>])<br><span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>, value)<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-3-【mitt】"><a href="#6-3-【mitt】" class="headerlink" title="6.3. 【mitt】"></a>6.3. 【mitt】</h2><p>概述：与消息订阅与发布（<code>pubsub</code>）功能类似，可以实现任意组件间通信。</p><p>安装<code>mitt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i mitt<br></code></pre></td></tr></table></figure><p>新建文件：<code>src\utils\emitter.ts</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入mitt </span><br><span class="hljs-keyword">import</span> mitt <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mitt&quot;</span>;<br><br><span class="hljs-comment">// 创建emitter</span><br><span class="hljs-keyword">const</span> emitter = <span class="hljs-title function_">mitt</span>()<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  // 绑定事件</span><br><span class="hljs-comment">  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;</span><br><span class="hljs-comment">    console.log(&#x27;abc事件被触发&#x27;,value)</span><br><span class="hljs-comment">  &#125;)</span><br><span class="hljs-comment">  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;</span><br><span class="hljs-comment">    console.log(&#x27;xyz事件被触发&#x27;,value)</span><br><span class="hljs-comment">  &#125;)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  setInterval(() =&gt; &#123;</span><br><span class="hljs-comment">    // 触发事件</span><br><span class="hljs-comment">    emitter.emit(&#x27;abc&#x27;,666)</span><br><span class="hljs-comment">    emitter.emit(&#x27;xyz&#x27;,777)</span><br><span class="hljs-comment">  &#125;, 1000);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  setTimeout(() =&gt; &#123;</span><br><span class="hljs-comment">    // 清理事件</span><br><span class="hljs-comment">    emitter.all.clear()</span><br><span class="hljs-comment">  &#125;, 3000); </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 创建并暴露mitt</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> emitter<br></code></pre></td></tr></table></figure><p>接收数据的组件中：绑定事件、同时在销毁前解绑事件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/emitter&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-comment">// 绑定事件</span><br>emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;send-toy事件被触发&#x27;</span>,value)<br>&#125;)<br><br><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// 解绑事件</span><br>  emitter.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>【第三步】：提供数据的组件，在合适的时候触发事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> emitter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/emitter&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendToy</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">// 触发事件</span><br>  emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;send-toy&#x27;</span>,toy.<span class="hljs-property">value</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意这个重要的内置关系，总线依赖着这个内置关系</strong></p><h2 id="6-4-【v-model】"><a href="#6-4-【v-model】" class="headerlink" title="6.4.【v-model】"></a>6.4.【v-model】</h2><ol><li><p>概述：实现 <strong>父↔子</strong> 之间相互通信。</p></li><li><p>前序知识 —— <code>v-model</code>的本质</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 使用v-model指令 --&gt;<br>&lt;input type=&quot;text&quot; v-model=&quot;userName&quot;&gt;<br><br>&lt;!-- v-model的本质是下面这行代码 --&gt;<br>&lt;input <br>  type=&quot;text&quot; <br>  :value=&quot;userName&quot; <br>  @input=&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;<br>&gt;<br></code></pre></td></tr></table></figure></li><li><p>组件标签上的<code>v-model</code>的本质：<code>:moldeValue</code> ＋ <code>update:modelValue</code>事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 组件标签上使用v-model指令 --&gt;<br>&lt;AtguiguInput v-model=&quot;userName&quot;/&gt;<br><br>&lt;!-- 组件标签上v-model的本质 --&gt;<br>&lt;AtguiguInput :modelValue=&quot;userName&quot; @update:model-value=&quot;userName = $event&quot;/&gt;<br></code></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;box&quot;&gt;<br>    &lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;<br>&lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;<br>    &lt;input <br>       type=&quot;text&quot; <br>       :value=&quot;modelValue&quot; <br>       @input=&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;<br>    &gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;<br>  // 接收props<br>  defineProps([&#x27;modelValue&#x27;])<br>  // 声明事件<br>  const emit = defineEmits([&#x27;update:model-value&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>也可以更换<code>value</code>，例如改成<code>abc</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 也可以更换value，例如改成abc--&gt;<br>&lt;AtguiguInput v-model:abc=&quot;userName&quot;/&gt;<br><br>&lt;!-- 上面代码的本质如下 --&gt;<br>&lt;AtguiguInput :abc=&quot;userName&quot; @update:abc=&quot;userName = $event&quot;/&gt;<br></code></pre></td></tr></table></figure><p><code>AtguiguInput</code>组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;box&quot;&gt;<br>    &lt;input <br>       type=&quot;text&quot; <br>       :value=&quot;abc&quot; <br>       @input=&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;<br>    &gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;AtguiguInput&quot;&gt;<br>  // 接收props<br>  defineProps([&#x27;abc&#x27;])<br>  // 声明事件<br>  const emit = defineEmits([&#x27;update:abc&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>如果<code>value</code>可以更换，那么就可以在组件标签上多次使用<code>v-model</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;AtguiguInput v-model:abc=&quot;userName&quot; v-model:xyz=&quot;password&quot;/&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-5-【-attrs-】"><a href="#6-5-【-attrs-】" class="headerlink" title="6.5.【$attrs 】"></a>6.5.【$attrs 】</h2><ol><li><p>概述：<code>$attrs</code>用于实现<strong>当前组件的父组件</strong>，向<strong>当前组件的子组件</strong>通信（<strong>祖→孙</strong>）。</p></li><li><p>具体说明：<code>$attrs</code>是一个对象，包含所有父组件传入的标签属性。</p><blockquote><p> 注意：<code>$attrs</code>会自动排除<code>props</code>中声明的属性(可以认为声明过的 <code>props</code> 被子组件自己“消费”了)</p></blockquote></li></ol><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    &lt;h3&gt;父组件&lt;/h3&gt;<br>&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot; :updateA=&quot;updateA&quot;/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;<br>import Child from &#x27;./Child.vue&#x27;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>let a = ref(1)<br>let b = ref(2)<br>let c = ref(3)<br>let d = ref(4)<br><br>function updateA(value)&#123;<br>a.value = value<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;child&quot;&gt;<br>&lt;h3&gt;子组件&lt;/h3&gt;<br>&lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;<br>import GrandChild from &#x27;./GrandChild.vue&#x27;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>孙组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;grand-child&quot;&gt;<br>&lt;h3&gt;孙组件&lt;/h3&gt;<br>&lt;h4&gt;a：&#123;&#123; a &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;b：&#123;&#123; b &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;c：&#123;&#123; c &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;d：&#123;&#123; d &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;x：&#123;&#123; x &#125;&#125;&lt;/h4&gt;<br>&lt;h4&gt;y：&#123;&#123; y &#125;&#125;&lt;/h4&gt;<br>&lt;button @click=&quot;updateA(666)&quot;&gt;点我更新A&lt;/button&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;<br>defineProps([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;updateA&#x27;])<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="6-6-【-refs、-parent】"><a href="#6-6-【-refs、-parent】" class="headerlink" title="6.6. 【$refs、$parent】"></a>6.6. 【$refs、$parent】</h2><ol><li><p>概述：</p><ul><li><code>$refs</code>用于 ：<strong>父→子。</strong></li><li><code>$parent</code>用于：<strong>子→父。</strong></li></ul></li><li><p>原理如下：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>$refs</code></td><td>值为对象，包含所有被<code>ref</code>属性标识的<code>DOM</code>元素或组件实例。</td></tr><tr><td><code>$parent</code></td><td>值为对象，当前组件的父组件实例对象。</td></tr></tbody></table></li></ol><p>比如:在父组件挂载完毕获取组件实例</p><p>父组件内部代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h1&gt;ref与$parent&lt;/h1&gt;<br>    &lt;Son ref=&quot;son&quot;&gt;&lt;/Son&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import Son from &quot;./Son.vue&quot;;<br>import &#123; onMounted, ref &#125; from &quot;vue&quot;;<br>const son = ref();<br>onMounted(() =&gt; &#123;<br>  console.log(son.value);<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>但是需要注意，如果想让父组件获取子组件的数据或者方法需要通过defineExpose对外暴露,因为vue3中组件内部的数据对外“关闭的”，外部不能访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref &#125; from &quot;vue&quot;;<br>//数据<br>let money = ref(1000);<br>//方法<br>const handler = ()=&gt;&#123;<br>&#125;<br>defineExpose(&#123;<br>  money,<br>   handler<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>$parent可以获取某一个组件的父组件实例VC,因此可以使用父组件内部的数据与方法。必须子组件内部拥有一个按钮点击时候获取父组件实例，当然父组件的数据与方法需要通过defineExpose方法对外暴露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click=&quot;handler($parent)&quot;&gt;点击我获取父组件实例&lt;/button&gt;<br></code></pre></td></tr></table></figure><h2 id="6-7-【provide、inject】"><a href="#6-7-【provide、inject】" class="headerlink" title="6.7. 【provide、inject】"></a>6.7. 【provide、inject】</h2><ol><li><p>概述：实现<strong>祖孙组件</strong>直接通信</p></li><li><p>具体使用：</p><ul><li>在祖先组件中通过<code>provide</code>配置向后代组件提供数据</li><li>在后代组件中通过<code>inject</code>配置来声明接收数据</li></ul></li><li><p>具体编码：</p><p>【第一步】父组件中，使用<code>provide</code>提供数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;father&quot;&gt;<br>    &lt;h3&gt;父组件&lt;/h3&gt;<br>    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;<br>    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt;<br>    &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt;<br>    &lt;Child/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;<br>  import Child from &#x27;./Child.vue&#x27;<br>  import &#123; ref,reactive,provide &#125; from &quot;vue&quot;;<br>  // 数据<br>  let money = ref(100)<br>  let car = reactive(&#123;<br>    brand:&#x27;奔驰&#x27;,<br>    price:100<br>  &#125;)<br>  // 用于更新money的方法<br>  function updateMoney(value:number)&#123;<br>    money.value += value<br>  &#125;<br>  // 提供数据<br>  provide(&#x27;moneyContext&#x27;,&#123;money,updateMoney&#125;)<br>  provide(&#x27;car&#x27;,car)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注意：子组件中不用编写任何东西，是不受到任何打扰的</p></blockquote><p>【第二步】孙组件中使用<code>inject</code>配置项接受数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;grand-child&quot;&gt;<br>    &lt;h3&gt;我是孙组件&lt;/h3&gt;<br>    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;<br>    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;<br>    &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;<br>  import &#123; inject &#125; from &#x27;vue&#x27;;<br>  // 注入数据<br> let &#123;money,updateMoney&#125; = inject(&#x27;moneyContext&#x27;,&#123;money:0,updateMoney:(x:number)=&gt;&#123;&#125;&#125;)<br>  let car = inject(&#x27;car&#x27;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-8-【pinia】"><a href="#6-8-【pinia】" class="headerlink" title="6.8. 【pinia】"></a>6.8. 【pinia】</h2><p>参考之前<code>pinia</code>部分的讲解</p><h2 id="6-9-【slot】"><a href="#6-9-【slot】" class="headerlink" title="6.9. 【slot】"></a>6.9. 【slot】</h2><h3 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="1. 默认插槽"></a>1. 默认插槽</h3><img src="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/default_slot.png" class title="img"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category title=&quot;今日热门游戏&quot;&gt;<br>          &lt;ul&gt;<br>            &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>          &lt;/ul&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>          &lt;div class=&quot;item&quot;&gt;<br>            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;<br>            &lt;!-- 默认插槽 --&gt;<br>            &lt;slot&gt;&lt;/slot&gt;<br>          &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>        &lt;Category title=&quot;今日热门游戏&quot;&gt;<br>          &lt;template v-slot:s1&gt;<br>            &lt;ul&gt;<br>              &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>            &lt;/ul&gt;<br>          &lt;/template&gt;<br>          &lt;template #s2&gt;<br>            &lt;a href=&quot;&quot;&gt;更多&lt;/a&gt;<br>          &lt;/template&gt;<br>        &lt;/Category&gt;<br>子组件中：<br>        &lt;template&gt;<br>          &lt;div class=&quot;item&quot;&gt;<br>            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;<br>            &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;<br>            &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;<br>          &lt;/div&gt;<br>        &lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h3><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（新闻数据在<code>News</code>组件中，但使用数据所遍历出来的结构由<code>App</code>组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件中：<br>      &lt;Game v-slot=&quot;params&quot;&gt;<br>      &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt;<br>      &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;<br>        &lt;ul&gt;<br>          &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;<br>        &lt;/ul&gt;<br>      &lt;/Game&gt;<br><br>子组件中：<br>      &lt;template&gt;<br>        &lt;div class=&quot;category&quot;&gt;<br>          &lt;h2&gt;今日游戏榜单&lt;/h2&gt;<br>          &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot;&gt;&lt;/slot&gt;<br>        &lt;/div&gt;<br>      &lt;/template&gt;<br><br>      &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt;<br>        import &#123;reactive&#125; from &#x27;vue&#x27;<br>        let games = reactive([<br>          &#123;id:&#x27;asgdytsa01&#x27;,name:&#x27;英雄联盟&#x27;&#125;,<br>          &#123;id:&#x27;asgdytsa02&#x27;,name:&#x27;王者荣耀&#x27;&#125;,<br>          &#123;id:&#x27;asgdytsa03&#x27;,name:&#x27;红色警戒&#x27;&#125;,<br>          &#123;id:&#x27;asgdytsa04&#x27;,name:&#x27;斗罗大陆&#x27;&#125;<br>        ])<br>      &lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h1 id="7-其它-API"><a href="#7-其它-API" class="headerlink" title="7. 其它 API"></a>7. 其它 API</h1><h2 id="7-1-【shallowRef-与-shallowReactive-】"><a href="#7-1-【shallowRef-与-shallowReactive-】" class="headerlink" title="7.1.【shallowRef 与 shallowReactive 】"></a>7.1.【shallowRef 与 shallowReactive 】</h2><h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a><code>shallowRef</code></h3><ol><li><p>作用：创建一个响应式数据，但只对顶层属性进行响应式处理。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myVar = <span class="hljs-title function_">shallowRef</span>(initialValue);<br></code></pre></td></tr></table></figure></li><li><p>特点：只跟踪引用值的变化，不关心值内部的属性变化。</p></li></ol><h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a><code>shallowReactive</code></h3><ol><li><p>作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myObj = <span class="hljs-title function_">shallowReactive</span>(&#123; ... &#125;);<br></code></pre></td></tr></table></figure></li><li><p>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>通过使用 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowref"><code>shallowRef()</code></a> 和 <a href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive"><code>shallowReactive()</code></a> 来绕开深度响应。浅层式 <code>API</code> 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。</p></blockquote><h2 id="7-2-【readonly-与-shallowReadonly】"><a href="#7-2-【readonly-与-shallowReadonly】" class="headerlink" title="7.2.【readonly 与 shallowReadonly】"></a>7.2.【readonly 与 shallowReadonly】</h2><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><strong><code>readonly</code></strong></h3><ol><li><p>作用：用于创建一个对象的深只读副本。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> original = <span class="hljs-title function_">reactive</span>(&#123; ... &#125;);<br><span class="hljs-keyword">const</span> readOnlyCopy = <span class="hljs-title function_">readonly</span>(original);<br></code></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li>对象的所有嵌套属性都将变为只读。</li><li>任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。</li></ul></li><li><p>应用场景：</p><ul><li>创建不可变的状态快照。</li><li>保护全局状态或配置不被修改。</li></ul></li></ol><h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a><strong><code>shallowReadonly</code></strong></h3><ol><li><p>作用：与 <code>readonly</code> 类似，但只作用于对象的顶层属性。</p></li><li><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> original = <span class="hljs-title function_">reactive</span>(&#123; ... &#125;);<br><span class="hljs-keyword">const</span> shallowReadOnlyCopy = <span class="hljs-title function_">shallowReadonly</span>(original);<br></code></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li><p>只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。</p></li><li><p>适用于只需保护对象顶层属性的场景。</p></li></ul></li></ol><h2 id="7-3-【toRaw-与-markRaw】"><a href="#7-3-【toRaw-与-markRaw】" class="headerlink" title="7.3.【toRaw 与 markRaw】"></a>7.3.【toRaw 与 markRaw】</h2><h3 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a><code>toRaw</code></h3><ol><li><p>作用：用于获取一个响应式对象的原始对象， <code>toRaw</code> 返回的对象不再是响应式的，不会触发视图更新。</p><blockquote><p>官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。</p></blockquote><blockquote><p>何时使用？ —— 在需要将响应式对象传递给非 <code>Vue</code> 的库或外部系统时，使用 <code>toRaw</code> 可以确保它们收到的是普通对象</p></blockquote></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive,toRaw,markRaw,isReactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-comment">/* toRaw */</span><br><span class="hljs-comment">// 响应式对象</span><br><span class="hljs-keyword">let</span> person = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tony&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;)<br><span class="hljs-comment">// 原始对象</span><br><span class="hljs-keyword">let</span> rawPerson = <span class="hljs-title function_">toRaw</span>(person)<br><br><br><span class="hljs-comment">/* markRaw */</span><br><span class="hljs-keyword">let</span> citysd = <span class="hljs-title function_">markRaw</span>([<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda01&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;北京&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda02&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;上海&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda03&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;天津&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda04&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;重庆&#x27;</span>&#125;<br>])<br><span class="hljs-comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span><br><span class="hljs-keyword">let</span> citys2 = <span class="hljs-title function_">reactive</span>(citys)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(person))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(rawPerson))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(citys))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isReactive</span>(citys2))<br></code></pre></td></tr></table></figure></li></ol><h3 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a><code>markRaw</code></h3><ol><li><p>作用：标记一个对象，使其<strong>永远不会</strong>变成响应式的。</p><blockquote><p>例如使用<code>mockjs</code>时，为了防止误把<code>mockjs</code>变为响应式对象，可以使用 <code>markRaw</code> 去标记<code>mockjs</code></p></blockquote></li><li><p>编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* markRaw */</span><br><span class="hljs-keyword">let</span> citys = <span class="hljs-title function_">markRaw</span>([<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda01&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;北京&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda02&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;上海&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda03&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;天津&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">id</span>:<span class="hljs-string">&#x27;asdda04&#x27;</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;重庆&#x27;</span>&#125;<br>])<br><span class="hljs-comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span><br><span class="hljs-keyword">let</span> citys2 = <span class="hljs-title function_">reactive</span>(citys)<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-4-【customRef】"><a href="#7-4-【customRef】" class="headerlink" title="7.4.【customRef】"></a>7.4.【customRef】</h2><p>作用：创建一个自定义的<code>ref</code>，并对其依赖项跟踪和更新触发进行逻辑控制。</p><p>实现防抖效果（<code>useSumRef.ts</code>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;customRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">initValue</span>:<span class="hljs-built_in">string</span>,<span class="hljs-attr">delay</span>:<span class="hljs-built_in">number</span></span>)&#123;<br>  <span class="hljs-keyword">let</span> msg = <span class="hljs-title function_">customRef</span>(<span class="hljs-function">(<span class="hljs-params">track,trigger</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">timer</span>:<span class="hljs-built_in">number</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">track</span>() <span class="hljs-comment">// 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新</span><br>        <span class="hljs-keyword">return</span> initValue<br>      &#125;,<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer)<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          initValue = value<br>          <span class="hljs-title function_">trigger</span>() <span class="hljs-comment">//通知Vue数据msg变化了</span><br>        &#125;, delay);<br>      &#125;<br>    &#125;<br>  &#125;) <br>  <span class="hljs-keyword">return</span> &#123;msg&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组件中使用：</p><h1 id="8-Vue3新组件"><a href="#8-Vue3新组件" class="headerlink" title="8. Vue3新组件"></a>8. Vue3新组件</h1><h2 id="8-1-【Teleport】"><a href="#8-1-【Teleport】" class="headerlink" title="8.1. 【Teleport】"></a>8.1. 【Teleport】</h2><ul><li>什么是Teleport？—— Teleport 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;body&#x27;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是一个弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是弹窗中的一些内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-2-【Suspense】"><a href="#8-2-【Suspense】" class="headerlink" title="8.2. 【Suspense】"></a>8.2. 【Suspense】</h2><ul><li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验 </li><li>使用步骤： <ul><li>异步引入组件</li><li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li></ul></li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent,<span class="hljs-title class_">Suspense</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Child.vue&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div class=&quot;app&quot;&gt;<br>        &lt;h3&gt;我是App组件&lt;/h3&gt;<br>        &lt;Suspense&gt;<br>          &lt;template v-slot:default&gt;<br>            &lt;Child/&gt;<br>          &lt;/template&gt;<br>          &lt;template v-slot:fallback&gt;<br>            &lt;h3&gt;加载中.......&lt;/h3&gt;<br>          &lt;/template&gt;<br>        &lt;/Suspense&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="8-3-【全局API转移到应用对象】"><a href="#8-3-【全局API转移到应用对象】" class="headerlink" title="8.3.【全局API转移到应用对象】"></a>8.3.【全局API转移到应用对象】</h2><ul><li><code>app.component</code></li><li><code>app.config</code></li><li><code>app.directive</code></li><li><code>app.mount</code></li><li><code>app.unmount</code></li><li><code>app.use</code></li></ul><h2 id="8-4-【其他】"><a href="#8-4-【其他】" class="headerlink" title="8.4.【其他】"></a>8.4.【其他】</h2><ul><li><p>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</p></li><li><p><code>keyCode</code> 作为 <code>v-on</code> 修饰符的支持。</p></li><li><p><code>v-model</code> 指令在组件上的使用已经被重新设计，替换掉了 <code>v-bind.sync。</code></p></li><li><p><code>v-if</code> 和 <code>v-for</code> 在同一个元素身上使用时的优先级发生了变化。</p></li><li><p>移除了<code>$on</code>、<code>$off</code> 和 <code>$once</code> 实例方法。</p></li><li><p>移除了过滤器 <code>filter</code>。</p></li><li><p>移除了<code>$children</code> 实例 <code>propert</code>。</p><p>……</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.Promise与JS异步</title>
    <link href="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/4-Promise%E4%B8%8EJS%E5%BC%82%E6%AD%A5/"/>
    <url>/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/4-Promise%E4%B8%8EJS%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<ol><li>为什么要引入Promise？</li><li>如何理解Promise？</li><li>什么是微任务与宏任务？</li><li>async 和 await 的原理和作用是什么？</li></ol><span id="more"></span><h2 id="Promise-与-JS异步-微任务与宏任务-async-与-await"><a href="#Promise-与-JS异步-微任务与宏任务-async-与-await" class="headerlink" title="Promise 与 JS异步 &#x2F; 微任务与宏任务 &#x2F; async 与 await"></a>Promise 与 JS异步 &#x2F; 微任务与宏任务 &#x2F; async 与 await</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#Promise%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93">NodeJS核心总结 - 相</a></p><p><a href="https://lilichao.com/?p=6460">异步编程 – 李立超 | lilichao.com</a></p><p><a href="https://www.bilibili.com/video/BV1qN4y1A7jM?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=3">03_Promise介绍_哔哩哔哩_bilibili</a></p></blockquote><p>推荐B站李立超老师的教学视频和笔记，重点突出且内容精简，已针对老师视频和资料做了详细的总结。</p><hr><h3 id="1-Promise的引入"><a href="#1-Promise的引入" class="headerlink" title="1.Promise的引入"></a>1.Promise的引入</h3><p><strong>Promise 在 JavaScript 中用于实现异步编程？</strong></p><p>在 JavaScript 中，<strong>异步编程</strong>是为了解决<strong>单线程模型下的耗时操作不阻塞主线程</strong>的问题。</p><p>JavaScript 本身是<strong>单线程执行</strong>的，所有代码默认是同步执行的。如果将网络请求、文件读取、定时器等<strong>耗时操作</strong>都以同步方式执行，会直接阻塞主线程，导致页面卡顿甚至失去响应。</p><p>与JAVA等语言通过多线程的方式不同，为了解决这个问题，JavaScript 采用了<strong>异步机制</strong>：</p><ul><li>将耗时任务<strong>交给宿主环境（如浏览器或 Node.js）中的异步 API 执行</strong></li><li>当异步操作完成后，宿主环境会把对应的回调任务<strong>以事件的形式放入任务队列</strong></li><li>JavaScript 主线程通过事件循环机制，在合适的时机取出这些任务并执行回调函数</li></ul><p>这就是 JavaScript 异步执行的基本原理，例如：<code>setTimeout</code> 的异步任务由<strong>宿主环境执行</strong>，计时完成后，宿主环境将<strong>回调函数作为一个宏任务放入任务队列</strong>；当 JS 主线程空闲时，事件循环机制会将该回调函数取出并压入调用栈执行。</p><p><strong>最早的异步方案：回调函数</strong></p><p>JavaScript 最早通过<strong>回调函数（callback）</strong>来处理异步操作：在发起异步任务时传入一个回调函数，等任务完成后再调用该回调处理结果。</p><p>但回调方式存在明显缺陷：</p><ol><li>多层异步嵌套会形成“<strong>回调地狱</strong>”，代码结构混乱、可读性差</li><li>错误处理分散在各个回调中，难以统一管理</li><li>异步流程不直观，不利于维护和扩展</li></ol><p><strong>Promise 的作用</strong></p><p>为了解决回调函数的问题，ES6 引入了 <strong>Promise</strong>。</p><p><strong>Promise 本质上是一个用于描述“异步操作最终结果”的对象</strong>，它有三种状态：</p><ul><li><code>pending</code>（进行中）</li><li><code>fulfilled</code>（已成功）</li><li><code>rejected</code>（已失败）</li></ul><p>Promise 的核心价值在于：</p><ol><li><strong>支持链式调用</strong>（<code>then</code> &#x2F; <code>catch</code>），避免回调地狱</li><li><strong>统一错误处理</strong>，异常可以沿链向下传递</li><li><strong>使异步流程更清晰</strong>，逻辑结构更接近同步代码</li><li>为 <code>async / await</code> 提供了基础能力</li></ol><p><strong>总结一句话</strong></p><p>JavaScript 的异步编程是通过将耗时任务交给宿主环境执行、再通过事件机制回到主线程完成的；Promise 通过<font color="#409eff">状态管理</font>和<font color="#409eff">链式调用</font>，解决了回调函数在可读性、错误处理和维护性上的问题，是现代 JavaScript 异步编程的核心基础。</p><h3 id="2-Promise介绍"><a href="#2-Promise介绍" class="headerlink" title="2.Promise介绍"></a>2.Promise介绍</h3><h4 id="【状态管理】"><a href="#【状态管理】" class="headerlink" title="【状态管理】"></a>【状态管理】</h4><p>首先要明确一点：<strong>Promise 本质上也是一个对象</strong>，它的作用是用来“保存数据”。<br> 那它和普通对象（比如 <code>&#123;&#125;</code>、<code>Map</code>）有什么本质区别？</p><p>区别不在于“能不能存数据”，而在于——<strong>Promise 专门用来存储「异步任务的结果」</strong>。</p><p><strong>异步任务有一个天然的问题：结果不是立即产生的，而是在未来某个时间点才会出现。</strong>因此，异步任务在设计上必须依赖<strong>回调函数</strong>来“通知结果已经产生”。</p><p>这样的回调函数再Promise中有两个，<code>resolve</code>表示任务成功时的回调，<code>reject</code> 表示失败时的回调，最原始的异步模型大致是这样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AsynchronousFunction</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-title class_">AsynchronousFunction</span>(<span class="hljs-function">(<span class="hljs-params">args</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">args</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里的 <code>AsynchronousFunction</code> 并不是返回结果，而是<strong>在未来的某个时间点主动调用回调函数</strong>。</p><p>在 Promise 中，<code>resolve</code> 和 <code>reject</code> <strong>不再负责“打印结果”或“立刻处理结果”</strong>，<br> 而是负责——<strong>把结果保存到 Promise 对象内部</strong>。</p><p>因此，异步函数不再是我们自己调用的函数，而是作为 <strong>Promise 构造函数的参数</strong>：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这段代码里有两个非常重要的点：</p><ol><li><code>new Promise(...)</code> 会<strong>立刻执行</strong>传入的函数</li><li>异步任务在这个函数内部执行，结果通过 <code>resolve / reject</code> 存入 Promise</li></ol><p>此时，Promise 对象已经创建完成了，但异步任务还没有结束。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise) <span class="hljs-comment">// PromiseState = &#x27;pending&#x27;, PromiseResult = &#x27;undefined&#x27;</span><br></code></pre></td></tr></table></figure><p>如果我们立刻读取这个 Promise是读不到结果的。原因是数据还没回来。这个时候我们就需要<font color="#409eff">promise告诉我们任务是否结束</font>，也就是当前的状态，这里就引出了 Promise 的第一个核心能力：<strong>状态管理</strong>。</p><p>Promise 内部维护了两个“隐藏属性”：</p><ul><li><code>PromiseState</code>：表示当前状态</li><li><code>PromiseResult</code>：真正存储数据的位置</li></ul><p>Promise 一共有三种状态：</p><ul><li><code>pending</code>：初始状态，异步任务尚未完成</li><li><code>fulfilled</code>：任务成功完成，数据通过 <code>resolve</code> 存入</li><li><code>rejected</code>：任务失败或抛出异常，数据通过 <code>reject</code> 或错误存入</li></ul><p>状态变化只有一种方向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">pending → fulfilled<br>pending → rejected<br></code></pre></td></tr></table></figure><p><strong>一旦状态发生变化，就不可逆转</strong>。<br> 这也意味着：</p><ul><li><code>resolve</code> 和 <code>reject</code> 只能有一个生效</li><li>且只能执行一次</li></ul><p>当异步任务完成后，Promise 内部会变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(promise)<br>    <span class="hljs-comment">// PromiseState: &quot;fulfilled&quot;</span><br>    <span class="hljs-comment">// PromiseResult: &quot;哈哈&quot;</span><br>&#125;, <span class="hljs-number">11000</span>)<br></code></pre></td></tr></table></figure><p>问题到这里就变成了：</p><p><em><strong>既然不能同步读取 PromiseResult，那怎么才能在“合适的时机”拿到结果？</strong></em></p><p>答案就是：<code>then</code>。</p><p><code>then</code> 是 Promise 的实例方法，用来<strong>注册“当状态发生变化后要执行的回调函数”</strong>。</p><ul><li>当 Promise 变为 <code>fulfilled</code> 时，执行第一个回调</li><li>当 Promise 变为 <code>rejected</code> 时，执行第二个回调</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>这里的关键不是“then 能拿到数据”，而是<strong>then 会被 Promise 主动调用，而不是我们去“轮询”Promise 的状态。</strong></p><p>这也是 Promise 相比定时器、回调嵌套最大的进步。</p><p>在实际开发中，为了让错误处理更集中，通常会使用 <code>catch</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">promise<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>    &#125;)<br></code></pre></td></tr></table></figure><p><code>catch</code> 本质上只关心 <code>rejected</code> 状态。</p><p>此外，Promise 还提供了 <code>finally</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;无论成功还是失败都会执行&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>finally</code> 不接收结果参数，也不区分状态，它只关心一件事：<strong>这个异步任务“结束了”。</strong></p><h4 id="【链式调用】"><a href="#【链式调用】" class="headerlink" title="【链式调用】"></a>【链式调用】</h4><p>到这里我们已经知道，Promise 的核心作用是：<br> <strong>通过状态管理，在合适的时间点取到异步任务的结果</strong>。</p><p>但仅仅能“取到结果”还不够。真实开发中，异步任务往往不是一步，而是<strong>多个异步步骤顺序执行</strong>，并且要求：</p><ol><li>上一步的结果作为下一步的输入</li><li>错误能够统一处理</li><li>代码不能层层嵌套形成“回调地狱”</li></ol><p>这正是 Promise 的<strong>链式调用</strong>要解决的问题。</p><p>那么，什么是链式调用？</p><p>从语法角度看，链式调用并不神秘，它只依赖一个条件：<strong>一个对象的方法，返回的还是一个对象，并且这个对象也具有相同的方法。</strong></p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">object.<span class="hljs-title function_">method1</span>().<span class="hljs-title function_">method2</span>().<span class="hljs-title function_">method3</span>()<br></code></pre></td></tr></table></figure><p>只要 <code>method1</code> 的返回值仍然是一个拥有 <code>method2</code> 的对象，这个链条就可以一直写下去。</p><p>如果某个方法返回的还是同一个对象实例，那么形式可能变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">object.<span class="hljs-title function_">method1</span>().<span class="hljs-title function_">method1</span>().<span class="hljs-title function_">method1</span>()<br></code></pre></td></tr></table></figure><p>而 Promise 的 <code>then</code>，正是基于这种思想设计的。</p><p>关键结论是：<strong>每一次 <code>then</code> 执行，都会返回一个全新的 Promise 对象。</strong></p><p>这个新的 Promise 会把 <code>then</code> 回调函数的<strong>返回值</strong>作为自己的结果保存起来：</p><ul><li>如果 <code>then</code> 中 <strong>返回普通值</strong><br> → 这个值会被包装成一个“已成功的 Promise”</li><li>如果 <strong>没有显式 return</strong><br> → 新 Promise 的结果为 <code>undefined</code></li><li>如果 <strong>返回的是一个 Promise</strong><br> → 新 Promise 会“等待”这个 Promise 的结果</li></ul><p>先看一个最直观的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> promise2 = promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> promise3 = promise2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这里并没有发生什么“魔法”，只是：</p><ol><li>第一个 Promise 成功</li><li><code>then</code> 被触发</li><li><code>then</code> 返回一个值</li><li>这个值被存入<strong>新的 Promise</strong></li><li>下一个 <code>then</code> 再从这个新 Promise 中取值</li></ol><p>因为 <code>then</code> 返回的一定是 Promise，所以这段代码完全可以写成链式形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br>promise<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span><br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>这样写的本质是：<strong>把“嵌套的回调结构”，改造成“值的顺序传递模型”。</strong></p><p>也正因为每一步都只是“返回一个值或 Promise”，代码结构从“向右不断缩进”，变成了“从上到下线性展开”，这就从根本上解决了<strong>回调地狱</strong>的问题。</p><p>接下来是另一个关键问题：<strong>错误应该怎么处理？</strong></p><p>如果在每一个 <code>then</code> 中都写错误处理代码，不但冗余，而且很难维护。Promise 提供的做法是：**统一在链条末尾使用 <code>catch</code>**。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哎呀出错了，随便返回一个吧&quot;</span>, <span class="hljs-number">8888</span>)<br>    &#125;)<br></code></pre></td></tr></table></figure><p>这段代码里有一个非常重要但常被忽略的规则：<strong>只要前面的 Promise 链条处于“正常 fulfilled 状态”，<code>catch</code> 就不会执行，将参数不变地封装成一个新的 Promise 并返回。</strong></p><p>也就是说：</p><ul><li><code>catch</code> 只会在<strong>某一步返回 rejected 或抛出异常</strong>时触发</li><li>一旦进入 <code>catch</code>，错误就被“接住”了</li><li>如果错误被处理并返回一个值，链条仍然可以继续</li></ul><p>因此可以这样理解：</p><ul><li><code>then</code> 负责<strong>正常流程的结果传递</strong></li><li><code>catch</code> 负责<strong>异常流程的集中处理</strong></li></ul><p>Promise 的链式调用，本质上并不是“连续调用函数”，而是<strong>用 Promise 对象，把“异步执行过程”拆分成一段一段可组合的状态转换。</strong></p><p>到这里，Promise 的三个核心能力已经完整闭合：</p><ol><li>用状态保存异步结果</li><li>用 <code>then</code> 实现顺序依赖</li><li>用 <code>catch</code> 实现统一错误处理</li></ol><h3 id="3-微任务与宏任务"><a href="#3-微任务与宏任务" class="headerlink" title="3.微任务与宏任务"></a>3.微任务与宏任务</h3><p>在 JavaScript 中，代码的执行并不是“写一行、立刻执行一行”，而是基于<strong>事件循环机制（Event Loop）</strong>来完成的。<br> 为了协调同步代码、异步回调以及 UI 渲染，JavaScript 将任务按照执行优先级划分为两类：<strong>宏任务（MacroTask）</strong> 和 <strong>微任务（MicroTask）</strong>。</p><p>ES 规范中定义了一个内部队列，称为 <strong>PromiseJobs</strong>，用于存放由 Promise 产生的回调任务（如 <code>then</code>、<code>catch</code>、<code>finally</code>）。这个队列在实际开发和学习中通常被称为<strong>微任务队列（microtask queue）</strong>。<br> 与之相对，像 <code>setTimeout</code>、<code>setInterval</code> 等 API 所产生的回调，会被放入<strong>宏任务队列（macrotask queue）</strong>。</p><p>当 JavaScript 引擎开始执行代码时，<strong>整个 <code>script</code> 脚本本身会被视为第一个宏任务</strong>，并进入宏任务队列。此时：</p><ul><li>调用栈（Call Stack）为空</li><li>微任务队列为空</li><li>宏任务队列中包含当前脚本任务</li></ul><p><font color="#409eff">事件循环的整体执行流程可以概括为以下几个步骤：</font></p><ol><li>从宏任务队列中取出一个宏任务（最开始就是 <code>script</code>），放入调用栈中执行</li><li>在宏任务执行过程中，如果产生了微任务（例如 Promise 的 <code>then</code> 回调），就将它们加入微任务队列</li><li>当前宏任务执行完成后，调用栈清空，此时<strong>不会立刻执行下一个宏任务</strong></li><li>引擎会立刻检查微任务队列，并按照先进先出的顺序，将所有微任务依次放入调用栈中执行，直到微任务队列被清空</li><li>微任务全部执行完毕后，事件循环才会继续取出下一个宏任务</li><li>重复上述过程，直到所有任务执行完成</li></ol><p>需要特别强调的是：<br> <strong>在一次宏任务执行结束后，微任务队列一定会被“清空执行”，而不是只执行其中一个微任务。</strong></p><p>正是这种调度策略，使得微任务具有比宏任务更高的执行优先级。<br> 因此在实际表现上：</p><ul><li><code>Promise.then / catch / finally</code> 的回调</li><li>总是会比 <code>setTimeout(fn, 0)</code> 更早执行</li></ul><p>这种设计的好处在于：微任务可以在两个宏任务之间，对程序状态进行快速、连续的补充处理，从而保证 Promise 状态变化和链式调用的<strong>一致性与及时性</strong>，同时也提高了程序的整体响应速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-comment">// 2 , 1 </span><br></code></pre></td></tr></table></figure><p>那么现在对于前面提到的一个例子如下，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>整个执行顺序如下：</strong></p><p><strong>宏任务：script（当前整段代码）</strong></p><ul><li>执行 <code>new Promise(...)</code><ul><li>注册定时器（1s 后才可能入宏任务队列）</li></ul></li><li>执行 <code>.then(...)</code><ul><li>把回调登记到 Promise 上（此时不入微任务队列）</li></ul></li></ul><p>1s 后：</p><ul><li><strong>宏任务：timer 回调入队并被执行</strong><ul><li>执行 <code>resolve(&quot;哈哈&quot;)</code><ul><li>Promise fulfilled</li><li><code>then</code> 回调 <strong>入微任务队列</strong></li></ul></li></ul></li><li>timer 宏任务执行完毕</li><li><strong>立刻清空微任务队列</strong><ul><li>执行 <code>then</code> 回调 → <code>console.log(&quot;哈哈&quot;)</code></li></ul></li></ul><p><strong><code>Promise</code>登记过程</strong></p><p>在规范层面，每一个 Promise 内部至少维护这三类“槽位”：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">Promise &#123;<br>  <span class="hljs-string">[[PromiseState]]</span>: pending | fulfilled | rejected<br>  <span class="hljs-string">[[PromiseResult]]</span>: value | reason<br>  <span class="hljs-string">[[PromiseReactions]]</span>: &#123;<br>      fulfillReactions: [],<br>      rejectReactions: []<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>.then()</code> 做的事情，本质上只有三步，当写：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">promise.then(<span class="hljs-keyword">on</span>Fulfilled, <span class="hljs-keyword">on</span>Rejected)<br></code></pre></td></tr></table></figure><p>JS 引擎内部（逻辑等价，不是源码）会做：</p><p>① 创建一个新的 Promise（这是链式调用的根）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">newPromise</span> <span class="hljs-operator">=</span> new Promise(...)<br></code></pre></td></tr></table></figure><p>这个 Promise 还没有状态，是 <code>pending</code>。</p><p>② 把回调“包装成 reaction 对象”：不是简单存一个函数，而是一个<strong>结构体</strong>，类似这样：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-attr">reaction</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br>  onFulfilled,          <span class="hljs-comment">// 成功回调</span><br>  onRejected,           <span class="hljs-comment">// 失败回调</span><br><span class="hljs-symbol">  capability:</span> <span class="hljs-punctuation">&#123;</span><br>    resolve,            <span class="hljs-comment">// newPromise 的 resolve</span><br>    reject              <span class="hljs-comment">// newPromise 的 reject</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这一步非常关键：<strong>reaction 把“当前 Promise 的回调”和“下一个 Promise 的控制权”绑在了一起</strong></p><p>这就是为什么：<code>then</code> 的返回值会由回调的返回值决定</p><p>③ 根据当前 Promise 状态，决定“登记”还是“立刻调度”</p><p><strong>情况 A：当前 Promise 是 <code>pending</code></strong></p><p>此时引擎会做：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">promise.<span class="hljs-string">[[PromiseReactions]]</span>.fulfillReactions.push(reaction)<br>promise.<span class="hljs-string">[[PromiseReactions]]</span>.rejectReactions.push(reaction)<br></code></pre></td></tr></table></figure><p><strong>只登记，不执行，不入队列</strong></p><p>也就是说：<code>.then()</code> 在 pending 状态下只是“订阅事件”，类似 addEventListener</p><p><strong>情况 B：当前 Promise 已经是 <code>fulfilled</code></strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>(100).the<span class="hljs-meta">n</span>(fn)<br></code></pre></td></tr></table></figure><p>此时不会登记到列表，而是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">把 reaction 立刻封装成一个 microtask<br>推入 PromiseJobs（微任务队列）<br></code></pre></td></tr></table></figure><p>这就是为什么：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>().the<span class="hljs-meta">n</span>(fn)<br></code></pre></td></tr></table></figure><p><strong>一定是异步执行的</strong></p><p>情况 C：当前 Promise 已经是 <code>rejected</code></p><p>逻辑完全对称，只走 reject 分支。</p><p><strong>状态一旦切换，Promise 就“封印”了，取出之前登记的 reactions</strong></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> <span class="hljs-variable">each</span> <span class="hljs-variable">reaction</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-variable">fulfillReactions</span>:<br>    <span class="hljs-function"><span class="hljs-title">enqueueMicrotask</span>(<span class="hljs-variable">reaction</span>)</span><br></code></pre></td></tr></table></figure><p>注意这句话非常重要：<strong>是 resolve 触发了微任务的创建，而不是 then</strong></p><h3 id="4-async-和-await"><a href="#4-async-和-await" class="headerlink" title="4.async 和 await"></a>4.async 和 await</h3><p><code>async</code> 和 <code>await</code> 是 ES2017 引入的基于 Promise 的语法糖，用来以同步的书写方式处理异步操作。被 <code>async</code> 修饰的函数会始终返回一个 Promise，当函数返回普通值时会被自动包装成一个已完成状态的 Promise，当函数抛出异常时则会返回一个拒绝状态的 Promise。<code>await</code> 只能在 <code>async</code> 函数中使用，它会暂停函数的执行，等待其后表达式返回的 Promise 完成，并将完成的值作为返回结果，如果 Promise 被拒绝则会抛出异常，需要用 <code>try...catch</code> 来捕获。<font color="#409eff">即使 <code>await</code> 后面不是 Promise，也会被转换成一个已完成的 Promise 再处理。</font><code>async/await</code> 的核心优势是让异步代码看起来像同步代码一样直观，减少回调嵌套和链式 then 带来的可读性问题，同时可以通过 <code>try...catch</code> 统一捕获错误，从而让异步逻辑结构更清晰。但它并没有改变 JavaScript 单线程、事件循环的本质，底层依然是通过 Promise 和微任务机制来调度执行的。</p><h4 id="【async函数】"><a href="#【async函数】" class="headerlink" title="【async函数】"></a>【async函数】</h4><p>async是一个加在函数前的修饰符，用来创建一个异步函数，被async定义的函数会默认返回一个Promise对象resolve的值。</p><p>因此对async函数可以直接then，返回值就是then方法传入的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async基础语法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">fun0</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val) <span class="hljs-comment">// 1,1</span><br>&#125;)<br><br><span class="hljs-comment">// ===&gt; 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">fun1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// Promise Promise</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="【await】"><a href="#【await】" class="headerlink" title="【await】"></a>【await】</h4><p>await 也是一个修饰符，只能放在async定义的函数内。可以理解为<strong>等待</strong>。</p><p>await 修饰的如果是Promise对象，可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p><p><code>await expr</code> 的语义近似是<strong>把 <code>expr</code> 先变成 <code>Promise.resolve(expr)</code>，然后在它 fulfilled 之后，用 <code>.then(...)</code> 继续执行后续代码。</strong>即使 <code>expr</code> 是普通值（比如 <code>1</code>），也会走一次“异步恢复”（微任务）。</p><p>注意事项</p><ul><li>await必须写在async函数中，但是async函数中可以没有await</li><li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li><li><font color="#409eff">当我们使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕以后，被放入到微任务队列中。</font></li></ul><h4 id="【面试题】"><a href="#【面试题】" class="headerlink" title="【面试题】"></a>【面试题】</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 非promise的东西当做await表达式的结果</span><br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)  <span class="hljs-comment">// Promise中返回的内容（resolve或reject的参数）</span><br>    &#125;)<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>&#125;<br><span class="hljs-comment">// === &gt; </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a, b, c;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)                 <span class="hljs-comment">// await 1</span><br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>      a = v;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;     <span class="hljs-comment">// await new Promise(...)</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);<br>        &#125;, <span class="hljs-number">3000</span>);<br>      &#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>      b = v;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>((<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// await IIFE</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function&quot;</span>;<br>      &#125;)());<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<br>      c = v;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c);<br>      <span class="hljs-comment">// async fun 默认返回 Promise&lt;undefined&gt;</span><br>      <span class="hljs-comment">// 这里不 return 等价于 return undefined，链会 resolve(undefined)</span><br>    &#125;);<br>&#125;<br><br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 3秒后输出： 1 &quot;setTimeout&quot; &quot;function&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">aysnc <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn4</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;<br><span class="hljs-title function_">fn4</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// =&gt;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn4</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>        <span class="hljs-title function_">resolve</span>()<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">// 1,2,4,3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>)<br>        &#125;, <span class="hljs-number">0</span>)<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>    &#125;)<br><br>&#125;))<br><span class="hljs-title function_">first</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br><span class="hljs-comment">// 3,7,4,1,2,5</span><br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS核心总结</title>
    <link href="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"/>
    <url>/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>NodeJS简介 &#x2F; 包管理器 &#x2F; 计算机网络 &#x2F; Promise &#x2F; Express &#x2F; Buffer &#x2F; Path &#x2F; 会话控制</p><span id="more"></span><h1 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h1><blockquote><p><a href="https://nodejs.org/en">Node.js — Run JavaScript Everywhere</a></p></blockquote><p>Node.js 是一个基于 <strong>Chrome V8 引擎</strong> 构建的 <strong>JavaScript 运行环境</strong>，它让你能够在服务器端运行 JavaScript 代码。</p><ul><li><strong>本质</strong>：Node.js 是一个 JavaScript 运行环境（runtime environment），让 JavaScript 脱离浏览器、在服务器上运行。</li><li><strong>核心引擎</strong>：使用 Google 的 V8 JavaScript 引擎。</li><li><strong>异步 I&#x2F;O</strong>：采用 <strong>事件驱动、非阻塞（non-blocking）I&#x2F;O 模型</strong>，非常适合处理高并发请求。</li></ul><h2 id="Node-js-的特点"><a href="#Node-js-的特点" class="headerlink" title="Node.js 的特点"></a>Node.js 的特点</h2><table><thead><tr><th>特点</th><th>描述</th></tr></thead><tbody><tr><td>非阻塞 I&#x2F;O</td><td>异步处理请求，性能高</td></tr><tr><td>单线程事件循环</td><td>用一个线程处理多个请求，通过事件循环实现并发</td></tr><tr><td>跨平台</td><td>支持 Windows、Linux、macOS 等操作系统</td></tr><tr><td>使用 JavaScript</td><td>前后端统一开发语言（同一API）</td></tr><tr><td>大量模块支持</td><td>拥有丰富的 NPM（Node Package Manager）生态系统</td></tr></tbody></table><h2 id="Node-js-常见用途"><a href="#Node-js-常见用途" class="headerlink" title="Node.js 常见用途"></a>Node.js 常见用途</h2><ol><li><strong>构建 Web 服务器</strong>（如 Express 框架）</li><li><strong>API 接口服务</strong>（RESTful、GraphQL）</li><li><strong>实时通信应用</strong>（如聊天室、Socket.io）</li><li><strong>命令行工具开发</strong></li><li><strong>构建微服务架构</strong></li><li><strong>自动化构建工具</strong>（Webpack、Gulp 等）</li><li><strong>物联网（IoT）项目</strong></li></ol><hr><h2 id="Node-js-的核心模块"><a href="#Node-js-的核心模块" class="headerlink" title="Node.js 的核心模块"></a>Node.js 的核心模块</h2><table><thead><tr><th>模块名</th><th>功能简介</th></tr></thead><tbody><tr><td><code>http</code></td><td>创建 Web 服务器</td></tr><tr><td><code>fs</code></td><td>文件系统操作</td></tr><tr><td><code>path</code></td><td>处理文件路径</td></tr><tr><td><code>events</code></td><td>事件处理</td></tr><tr><td><code>stream</code></td><td>数据流操作</td></tr><tr><td><code>os</code></td><td>系统信息获取</td></tr><tr><td><code>process</code></td><td>创建子进程</td></tr></tbody></table><h2 id="NVM简介"><a href="#NVM简介" class="headerlink" title="NVM简介"></a>NVM简介</h2><p>NVM（Node Version Manager）是 <strong>Node.js 版本管理工具</strong>，可以方便地在同一台机器上安装和切换多个 Node.js 版本。</p><ul><li><strong>全称</strong>：Node Version Manager</li><li><strong>作用</strong>：帮助你在同一系统中安装、管理和切换多个版本的 Node.js。</li><li><strong>使用场景</strong>：<ul><li>不同项目需要不同版本的 Node.js。</li><li>测试代码在不同 Node.js 版本下的兼容性。</li><li>避免全局安装冲突。</li></ul></li></ul><p><strong>NVM 的主要功能</strong></p><table><thead><tr><th>功能</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>安装 Node.js</td><td><code>nvm install 16.20.2</code></td><td>安装指定版本的 Node</td></tr><tr><td>查看已安装版本</td><td><code>nvm ls</code></td><td>显示当前安装的所有 Node.js 版本</td></tr><tr><td>查看可安装版本</td><td><code>nvm ls-remote</code></td><td>查看远程所有可安装版本</td></tr><tr><td>使用某版本</td><td><code>nvm use 16.20.2</code></td><td>临时切换 Node.js 版本</td></tr><tr><td>设置默认版本</td><td><code>nvm alias default 16.20.2</code></td><td>设置默认使用的版本</td></tr><tr><td>卸载版本</td><td><code>nvm uninstall 14.21.3</code></td><td>删除指定版本的 Node</td></tr></tbody></table><h2 id="Node-js-使用"><a href="#Node-js-使用" class="headerlink" title="Node.js 使用"></a>Node.js 使用</h2><p>和之前学习的JavaScript不同，Node.js需要运行在服务器端，说的直白一些我们需要通过命令行来执行JS代码。通过命令行执行js代码有两种方式：</p><p>第一种直接在命令行中输入node，会进入到node的REPL界面（交互编程环境），在REPL下和浏览器的控制台类似，我们可以直接输入各种JS代码，REPL会立即执行这些代码并输出结果（.exit用来退出REPL）。</p><img src="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220927094943815.png" class title="img"><p>第二种也是我们最常使用的一种，就是将js代码编写到一个js文件中，然后通过命令行执行js文件</p><img src="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220927095238144.png" class title="img"><p>Node.js虽然也属于js，但是它和浏览器中js还是有所区别的。对于ECMAScript标准来说，它们是一致的所以像是原始值、流程控制语句、运算符、函数、对象、数组、内建对象这些东西无论是浏览器环境还是node中都是一样的。对于宿主对象来说浏览器和node是截然不同的，像是DOM、BOM这些对象在node中通通是不存在的，但是一些东西在Node中依然得到了保留，比如console对象、比如定时器之类。</p><h2 id="Node-js-的作用"><a href="#Node-js-的作用" class="headerlink" title="Node.js 的作用"></a>Node.js 的作用</h2><ol><li><strong>开发服务器应用</strong> —— 因为 Node.js 提供了服务端能力</li></ol><p><strong>解释：</strong></p><p>JavaScript 原本只运行在浏览器中，不能访问磁盘、网络、数据库等“后端功能”。但通过 <strong>Node.js</strong>，JavaScript 拥有了这些底层访问能力：</p><ul><li>Node.js 提供了 HTTP 模块，可以构建 Web 服务器</li><li>提供文件系统（fs）、网络（net）、数据库连接等 API</li><li>使用异步非阻塞 I&#x2F;O 机制，非常适合处理<strong>高并发请求</strong></li></ul><p><strong>举例场景：</strong></p><table><thead><tr><th>应用类型</th><th>示例</th></tr></thead><tbody><tr><td>API 服务</td><td>RESTful 或 GraphQL 接口</td></tr><tr><td>实时服务</td><td>聊天服务器、在线协作、弹幕系统</td></tr><tr><td>Web 后端</td><td>博客系统、论坛系统、内容管理系统（CMS）</td></tr></tbody></table><p><strong>常用工具</strong>：Express、Koa、NestJS</p><ol start="2"><li><strong>开发工具类应用</strong> —— 因为 Node.js 可直接操作系统资源</li></ol><p><strong>解释：</strong></p><p>Node.js 能读取文件、执行命令、读取环境变量，因此非常适合用来开发 <strong>命令行工具</strong> 或 <strong>项目构建工具</strong>：</p><ul><li>可以写项目脚手架（自动创建目录结构）</li><li>实现自动构建、打包、格式化等工具</li><li>可以发布为 npm 包，方便分发与使用</li></ul><p><strong>举例场景：</strong></p><table><thead><tr><th>工具类型</th><th>示例</th></tr></thead><tbody><tr><td>前端构建工具</td><td>Webpack、Vite、Rollup</td></tr><tr><td>命令行工具</td><td>Vue CLI、create-react-app</td></tr><tr><td>自动化工具</td><td>ESLint、Prettier、Gulp、Husky</td></tr></tbody></table><p><strong>优势：</strong> 使用 JavaScript 写工具，让前端开发流程更统一、可自动化。</p><ol start="3"><li><strong>开发桌面端应用</strong> —— 因为 JavaScript 可借助 <font color="#409eff">Electron </font>实现跨平台桌面程序</li></ol><p><strong>解释：</strong></p><p>通过 <strong>Electron</strong>（基于 Node.js + Chromium），JavaScript 可以构建完整的桌面应用，支持：</p><ul><li>系统窗口管理（打开窗口、菜单栏、托盘图标等）</li><li>访问系统资源（文件读写、系统通知、硬件接口）</li><li>使用 HTML&#x2F;CSS&#x2F;JS 构建 UI，适配所有平台（Windows、macOS、Linux）</li></ul><p><strong>举例场景：</strong></p><table><thead><tr><th>应用类型</th><th>示例</th></tr></thead><tbody><tr><td>编辑器类</td><td>VS Code、Atom</td></tr><tr><td>聊天类</td><td>Slack、Discord（旧版本）</td></tr><tr><td>开发工具</td><td>Postman、Insomnia、Figma 桌面版</td></tr></tbody></table><p><strong>为什么可行？</strong></p><ul><li>Electron 中，<strong>前端页面用浏览器渲染，后端逻辑由 Node.js 支撑</strong></li><li>统一语言栈，开发效率高</li><li>支持跨平台打包</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><font color="#409eff">面试模板：</font></p><p>Node.js 是一个基于 Chrome V8 引擎构建的 JavaScript 运行时环境，它让 JavaScript 不再局限于浏览器中运行，而是可以直接在服务器端执行。Node.js 采用事件驱动、非阻塞 I&#x2F;O 的模型，这种设计使得它在处理高并发、I&#x2F;O 密集型任务时具有非常高的性能和扩展性。所有 I&#x2F;O 操作都通过<strong>事件循环和回调机制</strong>来异步执行，从而避免了线程阻塞的问题。Node.js 提供了丰富的内置模块，比如文件系统、HTTP、网络等，同时也有全球最大的开源包管理生态——npm。总结来说，Node.js 的特点是单线程、事件驱动、异步非阻塞，优势在于高并发处理能力和丰富的生态，缺点是 CPU 密集型任务表现不佳，因为单线程在处理复杂计算时容易阻塞事件循环。</p><p>事件驱动就是程序的执行流程由事件来推动，而不是按顺序一行行地死等结果。在 Node.js 里，有一个事件循环机制，所有任务会被注册成事件，当某个事件发生，比如网络请求完成、文件读取结束，就会触发对应的回调函数执行，这样程序不必在原地等待，而是去忙别的事，等事件通知。</p><p>非阻塞 I&#x2F;O 是指在执行 I&#x2F;O 操作，比如读文件、查数据库、发网络请求时，不会阻塞代码的继续运行。传统的阻塞模式是必须等 I&#x2F;O 完成才继续执行后面的代码，而 Node.js 的非阻塞 I&#x2F;O 会立即返回，先把操作交给系统后台去处理，当处理完成后通过事件和回调通知程序，这样可以同时发起多个 I&#x2F;O 请求，不浪费等待的时间。</p><h1 id="JavaScript模块化"><a href="#JavaScript模块化" class="headerlink" title="JavaScript模块化"></a>JavaScript模块化</h1><blockquote><p>知识点总结：尚硅谷\禹神：一小时速通JavaScript模块化</p></blockquote><p><font color="#409eff">面试模板：</font></p><p>JavaScript 模块化是一种将代码按照功能拆分成独立文件的编程方式，每个模块内部定义自己的作用域和功能，并通过特定的导出与导入机制实现复用。模块化的出现主要是为了解决早期 JavaScript 在全局作用域下编写代码所带来的全局变量污染、依赖顺序混乱以及数据暴露不安全等问题。通过模块化，每个模块都有独立的作用域，避免了不同模块之间的变量和函数相互覆盖；同时模块通过显式的 <code>import</code> 和 <code>export</code> 声明依赖关系，不再依赖于手动调整脚本引入顺序，从而解决依赖混乱的问题；此外，模块内部的数据和实现细节如果不导出，外部是无法访问的，这样就实现了数据的封装与安全。早期的模块化方案包括 IIFE 自执行函数封装、CommonJS（主要用于 Node.js）和 AMD（浏览器端异步加载），现代 JavaScript 则通过 ES Module（<code>import</code>&#x2F;<code>export</code>）在语言层面原生支持模块化，并结合构建工具打包，既解决了全局污染和依赖混乱的问题，也让数据访问更可控、更安全。</p><h1 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h1><h2 id="NPM介绍"><a href="#NPM介绍" class="headerlink" title="NPM介绍"></a>NPM介绍</h2><p>NPM（<strong>Node Package Manager</strong>）是 <strong>Node.js 的包管理工具</strong>，也是<strong>世界上最大的 JavaScript 软件包生态系统</strong>。</p><ul><li><strong>全称</strong>：Node Package Manager</li><li><strong>功能</strong>：用于安装、管理、共享 JavaScript 包（模块&#x2F;库）</li><li><strong>作用对象</strong>：主要配合 Node.js 使用，但也适用于前端项目（如 Vue、React）</li></ul><blockquote><p>安装 Node.js 时通常会自动附带安装 NPM。</p></blockquote><p><strong>三大功能</strong></p><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>安装模块</td><td>安装你项目需要的库（如 <code>express</code>、<code>lodash</code>）</td></tr><tr><td>管理依赖</td><td></td></tr><tr><td>发布包</td><td>将你自己的模块上传到 NPM 仓库，供他人使用</td></tr></tbody></table><p>NPM 常用命令速查表</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm init</code></td><td>初始化项目，创建 <code>package.json</code></td><td>会提示填写信息</td></tr><tr><td><code>npm init -y</code></td><td>快速初始化项目</td><td>使用默认值跳过询问</td></tr></tbody></table><p>安装依赖</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm install</code> 或 <code>npm i</code></td><td>安装所有依赖（根据 <code>package.json</code>）</td><td>生成 <code>node_modules</code> 和 <code>package-lock.json</code></td></tr><tr><td><code>npm install &lt;包名&gt;</code></td><td>安装指定包，添加到 <code>dependencies</code></td><td>默认本地安装</td></tr><tr><td><code>npm install &lt;包名&gt; --save-dev</code> 或 <code>-D</code></td><td>安装为开发依赖</td><td>添加到 <code>devDependencies</code></td></tr><tr><td><code>npm install -g &lt;包名&gt;</code></td><td>全局安装一个包</td><td>多用于 CLI 工具（如 nodemon）</td></tr></tbody></table><p>卸载依赖</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm uninstall &lt;包名&gt;</code></td><td>卸载依赖并从 <code>package.json</code> 中移除</td><td>支持卸载开发依赖</td></tr></tbody></table><p>更新与查看</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm update &lt;包名&gt;</code></td><td>更新某个依赖包</td><td>自动安装符合 semver 的最新版本</td></tr><tr><td><code>npm outdated</code></td><td>查看过时的依赖包</td><td>显示当前版本、最新版本等</td></tr><tr><td><code>npm list</code></td><td>查看当前项目依赖结构</td><td>默认显示完整树</td></tr><tr><td><code>npm list --depth=0</code></td><td>查看顶级依赖</td><td>常用于查看主要依赖版本</td></tr></tbody></table><p>运行脚本</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm start</code></td><td>执行 <code>package.json</code> 中的 <code>start</code> 脚本</td><td>如：<code>&quot;start&quot;: &quot;node index.js&quot;</code></td></tr><tr><td><code>npm run &lt;脚本名&gt;</code></td><td>执行自定义脚本</td><td>如：<code>npm run dev</code></td></tr><tr><td><code>npm test</code></td><td>执行 <code>test</code> 脚本</td><td>一般用于单元测试</td></tr></tbody></table><p> 镜像源设置（加速）</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm config set registry &lt;url&gt;</code></td><td>设置 NPM 镜像地址</td><td>如淘宝源 <code>https://registry.npmmirror.com</code></td></tr><tr><td><code>npm config get registry</code></td><td>查看当前镜像源</td><td>可用于确认是否设置成功</td></tr></tbody></table><p>其他实用命令</p><table><thead><tr><th>命令</th><th>功能说明</th><th>备注</th></tr></thead><tbody><tr><td><code>npm cache clean --force</code></td><td>清除本地缓存</td><td>修复安装错误时常用</td></tr><tr><td><code>npm doctor</code></td><td>检查 NPM 环境配置</td><td>帮助诊断问题</td></tr><tr><td><code>npm version &lt;type&gt;</code></td><td>自动升级版本号</td><td><code>type</code>为 <code>patch</code>、<code>minor</code>、<code>major</code> 等</td></tr><tr><td><code>npm publish</code></td><td>发布自己的包到 NPM 仓库</td><td>需要先登录账户</td></tr><tr><td><code>npm login</code></td><td>登录到 NPM 账号</td><td>发布包前必须登录</td></tr></tbody></table><h2 id="Yarn和Pnpm"><a href="#Yarn和Pnpm" class="headerlink" title="Yarn和Pnpm"></a>Yarn和Pnpm</h2><p><strong>Yarn</strong></p><ul><li>安装速度快（比 npm 早期版本快很多）</li><li>默认使用 <code>yarn.lock</code> 锁定依赖</li><li>支持 <strong>Plug’n’Play（PnP）</strong>，跳过 <code>node_modules</code></li></ul><p><strong>pnpm</strong></p><ul><li>采用 <strong>符号链接 + 全局内容寻址存储</strong> 节省磁盘空间</li><li>更严格的依赖隔离，防止 <code>npm</code> 和 <code>yarn</code> 容易出现的“幽灵依赖”</li><li>支持 monorepo（内置 workspace）</li></ul><table><thead><tr><th>功能</th><th>npm 命令</th><th>yarn 命令</th><th>pnpm 命令</th></tr></thead><tbody><tr><td>初始化项目</td><td><code>npm init</code>  <code>npm init -y</code></td><td><code>yarn init</code>  <code>yarn init -y</code></td><td><code>pnpm init</code>  <code>pnpm init -y</code></td></tr><tr><td>安装依赖（全部）</td><td><code>npm install</code>  <code>npm i</code></td><td><code>yarn install</code></td><td><code>pnpm install</code></td></tr><tr><td>安装依赖（指定）</td><td><code>npm install 包名</code></td><td><code>yarn add 包名</code></td><td><code>pnpm add 包名</code></td></tr><tr><td>安装开发依赖</td><td><code>npm install 包名 --save-dev</code>  <code>npm i 包名 -D</code></td><td><code>yarn add 包名 --dev</code></td><td><code>pnpm add 包名 -D</code></td></tr><tr><td>安装全局包</td><td><code>npm install -g 包名</code></td><td><code>yarn global add 包名</code></td><td><code>pnpm add -g 包名</code></td></tr><tr><td>移除依赖</td><td><code>npm uninstall 包名</code>  <code>npm rm 包名</code></td><td><code>yarn remove 包名</code></td><td><code>pnpm remove 包名</code></td></tr><tr><td>更新依赖</td><td><code>npm update 包名</code></td><td><code>yarn upgrade 包名</code></td><td><code>pnpm update 包名</code></td></tr><tr><td>查看过期依赖</td><td><code>npm outdated</code></td><td><code>yarn outdated</code></td><td><code>pnpm outdated</code></td></tr><tr><td>运行脚本</td><td><code>npm run 脚本名</code></td><td><code>yarn run 脚本名</code>  <code>yarn 脚本名</code></td><td><code>pnpm run 脚本名</code>  <code>pnpm 脚本名</code></td></tr><tr><td>清缓存</td><td><code>npm cache clean --force</code></td><td><code>yarn cache clean</code></td><td><code>pnpm store prune</code></td></tr><tr><td>查看依赖树</td><td><code>npm list</code></td><td><code>yarn list</code></td><td><code>pnpm list</code></td></tr><tr><td>安装指定版本</td><td><code>npm install 包名@版本</code></td><td><code>yarn add 包名@版本</code></td><td><code>pnpm add 包名@版本</code></td></tr><tr><td>安装本地包</td><td><code>npm install ./路径</code></td><td><code>yarn add ./路径</code></td><td><code>pnpm add ./路径</code></td></tr></tbody></table><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p><code>package.json</code> 是 <strong>Node.js</strong> 和 <strong>前端项目（如使用 npm 或 yarn 管理依赖的项目）</strong> 中的一个核心配置文件。它是一个 <strong>JSON 格式的文件</strong>，主要用来描述项目的基本信息、依赖关系、脚本命令等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;your-project-name&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 项目名称</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span>                 <span class="hljs-comment">// 版本号，遵循语义化版本规则</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;A short description of your project&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 项目描述</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span>                 <span class="hljs-comment">// 项目入口文件</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                       <span class="hljs-comment">// 脚本命令，可以用 npm run 命令调用</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 启动项目</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jest&quot;</span>                  <span class="hljs-comment">// 测试命令</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>                      <span class="hljs-comment">// 关键词，便于搜索</span><br>    <span class="hljs-string">&quot;node&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;express&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;example&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Your Name&quot;</span><span class="hljs-punctuation">,</span>             <span class="hljs-comment">// 作者</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIT&quot;</span><span class="hljs-punctuation">,</span>                  <span class="hljs-comment">// 许可证类型</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                  <span class="hljs-comment">// 生产依赖包</span><br>    <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lodash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.20&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>               <span class="hljs-comment">// 开发依赖包，仅在开发环境需要</span><br>    <span class="hljs-attr">&quot;jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^26.4.2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                   <span class="hljs-comment">// 代码仓库信息</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/yourname/your-repo.git&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;engines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>                     <span class="hljs-comment">// 指定 Node.js 或 npm 的版本要求</span><br>    <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&gt;=14.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;private&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>                  <span class="hljs-comment">// 是否为私有项目，true 时禁止发布到 npm</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>常见字段作用：</strong></p><ul><li><strong>name</strong>：包的名称。</li><li><strong>version</strong>：版本号。</li><li><strong>description</strong>：项目描述。</li><li><strong>main</strong>：入口文件。</li><li><strong>scripts</strong>：定义脚本命令，如启动、测试、构建等。</li><li><strong>dependencies</strong>：生产环境依赖的包。</li><li><strong>devDependencies</strong>：开发环境依赖的包。</li><li><strong>repository</strong>：仓库地址。</li><li><strong>keywords</strong>：关键字。</li><li><strong>author</strong>：作者。</li><li><strong>license</strong>：开源协议。</li><li><strong>private</strong>：防止发布到 npm（通常私有项目设置为 true）。</li></ul><p><strong>生产依赖包 (<code>dependencies</code>)</strong></p><ul><li><strong>用途</strong>：这些依赖是你的项目在 <strong>运行时（生产环境）</strong> 必须依赖的包。也就是说，当你的应用真正上线、给用户使用时，程序依赖的这些包必须存在。</li></ul><p><strong>开发依赖包 (<code>devDependencies</code>)</strong></p><ul><li><strong>用途</strong>：这些依赖是你在 <strong>开发阶段</strong> 用来辅助开发、测试、构建、代码检查等的工具包，生产环境不需要它们。最终运行的时候不需要打包。</li></ul><p><strong>举例</strong>：</p><ul><li>代码打包工具（如 <code>webpack</code>、<code>rollup</code>）</li><li>测试框架（如 <code>jest</code>、<code>mocha</code>）</li><li>代码格式检查工具（如 <code>eslint</code>、<code>prettier</code>）</li></ul><p><strong><code>package-lock.json</code></strong></p><ul><li><strong>作用</strong>：锁定项目中所有依赖包的<strong>具体版本号</strong>和<strong>依赖树结构</strong>，确保每次安装依赖时，安装的包版本一致，避免因依赖版本变化导致代码不稳定，也不免反复按照多个版本依赖。node自动配置，不需要手动修改。</li></ul><h2 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h2><p><strong>npx</strong> 是 Node.js 自带的一个命令行工具（从 <strong>npm 5.2.0</strong> 开始内置），它的主要作用是 <strong>执行 Node.js 项目中的可执行包（CLI 工具）</strong>，而不需要你提前全局安装它。</p><h3 id="【为什么有-npx】"><a href="#【为什么有-npx】" class="headerlink" title="【为什么有 npx】"></a>【为什么有 npx】</h3><p>在 npx 出现之前：</p><ul><li>如果想用某个 npm 包的命令行工具（比如 <code>create-react-app</code>），你必须先用 <code>npm install -g create-react-app</code> 全局安装。</li><li>全局安装会导致版本管理困难，不同项目可能需要不同版本。</li></ul><p>npx 解决了这些问题：</p><ul><li>直接运行包的可执行文件，不必全局安装。</li><li>可以运行项目本地 <code>node_modules</code> 里的 CLI 工具。</li><li>支持临时安装一次性运行的工具，执行后自动清除。</li></ul><h3 id="【使用方式】"><a href="#【使用方式】" class="headerlink" title="【使用方式】"></a>【使用方式】</h3><p><strong>运行已安装在项目中的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx eslint src/<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./node_modules/.bin/eslint src/<br></code></pre></td></tr></table></figure><p>（npx 会自动到 <code>node_modules/.bin</code> 找可执行文件）</p><p><strong>运行一次性工具（没安装过）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx cowsay <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>npx 会先下载 <code>cowsay</code>（存在临时目录），执行后删除。</p><p><strong>指定包版本执行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-react-app@4.0.0 my-app<br></code></pre></td></tr></table></figure><p>可以避免全局安装多个版本冲突。</p><p><strong>执行 GitHub &#x2F; Gist 上的包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx github:username/repo<br>npx gist:1234567890abcdef<br></code></pre></td></tr></table></figure><h1 id="计算机网络知识"><a href="#计算机网络知识" class="headerlink" title="计算机网络知识"></a>计算机网络知识</h1><blockquote><p><a href="https://www.bilibili.com/video/BV19E411D78Q/?spm_id_from=333.337.search-card.all.click&vd_source=ff414aaf189e3a685358d2a984fd4742">王道计算机考研 计算机网络_哔哩哔哩_bilibili</a> —— 传输层和应用层部分</p><p><a href="./1.6W%E5%AD%97%EF%BC%81%E6%A2%B3%E7%90%8650%E9%81%93%E7%BB%8F%E5%85%B8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%94%B6%E8%97%8F%E7%89%88%EF%BC%89.pdf">1.6W字！梳理50道经典计算机网络面试题（收藏版）</a></p><p><a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络——面试题</a></p><p><a href="https://www.yuque.com/cuggz/feplus/cxuwy0">计算机网络——前端充电宝</a></p></blockquote><h2 id="一个最常见的面试题"><a href="#一个最常见的面试题" class="headerlink" title="一个最常见的面试题"></a>一个最常见的面试题</h2><blockquote><p>当浏览器中输入一行地址以后发生了什么？（例如<a href="https://www.baidu.com/">https://www.baidu.com</a>)</p></blockquote><ol><li><strong>URL 解析</strong></li></ol><ul><li>浏览器首先解析你输入的地址 <code>https://www.baidu.com</code></li><li>分解出：<ul><li>协议（<code>https</code>）</li><li>主机名（<code>www.baidu.com</code>）</li><li>端口（<code>https</code> 默认 443）</li><li>路径（<code>/</code>）</li><li>查询参数（如果有）</li></ul></li></ul><hr><ol start="2"><li><strong>检查缓存</strong></li></ol><p>浏览器会先看看本地有没有现成的资源，按顺序查找：</p><ol><li>浏览器缓存（Memory Cache &#x2F; Disk Cache）</li><li>操作系统缓存（DNS 缓存）</li><li>路由器缓存</li><li>ISP DNS 缓存<br>如果缓存命中，就直接用缓存返回数据，不再走后续步骤。</li></ol><hr><ol start="3"><li><strong>DNS 解析</strong></li></ol><p>如果缓存中没找到域名的 IP，需要向 DNS 服务器查询：</p><ol><li>浏览器调用操作系统的 <strong>DNS 解析库</strong></li><li>OS 向本地配置的 DNS 服务器发起请求</li><li>如果是多级域名，DNS 会从根域名服务器开始逐级解析：<ul><li>根 DNS → <code>.com</code> 顶级域 DNS → <code>baidu.com</code> 权威 DNS</li></ul></li><li>最终得到目标服务器的 <strong>IP 地址</strong>（比如 <code>220.181.38.150</code>）</li></ol><hr><ol start="4"><li><strong>浏览器与服务器建立连接（TCP&#x2F;IP）</strong></li></ol><p>浏览器使用 IP 与服务器建立 TCP 连接：</p><ol><li><strong>SYN</strong>（浏览器 → 服务器，请求建立连接）</li><li><strong>SYN-ACK</strong>（服务器 → 浏览器，同意建立连接）</li><li><strong>ACK</strong>（浏览器 → 服务器，确认）<br>连接建立后，浏览器和服务器之间可以可靠地收发数据。</li></ol><p>HTTPS 会在 TCP 基础上进行 <strong>TLS 握手</strong>，确保数据加密传输：</p><ol><li>浏览器发送支持的加密算法和随机数</li><li>服务器返回证书和公钥</li><li>浏览器验证证书合法性</li><li>双方协商会话密钥<br>握手完成后，所有 HTTP 数据会被加密传输。</li></ol><hr><ol start="5"><li><strong>浏览器发送HTTP请求</strong></li></ol><p>浏览器构造请求报文：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">GET / HTTP/1.1<br><span class="hljs-section">Host: www.baidu.com</span><br><span class="hljs-section">User-Agent: ...</span><br><span class="hljs-section">Accept: ...</span><br></code></pre></td></tr></table></figure><p>通过 TCP 连接发送到服务器</p><hr><ol start="6"><li><strong>服务器处理请求</strong></li></ol><p>服务器（比如 Nginx + 应用层）：</p><ol><li>接收请求数据</li><li>根据 URL 路径匹配资源或调用后端程序</li><li>查询数据库 &#x2F; 缓存</li><li>生成 HTTP 响应（包含 HTML &#x2F; JSON &#x2F; 图片等）</li></ol><hr><ol start="7"><li><strong>返回 HTTP 响应</strong></li></ol><ul><li><p>服务器把响应通过 TCP 发送给浏览器</p></li><li><p>响应报文可能是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span><br><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html</span><br><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">1024</span><br><br><span class="hljs-string">&lt;html&gt;...&lt;/html&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>如果有 <strong>压缩（gzip&#x2F;br）</strong>，浏览器需要解压</p></li></ul><hr><ol start="8"><li><strong>浏览器渲染页面</strong></li></ol><p>浏览器渲染引擎（如 Blink &#x2F; WebKit）执行：</p><ol><li><strong>解析 HTML</strong> → 生成 DOM 树</li><li><strong>解析 CSS</strong> → 生成 CSSOM 树</li><li><strong>合并 DOM + CSSOM</strong> → 生成渲染树</li><li><strong>布局（Layout）</strong>：计算元素位置和大小</li><li><strong>绘制（Paint）</strong>：将像素绘制到屏幕</li><li><strong>执行 JavaScript</strong>（如果遇到 <code>&lt;script&gt;</code> 标签，可能阻塞解析）</li><li>如果页面有图片、CSS、JS 等资源，会<strong>并行发起请求</strong>（重复上述流程）</li></ol><hr><ol start="10"><li><strong>连接关闭</strong></li></ol><ul><li>如果使用 HTTP&#x2F;1.1 且有 <code>Connection: keep-alive</code>，TCP 连接会复用</li><li>HTTP&#x2F;2 &#x2F; HTTP&#x2F;3 会多路复用一个连接</li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>客户端与服务器之间进行通信，需要确定三个地址：<code>MAC地址</code>、<code>IP地址</code>、<code>端口号</code>。</p><ul><li><strong>MAC 地址</strong>（物理地址）：定位 <strong>同一局域网中</strong> 的设备</li><li><strong>IP 地址</strong>（网络地址）：在 <strong>整个互联网范围</strong> 唯一定位一台设备（或者网络节点）</li><li><strong>端口号</strong>（进程地址）：在一台设备上区分不同的应用程序</li></ul><p>根据 IP地址 + 端口号， 可以确定整个互联网中唯一一台设备的唯一进程。IP就好比快递传输中的通讯地址，进程好比收件人。那么MAC地址呢？如果需要跨省传输，那么快递会经过中转站，MAC地址也会改变。也就是<font color="#409eff">IP地址不变，MAC地址每跳改变，端口号唯一定位进程</font>。</p><ul><li>源IP和目的IP地址不会变。始终表示【发货地 -&gt; 目的地】</li><li>源MAC地址和目的MAC地址可能改变。【发货地 -&gt; A省中转站】 -&gt; 【A省中转站 -&gt; B省中转站】 -&gt; 【B省中转站 -&gt; 目的地】</li></ul><p>其中</p><ul><li>端口号是默认或者手动配置的，在传输层添加。</li><li>IP地址通过DNS解析域名得到，在网络层添加。</li><li>MAC地址通过ARP协议，利用IP地址获取，在数据链路层添加。</li></ul><blockquote><p>假设客户端向服务器发送一个 HTTP 请求，整个过程从应用层开始，依次经过传输层、网络层、数据链路层，到物理层发送出去，服务器再反向解析，完成通信。</p></blockquote><ol><li>应用层（Application Layer）</li></ol><ul><li><strong>作用</strong>：提供用户直接使用的服务，处理具体应用协议，比如 HTTP、FTP、SMTP、DNS 等。</li><li><strong>过程</strong>：<ul><li>用户在浏览器输入 URL 发起 HTTP 请求。</li><li>应用层生成符合 HTTP 协议格式的数据（请求报文），准备发送。</li><li>调用下一层（传输层）接口发送数据。</li></ul></li></ul><ol start="2"><li>传输层（Transport Layer）</li></ol><ul><li><strong>作用</strong>：实现端到端的通信管理，提供可靠（TCP）或不可靠（UDP）的传输服务，负责分段、重传、流量控制、端口管理。</li><li><strong>过程</strong>：<ul><li>应用层数据被切分成传输层的数据段（TCP 段或 UDP 数据报）。</li><li>为数据段添加<strong>源端口和目的端口号</strong>，确定通信的进程。</li><li>如果是 TCP，会建立连接（三次握手），保证可靠传输。</li><li>数据段传给下一层（网络层）。</li></ul></li></ul><ol start="3"><li>网络层（Network Layer）</li></ol><ul><li><strong>作用</strong>：负责数据包<strong>从源主机到目标主机的路由选择和转发，主要协议是 IP</strong>。</li><li><strong>过程</strong>：<ul><li>传输层传过来的数据段被封装成数据包（IP 包）。</li><li>添加源 IP 和目的 IP 地址。</li><li>网络层根据目标 IP 寻找路由路径，决定发送到哪个下一跳。</li><li>发送给数据链路层。</li></ul></li></ul><ol start="4"><li>数据链路层（Data Link Layer）</li></ol><ul><li><strong>作用</strong>：负责相邻节点之间的可靠传输，处理物理地址（MAC）、帧的封装和差错检测。</li><li><strong>过程</strong>：<ul><li>将网络层传来的数据包封装成帧（Frame）。</li><li><strong>添加源 MAC 和目的 MAC 地址</strong>。</li><li>通过帧校验序列（FCS）实现差错检测。</li><li>发送到物理层。</li></ul></li></ul><ol start="5"><li>物理层（Physical Layer）</li></ol><ul><li><strong>作用</strong>：负责物理传输媒体上的比特流传输，如电信号、光信号等。</li><li><strong>过程</strong>：<ul><li>把数据链路层的帧转化成适合传输的电信号或光信号。</li><li>通过网线、光纤、无线信道等物理媒介发送给目标设备。</li></ul></li></ul><p>传输到目标服务器后，接收端的流程是反向的：</p><ol><li><strong>物理层</strong>接收信号，转成比特流交给数据链路层。</li><li><strong>数据链路层</strong>解析帧，校验数据，提取数据包。</li><li><strong>网络层</strong>检查 IP 地址，进行路由处理，将数据包交给传输层。</li><li><strong>传输层</strong>重组数据段，校验完整性，确认端口，组装成应用层数据。</li><li><strong>应用层</strong>根据协议解析数据，完成请求处理（如 HTTP 请求被 Web 服务器解析），返回响应。</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss">客户端（发送端）<br>应用层 (HTTP请求)<br>    ↓<br>传输层 (TCP段，加端口)<br>    ↓<br>网络层 (IP包，加IP地址)<br>    ↓<br>数据链路层 (帧，加MAC地址)<br>    ↓<br>物理层 (电信号/光信号)<br><br>--------------------网络传输--------------------<br><br>服务器端（接收端）<br>物理层 (接收信号)<br>    ↑<br>数据链路层 (帧解包，MAC地址校验)<br>    ↑<br>网络层 (IP解包，路由处理)<br>    ↑<br>传输层 (TCP重组，端口校验)<br>    ↑<br>应用层 (HTTP请求解析)<br></code></pre></td></tr></table></figure><p><font color="#409eff">为什么同时需要IP地址和MAC地址：</font></p><p><strong>MAC 地址（物理地址 &#x2F; 硬件地址）</strong></p><ul><li><p>作用：<br>用来标识 <strong>同一局域网内</strong> 的网络设备，在数据链路层用于点对点传输。</p></li><li><p>特性：</p><ul><li>唯一性：理论上全球唯一。</li><li>不可更改（可以通过软件伪造）。</li><li>只在局域网范围内有效，跨网络传输时会被替换（由路由器处理）。</li></ul></li></ul><p><strong>IP 地址（逻辑地址）</strong></p><ul><li><p><strong>作用</strong>：<br>用于在 <strong>不同网络之间</strong> 定位主机，实现数据包的路由转发。</p></li><li><p><strong>特性</strong>：</p><ul><li>逻辑性：可以手动配置，也可以自动分配（DHCP）。</li><li>会变化（设备换网络、换运营商，IP就可能变）。</li><li>在跨网通信时必须依赖IP进行寻址。</li></ul><blockquote><p>MAC地址跨网络传输时会被更新，起到中转的作用。</p></blockquote><p>示例：你的电脑（Client）要访问 <strong><code>www.example.com</code></strong> 服务器（Server）。</p></li></ul><p><strong>步骤 1：DNS 解析</strong></p><ol><li>你在浏览器输入 <code>www.example.com</code>。</li><li>浏览器向 <strong>DNS 服务器</strong> 查询，获取目标服务器的 <strong>IP 地址</strong>（假设是 <code>93.184.216.34</code>）。</li><li>现在你的电脑知道了对方的 IP 地址，但还不知道对方的 <strong>MAC 地址</strong>。</li></ol><p><strong>步骤 2：ARP 获取 MAC 地址（局域网内通信）</strong></p><ol><li>如果目标 IP 在<strong>同一个局域网</strong>：<ul><li>电脑发出 <strong>ARP 广播</strong>（”谁是 93.184.216.34，请告诉我你的 MAC 地址”）。</li><li>目标主机返回自己的 MAC 地址。</li></ul></li><li>如果目标 IP 不在同一个局域网（大多数访问互联网的情况）：<ul><li>电脑会先查本地路由表，发现目标 IP 要通过<strong>网关（路由器）</strong>转发。</li><li>电脑用 ARP 请求获取 <strong>网关的 MAC 地址</strong>（因为第一跳是网关，而不是服务器）。</li></ul></li></ol><p><strong>步骤 3：封装并发送数据</strong></p><ol><li>电脑把数据封装成 <strong>IP 包</strong>（源 IP &#x3D; 你的电脑，目标 IP &#x3D; 服务器）。</li><li>在 IP 包外面再封装一层 <strong>以太网帧</strong>（源 MAC &#x3D; 你的电脑，目标 MAC &#x3D; 网关的 MAC）。</li><li>数据从你的电脑发到网关。</li></ol><p><strong>步骤 4：跨网络传输（路由器处理）</strong></p><ol><li>网关收到帧后，解封装，读取 IP 头，发现目标 IP 在外网。</li><li>根据路由表，把数据转发给下一个路由器：<ul><li><font color="#409eff">修改以太网帧的 <strong>源 MAC</strong> &#x3D; 自己的 MAC，<strong>目标 MAC</strong> &#x3D; 下一跳路由器的 MAC。</font></li><li><strong>IP 地址保持不变</strong>（源 IP 依旧是你的电脑，目标 IP 依旧是服务器）。</li></ul></li><li>经过多个路由器，这个过程不断重复。</li></ol><p><strong>步骤 5：目标服务器接收</strong></p><ol><li>数据到达服务器所在的局域网后，最后一个路由器通过 ARP 找到服务器的 MAC 地址。</li><li>以太网帧（目标 MAC &#x3D; 服务器 MAC）送到服务器。</li><li>服务器解封装，以 IP 为依据确认是发给自己的，然后交给 TCP&#x2F;应用层处理。</li></ol><p><strong>核心要点</strong></p><ul><li><strong>IP 地址</strong>：跨网络定位主机（类似全球地址系统）。</li><li><strong>MAC 地址</strong>：在局域网内唯一标识设备（类似局域网内门牌号）。</li><li><strong>ARP 协议</strong>：IP ↔ MAC 之间的翻译员。</li><li>在跨网通信中，<strong>IP 地址不变</strong>，<strong>MAC 地址每一跳都会改变</strong>（因为每一跳的物理链路是不同的）。</li></ul><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h3 id="1-DNS-协议的概念"><a href="#1-DNS-协议的概念" class="headerlink" title="1. DNS 协议的概念"></a>1. DNS 协议的概念</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的IP 地址。</p><h3 id="2-DNS同时使用TCP和UDP协议"><a href="#2-DNS同时使用TCP和UDP协议" class="headerlink" title="2. DNS同时使用TCP和UDP协议"></a>2. DNS同时使用TCP和UDP协议</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p><p>（1）在区域传输的时候使用TCP协议</p><ul><li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li><li>TCP是一种可靠连接，保证了数据的准确性。</li></ul><p>（2）在域名解析的时候使用UDP协议</p><ul><li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li></ul><h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><p>比如我们如果想要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，我们首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4.迭代查询与递归查询"></a>4.迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p><ul><li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li><li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li></ul><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><p><code>（Name，Value，Type，TTL）</code></p><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p><ol><li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li><li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li><li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li></ol><h2 id="TCP和UDP协议"><a href="#TCP和UDP协议" class="headerlink" title="TCP和UDP协议"></a>TCP和UDP协议</h2><h3 id="【TCP与UDP协议特点】"><a href="#【TCP与UDP协议特点】" class="headerlink" title="【TCP与UDP协议特点】"></a>【TCP与UDP协议特点】</h3><p><strong>TCP 协议特点</strong></p><ul><li><strong>面向连接</strong>：通信前需要建立连接（三次握手）。</li><li><strong>可靠传输</strong>：通过<strong>确认应答、重传机制</strong>保证数据不丢失、不乱序。</li><li><strong>面向字节流</strong>：数据被看作连续的字节流，没有明确边界。</li><li><strong>流量控制</strong>：通过滑动窗口控制发送速率，避免接收方处理不过来。</li><li><strong>拥塞控制</strong>：慢启动、拥塞避免、快速重传等算法，避免网络拥堵。</li><li><strong>开销相对大</strong>：头部20字节起。</li></ul><p><strong>UDP 协议特点</strong></p><ul><li><strong>无连接</strong>：发送数据前不建立连接，直接发送。</li><li><strong>不保证可靠性</strong>：不确认、不重传，可能丢包、乱序。</li><li><strong>面向报文</strong>：发送方一次发送的数据作为一个整体接收，保留数据边界。</li><li><strong>速度快</strong>：无握手和复杂控制，延迟低。</li><li><strong>开销小</strong>：头部只有8字节。</li><li><strong>常用于</strong>：实时通信（视频、语音）、广播、多播、DNS查询等。</li></ul><p><strong>TCP vs UDP 对比表</strong></p><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否连接</td><td>面向连接</td><td>无连接</td></tr><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>数据顺序</td><td>保证顺序</td><td>不保证</td></tr><tr><td>传输形式</td><td>字节流</td><td>报文</td></tr><tr><td>速度</td><td>较慢</td><td>快</td></tr><tr><td>开销</td><td>大（20字节以上）</td><td>小（8字节）</td></tr><tr><td>场景</td><td>HTTP、FTP、SMTP</td><td>视频、语音、DNS</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li><strong>TCP</strong>：需要可靠性和顺序的传输（如网页、文件、邮件）。</li><li><strong>UDP</strong>：追求速度、容忍少量丢包的应用（如直播、游戏、DNS）。</li></ul><h3 id="【面试考点】"><a href="#【面试考点】" class="headerlink" title="【面试考点】"></a>【面试考点】</h3><ul><li>UDP协议特点</li><li>TPC协议特点</li><li>TPC三次握手（为什么不采用二次握手）</li><li>TPC四次挥手（为什么不采用三次挥手）</li><li>TPC拥塞控制（慢开始，拥塞控制，快开始，快重传）</li><li>TPC流量控制（根据返回窗口和拥塞窗口计算）</li><li>TPC可靠传输（校验（不是重点）—— 序号 —— 确认 —— 重传（超时重传和快重传）</li></ul><p><font color="#409eff">具体内容见标题下方PDF笔记链接</font></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="【HTTP协议概述】"><a href="#【HTTP协议概述】" class="headerlink" title="【HTTP协议概述】"></a>【HTTP协议概述】</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p><p>HTTP协议具有以下<strong>优点</strong>：</p><ul><li>支持客户端&#x2F;服务器模式</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li><strong>无连接</strong>：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li><li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li></ul><p>HTTP协议具有以下<strong>缺点</strong>：</p><ul><li><strong>无状态：</strong>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li><li><strong>明文传输：</strong>协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li><li><strong>不安全</strong></li></ul><p>（1）通信使用明文（不加密），内容可能会被窃听</p><p>（2）不验证通信方的身份，因此有可能遭遇伪装</p><p>（3）无法证明报文的完整性，所以有可能已遭篡改</p><h3 id="【HTTP连接方式】"><a href="#【HTTP连接方式】" class="headerlink" title="【HTTP连接方式】"></a>【HTTP连接方式】</h3><p>HTTP 协议是基于 TCP&#x2F;IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p><ul><li><strong>长连接</strong></li></ul><p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。</p><p>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。</p><p>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p><p>对于不同版本的采用不同的连接方式：</p><ul><li><p>在HTTP&#x2F;1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</p></li><li><p>在HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</p></li><li><p><strong>管道网络传输</strong></p></li></ul><p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p><p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。<font color="#409eff">也就是流水线式连接</font>。</p><h3 id="【HTTP无连接含义】"><a href="#【HTTP无连接含义】" class="headerlink" title="【HTTP无连接含义】"></a>【HTTP无连接含义】</h3><ol><li>“无连接”指的是<strong>应用层的逻辑连接</strong></li></ol><ul><li>HTTP是<strong>应用层协议</strong>，设计时的“无连接”是指：<ul><li><strong>每个请求&#x2F;响应完成后，应用层不会保留连接状态</strong></li><li>一次请求处理完毕，双方不会保存这次会话的信息</li></ul></li><li>换句话说，HTTP协议本身不管理连接的持续，也不维持会话状态</li></ul><ol start="2"><li>HTTP与传输层TCP的关系</li></ol><ul><li>HTTP协议基于<strong>传输层TCP协议</strong></li><li>TCP是<strong>面向连接的协议</strong>，会建立并维护连接（如三次握手、四次挥手）</li><li>但HTTP层面，在一次请求-响应完成后，默认关闭TCP连接（HTTP&#x2F;1.0短连接）</li></ul><ol start="3"><li>什么叫无连接</li></ol><ul><li>请求和响应是<strong>独立的</strong></li><li>不需要也不保持之前请求的状态</li><li>每次请求都必须携带完成该请求所需的全部信息（例如cookies、认证信息等）</li></ul><ol start="4"><li>现代HTTP的持久连接</li></ol><ul><li>HTTP&#x2F;1.1引入持久连接，允许复用底层TCP连接，但仍然保持HTTP层的无状态特性</li><li>即使连接保持，HTTP仍然是无连接协议，因为它不维护会话信息，状态由应用管理</li></ul><p><font color="#409eff">HTTP的无连接也使得HTTP是无状态的</font>。</p><h3 id="【HTTP无状态含义】"><a href="#【HTTP无状态含义】" class="headerlink" title="【HTTP无状态含义】"></a>【HTTP无状态含义】</h3><p><strong>1. 定义</strong></p><ul><li><strong>HTTP是无状态协议</strong>，意味着<strong>服务器不会自动保留客户端之前请求的任何信息</strong>。</li><li>每一次HTTP请求都是<strong>独立的、互不关联</strong>的。</li></ul><ol start="2"><li><strong>具体表现</strong></li></ol><ul><li>当客户端向服务器发送请求时，服务器仅根据当前请求来处理，并不依赖之前的请求。</li><li>请求处理完毕后，服务器不会保存任何会话信息（状态）。</li><li>下一次请求服务器不会“记得”之前的任何事情。</li></ul><ol start="3"><li><strong>举例说明</strong></li></ol><ul><li>你第一次访问一个购物网站，添加商品到购物车后关闭页面。</li><li>第二次访问时，如果没有额外机制，服务器不知道你之前放了什么商品，因为HTTP本身不保存状态。</li></ul><ol start="4"><li><strong>无状态带来的问题</strong></li></ol><ul><li>不能自动跟踪用户会话</li><li>需要通过其他机制实现状态管理（例如：Cookie、Session、Token）</li></ul><ol start="5"><li><strong>如何解决无状态？</strong></li></ol><ul><li><strong>Cookie</strong>：浏览器保存少量信息，随请求发送给服务器</li><li><strong>Session</strong>：服务器存储用户状态，客户端通过Cookie保存会话ID</li><li><strong>Token</strong>：如JWT，包含用户身份信息，客户端每次请求携带</li></ul><ol start="6"><li><strong>为什么设计为无状态？</strong></li></ol><ul><li>简化服务器设计，提高性能和可伸缩性</li><li>服务器无需保存大量状态信息，方便分布式部署</li></ul><h3 id="【HTTP1-1】"><a href="#【HTTP1-1】" class="headerlink" title="【HTTP1.1】"></a>【HTTP1.1】</h3><p><strong>HTTP 1.1版本</strong>较之前的1.0版本又有了更大的更新，它进一步完善了HTTP协议，现在仍然有在使用，它主要有以下更新：</p><ul><li><strong>持久连接（长连接）</strong><br>该版本之前的版本所建立的都是短连接，该版本引入了持久连接的概念，就是TCP连接默认是不关闭的，建立一个TCP连接，就可以发送多个请求，减少了建立和关闭连接的消耗和延迟。<br>在请求头设置一个非标准的Connection字段:<code>Connection: keep-alive</code>就可以进行长连接，这个字段要求服务器不要关闭TCP连接，服务器同样会回应这个字段。如果想要关闭TCP连接，就要在请求中设置字段：<code>Connection: false</code></li><li><strong>管道机制(流水线式）</strong>：该版本还引入了管道机制，即在一个TCP连接里，客户端可以同时发送多个请求，不需要等收到上一个请求回应，就可以发送新的请求，但是请求的响应还是按照请求发送的顺序返回的，这样就进一步提高了HTTP协议的效率</li><li><strong>分块传输编码</strong>：在HTTP1.0版本中，如果在服务器端遇到较为耗费时间的操作，那么需要等到这一操作全部完成后，才会向客户端发送数据，这段等待时间很影响性能和客户体验。多以使用<strong>分块传输编码</strong>，只要请求或者回应的头部信息有<code>Transfer-Encoding</code>字段：<code>Transfer-Encoding: chunked</code>，就表明回应将由数量未定的数据块组成。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了</li><li>加入了新的<strong>请求方法</strong>：<strong>PUT、PATCH、HEAD、 OPTIONS、DELETE</strong></li><li>优化了<strong>缓存机制</strong>：<strong>强缓存</strong>和<strong>协商缓存</strong></li><li>客户端请求的头部信息<strong>加入了</strong><code>Host</code><strong>字段</strong>，用来指定服务器的域名，这样就可以区分同一个物理主机中的不同虚拟主机的域名</li></ul><h3 id="【HTTPS】"><a href="#【HTTPS】" class="headerlink" title="【HTTPS】"></a>【HTTPS】</h3><h4 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h4><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL&#x2F;TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><img src="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png" class title="img"><p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p><p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p><h4 id="2-TLS-SSL的工作原理"><a href="#2-TLS-SSL的工作原理" class="headerlink" title="2. TLS&#x2F;SSL的工作原理"></a>2. TLS&#x2F;SSL的工作原理</h4><p><strong>TLS&#x2F;SSL</strong>全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p><p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商<img src="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png" class title="img"></li></ul><p><strong>2.1 散列函数hash</strong></p><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p><p><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p><p><strong>2.2 对称加密</strong></p><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p><p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p><p><strong>特点：</strong> 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p><p><strong>2.3 非对称加密</strong></p><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p><p><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p><p>综合上述算法特点，TLS&#x2F;SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p><h4 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a>3. 数字证书</h4><p>现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。</p><h4 id="4-TLS握手"><a href="#4-TLS握手" class="headerlink" title="4. TLS握手"></a>4. TLS握手</h4><p>HTTPS通信过程</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">浏览器（客户端）<br><span class="hljs-code">     |</span><br><span class="hljs-code">TCP三次握手</span><br><span class="hljs-code">     |</span><br><span class="hljs-code">TLS握手（客户端Hello → 服务器Hello +证书 → 密钥协商）</span><br><span class="hljs-code">     |</span><br><span class="hljs-code">对称加密的HTTP通信</span><br><span class="hljs-code">     |</span><br><span class="hljs-code">连接关闭</span><br></code></pre></td></tr></table></figure><p>假设你用浏览器访问 <code>https://www.example.com</code>，进行TLS握手，具体过程如下：</p><ol><li>客户端发送 ClientHello</li></ol><ul><li>浏览器发送 ClientHello 消息，包含：<ul><li>支持的 TLS 协议版本（比如 TLS 1.2）</li><li>支持的加密套件列表（如 AES256-GCM-SHA384、ECDHE-RSA-AES128-SHA256 等）</li><li>一个随机数（ClientRandom），用于后续生成密钥</li><li>支持的压缩方法等扩展信息</li></ul></li></ul><ol start="2"><li>服务器响应 ServerHello</li></ol><ul><li>服务器选择使用的 TLS 版本和加密套件，比如 TLS 1.2 和 ECDHE-RSA-AES128-SHA256</li><li>服务器生成自己的随机数（ServerRandom）</li><li>发送 ServerHello 消息给客户端，包含：<ul><li>选定的协议版本和加密套件</li><li>ServerRandom</li></ul></li><li><strong>发送服务器数字证书</strong>，证书里包含服务器的公钥（如RSA公钥）和证书链</li><li>服务器可能还会发送 ServerHelloDone，表示握手消息发送完毕</li></ul><ol start="3"><li>客户端验证服务器证书</li></ol><ul><li>客户端验证服务器证书是否合法：<ul><li>是否被受信任的证书颁发机构（CA）签发</li><li>证书是否过期</li><li>证书的域名是否与访问域名匹配</li></ul></li><li>如果证书合法，客户端继续握手；否则，浏览器会提示安全警告</li></ul><ol start="4"><li>客户端生成预主密钥（Pre-Master Secret）</li></ol><ul><li>客户端生成一个随机数，称为 <strong>预主密钥</strong></li><li>使用服务器公钥加密这个预主密钥（保证只有服务器能解密）</li><li>将加密后的预主密钥发送给服务器</li></ul><ol start="5"><li>服务器用私钥解密预主密钥</li></ol><ul><li>服务器用自己的私钥解密出预主密钥</li></ul><ol start="6"><li>双方生成对称加密密钥</li></ol><ul><li>客户端和服务器分别使用<strong>预主密钥</strong>和之前交换的两个随机数（ClientRandom 和 ServerRandom）</li><li>通过预定义的密钥派生函数生成一组对称密钥（用于加密和MAC验证）</li></ul><ol start="7"><li>握手完成（ChangeCipherSpec &amp; Finished）</li></ol><ul><li>客户端发送 ChangeCipherSpec 消息，告诉服务器后续消息将用协商好的密钥加密</li><li>客户端发送 Finished 消息，内容被加密，包含之前所有握手消息的摘要，用于验证握手完整性</li><li>服务器响应 ChangeCipherSpec 和 Finished 消息，完成握手</li></ul><ol start="8"><li>加密通信开始</li></ol><ul><li>后续客户端和服务器之间的HTTP数据都用对称密钥加密传输，保证机密性和完整性</li></ul><p><strong>随机数保证每次会话密钥唯一，确保每次密钥都独特且不可预测，随机数是明文传输。</strong></p><ul><li>随机数（ClientRandom 和 ServerRandom）与预主密钥一起参与<strong>会话密钥的生成</strong></li><li>通过这两个随机数，即使预主密钥相同，每次生成的对称密钥也会不同</li><li>避免重放攻击和密钥重复使用，提高安全性</li></ul><h3 id="【HTTP状态码】"><a href="#【HTTP状态码】" class="headerlink" title="【HTTP状态码】"></a>【HTTP状态码】</h3><p>应用通常就是客户端向服务器发出请求，服务器做出响应。状态码就是让我们知道 HTTP 请求是成功、失败还是其他。HTTP状态码通常分为五类：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>定义</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接受的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作来完成请求</td></tr><tr><td>4xx</td><td>Client Error (客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>常见状态码介绍</strong></p><ul><li><strong>200 OK</strong>：请求成功，服务器返回请求的数据。</li><li><strong>301 Moved Permanently</strong>：资源已被永久移动到新地址，客户端应更新请求链接。</li><li><strong>302 Found</strong>：资源临时移动，客户端应继续使用原地址。</li><li><strong>304 Not Modified</strong>：资源未修改，客户端可使用缓存，节省带宽。</li><li><strong>400 Bad Request</strong>：请求参数错误，服务器无法理解请求。</li><li><strong>401 Unauthorized</strong>：请求未经授权，需进行身份验证。</li><li><strong>403 Forbidden</strong>：服务器拒绝访问，权限不足。</li><li><strong>404 Not Found</strong>：请求资源不存在。</li><li><strong>500 Internal Server Error</strong>：服务器内部错误，无法完成请求。</li><li><strong>503 Service Unavailable</strong>：服务器暂时不可用，可能过载或维护。</li></ul><p>更详细的 <strong>HTTP状态码</strong> 总结：</p><p>1xx - 信息性状态码（暂时响应）</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>100</td><td>Continue（继续）</td><td>服务器已收到请求，客户端继续发送请求的剩余部分</td></tr><tr><td>101</td><td>Switching Protocols（切换协议）</td><td>服务器同意切换协议</td></tr></tbody></table><p>2xx - 成功状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功，服务器返回请求的数据</td></tr><tr><td>201</td><td>Created</td><td>请求成功且服务器创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>请求已接受，但未处理完成</td></tr><tr><td>204</td><td>No Content</td><td>请求成功，但没有内容返回</td></tr></tbody></table><p>3xx - 重定向状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently（永久移动）</td><td>请求的资源已永久移动到新URL</td></tr><tr><td>302</td><td>Found（临时移动）</td><td>请求的资源临时移动</td></tr><tr><td>303</td><td>See Other</td><td>请求的响应可以在另一个URL获得</td></tr><tr><td>304</td><td>Not Modified（未修改）</td><td>资源未修改，客户端可使用缓存内容</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向，方法不变</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>永久重定向，方法不变</td></tr></tbody></table><p>4xx - 客户端错误状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>400</td><td>Bad Request（错误请求）</td><td>请求参数有误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized（未授权）</td><td>需要身份验证，用户未登录或认证失败</td></tr><tr><td>403</td><td>Forbidden（禁止访问）</td><td>服务器拒绝请求，权限不足</td></tr><tr><td>404</td><td>Not Found（未找到）</td><td>请求资源不存在</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求方法不被允许</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时</td></tr><tr><td>429</td><td>Too Many Requests</td><td>请求过多，限流</td></tr></tbody></table><p>5xx - 服务器错误状态码</p><table><thead><tr><th>状态码</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error（服务器内部错误）</td><td>服务器发生错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能</td></tr><tr><td>502</td><td>Bad Gateway</td><td>网关错误，服务器作为代理时接收无效响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务器不可用，可能过载或维护</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>网关超时</td></tr></tbody></table><h3 id="【HTTP请求方法】"><a href="#【HTTP请求方法】" class="headerlink" title="【HTTP请求方法】"></a>【HTTP请求方法】</h3><h4 id="1-GET"><a href="#1-GET" class="headerlink" title="1. GET"></a>1. GET</h4><ul><li><strong>作用</strong>：请求访问指定资源，获取资源的表示（数据）。</li><li><strong>特点</strong>：只读操作，不应有副作用，幂等（多次请求结果相同）。</li><li><strong>常用场景</strong>：获取网页内容、查询数据等。</li></ul><h4 id="2-POST"><a href="#2-POST" class="headerlink" title="2. POST"></a>2. POST</h4><ul><li><strong>作用</strong>：向服务器提交数据，用于创建资源或触发操作。</li><li><strong>特点</strong>：非幂等，可能产生副作用（比如新增数据）。</li><li><strong>常用场景</strong>：提交表单、上传文件、创建新资源。</li></ul><h4 id="3-PUT"><a href="#3-PUT" class="headerlink" title="3. PUT"></a>3. PUT</h4><ul><li><strong>作用</strong>：更新指定资源，或者如果资源不存在则创建。</li><li><strong>特点</strong>：幂等（多次执行结果相同）。</li><li><strong>常用场景</strong>：修改用户信息、更新数据。</li></ul><h4 id="4-DELETE"><a href="#4-DELETE" class="headerlink" title="4. DELETE"></a>4. DELETE</h4><ul><li><strong>作用</strong>：删除指定资源。</li><li><strong>特点</strong>：幂等。</li><li><strong>常用场景</strong>：删除数据库中的记录或文件。</li></ul><h4 id="5-HEAD"><a href="#5-HEAD" class="headerlink" title="5. HEAD"></a>5. HEAD</h4><ul><li><strong>作用</strong>：类似GET请求，但只请求响应头，不返回响应体。</li><li><strong>用途</strong>：检测资源是否存在、检查更新、获取元数据。</li></ul><h4 id="6-OPTIONS"><a href="#6-OPTIONS" class="headerlink" title="6. OPTIONS"></a>6. OPTIONS</h4><ul><li><strong>作用</strong>：询问服务器支持的HTTP方法。</li><li><strong>用途</strong>：跨域请求时，浏览器发起预检请求。</li></ul><h4 id="7-PATCH"><a href="#7-PATCH" class="headerlink" title="7. PATCH"></a>7. PATCH</h4><ul><li><strong>作用</strong>：对资源进行部分修改。</li><li><strong>特点</strong>：非幂等，修改部分字段。</li><li><strong>常用场景</strong>：局部更新资源数据。</li></ul><h3 id="【HTTP请求报文结构】"><a href="#【HTTP请求报文结构】" class="headerlink" title="【HTTP请求报文结构】"></a>【HTTP请求报文结构】</h3><p>HTTP请求报文由三部分组成：</p><ol><li><strong>请求行（Request Line）</strong></li><li><strong>请求头部（Request Headers）</strong></li><li>空行</li><li><strong>请求体（Request Body）</strong>（可选）</li></ol><h4 id="请求行（Request-Line）"><a href="#请求行（Request-Line）" class="headerlink" title="请求行（Request Line）"></a><strong>请求行（Request Line）</strong></h4><p>请求行是请求报文的第一行，包含三个部分：<code>方法 请求URL 协议版本</code></p><ul><li><strong>方法（Method）</strong>：表示客户端希望对资源执行的操作，比如：<ul><li>GET（请求资源）</li><li>POST（提交数据）</li><li>PUT（更新资源）</li><li>DELETE（删除资源）</li><li>HEAD、OPTIONS、PATCH等</li></ul></li><li><strong>请求URL（Request-URI）</strong>：请求的资源地址，通常是相对路径，如 <code>/index.html</code>。</li><li><strong>协议版本（HTTP Version）</strong>：一般是 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">GET</span> /index.<span class="hljs-property">html</span> <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span><br></code></pre></td></tr></table></figure><h4 id="请求头部（Request-Headers）"><a href="#请求头部（Request-Headers）" class="headerlink" title="请求头部（Request Headers）"></a>请求头部（Request Headers）</h4><p>请求头部是若干行键值对，用于描述客户端环境、请求特性等信息。格式为：<code>字段名: 字段值</code></p><p>常见请求头字段包括：</p><ul><li><code>Host</code>：请求的主机名和端口（HTTP&#x2F;1.1中必须）</li><li><code>User-Agent</code>：客户端浏览器或工具信息</li><li><code>Accept</code>：客户端可接受的响应内容类型</li><li><code>Accept-Language</code>：客户端可接受的语言</li><li><code>Accept-Encoding</code>：客户端可接受的压缩编码</li><li><code>Connection</code>：是否保持连接（keep-alive）</li><li><code>Cookie</code>：客户端携带的Cookie信息</li><li><code>Content-Type</code>：请求体的数据类型（POST等请求才有）</li><li><code>Content-Length</code>：请求体长度</li></ul><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Host:</span> <span class="hljs-string">www.example.com</span><br><span class="hljs-attr">User-Agent:</span> <span class="hljs-string">Mozilla/5.0</span> <span class="hljs-string">(Windows</span> <span class="hljs-string">NT</span> <span class="hljs-number">10.0</span><span class="hljs-string">;</span> <span class="hljs-string">Win64;</span> <span class="hljs-string">x64)</span><br><span class="hljs-attr">Accept:</span> <span class="hljs-string">text/html,application/xhtml+xml</span><br><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span><br></code></pre></td></tr></table></figure><p><code>Content-Type</code>常用类型：</p><table><thead><tr><th>使用场景</th><th>Content-Type</th></tr></thead><tbody><tr><td>普通文本传输</td><td><code>text/plain; charset=utf-8</code></td></tr><tr><td>浏览器请求网页</td><td><code>text/html; charset=utf-8</code></td></tr><tr><td>AJAX请求JSON数据</td><td><code>application/json</code></td></tr><tr><td>HTML表单提交</td><td><code>application/x-www-form-urlencoded</code></td></tr><tr><td>文件上传</td><td><code>multipart/form-data</code></td></tr><tr><td>图片显示</td><td><code>image/png</code>、<code>image/jpeg</code></td></tr><tr><td>下载二进制文件</td><td><code>application/octet-stream</code></td></tr></tbody></table><h4 id="请求体（Request-Body）"><a href="#请求体（Request-Body）" class="headerlink" title="请求体（Request Body）"></a>请求体（Request Body）</h4><p>请求体是请求的实体内容，只有在某些请求方法中才有（如 POST、PUT）。用于发送提交的数据，比如表单数据、JSON等。</p><h3 id="【HTTP响应报文结构】"><a href="#【HTTP响应报文结构】" class="headerlink" title="【HTTP响应报文结构】"></a>【HTTP响应报文结构】</h3><p>HTTP响应报文由三部分组成：</p><ol><li><strong>响应行（Response Line）</strong></li><li><strong>响应头部（Response Headers）</strong></li><li>空行</li><li><strong>响应体（Response Body）</strong></li></ol><h4 id="响应行（Response-Line）"><a href="#响应行（Response-Line）" class="headerlink" title="响应行（Response Line）"></a>响应行（Response Line）</h4><p>响应行是响应报文的第一行，包含三个部分：<code>协议版本 状态码 状态描述</code></p><ul><li><strong>协议版本</strong>：如 HTTP&#x2F;1.1</li><li><strong>状态码（Status Code）</strong>：三位数字，表示响应状态，如：<ul><li>1xx：信息性状态</li><li>2xx：成功（200 OK）</li><li>3xx：重定向</li><li>4xx：客户端错误（404 Not Found）</li><li>5xx：服务器错误（500 Internal Server Error）</li></ul></li><li><strong>状态描述</strong>：对状态码的简短描述，如 OK、Not Found 等</li></ul><p>示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br></code></pre></td></tr></table></figure><h4 id="响应头部（Response-Headers）"><a href="#响应头部（Response-Headers）" class="headerlink" title="响应头部（Response Headers）"></a>响应头部（Response Headers）</h4><p>响应头部是若干行键值对，描述服务器和响应体的相关信息，格式同请求头：</p><p>常见响应头字段：</p><ul><li><code>Content-Type</code>：响应体的数据类型，如 <code>text/html</code>、<code>application/json</code></li><li><code>Content-Length</code>：响应体的字节长度</li><li><code>Server</code>：服务器软件信息</li><li><code>Set-Cookie</code>：服务器向客户端设置Cookie</li><li><code>Cache-Control</code>：缓存策略</li><li><code>Date</code>：响应时间</li><li><code>Connection</code>：连接状态</li></ul><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=UTF-8</span><br><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">138</span><br><span class="hljs-attr">Server:</span> <span class="hljs-string">Apache/2.4.41</span> <span class="hljs-string">(Ubuntu)</span><br><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span><br></code></pre></td></tr></table></figure><p>响应头部与响应体之间也用空行分隔。</p><h4 id="响应体（Response-Body）"><a href="#响应体（Response-Body）" class="headerlink" title="响应体（Response Body）"></a>响应体（Response Body）</h4><p>响应体包含服务器返回给客户端的具体资源内容，比如HTML页面、图片、JSON数据等。它的格式和内容由 <code>Content-Type</code> 头部决定。</p><h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><h3 id="【缓存基础】"><a href="#【缓存基础】" class="headerlink" title="【缓存基础】"></a>【缓存基础】</h3><p>浏览器缓存分为两大类：</p><ul><li><strong>强缓存（强制缓存，Fresh Cache）</strong>：直接使用缓存，不发请求给服务器。</li><li><strong>协商缓存（协商验证缓存，Conditional Cache）</strong>：先向服务器询问资源是否更新，服务器判断后决定是否返回资源。</li></ul><p>浏览器会先判断是否使用强缓存，强缓存未命中时才发起协商缓存请求。</p><h3 id="【强缓存（强制缓存）】"><a href="#【强缓存（强制缓存）】" class="headerlink" title="【强缓存（强制缓存）】"></a>【强缓存（强制缓存）】</h3><h4 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1. 工作流程"></a>1. 工作流程</h4><p>浏览器访问资源时：</p><ul><li>先检查该资源是否存在且未过期的强缓存。</li><li>如果存在且有效，直接从缓存读取，不发起网络请求。</li><li>如果强缓存失效，浏览器才会发起网络请求。</li></ul><h4 id="2-设置方式（响应头）"><a href="#2-设置方式（响应头）" class="headerlink" title="2. 设置方式（响应头）"></a>2. 设置方式（响应头）</h4><p>服务器通过HTTP响应头告诉浏览器缓存资源的有效时间：</p><ul><li><code>Expires</code>（HTTP&#x2F;1.0，绝对时间，格式固定）</li><li><code>Cache-Control</code>（HTTP&#x2F;1.1，推荐，优先级更高）</li></ul><p><strong>具体说明</strong></p><ul><li><code>Expires: &lt;GMT时间&gt;</code><br>表示资源过期时间，客户端只要在过期时间内，使用缓存。但<code>Expires</code>是绝对时间，可能受客户端和服务器时间不一致影响。</li><li><code>Cache-Control: max-age=&lt;秒&gt;</code><br>指定资源在客户端缓存的最大生命周期（秒）。max-age优先级高于Expires。</li><li>其他 Cache-Control 指令：<ul><li><code>public</code>：所有缓存都可以缓存</li><li><code>private</code>：只有私有缓存可缓存（浏览器）</li><li><code>no-cache</code>：不使用强缓存（需协商缓存）</li><li><code>no-store</code>：不缓存</li></ul></li></ul><h4 id="3-举例"><a href="#3-举例" class="headerlink" title="3. 举例"></a>3. 举例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-string">max-age=3600</span><br><span class="hljs-attr">Expires:</span> <span class="hljs-string">Wed,</span> <span class="hljs-number">11</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2025 12:00:00 </span><span class="hljs-string">GMT</span><br></code></pre></td></tr></table></figure><p>表示缓存1小时有效期，1小时内访问不请求服务器。</p><h3 id="【协商缓存（协商验证缓存）】"><a href="#【协商缓存（协商验证缓存）】" class="headerlink" title="【协商缓存（协商验证缓存）】"></a>【协商缓存（协商验证缓存）】</h3><h4 id="1-工作流程-1"><a href="#1-工作流程-1" class="headerlink" title="1. 工作流程"></a>1. 工作流程</h4><ul><li>当强缓存失效，浏览器会带上上次缓存时服务器返回的<strong>标识</strong>向服务器发起请求，询问资源是否更新。</li><li>服务器根据标识判断资源是否改变：<ul><li>如果未改变，返回 <code>304 Not Modified</code>，浏览器使用缓存资源。</li><li>如果改变，返回新的资源和状态码 <code>200 OK</code>。</li></ul></li></ul><h4 id="2-设置方式（请求头-响应头）"><a href="#2-设置方式（请求头-响应头）" class="headerlink" title="2. 设置方式（请求头 + 响应头）"></a>2. 设置方式（请求头 + 响应头）</h4><p>服务器通过响应头告诉客户端标识，下次请求时客户端会带上验证标识。</p><p><strong>两种常用验证方式</strong></p><table><thead><tr><th>验证方式</th><th>说明</th><th>相关头部</th></tr></thead><tbody><tr><td><strong>Last-Modified &#x2F; If-Modified-Since</strong></td><td>通过最后修改时间比较是否更新</td><td>服务器响应头：<code>Last-Modified</code>   浏览器请求头：<code>If-Modified-Since</code></td></tr><tr><td><strong>ETag &#x2F; If-None-Match</strong></td><td>通过文件的唯一标识（哈希等）比较是否更新</td><td>服务器响应头：<code>ETag</code>   浏览器请求头：<code>If-None-Match</code></td></tr></tbody></table><h4 id="具体过程举例"><a href="#具体过程举例" class="headerlink" title="具体过程举例"></a>具体过程举例</h4><ol><li>服务器返回：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Last-Modified:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">11</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2025 08:00:00 </span><span class="hljs-string">GMT</span><br><span class="hljs-attr">ETag:</span> <span class="hljs-string">&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>浏览器下次请求带：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">If-Modified-Since:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">11</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2025 08:00:00 </span><span class="hljs-string">GMT</span><br><span class="hljs-attr">If-None-Match:</span> <span class="hljs-string">&quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>服务器判断资源是否变化：</li></ol><ul><li>没变化，返回状态码 <code>304 Not Modified</code>，无响应体。</li><li>变化，返回状态码 <code>200 OK</code> 和新的资源。</li></ul><h3 id="【对比总结】"><a href="#【对比总结】" class="headerlink" title="【对比总结】"></a>【对比总结】</h3><table><thead><tr><th>方面</th><th>强缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td>作用</td><td>直接使用缓存，完全不请求服务器</td><td>先向服务器询问资源是否改变</td></tr><tr><td>触发条件</td><td>缓存有效期内</td><td>缓存过期或无强缓存时触发</td></tr><tr><td>缓存时间控制</td><td>通过 <code>Cache-Control</code> &#x2F; <code>Expires</code> 设置</td><td>服务器通过<code>Last-Modified</code>&#x2F;<code>ETag</code>提供验证标识</td></tr><tr><td>网络请求</td><td>无</td><td>有请求，但服务器可能返回304</td></tr><tr><td>性能</td><td>更快，不发请求</td><td>需要发请求但节省传输资源</td></tr><tr><td>是否返回响应体</td><td>不返回</td><td>未变时不返回，变时返回</td></tr></tbody></table><h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><p>浏览器从你输入网址开始，到页面呈现在屏幕上，大致经历以下步骤：</p><h4 id="1-解析-HTML-→-生成-DOM-树"><a href="#1-解析-HTML-→-生成-DOM-树" class="headerlink" title="1. 解析 HTML → 生成 DOM 树"></a>1. 解析 HTML → 生成 DOM 树</h4><ul><li>浏览器接收到 HTML 文本后，开始<strong>从上到下解析</strong>HTML标记。</li><li>解析过程中，浏览器会根据标签构建<strong>DOM（Document Object Model）树</strong>，DOM树是页面的结构化内存表示，包含所有元素节点、文本节点等。</li><li>每个 HTML 标签对应 DOM 树中的一个节点。</li><li>注意：如果遇到 <code>&lt;script&gt;</code> 标签，且没有设置 <code>async</code> 或 <code>defer</code>，浏览器会<strong>暂停解析HTML</strong>，先下载并执行脚本，执行完再继续解析。</li></ul><h4 id="2-解析-CSS-→-生成-CSSOM-树"><a href="#2-解析-CSS-→-生成-CSSOM-树" class="headerlink" title="2. 解析 CSS → 生成 CSSOM 树"></a>2. 解析 CSS → 生成 CSSOM 树</h4><ul><li>浏览器在解析HTML的过程中，如果遇到 <code>&lt;style&gt;</code> 标签或者外部CSS文件（<code>&lt;link rel=&quot;stylesheet&quot;&gt;</code>），会<strong>同时开始解析 CSS</strong>。</li><li>CSS解析器把 CSS 代码转换成<strong>CSSOM（CSS Object Model）树</strong>，描述所有选择器和样式规则。</li><li>CSSOM树描述了每个元素应该应用的样式。</li></ul><h4 id="3-合并-DOM-CSSOM-→-生成渲染树（Render-Tree）"><a href="#3-合并-DOM-CSSOM-→-生成渲染树（Render-Tree）" class="headerlink" title="3. 合并 DOM + CSSOM → 生成渲染树（Render Tree）"></a>3. 合并 DOM + CSSOM → 生成渲染树（Render Tree）</h4><ul><li>浏览器将 DOM树和 CSSOM树结合，生成<strong>渲染树（Render Tree）</strong>。</li><li>渲染树只包含<strong>需要渲染的节点</strong>（例如 <code>display:none</code> 的节点不会出现在渲染树中）。</li><li>渲染树的每个节点包含元素的几何信息（尺寸、颜色、字体等）以及它们的布局关系。</li></ul><h4 id="4-布局（Layout-或-Reflow）"><a href="#4-布局（Layout-或-Reflow）" class="headerlink" title="4. 布局（Layout 或 Reflow）"></a>4. 布局（Layout 或 Reflow）</h4><ul><li>浏览器根据渲染树计算每个节点的<strong>具体位置和大小</strong>（x、y坐标，宽高）。</li><li>这个过程称为布局或回流（Reflow）。</li><li>布局阶段确定元素在页面上的准确位置，供后续绘制使用。</li><li>布局依赖父元素和兄弟元素的位置关系，可能触发多次回流。</li></ul><h4 id="5-绘制（Paint）"><a href="#5-绘制（Paint）" class="headerlink" title="5. 绘制（Paint）"></a>5. 绘制（Paint）</h4><ul><li>布局完成后，浏览器会遍历渲染树，将每个节点的内容转化为实际的<strong>像素绘制指令</strong>，比如绘制文字、颜色、边框、阴影等。</li><li>绘制会生成<strong>图层</strong>（Layers），之后传递给合成器进行合成。</li></ul><h4 id="6-执行-JavaScript"><a href="#6-执行-JavaScript" class="headerlink" title="6. 执行 JavaScript"></a>6. 执行 JavaScript</h4><ul><li>浏览器遇到 <code>&lt;script&gt;</code> 标签时，如果没有 <code>async</code> 或 <code>defer</code>，会暂停 HTML 解析，<strong>下载并执行 JavaScript</strong>。</li><li>JS 脚本可以操作 DOM 和 CSSOM，改变页面结构和样式。</li><li>可能会导致重新生成渲染树、重新布局和重绘。</li><li>设置 <code>defer</code> 的脚本会延迟到 DOM 解析完成后执行。</li><li>设置 <code>async</code> 的脚本会在下载完成后立即执行，且不会阻塞 HTML 解析。</li></ul><h4 id="7-并行加载资源"><a href="#7-并行加载资源" class="headerlink" title="7. 并行加载资源"></a>7. 并行加载资源</h4><ul><li>页面中存在的资源（图片、CSS文件、JS文件、字体等）会<strong>并行向服务器发起请求</strong>。</li><li>这些资源的加载和解析可能和 HTML 解析并行，也可能会影响渲染流程（例如 CSS 解析阻塞渲染，JS 可能阻塞HTML解析）。</li><li>当这些资源加载完成，会触发对应的渲染更新。</li></ul><h1 id="Promise核心总结"><a href="#Promise核心总结" class="headerlink" title="Promise核心总结"></a>Promise核心总结</h1><h2 id="Promise的引入"><a href="#Promise的引入" class="headerlink" title="Promise的引入"></a>Promise的引入</h2><h3 id="【进程与线程】"><a href="#【进程与线程】" class="headerlink" title="【进程与线程】"></a>【进程与线程】</h3><p>程序执行的基本单位</p><ol><li>进程（Process）</li></ol><ul><li>程序的一次运行实例，拥有独立的资源和内存空间。</li><li>是操作系统分配资源的最小单位。</li><li>可以并发存在多个进程，互相之间相对独立。</li></ul><ol start="2"><li>线程（Thread）</li></ol><ul><li>线程是进程中的一个执行单元，是 CPU 调度的基本单位。</li><li>一个进程中可以有多个线程，这些线程共享该进程的资源。</li><li>多线程的出现使得<strong>并发处理任务</strong>成为可能。</li></ul><ol start="3"><li>JavaScript 的运行环境</li></ol><ul><li>JavaScript 是<strong>单线程语言</strong>，即同一时间只能执行一个任务。</li><li>其运行环境（如浏览器、Node.js）通过<strong>事件循环（Event Loop）</strong>机制，配合<strong>异步 API（如定时器、网络请求）</strong>实现了伪“并发”效果。</li></ul><h3 id="【同步】"><a href="#【同步】" class="headerlink" title="【同步】"></a>【同步】</h3><p>控制执行流程的两种模式</p><p><strong>1. 同步（Synchronous）</strong></p><ul><li>所有操作按顺序执行，当前操作未完成时，程序会阻塞，等待执行完毕后再继续。</li><li>简单、直观，但当某一步操作耗时时，<strong>整个程序都被阻塞</strong>。</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">blockingTask</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; <span class="hljs-number">5000</span>) &#123;&#125; <span class="hljs-comment">// 阻塞5秒</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;任务完成&quot;</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始任务&quot;</span>);<br><span class="hljs-title function_">blockingTask</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;后续代码&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出顺序为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">开始任务<br>任务完成<br>后续代码<br></code></pre></td></tr></table></figure><p><strong>2. 为什么不能一直用同步模式？</strong></p><p><font color="#409eff">同步的最大问题是阻塞</font>，所谓阻塞就是一段代码不执行完毕其后的所有代码也不会执行。比如上述的案例中，如果sum()函数执行速度比较慢，由于我们编写的是同步代码，所以在sum()执行完之前其后所有代码都不会执行，也就是它会阻塞后边代码的执行。像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-keyword">let</span> begin = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">while</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - begin &lt; <span class="hljs-number">10000</span>)&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一行打印&quot;</span>)<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二行打印&quot;</span>)<br></code></pre></td></tr></table></figure><p>上例中sum()执行时会停顿10秒，10秒以后才会返回结果，由于是同步执行的代码，所以sum()会阻塞其后所有代码的执行，导致整个程序的执行速度极差。</p><p>在现代应用中，经常需要进行一些<strong>高耗时的操作</strong>，如：</p><ul><li>向服务器请求数据</li><li>读写本地文件</li><li>等待用户输入或响应</li></ul><p>如果这些操作都采用同步模式，将导致：</p><ul><li>用户界面冻结</li><li>网络请求阻塞主线程</li><li>整体程序无响应</li></ul><p>因此，我们需要引入<strong>异步机制</strong>。</p><h3 id="【异步】"><a href="#【异步】" class="headerlink" title="【异步】"></a>【异步】</h3><ol><li><font color="#409eff">异步的基本思路: “耗时任务交给宿主环境，完成后以事件的形式再交还 JS 主线程执行回调。”</font></li></ol><ul><li>将耗时任务“挂起”，不会阻塞主线程。</li><li>当任务完成后，通过某种机制“通知”主程序进行处理。</li><li>异步任务不是 JavaScript 引擎执行的，而是由“宿主环境的底层系统组件”执行的</li></ul><table><thead><tr><th>异步类型</th><th>真正执行者</th></tr></thead><tbody><tr><td>setTimeout</td><td>浏览器 Timer 线程</td></tr><tr><td>fetch &#x2F; xhr</td><td>浏览器 Network 线程 + OS</td></tr><tr><td>DOM 事件</td><td>浏览器 UI 线程</td></tr><tr><td>Promise</td><td>JS 引擎（微任务调度）</td></tr></tbody></table><p><strong>2. JavaScript 的异步实现方式：回调函数</strong></p><p>最早的异步处理方法是使用<strong>回调函数（Callback）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncSum</span>(<span class="hljs-params">a, b, callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">callback</span>(a + b);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">asyncSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;结果是:&quot;</span>, result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">结果是: <span class="hljs-number">3</span> （延迟<span class="hljs-number">1</span>秒后输出）<br></code></pre></td></tr></table></figure><p>对于其他的编程语言，如java，它的处理方式简单且粗暴，即多线程。线程是计算机中运算的执行者，我们代码需要线程来执行，它是一个干活的人。但是对于Node.js来说，它本身就是单线程的，没有创建多个线程的能力（就像人不能影分身一样）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> a + b<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一行打印&quot;</span>)<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二行打印&quot;</span>)<br></code></pre></td></tr></table></figure><p>上述代码，我们将计算操作放入到了setTimeout中，同样是等待10s，但是setTimeout不会阻塞其他代码的执行，而是在10秒后将函数放入到任务队列中，这样一来就可以很好的解决掉阻塞的问题。</p><p>但与此同时也产生了一个问题，函数确实不会阻塞后续代码的执行了，但是由于函数的返回值设置到了setTimeout的回调函数中调用sum时便无法获取到函数的计算结果了，此时我们得到的结果是undefined。这也是异步的一个特点，<font color="#409eff">异步代码的执行结果无法通过返回值获得</font>，返回值只能用来获取同步代码的执行结果。那么如何获取异步代码的执行结果呢？答案只有一个——回调函数，异步代码通常都需要一个回调函数作为参数，当异步代码执行完毕取得结果时便可以将结果作为回调函数的参数进行传递，这样我们便可以在回调函数中来读取结果，并完成后续操作了，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, cb</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">cb</span>(a + b)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第一行打印&quot;</span>)<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;第二行打印&quot;</span>)<br></code></pre></td></tr></table></figure><p>通过这样一个介绍，相信你对异步多少能够了解了一些。在java这种多线程的编程语言中，通常需要一个叫做线程池的东西，在程序中随时要有一些线程在线程池中待命，当有任务时需要调用线程去执行程序以完成功能，当线程池中线程不够使用时还必须要创建新的线程协助完成任务，当线程池中的闲置线程过多时也必须要清理掉一些多余的线程。无论是线程池还是线程的管理程序都需要耗费一定的系统的性能，这就要求像java这种多线程的编程语言，必须要运行在一些性能较好的服务器中。</p><p>而Node.js这种异步的编程语言，由于始终只有一个线程在干活，不需要线程池存储线程，也无需线程的管理调用程序去管理线程，所以它对服务器的要求就比较低，从而也就降低了服务器的使用成本。但是异步的编程的方式也提升了程序的复杂度，使代码变得难以理解，于是如何简化异步代码，让其更容易编写于维护就是我们下一步要面临的问题。</p><p><strong>引入回调函数：异步的初级实现</strong></p><ol><li>回调函数的定义</li></ol><ul><li>回调函数是将一个函数作为参数传入另一个函数，在该函数执行结束后再调用这个“回调函数”。</li><li>适用于处理延迟返回的结果，如网络请求、定时器等。</li></ul><ol start="2"><li>为什么异步需要回调函数？</li></ol><ul><li>因为异步操作不会立即返回结果，所以必须通过某种方式在<strong>任务完成时通知我们</strong>。</li><li>回调函数就是这个“通知机制”的基本实现。</li></ul><ol start="3"><li>回调函数的局限性</li></ol><p>随着异步操作的增多，程序结构容易变得复杂，出现“<font color="#409eff">回调地狱”（Callback Hell）</font>问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">asyncSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-function">(<span class="hljs-params">r1</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">asyncSum</span>(r1, <span class="hljs-number">3</span>, <span class="hljs-function">(<span class="hljs-params">r2</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">asyncSum</span>(r2, <span class="hljs-number">4</span>, <span class="hljs-function">(<span class="hljs-params">r3</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;最终结果:&quot;</span>, r3);<br>        &#125;);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>问题包括：</p><ul><li>嵌套层级深，可读性差</li><li>错误处理复杂，不易维护</li><li>缺乏统一的流程控制机制</li></ul><p><font color="#409eff">因此Promise就是回调函数的替代方案。</font></p><h3 id="【Promise】"><a href="#【Promise】" class="headerlink" title="【Promise】"></a>【Promise】</h3><p><strong>1. 为什么引入 Promise？</strong></p><p>Promise 的设计目标是：</p><ul><li>提供一种统一的方式来处理异步操作</li><li>改善回调地狱问题</li><li>提供更好的错误处理机制</li><li>支持链式调用，流程清晰</li></ul><p><strong>2. Promise 的本质</strong></p><ul><li>是一个<strong>对象</strong>，用于表示一个异步操作最终的<strong>完成或失败</strong>。</li><li>有三种状态：<ul><li><code>pending</code>：初始状态</li><li><code>fulfilled</code>：操作成功，调用 <code>resolve</code></li><li><code>rejected</code>：操作失败，调用 <code>reject</code></li></ul></li></ul><p><strong>3. 基本语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncSum</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(a + b);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;<br><br><span class="hljs-title function_">asyncSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncSum</span>(result, <span class="hljs-number">3</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncSum</span>(result, <span class="hljs-number">4</span>);<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;最终结果:&quot;</span>, result);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;出错了:&quot;</span>, error);<br>    &#125;);<br></code></pre></td></tr></table></figure><p><strong>4. Promise 的优势</strong></p><ul><li><strong>结构清晰</strong>，避免回调嵌套</li><li><strong>链式调用</strong>，流程线性表达</li><li><strong>统一错误处理</strong>，通过 <code>catch</code> 实现异常捕获</li></ul><h3 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h3><table><thead><tr><th>问题</th><th>原始方案</th><th>存在的问题</th><th>改进方案</th></tr></thead><tbody><tr><td>耗时操作阻塞程序</td><td>同步代码执行</td><td>用户体验差，界面卡顿</td><td>异步执行</td></tr><tr><td>异步结果处理机制</td><td>回调函数（callback）</td><td>可读性差，嵌套复杂，难调试</td><td>Promise</td></tr><tr><td>多异步操作流程控制复杂</td><td>多层嵌套</td><td>缺乏统一流程管理</td><td>Promise 链式调用</td></tr><tr><td>异步错误难以处理</td><td>try-catch 无效</td><td>异常不易传播</td><td><code>.catch()</code></td></tr></tbody></table><p><font color="#409eff">面试回答模板：</font></p><p>在 JavaScript 中，由于它是单线程的，所有任务默认是同步执行的。但现实开发中，很多操作是耗时的，比如网络请求、文件读取、定时器等。如果这些都用同步方式处理，就会阻塞主线程，导致页面卡顿甚至无响应。</p><p>为了解决这个问题，JavaScript 引入了异步机制，而最早的异步处理方式就是回调函数。通过给异步操作传入一个回调函数，当操作完成后再调用这个回调来处理结果。</p><p>但回调函数有明显的缺点，尤其是当多个异步操作嵌套调用时，会形成所谓的“回调地狱”，代码层层嵌套、结构混乱、难以维护和调试。同时，错误处理也非常分散，不利于统一管理。</p><p>为了解决这些问题，ES6 引入了 Promise。它本质上是一个用于表示异步操作最终结果的对象。Promise 可以更清晰地组织异步代码，支持链式调用，把异步流程写得像同步代码一样清晰。它还提供统一的错误捕获机制，使得异步代码更加易读、易维护。</p><h2 id="Promise介绍"><a href="#Promise介绍" class="headerlink" title="Promise介绍"></a>Promise介绍</h2><blockquote><p><a href="https://lilichao.com/?p=6460">异步编程 – 李立超 | lilichao.com</a></p></blockquote><p>只要是通过回调函数来获取异步的结果，就一定会遇到回调地狱之类的问题。为了解决这个问题，JS为我们提供一个对象 —— Promise，Promise意为承诺，它可以用来存储一个值，并确保在你需要将这个值返回。这一点听上去似乎也并没有什么新奇的地方，任何一个对象都可以存储值，为什么非得用Promise呢？说到这就必须得看看Promise特别的存取数据的方式了！</p><h3 id="【创建Promise】"><a href="#【创建Promise】" class="headerlink" title="【创建Promise】"></a>【创建Promise】</h3><p>Promise存储值的方式非常的特别，我们先来看看它的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(executor)<br></code></pre></td></tr></table></figure><p>创建Promise时需要一个executor（执行器）为参数，执行器是一个回调函数，进一步调用它大概长这个样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure><p>回调函数在执行时会收到两个参数，两个参数都是函数。第一个函数通常命名为resolve，第二个函数通常会命名为reject。向Promise中存储值的关键就在于这两个函数，可以将想要存储到Promise中的值作为函数的参数传递，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样我们就将”哈哈”这个字符串存储到了Promise中，那么问题又来了，为什么需要两个函数存储值呢？很简单，resolve用来存储运行正确时的数据，reject用来存储运行出错时的错误信息。我们在使用Promise时需要根据不同的情况，调用不同的函数来存储不同的数据。</p><p>Promise为什么整了如此复杂的一种方式来存储数据呢？如果仅仅是存储其他的数据，这么做确实有点脱了放。但是Promise是专门为了异步调用而生的，所以Promise中存储的主要是异步调用的数据，也就是那些本来需要通过回调函数来传递的数据。在Promise中，可以直接调用异步代码，在异步代码执行完毕后直接调用resolve或reject来将执行结果存储到Promise中，这就解决了异步代码无法设置返回值的问题。换句话说，异步代码的执行结果可以直接存储到Promise中，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上例中通过setTimeout实现了一个异步调用，定时器会在10秒后执行，并调用resolve将”哈哈”存储到Promise中。现在你应该能够理解为什么Promise有这么一个奇怪的存储值的方式了吧？</p><h3 id="【获取Promise中的数据】"><a href="#【获取Promise中的数据】" class="headerlink" title="【获取Promise中的数据】"></a>【获取Promise中的数据】</h3><p>Promise存储数据的方式奇特，读取方式同样特殊。我们需要通过Promise的实例方法来读取存储到Promise中的数据。现在我们有这样一个Promise，Promise中通过resolve存储了一个数据”哈哈”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then是Promise的实例方法，通过该方法可以获取到Promise中存储的数据。它需要一个回调函数作为参数，Promise中存储的数据会作为回调函数的实参返回给我们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data) <span class="hljs-comment">// &quot;哈哈&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>注意：这种方式只适合读取通过resolve存储的数据，如果存储数据时出现了错误，或者是通过reject存储的数据，这种方式是读取不到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;出错了！&quot;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上边的两块代码都是读取不到数据的，而且运行时会在控制台报出错误信息。这是因为，then的第一个参数只负责读取Promise中代码正常执行的结果，也就是只有Promise中数据正常时才会被调用。当Promise中的代码出错，或通过reject来添加数据时，我们还需要为其指定第二个参数来处理错误。</p><p>then的第二个参数同样是一个回调函数，两个回调的函数的结构相同，不同点在于第一个回调函数会在没有异常时被调用。而第二个函数会在出现错误（或通过reject存储数据）时调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;主动抛出错误&quot;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;哈哈&quot;</span>)<br>    &#125;, <span class="hljs-number">10000</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了&quot;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure><p>上边两个案例中，then的第二个回调函数会执行。执行时异常信息或时reject中返回的数据会作为参数传递。现实开发中，第二个回调函数通常会用来编写异常处理的代码。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在Promise中维护着两个隐藏的值PromiseResult和PromiseState，PromiseResult是Promise中真正存储值的地方，在Promise中无论是通过resolve、reject还是报错时的异常信息都会存储到PromiseResult中。PromiseState用来表示Promise中值的状态，Promise一共有三种状态：pending、fulfilled、rejected。pending是Promise的初始化状态，此时Promise中没有任何值。fulfilled是Promise的完成状态，此时表示值已经正常存储到了Promise中（通过resolve）。rejected表示拒绝，此时表示值是通过reject存储的或是执行时出现了错误。</p><blockquote><p>状态一旦从 <code>pending</code> 转换为 <code>fulfilled</code> 或 <code>rejected</code>，<strong>就不可逆转</strong>。因此resolve()和reject()函数只能有一个执行且只能执行一次。</p></blockquote><p>当我们调用Promise的then方法时，相当于为Promise设置了一个回调函数，换句话说，<font color="#409eff">then中的回调函数不会立即执行，而是在Promise的PromiseState发生变化时才会执行</font>。如果PromiseState从pending变成了fulfilled则then的第一个回调函数执行，且PromiseResult的值作为参数传递给回调函数。如果PromiseState从pending变成了rejected则then的第二个回调函数执行，且PromiseResult的值作为参数传递给回调函数。</p><img src="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/NodeJS%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20221010132511667-1024x574.png" class title="img"><p><font color="#409eff">then执行后每次总会返回一个新的Promise</font>，并将then中回调函数的返回值存储到这个Promise中，如果没有指定返回值则新Promise中不会存储任何值。如果 <code>.then()</code> 的回调中<strong>返回的不是一个 Promise（而是普通值）</strong>，那它会被自动包装成一个<strong>立即 resolve 的 Promise</strong>，并作为<strong>下一个 <code>.then()</code> 的输入值</strong>继续执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> promise2 = promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> promise3 = promise2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在简化一些可以这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;第一步执行结果&quot;</span>)<br>&#125;)<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第二步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到结果：&quot;</span>, result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;第三步执行结果&quot;</span> <span class="hljs-comment">// 会作为新的结果存储到新Promise中</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>第一个then用来读取上边我们创建的Promise中存储的结果，第二个then用来读取第一个then所返回的结果，依此类推我们就可以根据需要一直then下去，如此便解决了“回调地狱”的问题。</p><p>有了Promise后，在异步函数中我们便不再需要通过回调函数来返回结果，取而代之的是返回一个Promise，并将异步执行的结果存储到Promise中，像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(a + b)<br>        &#125;, <span class="hljs-number">10000</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于sum的返回值是一个Promise，所以我们不在需要通过回调函数来读取结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;结果为：&quot;</span>, result) <span class="hljs-comment">// 结果为： 579</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>如果需要连续多次调用，也不会在有“回调地狱的问题”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br></code></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>除了then以外，Promise中还有一个catch方法，catch和then使用方式类似，但是catch中只需要一个回调函数作为参数。catch中回调函数的作用等同于then中的第二个回调函数，会在执行出错时被调用。既然有了then的第二个参数，为什么还需要一个catch呢？两个回调函数都写到then中，会导致代码不够清晰，但是多了一个catch后立刻就变的不一样了，开发时通常会在then中编写正常运行时的代码，catch中编写出现异常后要执行的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;出错了&quot;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// 出现异常，then中只传了一个回调函数，无法读取数据</span><br><span class="hljs-comment">// promise.then((data) =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(data)</span><br><span class="hljs-comment">// &#125;) </span><br><br><span class="hljs-comment">// 出现异常，可以通过catch来读取数据</span><br>promise.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>&#125;)<br></code></pre></td></tr></table></figure><p>当Promise中代码执行出错时（或者reject执行时），如果我们调用的是catch来处理数据，则Promise会将错误信息传递给catch的回调函数，我们便可以在catch中处理异常，同时catch回调函数的返回值会作为下一步Promise中的数据向下传递。如果我们调用了then来处理数据，同时没有传递第二个参数，这时then是不会执行的，而是将错误信息直接添加到下一步返回的Promise中，由后续的方法处理。在后续调用中如果有catch或then的第二个参数，则正常处理。如果没有，则报错。</p><p>简言之，处理Promise时，如果没有对Promise中的异常进行处理（无论是then的二参数，还是catch），则异常信息总是会封装到下一步的Promise中进行传递，直到找到异常处理的代码位置，如果一直没有处理，则报错。</p><p>这种设计方式使得我们可以在任意的位置对Promise的异常进行处理，例如有如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.7</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;出错了&quot;</span>)<br>        &#125;<br>        <span class="hljs-title function_">resolve</span>(a + b)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br></code></pre></td></tr></table></figure><p>上例代码中，sum函数有一定的几率会出现异常，但是我们并不确定何时会出现异常，这时有了catch就变的非常的方便，因为在出现异常后所有的then在异常处理前都不会执行，所以我们可以将catch写在调用链的最后，这样无论哪一步出现异常，我们都可以在最后统一处理。像是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哎呀出错了，随便返回一个吧&quot;</span>, <span class="hljs-number">8888</span>))<br></code></pre></td></tr></table></figure><p>当然如果我们想在中间处理异常也是没有问题的，只是需要注意在链式调用中间处理异常时，由于后续还有then要执行，所以一定不要忘了考虑是否需要在catch中返回一个结果供后续的Promise使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">777</span>))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 也可以在调用链的中间处理异常</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;出错了，我选择忽略这个错误，重新计算&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">sum</span>(<span class="hljs-number">123</span>, <span class="hljs-number">456</span>)<br>    &#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-title function_">sum</span>(result, <span class="hljs-number">888</span>))<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;哎呀出错了，随便返回一个吧&quot;</span>, <span class="hljs-number">8888</span>))<br></code></pre></td></tr></table></figure><p>还有一点要强调一下，<font color="#409eff">在Promise正常执行的情况下如果遇到catch，catch是不会执行的，此时Promise中的结果会自动传递给下一个Promise供后续使用</font>。</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally也是Promise的实例方法之一，和then、catch不同，无论何种情况finally中的回调函数总会执行，通常我们在finally中定义一些无论Promise正确执行与否都需要处理的工作。注意，finally的回调函数不会接收任何参数，同时finally的返回值也不会成为下一步的Promise中的结果。简单说，finally只是编写一些必须要执行的代码，不会对Promise产生任何实质的影响。</p><h3 id="【Promise静态方法】"><a href="#【Promise静态方法】" class="headerlink" title="【Promise静态方法】"></a>【Promise静态方法】</h3><table><thead><tr><th>方法名</th><th>简介</th></tr></thead><tbody><tr><td><code>Promise.resolve(value)</code></td><td>创建一个立即成功（fulfilled）的 Promise，值为 <code>value</code>（可以是普通值或另一个 Promise）</td></tr><tr><td><code>Promise.reject(reason)</code></td><td>创建一个立即失败（rejected）的 Promise，原因为 <code>reason</code></td></tr><tr><td><code>Promise.all(iterable)</code></td><td>所有 Promise 成功，整体才成功；有一个失败就失败（并抛出第一个失败的原因）</td></tr><tr><td><code>Promise.allSettled(iterable)</code></td><td>等待所有 Promise 都完成（无论成功或失败），返回每个结果的状态和对应值</td></tr><tr><td><code>Promise.race(iterable)</code></td><td>只看谁“先完成”（不论成功或失败），第一个 settle 的结果会被采用</td></tr><tr><td><code>Promise.any(iterable)</code></td><td>任意一个成功就整体成功，所有都失败才失败（返回一个 <code>AggregateError</code>）</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Promise.resolve</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">42</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// 输出 42</span><br><br><span class="hljs-comment">// Promise.reject</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)); <span class="hljs-comment">// 输出 Error</span><br><br><span class="hljs-comment">// Promise.all</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// Promise.race</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">res</span>(<span class="hljs-string">&#x27;A&#x27;</span>), <span class="hljs-number">100</span>)),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">res</span>(<span class="hljs-string">&#x27;B&#x27;</span>), <span class="hljs-number">200</span>))<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// &#x27;A&#x27;</span><br><br><span class="hljs-comment">// Promise.any</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;fail1&quot;</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;first success&quot;</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;second success&quot;</span>)<br>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)); <span class="hljs-comment">// &#x27;first success&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="【总结】-1"><a href="#【总结】-1" class="headerlink" title="【总结】"></a>【总结】</h3><table><thead><tr><th>问题</th><th>Promise 解决方式</th></tr></thead><tbody><tr><td>回调地狱（嵌套多、难阅读）</td><td>支持链式调用，使逻辑扁平化</td></tr><tr><td>错误分散、难统一处理</td><td>支持 <code>.catch()</code> 集中处理</td></tr><tr><td>同步代码无法获取异步结果</td><td>使用 <code>resolve</code> 显式返回结果</td></tr><tr><td>多个异步任务难以组织</td><td>可以组合 Promise.all、Promise.race 等</td></tr></tbody></table><p><font color="#409eff">面试模板：</font></p><p><strong>Promise 是 ES6 引入的一个构造函数，用来解决传统异步编程中回调地狱、回调嵌套等问题。</strong>它本质上是一个对象，用来<strong>存储异步操作的结果</strong>，并提供链式调用和统一的错误处理能力。在传统回调方式中，如果多个异步操作相互依赖，我们需要层层嵌套回调，代码结构混乱，可读性差，异常处理也分散，不易维护。而 Promise 的出现就是为了解决这些问题。</p><p>存储数据时，在Promise中维护着两个隐藏的值PromiseResult和PromiseState，PromiseResult是Promise中真正存储值的地方，在Promise中无论是通过resolve、reject还是报错时的异常信息都会存储到PromiseResult中。PromiseState用来表示Promise中值的状态，Promise一共有三种状态：pending、fulfilled、rejected。pending是Promise的初始化状态，此时Promise中没有任何值。fulfilled是Promise的完成状态，此时表示值已经正常存储到了Promise中（通过resolve）。rejected表示拒绝，此时表示值是通过reject存储的或是执行时出现了错误。<font color="#409eff">异步任务完成后，通过调用 <code>resolve</code> 或 <code>reject</code> 将结果“写入” Promise 对象，而不是通过回调函数“传出”。</font></p><p>调用数据时，使用 <code>.then()</code> 可以注册回调函数，用于处理 <code>resolve</code> 或 <code>reject</code> 的结果。每次调用 <code>.then()</code> 都会返回一个<strong>新的 Promise</strong>，并把上一个回调的返回结果继续向下传递，实现<strong>链式调用</strong>，避免了回调嵌套。<code>.catch()</code> 方法用于统一捕获 Promise 中的异常，不再需要在每一步都处理错误。当我们调用Promise的then方法时，相当于为Promise设置了一个回调函数，换句话说，<font color="#409eff">then中的回调函数不会立即执行，而是在Promise的PromiseState发生变化时才会执行</font>。如果PromiseState从pending变成了fulfilled则then的第一个回调函数执行，且PromiseResult的值作为参数传递给回调函数。如果PromiseState从pending变成了rejected则then的第二个回调函数执行，且PromiseResult的值作为参数传递给回调函数。</p><p>最终解决问题：</p><ul><li><strong>回调地狱</strong> → 通过链式调用让逻辑扁平化</li><li><strong>错误分散</strong> → 通过 <code>.catch()</code> 实现集中错误处理</li><li><strong>结果不可直接返回</strong> → 通过 <code>resolve()</code> 封装返回值，延迟处理</li><li><strong>可组合性差</strong> → Promise 提供 <code>Promise.all()</code>、<code>Promise.race()</code> 等组合方法来管理多个异步任务</li></ul><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>现在有这样一段代码，你能说出它在控制台中的输出结果吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>要真正的理解这一段代码，我们必须要先搞懂Promise中的实例方法then到底是在做什么？之前在学习Promise时，我们就已经说过了，then相当于为Promise设置了一个回调函数，当Promise中的数据处理完毕时，便会调用then所设置的回调函数来继续后续任务。</p><p>上例中，我们通过Promise.resolve()创建了一个理解完成的Promise，那么按道理讲then中的回调函数应该立刻执行啊？因为Promise已经完成了啊？所以打印的顺序不应该是“1 2 3”吗？如果能想到这些那么证明之前讲解的Promise你已经理解的差不多了，但是还不够准确！</p><p>then中的回调函数会在Promise完成后被调用，但是注意并不是立刻就调用，而是采用一种和定时器类似的处理方式，讲函数放入到一个任务队列中，而队列中的代码会在调用栈中的代码执行完毕后才会执行。也就是说then中的代码总是在当前调用栈中的代码执行完后才执行。所以上边代码的输出结果应该为：“1 3 2”</p><p>那么问题又来了，如果是这样的代码呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>错误的分析：setTimeout是定时器，它会在一段时间后将函数放入到任务队列中，而我们没有指定时间，也就意味着函数会立刻放入到任务队列中。then同样也是将函数放入到任务队列中，并且这个Promise是一个立即完成的Promise所以函数也是立刻进入任务队列。那么按照执行顺序来讲，定时器在前，then在后，所以定时器中的函数应该先进入队列，队列又是先进先出的，所以应该先1后2。</p><p>上边的分析看似合理，实际上是不对的。因为setTimeout和then虽然都将函数放入到队列中，但是却不是同一个队列。为了更合理的处理异步任务，ES标准规定了一个内部的队列“PromiseJobs”，这个队列是专门用来放置由Promise产生的回调函数的（then、catch、finally），这个队列我们通常被称为“微任务队列（microtask queue）”。相对的，setTimeout这些方法是将函数放入到了“宏任务队列（macrotask queue）”。</p><p>简单来说，任务队列有两个，宏任务队列和微任务队列。代码执行时，宏任务进入到宏任务队列，微任务进入到微任务队列。那么哪些任务时微任务，哪些任务是宏任务呢？其实大部分的任务都属于宏任务。而微任务通常在代码运行时产生，通常是由Promise所创建的，Promise的then、catch、finally中的回调函数会作为微任务进入到微任务队列中。</p><p>JS代码执行时，每一个宏任务执行完毕后，JS引擎会立即执行微任务队列中的所有任务，然后才是执行宏任务队列中的任务。换句话中then中的回调函数（微任务）会先于定时器中的回调函数（宏任务）执行。所以上例中代码的执行结果应该为：“2 1”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>))<br></code></pre></td></tr></table></figure><ul><li>将一个任务加入到微任务队列中。</li></ul><h3 id="【总结】-2"><a href="#【总结】-2" class="headerlink" title="【总结】"></a>【总结】</h3><p><font color="#409eff">面试模板：</font></p><p>在 JavaScript 中，代码的执行基于<strong>事件循环机制（Event Loop）</strong>。任务按照优先级分为两类：**宏任务（MacroTask）**和**微任务（MicroTask）**。</p><p>宏任务指的是<strong>每次执行栈运行的整体任务</strong>，执行完一个宏任务后，事件循环会去执行所有当前产生的微任务，然后再进入下一个宏任务。<br> 常见的宏任务包括：<code>script</code> 整体代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node）、<code>I/O</code>、<code>UI 渲染</code> 等。</p><p>微任务的优先级比宏任务高，它会在当前宏任务执行结束后、下一个宏任务开始前立即执行。常见的微任务包括：<code>Promise.then</code>&#x2F;<code>catch</code>&#x2F;<code>finally</code> 的回调、<code>MutationObserver</code>、<code>queueMicrotask</code> 等。</p><p>事件循环的顺序是：</p><ol><li>执行一个宏任务（比如 <code>script</code> 代码）</li><li>执行过程中如果产生微任务，将它们加入微任务队列</li><li>当前宏任务执行完后，立刻执行微任务队列，直到清空</li><li>再去执行下一个宏任务</li></ol><p>这样设计的好处是：微任务可以在宏任务之间进行高优先级的补充执行，提高响应速度，比如 <code>Promise</code> 的回调总是比 <code>setTimeout</code> 更快执行。</p><h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>async&#x2F;await 是ES7提出的基于Promise的解决异步的最终方案。</p><h3 id="【async函数】"><a href="#【async函数】" class="headerlink" title="【async函数】"></a>【async函数】</h3><p>async是一个加在函数前的修饰符，用来创建一个异步函数，被async定义的函数会默认返回一个Promise对象resolve的值。</p><p>因此对async函数可以直接then，返回值就是then方法传入的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async基础语法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">fun0</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val) <span class="hljs-comment">// 1,1</span><br>&#125;)<br><br><span class="hljs-comment">// ===&gt; 等价于</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">fun1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// Promise Promise</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//声明一个async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async function&#x27;</span>);<br>    <span class="hljs-comment">//情况1：返回非promise对象数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hahaha&#x27;</span>;<br>    <span class="hljs-comment">//情况2：返回是promise对象数据</span><br>    <span class="hljs-comment">/* return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="hljs-comment">// resolve(&#x27;ok&#x27;);</span><br><span class="hljs-comment">reject(&#x27;error&#x27;);</span><br><span class="hljs-comment">&#125;) */</span><br>    <span class="hljs-comment">//情况3：抛出异常</span><br>    <span class="hljs-comment">// throw new Error(&#x27;出错啦!!!&#x27;);</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">main</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h3 id="【await表达式】"><a href="#【await表达式】" class="headerlink" title="【await表达式】"></a>【await表达式】</h3><p>await 也是一个修饰符，只能放在async定义的函数内。可以理解为<strong>等待</strong>。</p><p>await 修饰的如果是Promise对象，可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p><p>注意事项</p><ul><li>await必须写在async函数中，但是async函数中可以没有await</li><li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li><li><font color="#409eff">当我们使用await调用函数后，当前函数后面的所有代码会在当前函数执行完毕以后，被放入到微任务队列中。</font></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>&#125;<br><span class="hljs-comment">// === &gt; </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> a,b,c<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        a = <span class="hljs-number">1</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        b = resolve<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        c = resolve<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 3秒后输出： 1 &quot;setTimeout&quot; &quot;function&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">time</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;,time)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">3000</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <br><span class="hljs-comment">// === &gt;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>))<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">log</span>(<span class="hljs-number">3000</span>);)<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br>        <span class="hljs-title function_">log</span>(<span class="hljs-number">2000</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 立即输出 undefined 1</span><br><span class="hljs-comment">// 1秒后输出 1000</span><br><span class="hljs-comment">// 2秒后输出 2000</span><br><span class="hljs-comment">// 3秒后输出 3000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//1、如果await右侧为非promise类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-string">&quot;非常6+7&quot;</span>;<br><br>    <span class="hljs-comment">//2、如果await右侧为promise成功类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125;)<br><br>    <span class="hljs-comment">//3、如果await右侧为promise失败类型数据,需要借助于try...catch捕获</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>        &#125;<br>&#125;<br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用async/await获取成功的结果</span><br><br><span class="hljs-comment">// 定义一个异步函数，3秒后才能获取到值(类似操作数据库)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomeThing</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;获取成功&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomeThing</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 3秒后输出：获取成功</span><br></code></pre></td></tr></table></figure><p>案例：async结合await读取文件内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1、导包</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123;promisify&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-comment">//2、将fs.readFile转化成promise风格的函数</span><br><span class="hljs-keyword">const</span> myreadfile = <span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><span class="hljs-comment">//3、声明async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//4、读取文件</span><br>        <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/4.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>);<br>    <span class="hljs-comment">//5、拼接读取文件内容</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one + two + three);<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//6、调用main函数</span><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><h3 id="【总结】-3"><a href="#【总结】-3" class="headerlink" title="【总结】"></a>【总结】</h3><p><code>async</code> 和 <code>await</code> 是 ES2017 引入的基于 Promise 的语法糖，用来以同步的书写方式处理异步操作。被 <code>async</code> 修饰的函数会始终返回一个 Promise，当函数返回普通值时会被自动包装成一个已完成状态的 Promise，当函数抛出异常时则会返回一个拒绝状态的 Promise。<code>await</code> 只能在 <code>async</code> 函数中使用，它会暂停函数的执行，等待其后表达式返回的 Promise 完成，并将完成的值作为返回结果，如果 Promise 被拒绝则会抛出异常，需要用 <code>try...catch</code> 来捕获。<font color="#409eff">即使 <code>await</code> 后面不是 Promise，也会被转换成一个已完成的 Promise 再处理。</font><code>async/await</code> 的核心优势是让异步代码看起来像同步代码一样直观，减少回调嵌套和链式 then 带来的可读性问题，同时可以通过 <code>try...catch</code> 统一捕获错误，从而让异步逻辑结构更清晰。但它并没有改变 JavaScript 单线程、事件循环的本质，底层依然是通过 Promise 和微任务机制来调度执行的。</p><h2 id="尚硅谷Promise从入门到精通"><a href="#尚硅谷Promise从入门到精通" class="headerlink" title="尚硅谷Promise从入门到精通"></a>尚硅谷Promise从入门到精通</h2><h3 id="一、前言：为什么会出现Promise"><a href="#一、前言：为什么会出现Promise" class="headerlink" title="一、前言：为什么会出现Promise?"></a>一、前言：为什么会出现Promise?</h3><p>Promise的重要性我认为没有必要多讲，概括起来说就是五个字：<strong>必！须！得！掌！握！</strong>。</p><p>而且还要掌握透彻，在实际的使用中，有非常多的应用场景我们不能立即知道应该如何继续往下执行。</p><p>最常见的一个场景就是ajax请求，通俗来说，由于网速的不同，可能你得到返回值的时间也是不同的，</p><p>这个时候我们就需要等待，结果出来了之后才知道怎么样继续下去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://v0.yiketianqi.com/api?unescape=1&amp;version=v61&amp;appid=82294778&amp;appsecret=4PKVFula&amp;city=%E5%8C%97%E4%BA%AC&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ajax的原生实现中，利用了onreadystatechange事件，当该事件触发并且符合一定条件时，才能拿到想要的数</p><p>据，之后才能开始处理数据，这样做看上去并没有什么麻烦，但如果这个时候，我们还需要另外一个ajax请求，这</p><p>个新ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就不得不等待上一个接口请求完成之</p><p>后，再请求后一个接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;https://v0.yiketianqi.com/api?unescape=1&amp;version=v61&amp;appid=82294778&amp;appsecret=4PKVFula&amp;city=%E5%8C%97%E4%BA%AC&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>            <br>            <span class="hljs-comment">//伪代码....</span><br>            <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>            xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;http://www.xx.com?a&#x27;</span>+xhr.<span class="hljs-property">responseText</span>);<br>            xhr.<span class="hljs-title function_">send</span>();<br>            xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span>&gt;=<span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span>&lt;<span class="hljs-number">300</span>)&#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>                        <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当出现第三个ajax(甚至更多)仍然依赖上一个请求时，我们的代码就变成了一场灾难。</p><p>这场灾难，往往也被称为<strong>回调地狱</strong>。</p><p>因此我们需要一个叫做Promise的东西，来解决这个问题，当然，除了回调地狱之外，还有个非常重要的需求就是</p><p><strong>为了代码更加具有可读性和可维护性，我们需要将数据请求与数据处理明确的区分开来</strong>。</p><p>上面的写法，是完全没有区分开，当数据变得复杂时，也许我们自己都无法轻松维护自己的代码了。</p><p>这也是模块化过程中，必须要掌握的一个重要技能，请一定重视。</p><h3 id="二、Promise是什么"><a href="#二、Promise是什么" class="headerlink" title="二、Promise是什么?"></a>二、Promise是什么?</h3><blockquote><p>Promise是异步编程的一种解决方案，比传统的解决方案回调函数更合理、更强大。</p><p>ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><p>指定回调函数的方式也变得更加灵活易懂，也解决了异步<code>回调地狱</code>的问题</p><p>旧方案是单纯使用回调函数，常见的异步操作有：定时器、fs模块、ajax、数据库操作  </p><p>从语法上说，Promise是一个构造函数；</p><p>从功能上说，Promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值。</p></blockquote><h4 id="2-1-Promise的初体验"><a href="#2-1-Promise的初体验" class="headerlink" title="2.1  Promise的初体验"></a>2.1  Promise的初体验</h4><p>创建promise对象（pending状态）</p><p>const p &#x3D; new Promise(executor);</p><p>其中：</p><p>executor函数:  执行器  (resolve, reject) &#x3D;&gt; {}</p><p>resolve函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {}</p><p>reject函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {}</p><p>executor会在Promise内部立即同步调用,异步操作在执行器中执行</p><p>实例对象调用Promise原型中的then方法来完成对结果的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//如果咱们公司今年挣钱了，年底就发奖金，否则不发</span><br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发奖金&#x27;</span>)<br>    &#125;, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;不发奖金&#x27;</span>)<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="三、使用Promise的好处"><a href="#三、使用Promise的好处" class="headerlink" title="三、使用Promise的好处?"></a>三、使用Promise的好处?</h3><h4 id="3-1-指定回调函数的方式更加灵活"><a href="#3-1-指定回调函数的方式更加灵活" class="headerlink" title="3.1  指定回调函数的方式更加灵活"></a>3.1  指定回调函数的方式更加灵活</h4><ol><li><p>旧的：必须在启动异步任务前指定</p></li><li><p>promise：启动异步任务-&gt;返回promise对象-&gt;给promise对象绑定回调函数</p><p>(甚至可以在异步任务结束后指定&#x2F;多个)</p></li></ol><h4 id="3-2-可以解决回调地狱问题，支持链式调用"><a href="#3-2-可以解决回调地狱问题，支持链式调用" class="headerlink" title="3.2 可以解决回调地狱问题，支持链式调用"></a>3.2 可以解决回调地狱问题，支持链式调用</h4><ol><li><p>什么是回调地狱？</p><p>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p></li><li><p>回调地狱的缺点?</p><p>不便于阅读</p><p>不便于异常处理</p></li><li><p>解决方案？</p><p>promise链式调用</p></li><li><p>终极解决方案？</p><p>async&#x2F;await</p></li></ol><h3 id="四、Promise实例对象的两个属性"><a href="#四、Promise实例对象的两个属性" class="headerlink" title="四、Promise实例对象的两个属性"></a>四、Promise实例对象的两个属性</h3><ul><li><p>PromiseState</p><p>此属性为promise对象的状态属性。</p><ul><li>fulfilled：成功的状态</li><li>rejected：失败的状态</li><li>pending：初始化的状态</li></ul><p>【注】状态只能由pending-&gt;fulfilled 或者是 pending-&gt;rejected</p></li><li><p>PromiseResult</p><p>此属性为promise对象的结果值（resolve以及reject函数的形参值）</p></li></ul><h3 id="五、resolve函数以及reject函数"><a href="#五、resolve函数以及reject函数" class="headerlink" title="五、resolve函数以及reject函数"></a>五、resolve函数以及reject函数</h3><ul><li>resolve：修改promise对象的状态，由pending修改到fulfilled；将实参设置到这个属性PromiseResult中。</li><li>reject：修改promise对象的状态，由pending修改到rejected；将实参设置到这个属性PromiseResult中。</li></ul><p>案例1：利用promise来进行读取文件操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.普通文件读取方式</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">//2.直接利用readfile来进行读取</span><br><span class="hljs-comment">/* fs.readFile(__dirname + &#x27;/data.txt&#x27;,(err,data)=&gt;&#123;</span><br><span class="hljs-comment">    if(err) throw err;</span><br><span class="hljs-comment">    console.log(data.toString());</span><br><span class="hljs-comment">&#125;) */</span><br><br><span class="hljs-comment">//3.利用promise来实现文件的读取</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(__dirname + <span class="hljs-string">&#x27;/data.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-title function_">reject</span>(err);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(data);<br>        &#125;<br>    &#125;)<br>&#125;); <br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>());<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例2：利用promise进行ajax请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>发送ajax请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//1.获取DOM元素对象</span></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">//2.绑定事件</span></span></span><br><span class="language-javascript"><span class="language-xml">        btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//3.创建promise实例对象</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//4.创建ajax实例对象</span></span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//5.打开请求</span></span></span><br><span class="language-javascript"><span class="language-xml">                xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;https://www.yiketianqi.com/free/day?appid=82294778&amp;appsecret=4PKVFula&amp;unescape=1&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//6.发送请求</span></span></span><br><span class="language-javascript"><span class="language-xml">                xhr.<span class="hljs-title function_">send</span>();</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-comment">//7.利用onreadystatechange事件</span></span></span><br><span class="language-javascript"><span class="language-xml">                xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-comment">//8.判断</span></span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                        <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                            <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                        &#125;<span class="hljs-keyword">else</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                            <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">response</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">                    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">            p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(value));</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取信息失败&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>案例3：利用promise进行数据库操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://127.0.0.1/project&#x27;</span>);<br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">//连接成功的情况</span><br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;);<br><br>    mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">//连接失败的情况</span><br>        <span class="hljs-title function_">reject</span>();<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//创建结构</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoteSchema</span> = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">content</span>: <span class="hljs-title class_">String</span><br>    &#125;)<br>    <span class="hljs-comment">//创建模型</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">NoteModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;notes&#x27;</span>, <span class="hljs-title class_">NoteSchema</span>);<br><br>    <span class="hljs-comment">//读取操作</span><br>    <span class="hljs-title class_">NoteModel</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>    &#125;)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;连接失败&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例4：封装一个函数，作用是读取文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ReadFileFun</span>(<span class="hljs-params">path</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>         fs.<span class="hljs-title function_">readFile</span>(path,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>              <span class="hljs-comment">//判断</span><br>              <span class="hljs-keyword">if</span>(err)&#123;<br>                    <span class="hljs-title function_">reject</span>(err)<br>              &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">resolve</span>(data);<br>              &#125;<br>         &#125;)<br>    &#125;);<br>&#125;<br><br><span class="hljs-title class_">ReadFileFun</span>(<span class="hljs-string">&#x27;./data.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>());<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>node中的promisify</p><ul><li>promisify  (只能在 NodeJS 环境中使用)</li><li>promisify 是 util 模块中的一个方法  util 是 nodeJS 的内置模块</li><li>作用: 返回一个新的函数, 函数的是 promise 风格的.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-comment">//通过 fs.readFile 创建一个新的函数</span><br><span class="hljs-keyword">const</span> mineReadFile = util.<span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><br><span class="hljs-title function_">mineReadFile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toString</span>());<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="六、Promise对象的状态"><a href="#六、Promise对象的状态" class="headerlink" title="六、Promise对象的状态"></a>六、Promise对象的状态</h3><p>Promise对象通过自身的状态来控制异步操作，Promise实例具有三种状态.</p><ul><li>异步操作未完成：pending</li><li>异步操作成功：fulfilled</li><li>异步操作失败：rejected</li></ul><p>这三种的状态的变化途径只有两种</p><ul><li>从pending(未完成)到fulfilled(成功)</li><li>从pending(未成功)到rejected(失败)</li></ul><p>一旦状态发生变化，就凝固了，不会再有新的状态变化，这也是Promise这个名字的由来，它的英语意思”承诺”，</p><p>一旦承诺生效，就不得再改变了，这也意味着Promise实例的状态变化只可能发生一次。</p><p>在Promise对象的构造函数中，将一个函数作为第一个参数。而这个函数，就是用来处理Promise的状态变化。</p><p>上面的resolve和reject都为一个函数，他们的作用分别是将状态修改为resolved和rejected。</p><p>因此，Promise的最终结果只有两种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">异步操作成功，<span class="hljs-title class_">Promise</span>实例传回一个值(value)，状态变为fulfilled.<br>异步操作失败，<span class="hljs-title class_">Promise</span>实例抛出一个错误(error),状态变为rejected<br></code></pre></td></tr></table></figure><h3 id="七、Promise的then方法"><a href="#七、Promise的then方法" class="headerlink" title="七、Promise的then方法"></a>七、Promise的then方法</h3><p>then：指定用于得到成功value的成功回调和用于得到失败reason的失败回调，<code>返回一个新的promise对象</code></p><ul><li>成功的状态：执行第一个回调函数</li><li>失败的状态：执行第二个回调函数</li></ul><p>promise.then()返回的新promise的结果状态由什么决定?</p><p>(1) 简单表达: 由then()指定的回调函数执行的结果决定</p><p>(2) 详细表达:</p><p>① 如果抛出异常, 新promise变为rejected, reason为抛出的异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>     <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;错误&#x27;</span>;<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>② 如果返回的是非promise的任意值, 新promise变为fulfilled, PromiseResult为返回的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>③ 如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;);<br><br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//resolve(&#x27;111&#x27;);</span><br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;)<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h3 id="八、Promise的链式调用"><a href="#八、Promise的链式调用" class="headerlink" title="八、Promise的链式调用"></a>八、Promise的链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//resolve(&#x27;ok&#x27;);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例：通过promise的链式调用来读取文件</p><p>回调地狱的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data1</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data2</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data3</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data1 + data2 + data3);<br>&#125;)<br>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>Promise的形式：</p><p>需求：读取resource下三个文件内容，并在控制台合并输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br> <span class="hljs-comment">//如果失败 则修改promise对象状态为失败</span><br>        <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err);<br>        <span class="hljs-comment">//如果成功 则修改promise对象状态为成功</span><br>        <span class="hljs-title function_">resolve</span>(data);<br>&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>             <span class="hljs-comment">//失败</span><br>            <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err);<br>            <span class="hljs-comment">//成功</span><br>            <span class="hljs-title function_">resolve</span>([value,data]);<br>        &#125;)<br>&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>             <span class="hljs-comment">//失败</span><br>            <span class="hljs-keyword">if</span>(err) <span class="hljs-title function_">reject</span>(err);<br>            value.<span class="hljs-title function_">push</span>(data);<br>            <span class="hljs-comment">//成功</span><br>            <span class="hljs-title function_">resolve</span>(value);<br>        &#125;)<br>&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>));<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="九、Promise下的几种方法"><a href="#九、Promise下的几种方法" class="headerlink" title="九、Promise下的几种方法"></a>九、Promise下的几种方法</h3><h4 id="9-1-Promise-resolve"><a href="#9-1-Promise-resolve" class="headerlink" title="9.1 Promise.resolve()"></a>9.1 Promise.resolve()</h4><p>将一个普通值转化为promise类型的数据</p><ul><li>若参数为非promise对象，则返回的结果为成功状态的promise对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">undefined</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><ul><li>若参数为promise对象，参数的状态决定返回结果的状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3);<br><br><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;OK&quot;</span>)));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p4);<br></code></pre></td></tr></table></figure><h4 id="9-2-Promise-reject"><a href="#9-2-Promise-reject" class="headerlink" title="9.2 Promise.reject()"></a>9.2 Promise.reject()</h4><p>返回的结果<code>始终为失败的Promise对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">123</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)));<br></code></pre></td></tr></table></figure><h4 id="9-3-Promise-catch"><a href="#9-3-Promise-catch" class="headerlink" title="9.3 Promise.catch()"></a>9.3 Promise.catch()</h4><p>功能是用来指定失败的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">//resolve(&#x27;success&#x27;);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br><br>p.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br><br><span class="hljs-comment">//then方法中不是必须传入两个参数，可以只传递成功时的回调函数</span><br><span class="hljs-comment">//也可以单独使用catch来指定失败的回调函数</span><br><br><span class="hljs-comment">//异常（错误）穿透</span><br><span class="hljs-comment">//当如果有多个需要执行的成功时的回调函数，可以不需要每一次都写失败回调，可以统一最后利用catch</span><br><span class="hljs-comment">//当如果promise对象的状态为reject的话，会一直向下穿透直到catch方法</span><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="9-4-Promise-all"><a href="#9-4-Promise-all" class="headerlink" title="9.4 Promise.all()"></a>9.4 Promise.all()</h4><p>作用：针对于多个Promise的异步任务进行处理</p><p>接收的参数：promise数组</p><p>返回值：promise对象，状态由<code>promise数组中的对象状态</code>决定</p><ul><li>若每个对象状态<code>都为</code>成功，则返回的promise对象状态为成功，</li></ul><p>​ 成功的结果值为<code>每个promise对象成功结构值组成的数组</code></p><ul><li>若<code>其中一个对象</code>状态为失败，则返回的promise对象状态为失败，</li></ul><p>​    失败的结果值为<code>失败的promise对象的结果值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;oh yeah&#x27;</span>);<br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，</p><p>那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</p><p>Promise.all接收一个Promise对象组成的数组作为参数，</p><p>当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//ES6中对Promise.all()的理解以及应用场景</span><br><span class="hljs-comment">//用于将多个Promise实例，包装成一个新的Promise实例</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>   <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功01&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功02&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason));<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功03&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">//参数可以不是数组，但必须是iterator接口</span><br><span class="hljs-keyword">let</span> pAll = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p2,p3]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pAll)<br><span class="hljs-comment">//pAll的状态是由p1,p2,p3来决定，只有当这三个都为成功，pAll才会为成功,反之，但凡其中一个失败结果就是失败</span><br><span class="hljs-comment">//这个时候第一个失败的实力的返回值会传递给pAll的回调函数，如果作为参数的实例，自己定义了catch方法，那么它一旦为rejected，是不会触碰到pAll中的catch方法</span><br>pAll.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>案例1：模拟请求三个接口中的数据，全部请求成功后获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUsersList</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//模拟请求用户列表数据</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;用户列表的数据&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBannersList</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//模拟请求用户列表数据</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;轮播图的数据&#x27;</span>);<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getVideoList</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//模拟请求用户列表数据</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;视频列表的数据&#x27;</span>);<br>        &#125;, <span class="hljs-number">3000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-comment">//初始加载的时候</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">initLoad</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> all = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">getUsersList</span>(), <span class="hljs-title function_">getBannersList</span>(), <span class="hljs-title function_">getVideoList</span>()]);<br>    <span class="hljs-comment">//获取成功请求的结果值</span><br>    all.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">initLoad</span>();<br></code></pre></td></tr></table></figure><p>案例2：修改多文件读取代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-keyword">const</span> mywriteFile = util.<span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><span class="hljs-keyword">let</span> one = <span class="hljs-title function_">mywriteFile</span>(<span class="hljs-string">&#x27;./resource/1.html&#x27;</span>);<br><span class="hljs-keyword">let</span> two = <span class="hljs-title function_">mywriteFile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>);<br><span class="hljs-keyword">let</span> three = <span class="hljs-title function_">mywriteFile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>);<br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([one,two,three]);<br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="9-5-Promise-race"><a href="#9-5-Promise-race" class="headerlink" title="9.5 Promise.race()"></a>9.5 Promise.race()</h4><p>Promise.race  race 赛跑的意思</p><p>参数: promise 数组</p><p>返回结果: promise 对象</p><p>状态由『最先改变状态的 promise对象』决定 </p><p>结果值由 『最先改变状态的 promise对象』决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>            &#125;, <span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;oh hou&#x27;</span>);<br><span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2, p3]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数。</p><p>不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。</p><p>而传递给then方法的值也会有所不同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">//ES6中Promise.race的用法以及使用场景</span><br>    <span class="hljs-comment">//将多个Promise实例包装成一个新的Promise实例</span><br>    <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejct</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p1成功&#x27;</span>)<br>        &#125;, <span class="hljs-number">2000</span>);<br>    &#125;)<br>    <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejct</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;p2成功&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">//调用</span><br>    <span class="hljs-keyword">const</span> prace = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]);<br>    <span class="hljs-comment">//Promise.race区别于Promise.all：</span><br>    <span class="hljs-comment">//只要是实例中有一个先改变状态，就会把这个实例的返回值传递给prace的回调函数</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//使用场景：请求超时提示</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>);<br>        &#125;, <span class="hljs-number">4000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;网络不畅,请求超时&#x27;</span>);<br>        &#125;, <span class="hljs-number">3000</span>);<br>    &#125;);<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">request</span>(), <span class="hljs-title function_">timeout</span>()]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="9-6-Promise-allSettled"><a href="#9-6-Promise-allSettled" class="headerlink" title="9.6 Promise.allSettled()"></a>9.6 Promise.allSettled()</h4><p>Promise.allSettled()方法，用来确定要一组异步操作是否都结束了(不管成功或失败)。</p><p>所以，它的名字叫”Settled”，包含了”fufilled”和”rejected”两种情况.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, url, <span class="hljs-literal">true</span>);<br>        xhr.<span class="hljs-title function_">send</span>();<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(xhr.<span class="hljs-property">responseText</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br><br>&#125;<br><span class="hljs-comment">//类比Promise下的all方法和allSettled</span><br><span class="hljs-comment">// Promise.all([ajax(&#x27;http://www.xiongmaoyouxuan.com/api/tabs&#x27;),</span><br><span class="hljs-comment">// ajax(&#x27;https://m.maizuo.com/gateway?cityId=110100&amp;k=4770248&#x27;)</span><br><span class="hljs-comment">// ]).then(value =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(value)</span><br><span class="hljs-comment">// &#125;).catch(error =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(error);</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://www.xiongmaoyouxuan.com/api/tabs&#x27;</span>),<br>                    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;https://m.maizuo.com/gateway?cityId=110100&amp;k=4770248&#x27;</span>)<br>                   ]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// console.log(value)</span><br>    <span class="hljs-keyword">let</span> successList = value.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;fulfilled&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(successList)<br><br>    <span class="hljs-keyword">let</span> errorList = value.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;rejected&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errorList)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="9-7-Promise-any"><a href="#9-7-Promise-any" class="headerlink" title="9.7 Promise.any()"></a>9.7 Promise.any()</h4><p>只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfiilled状态；</p><p>如果所有参数实例都变成rejected，包装实例就会变成rejected状态。</p><blockquote><p>Promise.any()跟Promise.race()方法很像，但是有一点不同，</p><p>就是Promise.any()不会因为某个Promise变成rejected状态而结束，</p><p>必须等到所有参数Promise变成rejected状态才会结束。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>        &#125;, <span class="hljs-number">1000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;okk&#x27;</span>);<br>        &#125;, <span class="hljs-number">2000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;, <span class="hljs-number">3000</span>)<br>    &#125;)<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([p1, p2, p3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="9-8-Promise-finally"><a href="#9-8-Promise-finally" class="headerlink" title="9.8 Promise.finally()"></a>9.8 Promise.finally()</h4><p>finally是在ES9(ES2018)中新增的一个特性：表示无论Promise对象变成fufilled还是rejected状态，最终都会被执行。</p><p>finally方法中的<code>回调函数</code>是不接受参数的，因为无论前面是fulfilled状态还是rejected状态， 它都是执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// resolve(&#x27;ok&#x27;);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="十、终止Promise链条"><a href="#十、终止Promise链条" class="headerlink" title="十、终止Promise链条"></a>十、终止Promise链条</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">111</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// return false;</span><br>    <span class="hljs-comment">// throw &#x27;出错啦&#x27;;</span><br>    <span class="hljs-comment">//有且只有一种方式 返回一个pending状态的promise对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;&#125;);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="十一、几个关键问题"><a href="#十一、几个关键问题" class="headerlink" title="十一、几个关键问题"></a>十一、几个关键问题</h3><h4 id="11-1-如何修改-promise-对象状态"><a href="#11-1-如何修改-promise-对象状态" class="headerlink" title="11.1 如何修改 promise 对象状态"></a>11.1 如何修改 promise 对象状态</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">//如何修改 promise 对象状态</span><br>    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//1. resolve</span><br>        <span class="hljs-comment">// resolve(&#x27;success&#x27;);</span><br>        <span class="hljs-comment">//2. reject</span><br>        <span class="hljs-comment">// reject(&#x27;error&#x27;);</span><br>        <span class="hljs-comment">//3. 抛出错误 异常</span><br>        <span class="hljs-comment">// throw &#x27;出问题啦! 你说出这样的话  你没有良心!!&#x27;;</span><br>        <span class="hljs-comment">// 状态的改变只有一次 </span><br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>    &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="11-2-指定多个回调执行情况"><a href="#11-2-指定多个回调执行情况" class="headerlink" title="11.2 指定多个回调执行情况"></a>11.2 指定多个回调执行情况</h4><p>问题：一个promise指定多个成功&#x2F;失败回调函数，都会调用吗？</p><p>答：会，但是前提是当promise对象的状态改变(fulfilled&#x2F;rejected)时才会调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>        <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">//promise对象是可以多次调用then方法完成多个成功/失败回调函数</span><br>            <span class="hljs-comment">//但是使用的前提是这个promise对象的状态必须要么是fulfilled或者是rejected</span><br>            <span class="hljs-comment">//不能是pending</span><br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;OK&#x27;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">//第一次指定回调</span><br>        p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>        &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>        &#125;);<br><br>        p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(value);<br>        &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">alert</span>(reason);<br>        &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="11-3-指定回调与改变状态先后顺序问题"><a href="#11-3-指定回调与改变状态先后顺序问题" class="headerlink" title="11.3 指定回调与改变状态先后顺序问题"></a>11.3 指定回调与改变状态先后顺序问题</h4><p>改变promise状态和指定回调函数执行谁先谁后？</p><ul><li><p>都有可能，正常情况下是先指定回调再改变状态，但也可以先改变状态在指定回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//若执行器函数中是异步任务, 则先指定回调, 然后再改变状态  更为常见</span><br><span class="hljs-comment">//若执行器函数中是同步任务, 则先改变状态, 然后再指定回调</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//同步任务</span><br>    <span class="hljs-comment">//resolve(&#x27;ok&#x27;);</span><br>    <span class="hljs-comment">//异步任务</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>如何先改状态再指定回调？</p><ul><li>在执行器中直接调用resolve()&#x2F;reject()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">//resolve(&#x27;ok&#x27;);</span><br><span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>延迟更长时间才调用then()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>)<br><br>&#125;)<br><span class="hljs-comment">//then方法使用定时器延迟更久的时间</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>    &#125;)<br><br>&#125;, <span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure></li><li><p>什么时候才能得到数据？</p><ul><li>如果是先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据</li><li>如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据</li></ul></li></ul><h4 id="11-4-promise-then-返回的新promise的结果状态由什么决定？"><a href="#11-4-promise-then-返回的新promise的结果状态由什么决定？" class="headerlink" title="11.4 promise.then()返回的新promise的结果状态由什么决定？"></a>11.4 promise.then()返回的新promise的结果状态由什么决定？</h4><ul><li>简单表达：由then指定的回调函数执行的结果决定</li><li>详细表达：<ul><li>如果抛出异常：新promise对象状态变成rejected，reason为抛出的异常</li><li>如果返回的是是非promise的任意值，新promise对象状态变成fulfilled，value为返回的值</li><li>如果返回的是另一个新的promise对象，此promise的结果就会称为新promise的结果</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> result = p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//return value;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;okk&#x27;</span>);<br>    &#125;)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h4 id="11-5-promise如何串联多个操作任务"><a href="#11-5-promise如何串联多个操作任务" class="headerlink" title="11.5 promise如何串联多个操作任务?"></a>11.5 promise如何串联多个操作任务?</h4><ul><li>promise的then()返回一个新的promise对象，可以写成then()方法的链式调用</li><li>通过then()的链式调用串联多个同步&#x2F;异步任务</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>            <span class="hljs-title function_">reject</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>    &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>    &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="11-6-promise的异常穿透"><a href="#11-6-promise的异常穿透" class="headerlink" title="11.6 promise的异常穿透"></a>11.6 promise的异常穿透</h4><ul><li>当使用promise的then链式调用时, 可以在最后指定失败的回调,</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="11-7-中断promise链"><a href="#11-7-中断promise链" class="headerlink" title="11.7 中断promise链"></a>11.7 中断promise链</h4><ul><li>当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数</li><li>办法: 在回调函数中返回一个pending状态的promise对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123; &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(reason);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="十二、async和await"><a href="#十二、async和await" class="headerlink" title="十二、async和await"></a>十二、async和await</h3><p>async&#x2F;await 是ES7提出的基于Promise的解决异步的最终方案。</p><h4 id="12-1-async函数"><a href="#12-1-async函数" class="headerlink" title="12.1  async函数"></a>12.1  async函数</h4><p>async是一个加在函数前的修饰符，用来创建一个异步函数，被async定义的函数会默认返回一个Promise对象resolve的值。</p><p>因此对async函数可以直接then，返回值就是then方法传入的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async基础语法</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun0</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">fun0</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val) <span class="hljs-comment">// 1,1</span><br>&#125;)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">fun1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val); <span class="hljs-comment">// Promise Promise</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//声明一个async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async function&#x27;</span>);<br>    <span class="hljs-comment">//情况1：返回非promise对象数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hahaha&#x27;</span>;<br>    <span class="hljs-comment">//情况2：返回是promise对象数据</span><br>    <span class="hljs-comment">/* return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="hljs-comment">// resolve(&#x27;ok&#x27;);</span><br><span class="hljs-comment">reject(&#x27;error&#x27;);</span><br><span class="hljs-comment">&#125;) */</span><br>    <span class="hljs-comment">//情况3：抛出异常</span><br>    <span class="hljs-comment">// throw new Error(&#x27;出错啦!!!&#x27;);</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">main</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><h4 id="12-2-await表达式"><a href="#12-2-await表达式" class="headerlink" title="12.2  await表达式"></a>12.2  await表达式</h4><p>await 也是一个修饰符，只能放在async定义的函数内。可以理解为<strong>等待</strong>。</p><p>await 修饰的如果是Promise对象，可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p><p>注意事项</p><ul><li>await必须写在async函数中，但是async函数中可以没有await</li><li>如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;function&#x27;</span><br>    &#125;()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <span class="hljs-comment">// 3秒后输出： 1 &quot;setTimeout&quot; &quot;function&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">time</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(time);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;,time)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-title function_">log</span>(<span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-title function_">log</span>(<span class="hljs-number">2000</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-title function_">fun</span>(); <br><br><span class="hljs-comment">// 立即输出 undefined 1</span><br><span class="hljs-comment">// 1秒后输出 1000</span><br><span class="hljs-comment">// 2秒后输出 2000</span><br><span class="hljs-comment">// 3秒后输出 3000</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//1、如果await右侧为非promise类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-string">&quot;非常6+7&quot;</span>;<br><br>    <span class="hljs-comment">//2、如果await右侧为promise成功类型数据</span><br>    <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>    &#125;)<br><br>    <span class="hljs-comment">//3、如果await右侧为promise失败类型数据,需要借助于try...catch捕获</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> rs = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>        &#125;<br>&#125;<br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用async/await获取成功的结果</span><br><br><span class="hljs-comment">// 定义一个异步函数，3秒后才能获取到值(类似操作数据库)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomeThing</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;获取成功&#x27;</span>)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomeThing</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 3秒后输出：获取成功</span><br></code></pre></td></tr></table></figure><p>案例：async结合await读取文件内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1、导包</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123;promisify&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>);<br><span class="hljs-comment">//2、将fs.readFile转化成promise风格的函数</span><br><span class="hljs-keyword">const</span> myreadfile = <span class="hljs-title function_">promisify</span>(fs.<span class="hljs-property">readFile</span>);<br><span class="hljs-comment">//3、声明async函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//4、读取文件</span><br>        <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/4.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/2.html&#x27;</span>);<br>        <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myreadfile</span>(<span class="hljs-string">&#x27;./resource/3.html&#x27;</span>);<br>    <span class="hljs-comment">//5、拼接读取文件内容</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one + two + three);<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//6、调用main函数</span><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><h3 id="十三、JS中的宏队列与微队列"><a href="#十三、JS中的宏队列与微队列" class="headerlink" title="十三、JS中的宏队列与微队列"></a>十三、JS中的宏队列与微队列</h3><ul><li>说明<ul><li>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</li><li>宏列队: 用来保存待执行的宏任务(回调), 比如: 定时器回调&#x2F;DOM事件回调&#x2F;ajax回调</li><li>微列队: 用来保存待执行的微任务(回调), 比如: promise的回调&#x2F;MutationObserver的回调</li><li>JS执行时会区别这2个队列<ul><li>JS引擎首先必须先执行所有的初始化同步任务代码</li><li>每次准备取出第一个宏任务执行前, 都要将所有的微任务一个一个取出来执行</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>();<br>    <span class="hljs-comment">//return ;throw</span><br>    <span class="hljs-title function_">reject</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);<br></code></pre></td></tr></table></figure><h3 id="十四、Promise常见面试题"><a href="#十四、Promise常见面试题" class="headerlink" title="十四、Promise常见面试题"></a>十四、Promise常见面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">first</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-number">6</span>)<br>        &#125;, <span class="hljs-number">0</span>)<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>    &#125;)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br>    p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>    &#125;)<br><br>&#125;))<br><span class="hljs-title function_">first</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;0&quot;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>)<br>        <span class="hljs-title function_">resolve</span>()<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4&quot;</span>)<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;5&quot;</span>)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;6&quot;</span>);<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;7&quot;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;8&quot;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="十五、手写promise自定义基础结构的搭建"><a href="#十五、手写promise自定义基础结构的搭建" class="headerlink" title="十五、手写promise自定义基础结构的搭建"></a>十五、手写promise自定义基础结构的搭建</h3><h4 id="15-1-Promise-的基本结构"><a href="#15-1-Promise-的基本结构" class="headerlink" title="15.1   Promise 的基本结构"></a>15.1   Promise 的基本结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1- Promise 是一个构造函数</span><br><span class="hljs-comment"> * 2- Promise 接收一个参数，该参数的类型是函数（执行器函数executor）</span><br><span class="hljs-comment"> * 3- executor接收两个参数（resolve,reject）,参数的类型是函数</span><br><span class="hljs-comment"> * 4- 执行器函数会同步执行。</span><br><span class="hljs-comment"> * 5- then方法在其显式原型属性上</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br>    <span class="hljs-comment">// executor是执行器函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br>        <span class="hljs-title function_">executor</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>        &#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>        &#125;);<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是我的执行器函数&quot;</span>,resolve,reject)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;over&quot;</span>,<span class="hljs-title class_">Promise</span>);<br></code></pre></td></tr></table></figure><h4 id="15-2-Promise实例拥有两个实例属性"><a href="#15-2-Promise实例拥有两个实例属性" class="headerlink" title="15.2  Promise实例拥有两个实例属性"></a>15.2  Promise实例拥有两个实例属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1- Promise实例拥有两个实例属性：</span><br><span class="hljs-comment"> * 状态（[[PromiseState]]），初始状态为pending</span><br><span class="hljs-comment"> * 值（[[PromiseResult]]）,初始值为undefined</span><br><span class="hljs-comment">*/</span> <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-title function_">executor</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>&#125;);<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是我的执行器函数&quot;</span>,resolve,reject)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-3-更改状态三种方式-方法未抽离"><a href="#15-3-更改状态三种方式-方法未抽离" class="headerlink" title="15.3 更改状态三种方式-方法未抽离"></a>15.3 更改状态三种方式-方法未抽离</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 更改状态三种方式</span><br><span class="hljs-comment"> * 1- 通过调用resolve将状态更改为成功（fulfilled），接收的值为成功值</span><br><span class="hljs-comment"> * 2- 通过调用reject将状态更改为失败(rejected)，接收的值为失败值</span><br><span class="hljs-comment"> * 3- 抛出异常将状态更改为失败(rejected)，失败的值为异常信息。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将异常信息作为失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = err;<br>&#125;<br><br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-4-更改状态三种方式-抽离为普通函数"><a href="#15-4-更改状态三种方式-抽离为普通函数" class="headerlink" title="15.4  更改状态三种方式-抽离为普通函数"></a>15.4  更改状态三种方式-抽离为普通函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> _resolve = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> _reject = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将异常信息作为失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = err;<br>&#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-5-更改状态三种方式-抽离为箭头函数"><a href="#15-5-更改状态三种方式-抽离为箭头函数" class="headerlink" title="15.5   更改状态三种方式-抽离为箭头函数"></a>15.5   更改状态三种方式-抽离为箭头函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将异常信息作为失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = err;<br>&#125;<br><br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-6-状态只允许更改一次"><a href="#15-6-状态只允许更改一次" class="headerlink" title="15.6   状态只允许更改一次"></a>15.6   状态只允许更改一次</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * pending-&gt; fulfilled</span><br><span class="hljs-comment"> * pending-&gt; rejected</span><br><span class="hljs-comment"> * 改变状态只有这两种，且一个promise对象只能改变一次，，无论变成成功还是失败，都会有一个结果值</span><br><span class="hljs-comment"> * 成功的结果数据一般称为value，失败的结果值一般称为reason</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br></code></pre></td></tr></table></figure><h4 id="15-7-then函数调用成功或失败回调函数"><a href="#15-7-then函数调用成功或失败回调函数" class="headerlink" title="15.7  then函数调用成功或失败回调函数"></a>15.7  then函数调用成功或失败回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1- then是Promise中的原型方法</span><br><span class="hljs-comment"> * 2- then函数接收两个参数（成功回调，失败回调）</span><br><span class="hljs-comment"> * 3- 如果p1状态为成功执行成功回调，失败执行失败回调。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;<br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><h4 id="15-8-then函数中的回调函数是异步调用的"><a href="#15-8-then函数中的回调函数是异步调用的" class="headerlink" title="15.8  then函数中的回调函数是异步调用的"></a>15.8  then函数中的回调函数是异步调用的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br>&#125;<br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功回调&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败回调&quot;</span>,reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;over&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="15-9-then函数返回的是一个Promise实例"><a href="#15-9-then函数返回的是一个Promise实例" class="headerlink" title="15.9  then函数返回的是一个Promise实例"></a>15.9  then函数返回的是一个Promise实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-comment">// reject(2);</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功回调&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败回调&quot;</span>,reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-10-then函数返回的Promise实例状态以及值-未优化"><a href="#15-10-then函数返回的Promise实例状态以及值-未优化" class="headerlink" title="15.10  then函数返回的Promise实例状态以及值-未优化"></a>15.10  then函数返回的Promise实例状态以及值-未优化</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * then返回的Promise实例受成功或失败回调函数返回值的影响</span><br><span class="hljs-comment"> * 1- 如果返回的是非Promise,那么p2状态为成功，值为返回值</span><br><span class="hljs-comment"> * 2- 如果返回的是Promise,那么p2状态以及值与返回的状态，值相同。</span><br><span class="hljs-comment"> * 3- 如果出现异常，那么p2状态为失败，值为异常信息。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-comment">// value.then(v=&gt;&#123;</span><br><span class="hljs-comment">// // 将返回的Promise实例设置为成功，值为v</span><br><span class="hljs-comment">// resolve(v);</span><br><span class="hljs-comment">// &#125;,s=&gt;&#123;</span><br><span class="hljs-comment">// // 将返回的Promise实例设置为失败，值为s</span><br><span class="hljs-comment">// reject(s);</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// 简化：</span><br>value.<span class="hljs-title function_">then</span>(resolve,reject)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br><span class="hljs-comment">// 异步调用</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是失败回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// value是否为Promise实例</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-comment">// 将返回Promise设置为与value相同的结果</span><br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 返回成功promise,值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 返回失败promise,值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// resolve(100)</span><br>        <span class="hljs-comment">// reject(200)</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常2&quot;</span><br>    &#125;)<br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;成功回调&quot;,value);</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// resolve(100);</span><br>        <span class="hljs-comment">// reject(2)</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常3&quot;</span><br>    &#125;)<br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;失败回调&quot;,reason);</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-11-then函数返回的Promise实例状态以及值-优化封装函数-common"><a href="#15-11-then函数返回的Promise实例状态以及值-优化封装函数-common" class="headerlink" title="15.11   then函数返回的Promise实例状态以及值-优化封装函数_common"></a>15.11   then函数返回的Promise实例状态以及值-优化封装函数_common</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// resolve(1);</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">// return new Promise((resolve,reject)=&gt;&#123;</span><br>    <span class="hljs-comment">// // resolve(100)</span><br>    <span class="hljs-comment">// // reject(200)</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常2&quot;</span><br>    <span class="hljs-comment">// &#125;)</span><br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;成功回调&quot;,value);</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">// return new Promise((resolve,reject)=&gt;&#123;</span><br>    <span class="hljs-comment">// // resolve(100);</span><br>    <span class="hljs-comment">// // reject(2)</span><br>    <span class="hljs-comment">// throw &quot;异常3&quot;</span><br>    <span class="hljs-comment">// &#125;)</span><br>    <span class="hljs-comment">// return 1;</span><br>    <span class="hljs-comment">// console.log(&quot;失败回调&quot;,reason);</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-12-增加成功与失败回调函数的默认值"><a href="#15-12-增加成功与失败回调函数的默认值" class="headerlink" title="15.12  增加成功与失败回调函数的默认值"></a>15.12  增加成功与失败回调函数的默认值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 1- then如果省略成功回调，默认成功回调为 value=&gt;value;</span><br><span class="hljs-comment"> * 2- then如果省略失败回调，默认失败回调为 reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 立即调用函数的好处：可以避免对外部的变量造成污染。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// reject(2);</span><br>&#125;)<br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">then</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-14-执行器函数常用于处理异步行为"><a href="#15-14-执行器函数常用于处理异步行为" class="headerlink" title="15.14   执行器函数常用于处理异步行为"></a>15.14   执行器函数常用于处理异步行为</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = &#123;&#125;;<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-property">onResolved</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">onResolved</span>();<br>&#125;<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-property">onRejected</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">onRejected</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = &#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">100</span>);<br>    &#125;)<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败&quot;</span>,reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-15-可以指定多个成功或失败的回调"><a href="#15-15-可以指定多个成功或失败的回调" class="headerlink" title="15.15  可以指定多个成功或失败的回调"></a>15.15  可以指定多个成功或失败的回调</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>()&#123;<br><br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以指定多个成功或失败的回调</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">100</span>);<br>    &#125;)<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功1&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败1&quot;</span>,reason);<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功2&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败2&quot;</span>,reason);<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功3&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败3&quot;</span>,reason);<br>&#125;)<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功4&quot;</span>,value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败4&quot;</span>,reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-16-catch"><a href="#15-16-catch" class="headerlink" title="15.16  catch"></a>15.16  catch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以指定多个成功或失败的回调</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">100</span>);<br>    &#125;)<br>&#125;)<br><span class="hljs-comment">// p1.then(undefined,reason=&gt;&#123;</span><br><span class="hljs-comment">// console.log(reason);</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// catch的返回值是Promise实例,实例的属性与值取决于回调函数的返回值</span><br><span class="hljs-comment">// 返回值为非Promise实例，那么得到的状态为成功，值为返回值</span><br><span class="hljs-comment">// 返回值为Promise实例，那么得到的结果与返回的结果相同。</span><br><span class="hljs-comment">// 有异常，那么得到的状态为失败，值为异常信息。</span><br><span class="hljs-keyword">const</span> p2 = p1.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-comment">// console.log(reason);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>    &#125;)<br>    <span class="hljs-comment">// throw &quot;异常&quot;</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br></code></pre></td></tr></table></figure><h4 id="15-17-链式调用支持"><a href="#15-17-链式调用支持" class="headerlink" title="15.17  链式调用支持"></a>15.17  链式调用支持</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-18-异常穿透支持"><a href="#15-18-异常穿透支持" class="headerlink" title="15.18   异常穿透支持"></a>15.18   异常穿透支持</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;异常&quot;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>,reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-19-中断Promise链"><a href="#15-19-中断Promise链" class="headerlink" title="15.19   中断Promise链"></a>15.19   中断Promise链</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">// 在回调函数中返回一个`pendding`状态的promise对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// undefined</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">// 4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="15-20-resolve"><a href="#15-20-resolve" class="headerlink" title="15.20  resolve"></a>15.20  resolve</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<span class="hljs-comment">// 如果是Promise实例直接返回</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是Promise实例，那么返回的状态为成功，值为value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// const p1 = Promise.resolve(1);</span><br><span class="hljs-comment">// console.log(p1);</span><br><br><span class="hljs-comment">// const p1 = Promise.resolve(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="hljs-comment">// resolve(2);</span><br><span class="hljs-comment">// &#125;));</span><br><span class="hljs-comment">// console.log(p1);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// const p1 = Promise.resolve(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="hljs-comment">// reject(2);</span><br><span class="hljs-comment">// &#125;));</span><br><span class="hljs-comment">// console.log(p1);</span><br><br><br><span class="hljs-keyword">const</span> p =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>&#125;)<br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1===p);<br></code></pre></td></tr></table></figure><h4 id="15-21-reject"><a href="#15-21-reject" class="headerlink" title="15.21  reject"></a>15.21  reject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>)&#123;<br><span class="hljs-comment">// executor是执行器函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>)&#123;<br><span class="hljs-comment">// 记录成功与失败回调函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// 定义实例属性state,初始值为pending</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-comment">// 定义实例属性result,初始值为undefined</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-comment">// 定义resolve函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为成功(fulfilled)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<br><span class="hljs-comment">// 成功值为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>()<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 定义reject函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value=&gt;&#123;<br><span class="hljs-comment">// 当状态已经被更改过，不允许再次更改</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 将状态更改为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><span class="hljs-comment">// 将result设置为value</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>()<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-title function_">executor</span>(_resolve,_reject);<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-title function_">_reject</span>(err);<span class="hljs-comment">// 状态更改为失败，值为异常信息</span><br>&#125;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br><span class="hljs-comment">// onResolved:成功回调</span><br><span class="hljs-comment">// onRejected:失败回调</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved,onRejected</span>)&#123;<br><span class="hljs-comment">// 如果成功回调不是函数，那么增加成功回调默认值</span><br><span class="hljs-keyword">if</span>(!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onResolved = <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>value;<br>&#125;<br><span class="hljs-comment">// 如果失败回调不是函数，那么增加失败回调默认值</span><br><span class="hljs-keyword">if</span>(!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>))&#123;<br>onRejected = <span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// value是成功回调的返回值</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断value是不是通过Promise实例化出来的（判断value是否为Promise实例）</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) value.<span class="hljs-title function_">then</span>(resolve,reject);<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 不是Promise实例，将返回的Promise状态设置为成功，值为value</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (err)&#123;<br><span class="hljs-comment">// 有异常，将返回Promise的状态更改为失败，值为err</span><br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br><br>&#125;)<br>&#125;<br><span class="hljs-comment">// 状态成功调用onResolved</span><br><span class="hljs-comment">// p1的状态为成功</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onResolved);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>)&#123;<br>_common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,onRejected);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// pending</span><br><span class="hljs-comment">// 如果状态为pending,那么保存成功与失败回调</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onResolved),<br><span class="hljs-attr">onRejected</span>:_common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>,onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br><br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<span class="hljs-comment">// 如果是Promise实例直接返回</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是Promise实例，那么返回的状态为成功，值为value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">reject</span>(value);<br>&#125;)<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);<br><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-number">2</span>);<br>&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p3);<br></code></pre></td></tr></table></figure><h4 id="15-22-完成all"><a href="#15-22-完成all" class="headerlink" title="15.22 完成all"></a>15.22 完成all</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br><span class="hljs-comment">// 接收执行器函数(executor)，执行器函数会同步执行（立即执行）。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-comment">// 初始状态</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 初始值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// _resolve函数将状态更新为成功，成功值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-comment">// 状态更新为成功</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新成功值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>();<br>&#125;)<br>&#125;<br><span class="hljs-comment">// _reject函数将状态更新为失败，失败值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 状态更新为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>();<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-title function_">executor</span>(_resolve, _reject);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-comment">// 如果有异常，将状态更新为失败，失败的值为异常信息</span><br><span class="hljs-title function_">_reject</span>(err);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 将第二个参数（对象）合并至Promise.prototype对象中。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br><span class="hljs-comment">// 1- 接收成功与失败回调函数</span><br><span class="hljs-comment">// 2- 返回的是一个Promise实例</span><br><span class="hljs-comment">// 3- onResolved成功回调，默认值为value=&gt;value;</span><br><span class="hljs-comment">// 4- onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br><span class="hljs-comment">// onResolved成功回调，默认值为value=&gt;value;</span><br><span class="hljs-keyword">if</span> (!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br><span class="hljs-comment">//onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-keyword">if</span> (!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br><span class="hljs-keyword">throw</span> reason<br>&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// callback是成功或失败回调</span><br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// value是成功回调返回结果</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断是否为Promise实例</span><br><span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>value.<span class="hljs-title function_">then</span>(resolve, reject);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 非Promise实例</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br>&#125;)<br><br>&#125;<br><span class="hljs-comment">// 判断状态为成功，调用成功回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onResolved);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onRejected);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onResolved),<br><span class="hljs-attr">onRejected</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br>&#125;,<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected);<br>&#125;<br>&#125;)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 判断接收的参数是否为Promise实例，如果是直接返回</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是，创建一个新的Promise,状态为成功，值为value;</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 返回失败的Promise,失败值为接收的value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">reject</span>(value);<br>&#125;)<br>&#125;<br><span class="hljs-comment">// 1- 接收的是数组，返回的是Promise</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>)&#123;<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> successArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseArr.<span class="hljs-property">length</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,i</span>)=&gt;</span>&#123;<br>value.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>index++;<br>successArr[i] = v;<br><span class="hljs-keyword">if</span>(index === promiseArr.<span class="hljs-property">length</span>)&#123;<br><span class="hljs-title function_">resolve</span>(successArr);<br>&#125;<br>&#125;,<span class="hljs-function"><span class="hljs-params">s</span>=&gt;</span>&#123;<br><span class="hljs-comment">// 返回Promise的状态设置失败</span><br><span class="hljs-title function_">reject</span>(s);<br>&#125;)<br>&#125;)<br>&#125;)<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">200</span>)<br>    &#125;,<span class="hljs-number">50</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">300</span>)<br>    &#125;,<span class="hljs-number">200</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-comment">// all接收的数组中的元素是Promise实例。</span><br><span class="hljs-comment">// 元素中的Promise实例都成功，p的状态为成功，值为数组，数组的元素为成功值</span><br><span class="hljs-comment">// 元素中有一个失败，那么p的状态为失败，值为失败值</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1,p2,p3,p4]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><h4 id="15-23-完成race"><a href="#15-23-完成race" class="headerlink" title="15.23 完成race"></a>15.23 完成race</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br>    <span class="hljs-comment">// 接收执行器函数(executor)，执行器函数会同步执行（立即执行）。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">executor</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-comment">// 初始状态</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 初始值</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br>        <span class="hljs-comment">// _resolve函数将状态更新为成功，成功值为接收的value</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value =&gt; &#123;<br>            <span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-comment">// 状态更新为成功</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新成功值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>                item.<span class="hljs-title function_">onResolved</span>();<br>            &#125;)<br>        &#125;<br>        <span class="hljs-comment">// _reject函数将状态更新为失败，失败值为接收的value</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value =&gt; &#123;<br>            <span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 状态更新为失败</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新失败值</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>                item.<span class="hljs-title function_">onRejected</span>();<br>            &#125;)<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-title function_">executor</span>(_resolve, _reject);<br>        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>            <span class="hljs-comment">// 如果有异常，将状态更新为失败，失败的值为异常信息</span><br>            <span class="hljs-title function_">_reject</span>(err);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将第二个参数（对象）合并至Promise.prototype对象中。</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>        <span class="hljs-comment">// 1- 接收成功与失败回调函数</span><br>        <span class="hljs-comment">// 2- 返回的是一个Promise实例</span><br>        <span class="hljs-comment">// 3- onResolved成功回调，默认值为value=&gt;value;</span><br>        <span class="hljs-comment">// 4- onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br>        <span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>            <span class="hljs-comment">// onResolved成功回调，默认值为value=&gt;value;</span><br>            <span class="hljs-keyword">if</span> (!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>            <span class="hljs-comment">//onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br>            <span class="hljs-keyword">if</span> (!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">throw</span> reason<br>            &#125;;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-comment">// callback是成功或失败回调</span><br>                <span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br>                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// value是成功回调返回结果</span><br>                            <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br>                            <span class="hljs-comment">// 判断是否为Promise实例</span><br>                            <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>                                value.<span class="hljs-title function_">then</span>(resolve, reject);<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-comment">// 非Promise实例</span><br>                                <span class="hljs-title function_">resolve</span>(value);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>                            <span class="hljs-title function_">reject</span>(err);<br>                        &#125;<br>                    &#125;)<br><br>                &#125;<br>                <span class="hljs-comment">// 判断状态为成功，调用成功回调</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onResolved);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onRejected);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br>                        <span class="hljs-attr">onResolved</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onResolved),<br>                        <span class="hljs-attr">onRejected</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onRejected)<br>                    &#125;)<br>                &#125;<br>            &#125;)<br>        &#125;,<br>        <span class="hljs-keyword">catch</span>(onRejected)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected);<br>        &#125;<br>    &#125;)<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-comment">// 判断接收的参数是否为Promise实例，如果是直接返回</span><br>        <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 如果不是，创建一个新的Promise,状态为成功，值为value;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(value);<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-comment">// 返回失败的Promise,失败值为接收的value</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            <span class="hljs-title function_">reject</span>(value);<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 1- 接收的是数组，返回的是Promise</span><br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>)&#123;<br>        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> successArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseArr.<span class="hljs-property">length</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,i</span>)=&gt;</span>&#123;<br>                value.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>                    index++;<br>                    successArr[i] = v;<br>                    <span class="hljs-keyword">if</span>(index === promiseArr.<span class="hljs-property">length</span>)&#123;<br>                        <span class="hljs-title function_">resolve</span>(successArr);<br>                    &#125;<br>                &#125;,<span class="hljs-function"><span class="hljs-params">s</span>=&gt;</span>&#123;<br>                    <span class="hljs-comment">// 返回Promise的状态设置失败</span><br>                    <span class="hljs-title function_">reject</span>(s);<br>                &#125;)<br>            &#125;)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>            promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>                <span class="hljs-comment">// value.then(v=&gt;&#123;</span><br>                <span class="hljs-comment">// resolve(v);</span><br>                <span class="hljs-comment">// &#125;,s=&gt;&#123;</span><br>                <span class="hljs-comment">// reject(s);</span><br>                <span class="hljs-comment">// &#125;)</span><br>                value.<span class="hljs-title function_">then</span>(resolve,reject);<br>            &#125;)<br>        &#125;)<br>    &#125;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">200</span>)<br>    &#125;,<span class="hljs-number">50</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">300</span>)<br>    &#125;,<span class="hljs-number">200</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-comment">// race:返回的是Promise实例，谁先执行完就与谁的状态以及值相同。</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1,p2,p3,p4]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><h4 id="15-24-class版本实现Promise"><a href="#15-24-class版本实现Promise" class="headerlink" title="15.24 class版本实现Promise"></a>15.24 class版本实现Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) &#123;<br><span class="hljs-comment">// 1-将之前构造函数体内的语句放置到constructor函数中</span><br><span class="hljs-comment">// 2-将之前prototype的属性直接放置到Promise中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 判断接收的参数是否为Promise实例，如果是直接返回</span><br><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br><span class="hljs-keyword">return</span> value;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果不是，创建一个新的Promise,状态为成功，值为value;</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<br><span class="hljs-title function_">resolve</span>(value);<br>&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>)&#123;<br><span class="hljs-comment">// 返回失败的Promise,失败值为接收的value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">reject</span>(value);<br>&#125;)<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promiseArr</span>)&#123;<br><span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> successArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(promiseArr.<span class="hljs-property">length</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,i</span>)=&gt;</span>&#123;<br>value.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>index++;<br>successArr[i] = v;<br><span class="hljs-keyword">if</span>(index === promiseArr.<span class="hljs-property">length</span>)&#123;<br><span class="hljs-title function_">resolve</span>(successArr);<br>&#125;<br>&#125;,<span class="hljs-function"><span class="hljs-params">s</span>=&gt;</span>&#123;<br><span class="hljs-comment">// 返回Promise的状态设置失败</span><br><span class="hljs-title function_">reject</span>(s);<br>&#125;)<br>&#125;)<br>&#125;)<br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promiseArr</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>promiseArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><span class="hljs-comment">// value.then(v=&gt;&#123;</span><br><span class="hljs-comment">// resolve(v);</span><br><span class="hljs-comment">// &#125;,s=&gt;&#123;</span><br><span class="hljs-comment">// reject(s);</span><br><span class="hljs-comment">// &#125;)</span><br>value.<span class="hljs-title function_">then</span>(resolve,reject);<br>&#125;)<br>&#125;)<br>&#125;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-comment">// 初始状态</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-comment">// 初始值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span> = [];<br><span class="hljs-comment">// _resolve函数将状态更新为成功，成功值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-comment">// 状态更新为成功</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新成功值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onResolved</span>();<br>&#125;)<br>&#125;<br><span class="hljs-comment">// _reject函数将状态更新为失败，失败值为接收的value</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = value =&gt; &#123;<br><span class="hljs-comment">// 如果状态已经更改，直接跳出函数体</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> !== <span class="hljs-string">&quot;pending&quot;</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-comment">// 状态更新为失败</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = value;<span class="hljs-comment">// 更新失败值</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>item.<span class="hljs-title function_">onRejected</span>();<br>&#125;)<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-title function_">executor</span>(_resolve, _reject);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-comment">// 如果有异常，将状态更新为失败，失败的值为异常信息</span><br><span class="hljs-title function_">_reject</span>(err);<br>&#125;<br>&#125;<br><span class="hljs-title function_">then</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br><span class="hljs-comment">// onResolved成功回调，默认值为value=&gt;value;</span><br><span class="hljs-keyword">if</span> (!(onResolved <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br><span class="hljs-comment">//onRejected失败回调，默认值为reason=&gt;&#123;throw reason&#125;;</span><br><span class="hljs-keyword">if</span> (!(onRejected <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>)) onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br><span class="hljs-keyword">throw</span> reason<br>&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// callback是成功或失败回调</span><br><span class="hljs-keyword">const</span> _common = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// value是成功回调返回结果</span><br><span class="hljs-keyword">const</span> value = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span>);<br><span class="hljs-comment">// 判断是否为Promise实例</span><br><span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>value.<span class="hljs-title function_">then</span>(resolve, reject);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 非Promise实例</span><br><span class="hljs-title function_">resolve</span>(value);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br><span class="hljs-title function_">reject</span>(err);<br>&#125;<br>&#125;)<br><br>&#125;<br><span class="hljs-comment">// 判断状态为成功，调用成功回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;fulfilled&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onResolved);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-string">&quot;rejected&quot;</span>) _common.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, onRejected);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackFn</span>.<span class="hljs-title function_">push</span>(&#123;<br><span class="hljs-attr">onResolved</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onResolved),<br><span class="hljs-attr">onRejected</span>: _common.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, onRejected)<br>&#125;)<br>&#125;<br>&#125;)<br>&#125;<br><span class="hljs-keyword">catch</span>(onRejected)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected);<br>&#125;<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">Promise</span> = <span class="hljs-title class_">Promise</span>;<br>&#125;)(<span class="hljs-variable language_">window</span>);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-number">200</span>)<br>    &#125;,<span class="hljs-number">50</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">300</span>)<br>    &#125;,<span class="hljs-number">200</span>)<br>&#125;)<br><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">400</span>)<br>    &#125;,<span class="hljs-number">100</span>)<br>&#125;)<br><span class="hljs-comment">// race:返回的是Promise实例，谁先执行完就与谁的状态以及值相同。</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1,p2,p3,p4]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br></code></pre></td></tr></table></figure><h1 id="Express-Web服务"><a href="#Express-Web服务" class="headerlink" title="Express(Web服务)"></a>Express(Web服务)</h1><blockquote><p><a href="https://express.js.cn/">Express - Node.js Web 应用程序框架 - Express.js 框架</a></p></blockquote><h2 id="什么是Express"><a href="#什么是Express" class="headerlink" title="什么是Express"></a>什么是Express</h2><p><strong>Express</strong> 是一个基于 <strong>Node.js</strong> 的轻量级 Web 应用框架，用于构建 Web 服务和 API。</p><p>它提供了一个简单而灵活的方式来：</p><ul><li>处理 HTTP 请求和响应</li><li>定义路由规则</li><li>使用中间件进行功能扩展</li></ul><p>Node.js 负责运行 JavaScript 并处理底层 HTTP，而Express在http模块上封装一层API，使得Web服务和处理 HTTP 请求更加高效。</p><h3 id="【核心特点】"><a href="#【核心特点】" class="headerlink" title="【核心特点】"></a>【核心特点】</h3><ol><li><strong>轻量 &amp; 灵活</strong><ul><li>不像 Django、Rails 那样自带庞大功能，只提供核心 Web 处理能力</li><li>想要什么功能用中间件扩展即可</li></ul></li><li><strong>路由系统强大</strong><ul><li>方便定义不同 URL 对应的处理逻辑</li><li>支持 RESTful API 风格</li></ul></li><li><strong>中间件机制</strong><ul><li>核心思想：请求进来时可以经过一系列处理器（中间件），每个处理器做自己的事</li><li>比如日志记录、解析 JSON、权限校验、错误处理等</li></ul></li><li><strong>支持多种模板引擎</strong><ul><li>例如 EJS、Pug（原 Jade）、Handlebars 等</li></ul></li><li><strong>与 Node.js 原生 HTTP 完全兼容</strong><ul><li>底层还是 Node.js 的 <code>http</code> 模块</li></ul></li></ol><h2 id="Express-基础用法"><a href="#Express-基础用法" class="headerlink" title="Express 基础用法"></a>Express 基础用法</h2><p><strong>安装：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install express<br></code></pre></td></tr></table></figure><p><strong>最小示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 定义一个 GET 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Express!&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running on http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后在浏览器就可以访问 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">&lt;文件名&gt;</span><br><span class="hljs-title"># 或者</span><br><span class="hljs-title">nodemon</span> <span class="hljs-tag">&lt;文件名&gt;</span><br></code></pre></td></tr></table></figure><h3 id="【Express-的运行流程】"><a href="#【Express-的运行流程】" class="headerlink" title="【Express 的运行流程】"></a>【Express 的运行流程】</h3><ol><li><strong>客户端发送请求</strong>（浏览器、Postman、其他服务）</li><li><strong>Express 应用接收请求</strong></li><li><strong>依次执行匹配的中间件</strong></li><li><strong>路由匹配</strong></li><li><strong>执行对应的处理函数</strong></li><li><strong>返回响应给客户端</strong></li></ol><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express 路由"></a><strong>Express</strong> <strong>路由</strong></h2><blockquote><p>官方定义： 路由确定了应用程序如何响应客户端对特定端点的请求</p></blockquote><h3 id="【路由的使用】"><a href="#【路由的使用】" class="headerlink" title="【路由的使用】"></a>【路由的使用】</h3><p>一个路由由 <strong>请求方法</strong>、<strong>路径</strong> 和 <strong>回调函数</strong> 三部分组成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.&lt;method&gt;(path, callback)<br></code></pre></td></tr></table></figure><ul><li><strong>method</strong>：HTTP 方法（<code>get</code>、<code>post</code>、<code>all</code> 等）</li><li><strong>path</strong>：URL 路径</li><li><strong>callback</strong>：处理请求的函数 <code>(req, res) =&gt; &#123; ... &#125;</code></li></ul><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">// 创建应用对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// GET 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;网站首页&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 首页路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我才是真正的首页&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// POST 路由</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 匹配所有请求方法</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;1 秒钟为您找到相关结果约 100,000,000 个&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已经启动, 端口监听为 3000...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【获取请求参数】"><a href="#【获取请求参数】" class="headerlink" title="【获取请求参数】"></a>【获取请求参数】</h3><p>Express 提供了便捷的 API 获取请求报文中的数据，同时兼容原生 HTTP 获取方式。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/request&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 原生 HTTP 获取方式</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">method</span>);       <span class="hljs-comment">// 请求方法</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">url</span>);          <span class="hljs-comment">// URL</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">httpVersion</span>);  <span class="hljs-comment">// HTTP 协议版本</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>);      <span class="hljs-comment">// 请求头对象</span><br><br>  <span class="hljs-comment">// Express 独有方式</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>);        <span class="hljs-comment">// 查询字符串对象（重要）</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;host&#x27;</span>));  <span class="hljs-comment">// 获取指定请求头</span><br><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求报文的获取&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><table><thead><tr><th>API</th><th>类型</th><th>说明</th><th>示例值</th></tr></thead><tbody><tr><td><strong>req.method</strong></td><td>属性</td><td>获取请求方法（大写）</td><td><code>&quot;GET&quot;</code></td></tr><tr><td><strong>req.url</strong></td><td>属性</td><td>获取请求路径和查询字符串（原始）</td><td><code>&quot;/user?id=1&quot;</code></td></tr><tr><td><strong>req.httpVersion</strong></td><td>属性</td><td>获取 HTTP 协议版本</td><td><code>&quot;1.1&quot;</code></td></tr><tr><td><strong>req.headers</strong></td><td>对象</td><td>获取所有请求头</td><td><code>&#123; host: &#39;localhost:3000&#39;, ... &#125;</code></td></tr><tr><td><strong>req.get(name)</strong></td><td>方法</td><td>获取指定请求头（不区分大小写）</td><td><code>req.get(&#39;Host&#39;)</code> → <code>&quot;localhost:3000&quot;</code></td></tr><tr><td><strong>req.query</strong></td><td>对象</td><td>获取查询字符串参数（URL <code>?</code> 之后的部分）</td><td><code>/search?key=abc</code> → <code>&#123; key: &quot;abc&quot; &#125;</code></td></tr><tr><td><strong>req.params</strong></td><td>对象</td><td>获取路由参数（路径中声明的 <code>:name</code>）</td><td><code>/user/:id</code> 访问 <code>/user/100</code> → <code>&#123; id: &quot;100&quot; &#125;</code></td></tr><tr><td><strong>req.body</strong></td><td>对象</td><td>获取请求体数据（需配合 <code>express.json()</code> 或 <code>express.urlencoded()</code> 中间件）</td><td><code>&#123; username: &quot;tom&quot;, password: &quot;123&quot; &#125;</code></td></tr><tr><td><strong>req.path</strong></td><td>属性</td><td>获取 URL 路径（不含查询字符串）</td><td><code>&quot;/user&quot;</code></td></tr><tr><td><strong>req.hostname</strong></td><td>属性</td><td>获取主机名（不包含端口）</td><td><code>&quot;localhost&quot;</code></td></tr><tr><td><strong>req.ip</strong></td><td>属性</td><td>获取客户端 IP 地址</td><td><code>&quot;127.0.0.1&quot;</code></td></tr><tr><td><strong>req.protocol</strong></td><td>属性</td><td>获取协议</td><td><code>&quot;http&quot;</code></td></tr><tr><td><strong>req.secure</strong></td><td>属性</td><td>判断是否为 HTTPS 请求</td><td><code>false</code></td></tr></tbody></table><h3 id="【获取路由参数】"><a href="#【获取路由参数】" class="headerlink" title="【获取路由参数】"></a>【获取路由参数】</h3><p>路由参数是 URL 路径中以冒号（<code>:</code>）声明的部分，用来传递数据。</p><p><strong>示例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/:id.html&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;商品详情, 商品 id 为 &#x27;</span> + req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【响应设置】"><a href="#【响应设置】" class="headerlink" title="【响应设置】"></a>【响应设置】</h3><p>express 框架封装了一些 API 来方便给客户端响应数据，并且兼容原生 HTTP 模块的获取方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入 express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 1. 基本文本响应</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/text&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;这是一个普通的文本响应&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 2. JSON 响应</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/json&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 3. 设置状态码 + 发送内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/status&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;页面未找到&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 4. 设置响应头</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/header&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Custom-Header&#x27;</span>, <span class="hljs-string">&#x27;HelloHeader&#x27;</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;已设置自定义响应头&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 5. 链式调用（状态码 + 响应头 + 内容）</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/chain&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">201</span>)<br>     .<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;X-Powered-By&#x27;</span>, <span class="hljs-string">&#x27;Express&#x27;</span>)<br>     .<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;链式调用响应成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 6. 重定向</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/redirect&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 7. 文件下载</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/download&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">download</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;package.json&#x27;</span>)); <br>&#125;);<br><br><span class="hljs-comment">// 8. 发送文件内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/file&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">sendFile</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;home.html&#x27;</span>));<br>&#125;);<br><br><span class="hljs-comment">// 9. 自定义 404 响应（放在最后）</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器已启动：http://localhost:3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td><code>res.send()</code></td><td>发送文本 &#x2F; HTML &#x2F; Buffer &#x2F; JSON（自动识别类型）</td></tr><tr><td><code>res.json()</code></td><td>发送 JSON 数据</td></tr><tr><td><code>res.status(code)</code></td><td>设置 HTTP 状态码</td></tr><tr><td><code>res.set(header, value)</code></td><td>设置响应头</td></tr><tr><td><code>res.redirect(url)</code></td><td>重定向到新 URL</td></tr><tr><td><code>res.download(filePath)</code></td><td>提示客户端下载文件</td></tr><tr><td><code>res.sendFile(filePath)</code></td><td>直接返回文件内容</td></tr><tr><td><code>res.redirect(path)</code></td><td>路由重定向</td></tr></tbody></table><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><h3 id="【什么是中间件？】"><a href="#【什么是中间件？】" class="headerlink" title="【什么是中间件？】"></a>【什么是中间件？】</h3><p><strong>中间件（Middleware）</strong> 是 Express 中处理请求和响应过程的函数。<br> 它本质上就是一个函数，可以：</p><ul><li>访问 <code>req</code>（请求对象）</li><li>访问 <code>res</code>（响应对象）</li><li>调用 <code>next()</code> 把控制权交给下一个中间件</li><li>结束请求-响应流程</li></ul><p><strong>基本格式</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-comment">// 执行一些操作...</span><br>  <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// 交给下一个中间件</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【中间件分类】"><a href="#【中间件分类】" class="headerlink" title="【中间件分类】"></a>【中间件分类】</h3><table><thead><tr><th>类型</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td><strong>应用级中间件</strong></td><td>绑定到 <code>app</code> 实例，处理所有或特定路由的请求</td><td>用 <code>app.use()</code> 或 <code>app.METHOD()</code> 定义</td></tr><tr><td><strong>路由级中间件</strong></td><td>绑定到 <code>express.Router()</code> 实例，只作用于该路由</td><td>用 <code>router.use()</code> 或 <code>router.METHOD()</code> 定义</td></tr><tr><td><strong>内置中间件</strong></td><td>Express 内置的功能（解析 JSON、静态资源等）</td><td>不需要额外安装</td></tr><tr><td><strong>第三方中间件</strong></td><td>由社区提供，增强功能</td><td>需要 <code>npm install</code> 安装</td></tr><tr><td><strong>错误处理中间件</strong></td><td>捕获和处理错误</td><td>格式特殊：有 <strong>4 个参数</strong> <code>(err, req, res, next)</code></td></tr></tbody></table><h3 id="【常见中间件用法】"><a href="#【常见中间件用法】" class="headerlink" title="【常见中间件用法】"></a>【常见中间件用法】</h3><h4 id="1-应用级中间件"><a href="#1-应用级中间件" class="headerlink" title="1.应用级中间件"></a>1.应用级中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 全局中间件（所有请求都会经过）</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;全局中间件：&#x27;</span>, req.<span class="hljs-property">method</span>, req.<span class="hljs-property">url</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br><span class="hljs-comment">// 针对特定路由的中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问了 /user 路由&#x27;</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>));<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;用户中心&#x27;</span>));<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h4 id="2-路由级中间件"><a href="#2-路由级中间件" class="headerlink" title="2.路由级中间件"></a>2.路由级中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// 路由专用中间件</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;进入路由模块&#x27;</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;用户列表&#x27;</span>));<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/detail&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;用户详情&#x27;</span>));<br><br><span class="hljs-comment">// 挂载到 app</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, router);<br></code></pre></td></tr></table></figure><ul><li>实际路由为<code>/user/list</code>和<code>/user/detail</code>，中间件也只以<code>/use</code>为根路由下的子路由生效。</li></ul><h4 id="3-内置中间件"><a href="#3-内置中间件" class="headerlink" title="3.内置中间件"></a>3.内置中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 解析 JSON 请求体</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br><br><span class="hljs-comment">// 解析 URL-encoded 表单数据</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span> &#125;));<br><br><span class="hljs-comment">// 托管静态资源</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));<br></code></pre></td></tr></table></figure><ul><li><code>express.urlencoded()</code>：解析 URL-encoded 表单数据，没解析<code>res.body</code>返回为空。</li><li><code>express.static()</code>：托管静态资源。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入express框架</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">//创建服务对象</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-comment">//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;./public&#x27;</span>)); <span class="hljs-comment">//当然这个目录中都是一些静态资源</span><br><span class="hljs-comment">//如果访问的内容经常变化，还是需要设置路由</span><br><span class="hljs-comment">//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，</span><br><span class="hljs-comment">//则谁书写在前，优先执行谁</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/index.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">request,response</span>)=&gt;</span>&#123;<br>    respsonse.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;首页&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">//监听端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3000 端口启动....&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意事项:</p><ol><li><code>index.html</code> 文件为默认打开的资源</li><li>如果静态资源与路由规则同时匹配，谁先匹配谁就响应</li><li>路由响应动态资源，静态资源中间件响应静态资源</li></ol><h4 id="4-第三方中间件"><a href="#4-第三方中间件" class="headerlink" title="4.第三方中间件"></a>4.第三方中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> morgan = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;morgan&#x27;</span>); <span class="hljs-comment">// 日志中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">morgan</span>(<span class="hljs-string">&#x27;dev&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="5-错误处理中间件"><a href="#5-错误处理中间件" class="headerlink" title="5.错误处理中间件"></a>5.错误处理中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err, req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;出错了：&#x27;</span>, err.<span class="hljs-property">message</span>);<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;服务器错误&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>注意：必须放在所有路由之后，且有 <code>(err, req, res, next)</code> 四个参数。</p></blockquote><h3 id="【中间件执行顺序】"><a href="#【中间件执行顺序】" class="headerlink" title="【中间件执行顺序】"></a>【中间件执行顺序】</h3><ol><li>按定义顺序依次执行</li><li>同一路径匹配多个中间件时，需调用 <code>next()</code> 才会继续执行</li><li>如果某个中间件没有调用 <code>next()</code> 且没有结束响应，客户端会卡住</li><li><font color="#409eff"><code>res.send()</code>和<code>next()</code>不能同时使用。</font><ul><li><strong><code>res.send()</code><strong>直接</strong>结束响应</strong>，把数据发送给客户端,一旦调用，HTTP 响应就结束了，<strong>不能再发送数据或进入下一个中间件</strong></li><li>**<code>next()</code>**把控制权交给下一个匹配的中间件或路由处理函数，不会自动结束响应。</li></ul></li></ol><h3 id="【Router】"><a href="#【Router】" class="headerlink" title="【Router】"></a>【Router】</h3><p><strong>Express Router</strong> 是 Express 提供的<strong>路由模块化机制</strong>，用来把不同功能的路由拆分到单独文件，避免所有路由都堆在 <code>app.js</code> 里。</p><h4 id="创建Router"><a href="#创建Router" class="headerlink" title="创建Router"></a>创建Router</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// productRouter.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br><br><span class="hljs-comment">// 路由专属中间件</span><br>router.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;访问了商品路由：&#x27;</span>, req.<span class="hljs-property">method</span>, req.<span class="hljs-property">url</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;商品列表&#x27;</span>);<br>&#125;);<br><br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/detail/:id&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`商品详情 ID：<span class="hljs-subst">$&#123;req.params.id&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure><h4 id="在-app-js-中挂载"><a href="#在-app-js-中挂载" class="headerlink" title="在 app.js 中挂载"></a>在 app.js 中挂载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 导入路由模块</span><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./userRouter&#x27;</span>);<br><br><span class="hljs-comment">// 挂载到 /user 前缀</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, userRouter);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器已启动 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>router.use([path], middleware)</code></td><td>挂载中间件（可选路径前缀）</td></tr><tr><td><code>router.METHOD(path, handler)</code></td><td>定义路由（METHOD 如 <code>get</code>, <code>post</code> 等）</td></tr><tr><td><code>router.route(path)</code></td><td>链式定义同一路径的多个方法</td></tr><tr><td><code>module.exports = router</code></td><td>导出路由</td></tr></tbody></table><p><strong>链式写法示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/article&#x27;</span>)<br>  .<span class="hljs-title function_">get</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;获取文章&#x27;</span>))<br>  .<span class="hljs-title function_">post</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;新增文章&#x27;</span>))<br>  .<span class="hljs-title function_">put</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;更新文章&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="多模块结构"><a href="#多模块结构" class="headerlink" title="多模块结构"></a>多模块结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">project/<br>│── app.<span class="hljs-property">js</span><br>│── routes/<br>│    ├── user.<span class="hljs-property">js</span><br>│    ├── product.<span class="hljs-property">js</span><br>│    └── article.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/user&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/product&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/product&#x27;</span>));<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/article&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/article&#x27;</span>));<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="EJS模板"><a href="#EJS模板" class="headerlink" title="EJS模板"></a>EJS模板</h2><blockquote><p>官网: <strong><a href="https://ejs.co/">https://ejs.co/</a></strong></p><p>中文站：<strong><a href="https://ejs.bootcss.com/">https://ejs.bootcss.com/</a></strong></p></blockquote><p><strong>EJS (Embedded JavaScript templates)</strong> 是一个轻量级的 JavaScript 模板引擎，用来在 HTML 中嵌入 JavaScript 代码。<br> 它的作用：将 <strong>数据</strong> 和 <strong>模板</strong> 结合，生成最终 HTML</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install ejs<br></code></pre></td></tr></table></figure><h3 id="【Express-中使用-EJS】"><a href="#【Express-中使用-EJS】" class="headerlink" title="【Express 中使用 EJS】"></a>【Express 中使用 EJS】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 1. 设置模板引擎</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;ejs&#x27;</span>);<br><br><span class="hljs-comment">// 2. 设置模板文件夹（可选，默认 views 文件夹）</span><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, __dirname + <span class="hljs-string">&#x27;/views&#x27;</span>);<br><br><span class="hljs-comment">// 路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;;<br>  <span class="hljs-comment">// 3. 渲染模板</span><br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; user &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="【EJS-模板语法】"><a href="#【EJS-模板语法】" class="headerlink" title="【EJS 模板语法】"></a>【EJS 模板语法】</h3><p>假设 <code>views/index.ejs</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>EJS 示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎 &lt;%= user.name %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：&lt;%= user.age %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- for 循环 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    &lt;% for(let i=1; i&lt;=3; i++)&#123; %&gt;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项目 &lt;%= i %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    &lt;% &#125; %&gt;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- if 判断 --&gt;</span></span><br><span class="language-xml">  &lt;% if(user.age &gt;= 18) &#123; %&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>已成年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  &lt;% &#125; else &#123; %&gt;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>未成年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  &lt;% &#125; %&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="【EJS-语法规则】"><a href="#【EJS-语法规则】" class="headerlink" title="【EJS 语法规则】"></a>【EJS 语法规则】</h3><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;%= 变量 %&gt;</code></td><td>输出转义后的内容（防 XSS）</td></tr><tr><td><code>&lt;%- 变量 %&gt;</code></td><td>输出原始 HTML（不转义）</td></tr><tr><td><code>&lt;% JS代码 %&gt;</code></td><td>执行 JavaScript 代码，不输出</td></tr><tr><td><code>&lt;% include(&#39;file&#39;) %&gt;</code></td><td>引入子模板</td></tr><tr><td><code>&lt;% for()&#123;&#125; %&gt;</code></td><td>循环</td></tr><tr><td><code>&lt;% if()&#123;&#125; %&gt;</code></td><td>条件判断</td></tr></tbody></table><h3 id="【独立渲染-EJS（不依赖-Express）】"><a href="#【独立渲染-EJS（不依赖-Express）】" class="headerlink" title="【独立渲染 EJS（不依赖 Express）】"></a>【独立渲染 EJS（不依赖 Express）】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ejs&#x27;</span>);<br><br>ejs.<span class="hljs-title function_">renderFile</span>(<span class="hljs-string">&#x27;./views/index.ejs&#x27;</span>, &#123; <span class="hljs-attr">user</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125; &#125;, <span class="hljs-function">(<span class="hljs-params">err, str</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 输出 HTML</span><br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="FS模块总结"><a href="#FS模块总结" class="headerlink" title="FS模块总结"></a>FS模块总结</h1><p><code>fs</code> (<strong>File System</strong>) 是 Node.js 内置的文件系统模块</p><ul><li>用于 <strong>文件读写</strong>、<strong>目录操作</strong>、<strong>文件状态查看</strong> 等</li><li>提供 <strong>同步</strong>（<code>xxxSync</code>）和 <strong>异步</strong>（回调&#x2F;Promise）两种 API</li><li>异步版本<strong>不会阻塞</strong>线程，性能更好</li></ul><p>导入方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用API总表"><a href="#常用API总表" class="headerlink" title="常用API总表"></a>常用API总表</h2><table><thead><tr><th>类别</th><th>异步方法</th><th>同步方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>读取文件</strong></td><td><code>fs.readFile(path, [options], callback)</code></td><td><code>fs.readFileSync(path, [options])</code></td><td>读取整个文件内容</td></tr><tr><td><strong>写入文件</strong></td><td><code>fs.writeFile(path, data, [options], callback)</code></td><td><code>fs.writeFileSync(...)</code></td><td>覆盖写入文件</td></tr><tr><td><strong>追加写入</strong></td><td><code>fs.appendFile(...)</code></td><td><code>fs.appendFileSync(...)</code></td><td>追加内容到文件末尾</td></tr><tr><td><strong>删除文件</strong></td><td><code>fs.unlink(...)</code></td><td><code>fs.unlinkSync(...)</code></td><td>删除文件</td></tr><tr><td><strong>重命名&#x2F;移动</strong></td><td><code>fs.rename(...)</code></td><td><code>fs.renameSync(...)</code></td><td>重命名文件或移动位置</td></tr><tr><td><strong>检测文件状态</strong></td><td><code>fs.stat(...)</code></td><td><code>fs.statSync(...)</code></td><td>查看文件&#x2F;目录信息</td></tr><tr><td><strong>判断存在</strong></td><td><code>fs.exists(path）</code></td><td><code>fs.existsSync(path)</code></td><td>判断路径是否存在</td></tr><tr><td><strong>创建目录</strong></td><td><code>fs.mkdir(...)</code></td><td><code>fs.mkdirSync(...)</code></td><td>创建文件夹</td></tr><tr><td><strong>读取目录</strong></td><td><code>fs.readdir(...)</code></td><td><code>fs.readdirSync(...)</code></td><td>获取目录内容</td></tr><tr><td><strong>删除目录</strong></td><td><code>fs.rmdir(...)</code></td><td><code>fs.rmdirSync(...)</code></td><td>删除文件夹（空）</td></tr><tr><td><strong>流式读取</strong></td><td><code>fs.createReadStream(path)</code></td><td>-</td><td>创建可读流</td></tr><tr><td><strong>流式写入</strong></td><td><code>fs.createWriteStream(path)</code></td><td>-</td><td>创建可写流</td></tr></tbody></table><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><h3 id="【读取文件】"><a href="#【读取文件】" class="headerlink" title="【读取文件】"></a>【读取文件】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件内容:&#x27;</span>, data);<br>&#125;);<br><br><span class="hljs-comment">// 同步</span><br><span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><h3 id="【写入-追加】"><a href="#【写入-追加】" class="headerlink" title="【写入&#x2F;追加】"></a>【写入&#x2F;追加】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 覆盖写入</span><br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;Hello World&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 追加写入</span><br>fs.<span class="hljs-title function_">appendFile</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;\n追加内容&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【删除-重命名】"><a href="#【删除-重命名】" class="headerlink" title="【删除&#x2F;重命名】"></a>【删除&#x2F;重命名】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">unlink</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除成功&#x27;</span>);<br>&#125;);<br><br>fs.<span class="hljs-title function_">rename</span>(<span class="hljs-string">&#x27;./old.txt&#x27;</span>, <span class="hljs-string">&#x27;./new.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;重命名成功&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【目录操作】"><a href="#【目录操作】" class="headerlink" title="【目录操作】"></a>【目录操作】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建目录</span><br>fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">&#x27;./demo&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录创建成功&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 读取目录</span><br>fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">&#x27;./demo&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录内容:&#x27;</span>, files);<br>&#125;);<br><br><span class="hljs-comment">// 删除目录（空目录）</span><br>fs.<span class="hljs-title function_">rmdir</span>(<span class="hljs-string">&#x27;./demo&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录删除成功&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【文件状态】"><a href="#【文件状态】" class="headerlink" title="【文件状态】"></a>【文件状态】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, stats</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stats.<span class="hljs-title function_">isFile</span>()); <span class="hljs-comment">// true</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stats.<span class="hljs-title function_">isDirectory</span>()); <span class="hljs-comment">// false</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【流式读写】"><a href="#【流式读写】" class="headerlink" title="【流式读写】"></a>【流式读写】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./input.txt&#x27;</span>);<br><span class="hljs-keyword">const</span> ws = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&#x27;./output.txt&#x27;</span>);<br><br>rs.<span class="hljs-title function_">pipe</span>(ws); <span class="hljs-comment">// 直接管道传输</span><br></code></pre></td></tr></table></figure><ul><li><code>createReadStream</code> 会分块读取文件，读到一块就触发数据事件</li><li><code>pipe</code> 方法自动把读到的数据传给写入流</li><li>这样不用把整个文件一次加载进内存，适合大文件处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建读取流对象</span><br><span class="hljs-keyword">let</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&#x27;./观书有感.txt&#x27;</span>);<br><span class="hljs-comment">//每次取出 64k 数据后执行一次 data 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span>);<br>&#125;);<br><span class="hljs-comment">//读取完毕后, 执行 end 回调</span><br>rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取完成&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h2><ul><li><strong>同步</strong>：代码会阻塞等待文件操作完成</li><li><strong>异步</strong>：文件操作在后台进行，主线程可以继续执行其他任务</li><li>建议在高并发服务中<strong>优先使用异步</strong>版本</li></ul><h1 id="Buffer总结"><a href="#Buffer总结" class="headerlink" title="Buffer总结"></a>Buffer总结</h1><h2 id="Buffer是什么？"><a href="#Buffer是什么？" class="headerlink" title="Buffer是什么？"></a>Buffer是什么？</h2><ul><li>Buffer 是 Node.js 提供的 <strong>用于处理二进制数据的类数组对象</strong>。</li><li>它的出现解决了 JavaScript 语言本身不支持直接操作二进制数据的问题。</li><li>Buffer 常用于处理文件、网络通信等二进制数据流。</li></ul><h2 id="Buffer的创建"><a href="#Buffer的创建" class="headerlink" title="Buffer的创建"></a>Buffer的创建</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个长度为10的Buffer，内容未初始化（可能包含旧数据）</span><br><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 创建一个长度为10的Buffer，内容全部初始化为0</span><br><span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 通过数组创建Buffer</span><br><span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br><span class="hljs-comment">// 通过字符串创建Buffer，默认utf8编码</span><br><span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br><span class="hljs-comment">// 通过字符串创建Buffer，指定编码</span><br><span class="hljs-keyword">const</span> buf5 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;ascii&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th>操作</th><th>方法&#x2F;属性</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>获取长度</td><td><code>buf.length</code></td><td>Buffer字节长度</td><td><code>buf.length</code></td></tr><tr><td>写入字符串</td><td><code>buf.write(string, [offset], [length], [encoding])</code></td><td>写入内容</td><td><code>buf.write(&#39;abc&#39;)</code></td></tr><tr><td>读取字符串</td><td><code>buf.toString([encoding], [start], [end])</code></td><td>转为字符串</td><td><code>buf.toString(&#39;utf8&#39;, 0, 5)</code></td></tr><tr><td>合并 Buffer</td><td><code>Buffer.concat([buf1, buf2, ...])</code></td><td>合并多个Buffer</td><td><code>Buffer.concat([buf1, buf2])</code></td></tr><tr><td>拷贝数据</td><td><code>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</code></td><td>复制内容</td><td><code>buf1.copy(buf2)</code></td></tr><tr><td>截取子Buffer</td><td><code>buf.slice(start, end)</code></td><td>获取Buffer子区间</td><td><code>buf.slice(0, 3)</code></td></tr></tbody></table><h2 id="Buffer-与字符串的转换"><a href="#Buffer-与字符串的转换" class="headerlink" title="Buffer 与字符串的转换"></a>Buffer 与字符串的转换</h2><ul><li><p>Buffer → 字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>字符串 → Buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;字符串&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>编码支持</p><ul><li>支持多种编码格式：<code>utf8</code>（默认）、<code>ascii</code>、<code>base64</code>、<code>hex</code>、<code>latin1</code> 等。</li></ul><h2 id="示例：写入与读取"><a href="#示例：写入与读取" class="headerlink" title="示例：写入与读取"></a>示例：写入与读取</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);<br>buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 hello</span><br></code></pre></td></tr></table></figure><ul><li>通过 <code>Buffer.alloc(10)</code> 申请 10 字节空间；</li><li>用 <code>write</code> 写入字符串到 Buffer；</li><li>用 <code>toString</code> 读取指定范围的字节转换成字符串。</li><li>这样你就可以把字符串转换成二进制存储，也能从二进制读取对应字符串。</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>Buffer 大小固定，创建后不可动态扩容</li><li>使用 <code>Buffer.allocUnsafe</code> 可能包含旧数据，慎用</li><li>操作二进制数据时，注意编码和字节偏移</li></ul><h1 id="Path模块总结"><a href="#Path模块总结" class="headerlink" title="Path模块总结"></a>Path模块总结</h1><h2 id="Path模块简介"><a href="#Path模块简介" class="headerlink" title="Path模块简介"></a>Path模块简介</h2><ul><li><code>path</code> 是 Node.js 的核心模块，用于处理和转换文件路径。</li><li>解决不同操作系统（Windows、Linux、macOS）路径分隔符不同的问题。</li><li>提供了许多实用的方法来解析、拼接、格式化路径。</li></ul><h2 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用-API-及说明"><a href="#常用-API-及说明" class="headerlink" title="常用 API 及说明"></a>常用 API 及说明</h2><table><thead><tr><th>方法</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>path.basename(path, [ext])</code></td><td>返回路径中的文件名部分，可去除指定扩展名</td><td><code>path.basename(&#39;/foo/bar/baz.txt&#39;) // &#39;baz.txt&#39;</code></td></tr><tr><td><code>path.dirname(path)</code></td><td>返回路径中的目录部分</td><td><code>path.dirname(&#39;/foo/bar/baz.txt&#39;) // &#39;/foo/bar&#39;</code></td></tr><tr><td><code>path.extname(path)</code></td><td>返回路径中的扩展名</td><td><code>path.extname(&#39;index.html&#39;) // &#39;.html&#39;</code></td></tr><tr><td><code>path.parse(path)</code></td><td>解析路径为对象，包含 root、dir、base、ext、name</td><td><code>path.parse(&#39;/foo/bar/baz.txt&#39;)</code> 返回 <code>&#123; root: &#39;/&#39;, dir: &#39;/foo/bar&#39;, base: &#39;baz.txt&#39;, ext: &#39;.txt&#39;, name: &#39;baz&#39; &#125;</code></td></tr><tr><td><code>path.format(pathObject)</code></td><td>把路径对象转换回路径字符串</td><td><code>path.format(&#123; root: &#39;/&#39;, dir: &#39;/foo/bar&#39;, base: &#39;baz.txt&#39; &#125;)</code> 返回 <code>/foo/bar/baz.txt</code></td></tr><tr><td><code>path.isAbsolute(path)</code></td><td>判断路径是否为绝对路径</td><td><code>path.isAbsolute(&#39;/foo/bar&#39;) // true</code></td></tr><tr><td><code>path.join([...paths])</code></td><td>拼接路径，自动处理分隔符</td><td><code>path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz&#39;) // &#39;/foo/bar/baz&#39;</code></td></tr><tr><td><code>path.resolve([...paths])</code></td><td>解析为绝对路径，基于当前工作目录</td><td><code>path.resolve(&#39;foo&#39;, &#39;/bar&#39;, &#39;baz&#39;)</code> 返回绝对路径</td></tr><tr><td><code>path.relative(from, to)</code></td><td>计算从 <code>from</code> 到 <code>to</code> 的相对路径</td><td><code>path.relative(&#39;/data/orandea/test/aaa&#39;, &#39;/data/orandea/impl/bbb&#39;)</code> 返回 <code>../../impl/bbb</code></td></tr><tr><td><code>path.sep</code></td><td>当前操作系统的路径分隔符</td><td><code>&#39;\\&#39;</code>（Windows）或 <code>&#39;/&#39;</code>（Linux&#x2F;macOS）</td></tr><tr><td><code>path.delimiter</code></td><td>当前操作系统的环境变量分隔符</td><td><code>&#39;;&#39;</code>（Windows）或 <code>&#39;:&#39;</code>（Linux&#x2F;macOS）</td></tr></tbody></table><ul><li><code>__dirname</code> 与 <code>require</code> 类似，都是 Node.js 环境中的全局变量。<code>__dirname</code> 保存着 当前文件所在目录的绝对路径 ，可以使用 <code>__dirname</code> 与文件名拼接成绝对路径</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">js复制编辑<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> filePath = <span class="hljs-string">&#x27;/foo/bar/baz.txt&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件名:&#x27;</span>, path.<span class="hljs-title function_">basename</span>(filePath)); <span class="hljs-comment">// baz.txt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;目录名:&#x27;</span>, path.<span class="hljs-title function_">dirname</span>(filePath)); <span class="hljs-comment">// /foo/bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;扩展名:&#x27;</span>, path.<span class="hljs-title function_">extname</span>(filePath)); <span class="hljs-comment">// .txt</span><br><br><span class="hljs-keyword">const</span> parsed = path.<span class="hljs-title function_">parse</span>(filePath);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed);<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//   root: &#x27;/&#x27;,</span><br><span class="hljs-comment">//   dir: &#x27;/foo/bar&#x27;,</span><br><span class="hljs-comment">//   base: &#x27;baz.txt&#x27;,</span><br><span class="hljs-comment">//   ext: &#x27;.txt&#x27;,</span><br><span class="hljs-comment">//   name: &#x27;baz&#x27;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> joinedPath = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;拼接路径:&#x27;</span>, joinedPath); <span class="hljs-comment">// /foo/bar/baz</span><br><br><span class="hljs-keyword">const</span> resolvedPath = path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;/bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;绝对路径:&#x27;</span>, resolvedPath); <span class="hljs-comment">// 取决于当前工作目录</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;是否绝对路径:&#x27;</span>, path.<span class="hljs-title function_">isAbsolute</span>(filePath)); <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(<span class="hljs-string">&#x27;/foo/bar&#x27;</span>, <span class="hljs-string">&#x27;/foo/baz/file.txt&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;相对路径:&#x27;</span>, relativePath); <span class="hljs-comment">// ../../baz/file.txt</span><br></code></pre></td></tr></table></figure><h1 id="Mongodb数据库"><a href="#Mongodb数据库" class="headerlink" title="Mongodb数据库"></a>Mongodb数据库</h1><p>MongoDB 是一个基于 <strong>文档（Document）</strong> 的 NoSQL 数据库。它使用类似 JSON 的 BSON 格式存储数据，支持灵活的结构。</p><p>数据库就是管理数据的应用软件，对数据进行 增（c）、删（d）、改（u）、查（r）</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="【基础概念】"><a href="#【基础概念】" class="headerlink" title="【基础概念】"></a>【基础概念】</h3><ul><li><p><strong>数据库（Database）</strong><br>包含多个集合</p></li><li><p><strong>集合（Collection）</strong><br>类似于关系数据库的表，存储一组文档</p></li><li><p><strong>文档（Document）</strong><br>BSON 格式的数据结构，类似 JSON 对象<br>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-title class_">ObjectId</span>(<span class="hljs-string">&quot;...&quot;</span>),<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-string">&quot;skills&quot;</span>: [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;MongoDB&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>字段（Field）</strong><br>文档中的键值对，可以嵌套、数组等</p></li></ul><h3 id="【MongoDB-和-关系数据库】"><a href="#【MongoDB-和-关系数据库】" class="headerlink" title="【MongoDB 和 关系数据库】"></a>【MongoDB 和 关系数据库】</h3><ol><li><strong>数据怎么存</strong>？</li></ol><ul><li><strong>MongoDB</strong>：像存 JSON（一种写数据的格式），灵活，字段不固定，能直接嵌套数组和对象。</li><li><strong>关系数据库</strong>：数据存表里，行和列固定，必须先定义好表结构。</li></ul><ol start="2"><li><strong>怎么查数据</strong>？</li></ol><ul><li><strong>MongoDB</strong>：用 JSON 风格的语句查数据，比较像写对象。</li><li><strong>关系数据库</strong>：用 SQL 语句查数据，要写 <code>SELECT</code>、<code>JOIN</code> 等。</li></ul><ol start="3"><li><strong>数据关系和事务</strong></li></ol><ul><li><strong>MongoDB</strong>：适合关系不复杂的数据，也支持事务，但不如关系数据库成熟。</li><li><strong>关系数据库</strong>：关系复杂（比如多个表之间关联），事务支持特别好，保证数据准确。</li></ul><ol start="4"><li><strong>扩展和性能</strong></li></ol><ul><li><strong>MongoDB</strong>：很容易增加服务器横向扩展，适合海量数据和高并发。</li><li><strong>关系数据库</strong>：通常是往服务器加配置（纵向扩展），横向扩展比较难。</li></ul><p><strong>MongoDB 更灵活，适合大数据和变化快的应用；关系数据库更严谨，适合传统业务和复杂数据关联。</strong></p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><blockquote><p>参考文档： <a href="./mongodb.pdf">mongodb.pdf</a> </p></blockquote><h1 id="会话控制"><a href="#会话控制" class="headerlink" title="会话控制"></a>会话控制</h1><blockquote><p><a href="https://www.yuque.com/cuggz/interview/browser">前端面试题之浏览器原理篇</a></p></blockquote><h2 id="会话概念"><a href="#会话概念" class="headerlink" title="会话概念"></a>会话概念</h2><p><strong>会话（Session）</strong>，在网络通信里，指的是<strong>客户端与服务器之间，从建立连接开始，到连接关闭为止的一段连续交互过程</strong>。有两层含义。</p><ul><li>底层通信会话：从TCP连接建立到TCP连接断开的通信过程。</li><li>应用层逻辑会话：用 Session ID 等机制，从用户首次登录创建Session ID到超时或者登出，Session ID过期属于同一个“会话”</li></ul><p><strong>会话的本质</strong></p><ul><li>是一段有<strong>起点</strong>和<strong>终点</strong>的、有状态的通信过程</li><li>用来维持用户和服务器之间的<strong>上下文</strong>（Context）</li><li>可以跨多次请求，让服务端“记住”客户端。</li></ul><p>HTTP 是一种无状态的协议，它没有办法区分多次的请求是否来自于同一个客户端， 无法区分用户，因此需要过程<code>会话控制</code>来解决该问题。</p><p>常见的会话控制技术有三种：</p><ul><li>cookie</li><li>session</li><li>token</li></ul><h2 id="会话控制技术"><a href="#会话控制技术" class="headerlink" title="会话控制技术"></a>会话控制技术</h2><h3 id="【Cookie-会话控制】"><a href="#【Cookie-会话控制】" class="headerlink" title="【Cookie 会话控制】"></a>【Cookie 会话控制】</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><ul><li><strong>Cookie</strong> 是 <strong>浏览器端的一种存储机制</strong>，它本质上就是浏览器保存的一小段键值对数据。</li><li>浏览器会在后续请求中<strong>自动携带对应域名的 Cookie</strong> 发送给服务器。</li><li>服务器根据 Cookie 中的内容（比如用户 ID、Session ID）来识别用户。</li></ul><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a><strong>实现流程</strong></h4><ol><li><p><strong>第一次请求</strong></p><ul><li><p>客户端访问服务器，没有 Cookie</p></li><li><p>服务器响应中返回 <code>Set-Cookie</code> 头：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: userid=<span class="hljs-number">12345</span>; <span class="hljs-title class_">Expires</span>=<span class="hljs-title class_">Wed</span>, <span class="hljs-number">14</span> <span class="hljs-title class_">Aug</span> <span class="hljs-number">2025</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">GMT</span>; <span class="hljs-title class_">Path</span>=/<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>浏览器存储 Cookie</strong>（内存或硬盘）</p></li><li><p><strong>后续请求自动附带 Cookie</strong></p><ul><li><p>浏览器向同域名发请求时，自动在请求头中加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Cookie</span>: userid=<span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>服务器读取 Cookie 内容</strong>，执行逻辑</p></li></ol><p><strong>浏览器关闭时 Cookie “过期”的原理</strong></p><ul><li><strong>会话 Cookie</strong><ul><li>存在内存里（浏览器进程内存空间）</li><li>浏览器退出 → 进程销毁 → 内存释放 → Cookie 消失</li><li>下次启动浏览器，内存是空的，自然就“过期”了</li></ul></li><li><strong>持久 Cookie</strong><ul><li>存在硬盘文件</li><li>浏览器启动时会读取文件并加载还没过期的 Cookie</li><li>只有到 <code>Expires</code> &#x2F; <code>Max-Age</code> 到期，或用户手动删除时才会失效</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 启用 cookie 解析中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cookieParser</span>());<br><br><span class="hljs-comment">// 设置 Cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/set-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 不带时效性（会话 cookie，浏览器关闭即失效）</span><br>  res.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>);<br>  <span class="hljs-comment">// 带时效性（持久 cookie）</span><br>  res.<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&#x27;email&#x27;</span>, <span class="hljs-string">&#x27;23123456@qq.com&#x27;</span>, &#123; <span class="hljs-attr">maxAge</span>: <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> &#125;);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Cookie 已设置&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 读取 Cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/get-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">cookies</span>); <span class="hljs-comment">// &#123; username: &#x27;wangwu&#x27;, email: &#x27;...&#x27; &#125;</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`当前 Cookie: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(req.cookies)&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 删除 Cookie</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/delete-cookie&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">clearCookie</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Cookie 已删除&#x27;</span>);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已启动，端口 3000&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>自动化：浏览器帮你存储和发送，开发方便</li><li>兼容性好：几乎所有浏览器支持</li><li>可以存储少量信息（4KB 左右）</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li>容量小</li><li>每次请求都会带上 Cookie，增加流量</li><li>明文存储，容易被窃取（可配合 <code>Secure</code>、<code>HttpOnly</code>）</li><li>不适合存储敏感信息（应存 ID 而非用户密码）</li></ul><h3 id="【Session-会话控制】"><a href="#【Session-会话控制】" class="headerlink" title="【Session 会话控制】"></a>【Session 会话控制】</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>Session</strong> 是服务器端维护的会话状态信息。</li><li>客户端只存一个<strong>Session ID</strong>（通常在 Cookie 中），具体的会话数据保存在服务器内存、数据库或缓存中。</li><li>每次请求时，客户端带上 Session ID，服务器根据这个 ID 找到之前的会话数据。</li></ul><h4 id="实现流程-1"><a href="#实现流程-1" class="headerlink" title="实现流程"></a>实现流程</h4><ol><li><strong>第一次请求</strong><ul><li>客户端访问服务器，没有 Session ID</li><li>服务器生成一个唯一的 Session ID（比如 <code>abc123</code>）</li><li>在服务器端开辟存储空间，保存用户状态（如登录信息）</li><li>通过 <code>Set-Cookie</code> 把 Session ID 发给客户端</li></ul></li><li><strong>后续请求</strong><ul><li>浏览器带上 Cookie 中的 Session ID</li><li>服务器用这个 ID 找到对应会话数据</li></ul></li><li><strong>会话结束</strong><ul><li>Session 过期时间到 &#x2F; 用户登出 &#x2F; 服务器重启（如果没持久化）</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-comment">// 1. 安装包：npm i express-session connect-mongo</span><br><span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MongoStore</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;connect-mongo&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br><span class="hljs-comment">// 2. 设置 session 中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sid&#x27;</span>,                 <span class="hljs-comment">// Cookie 名称，默认 connect.sid</span><br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;atguigu&#x27;</span>,           <span class="hljs-comment">// 签名，用于加密 session ID</span><br>  <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 是否保存未初始化的 session</span><br>  <span class="hljs-attr">resave</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 是否每次请求都重新保存 session</span><br>  <span class="hljs-attr">store</span>: <span class="hljs-title class_">MongoStore</span>.<span class="hljs-title function_">create</span>(&#123;   <span class="hljs-comment">// 存储到 MongoDB</span><br>    <span class="hljs-attr">mongoUrl</span>: <span class="hljs-string">&#x27;mongodb://127.0.0.1:27017/project&#x27;</span><br>  &#125;),<br>  <span class="hljs-attr">cookie</span>: &#123;<br>    <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 前端 JS 无法操作</span><br>    <span class="hljs-attr">maxAge</span>: <span class="hljs-number">1000</span> * <span class="hljs-number">300</span>         <span class="hljs-comment">// Session ID 过期时间（毫秒）</span><br>  &#125;<br>&#125;));<br><br><span class="hljs-comment">// 3. 创建 Session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;zhangsan&#x27;</span>;<br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">email</span> = <span class="hljs-string">&#x27;zhangsan@qq.com&#x27;</span>;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;登录成功，Session 已创建&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 4. 获取 Session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;session 信息:&#x27;</span>, req.<span class="hljs-property">session</span>);<br>  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">session</span>.<span class="hljs-property">username</span>) &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`你好 <span class="hljs-subst">$&#123;req.session.username&#125;</span>`</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请登录或注册&#x27;</span>);<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 5. 销毁 Session</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/logout&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;成功退出&#x27;</span>);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 6. 启动服务</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务已启动，端口 3000 监听中...&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>安全性较高：敏感数据存在服务器，不暴露给客户端</li><li>容量大：不受 Cookie 4KB 限制</li><li>可以存复杂结构（对象、列表）</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>占用服务器资源（内存、数据库）</li><li>多服务器环境需要 Session 共享（Redis、数据库同步）</li><li>默认依赖 Cookie 存 Session ID（禁用 Cookie 时要用 URL 重写）</li></ul><h3 id="【Token-会话控制】"><a href="#【Token-会话控制】" class="headerlink" title="【Token 会话控制】"></a>【Token 会话控制】</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><ul><li><strong>Token</strong> 是由服务器签发给客户端的加密字符串，通常包含用户信息和签名。</li><li>客户端持有 Token，后续请求时手动带上（通常放在 <code>Authorization</code> 头中）。</li><li>服务器<strong>不存储 Token 状态</strong>，而是通过解密&#x2F;验证签名来判断 Token 是否有效（JWT 就是这种无状态 Token 的典型实现）。</li><li>服务器验证 <strong>Token 签名</strong> 的核心原理，就是<strong>用同一密钥和相同算法重新生成签名，然后和 Token 里自带的签名比对</strong>，如果一致就说明 Token 没被篡改。</li><li><strong>Token 被截取</strong>，那么在它的有效期内，截取者就可以冒充你发起请求，从而导致<strong>权限丢失</strong>或<strong>数据泄露</strong>。</li></ul><h4 id="实现流程（JWT-为例）"><a href="#实现流程（JWT-为例）" class="headerlink" title="实现流程（JWT 为例）"></a>实现流程（JWT 为例）</h4><ol><li><p><strong>用户登录</strong></p><ul><li>客户端发送账号密码到服务器</li><li>服务器验证成功后，生成 Token（Base64 编码 + 签名）</li><li>返回 Token 给客户端</li></ul></li><li><p><strong>客户端存储 Token</strong></p><ul><li>存在 LocalStorage &#x2F; SessionStorage</li></ul></li><li><p><strong>后续请求</strong></p><ul><li><p>客户端在请求头加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Authorization</span>: <span class="hljs-title class_">Bearer</span> &lt;token&gt;<br></code></pre></td></tr></table></figure></li><li><p>服务器验证签名和过期时间，直接解析出用户信息</p></li></ul></li><li><p><strong>过期或刷新</strong></p><ul><li>Token 一旦签发无法撤回（除非维护黑名单）</li><li>常配合 Refresh Token 实现续期</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// jwt-demo.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SECRET_KEY</span> = <span class="hljs-string">&#x27;my_secret_key&#x27;</span>;<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 模拟用户验证</span><br>  <span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;alice&#x27;</span> &#125;;<br>  <span class="hljs-keyword">const</span> token = jwt.<span class="hljs-title function_">sign</span>(user, <span class="hljs-variable constant_">SECRET_KEY</span>, &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;1m&#x27;</span> &#125;); <br>  <span class="hljs-comment">// 负载（Payload） 秘钥（Secret Key） 配置对象，过期时间 60 秒</span><br>  res.<span class="hljs-title function_">json</span>(&#123; token &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/profile&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> authHeader = req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;authorization&#x27;</span>];<br>  <span class="hljs-keyword">if</span> (!authHeader) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">401</span>);<br><br>  <span class="hljs-keyword">const</span> token = authHeader.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>];<br>  jwt.<span class="hljs-title function_">verify</span>(token, <span class="hljs-variable constant_">SECRET_KEY</span>, <span class="hljs-function">(<span class="hljs-params">err, user</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">sendStatus</span>(<span class="hljs-number">403</span>);<br>    res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">`欢迎你，<span class="hljs-subst">$&#123;user.username&#125;</span>`</span> &#125;);<br>  &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3002</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;JWT 示例运行在 http://localhost:3002&#x27;</span>));<br><br></code></pre></td></tr></table></figure><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>无状态：服务器不存会话，易于扩展</li><li>跨平台：适合 Web、移动端、第三方 API</li><li>传输灵活：可放在 URL、Header、Cookie</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法主动让 Token 失效（除非加黑名单）</li><li>Token 长度比 Session ID 大（增加流量）</li><li>安全性依赖加密与签名算法</li></ul><h2 id="两种网络攻击"><a href="#两种网络攻击" class="headerlink" title="两种网络攻击"></a>两种网络攻击</h2><h3 id="【CSRF-攻击（Cross-Site-Request-Forgery）】"><a href="#【CSRF-攻击（Cross-Site-Request-Forgery）】" class="headerlink" title="【CSRF 攻击（Cross-Site Request Forgery）】"></a>【CSRF 攻击（Cross-Site Request Forgery）】</h3><p><strong>概念</strong></p><ul><li>攻击者诱导已登录用户在浏览器中发送<strong>伪造请求</strong>到受信任网站，执行用户权限内的操作。</li><li>核心是利用用户已经登录的状态（Cookie、Session、Token）。</li></ul><p><strong>原理</strong></p><ol><li>用户登录网站 A，Cookie 已认证</li><li>用户访问攻击者网站 B</li><li>B 页面发起请求到 A（GET&#x2F;POST），浏览器会自动携带 A 的 Cookie</li><li>A 接收到请求，误以为是用户本人操作 → 执行敏感操作</li></ol><p><strong>举例</strong></p><ul><li>用户已登录银行网站，攻击页面发起：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bank.com/transfer?to=attacker&amp;amount=1000&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>浏览器携带银行 Cookie → 转账成功</li></ul><p><strong>防护方法</strong></p><ol><li><strong>CSRF Token</strong><ul><li>服务器生成随机 Token，绑定用户 Session</li><li>请求中必须携带 Token，服务器校验一致才执行操作</li></ul></li><li>验证 Referer&#x2F;Origin 请求头<ul><li>检查请求来源是否可信</li></ul></li><li>使用验证<ul><li>验证码</li><li>人机验证</li></ul></li></ol><h3 id="【XSS-攻击（Cross-Site-Scripting）】"><a href="#【XSS-攻击（Cross-Site-Scripting）】" class="headerlink" title="【XSS 攻击（Cross-Site Scripting）】"></a>【XSS 攻击（Cross-Site Scripting）】</h3><p><strong>概念</strong></p><ul><li>攻击者在网页中注入恶意脚本（通常是 JavaScript），当用户浏览网页时，脚本在用户浏览器执行。</li><li>目标：<strong>窃取用户信息、篡改页面、执行恶意操作</strong>。</li></ul><p><strong>分类</strong></p><ol><li><strong>存储型 XSS</strong><ul><li>恶意脚本存储在服务器数据库或文件中</li><li>用户访问页面时，脚本被加载执行</li><li>例：留言板、评论区注入 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li></ul></li><li><strong>反射型 XSS</strong><ul><li>恶意脚本随 URL 或表单提交被反射回页面</li><li>用户点击链接就触发</li><li>例：<code>http://example.com/search?q=&lt;script&gt;alert(1)&lt;/script&gt;</code></li></ul></li><li><strong>DOM 型 XSS</strong><ul><li>恶意脚本只在浏览器端操作 DOM 执行</li><li>不经过服务器直接通过前端 JS 执行</li></ul></li></ol><p><strong>危害</strong></p><ul><li>窃取 Cookie、Token、Session 信息</li><li>劫持用户操作</li><li>页面篡改、钓鱼攻击</li></ul><p><strong>防护方法</strong></p><ul><li><p>对用户输入进行 <strong>HTML 转义</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> -&gt; <span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span></span></span><br></code></pre></td></tr></table></figure></li></ul><h1 id="接口请求处理"><a href="#接口请求处理" class="headerlink" title="接口请求处理"></a>接口请求处理</h1><h2 id="RESTFul风格设计"><a href="#RESTFul风格设计" class="headerlink" title="RESTFul风格设计"></a>RESTFul风格设计</h2><blockquote><p><a href="https://restfulapi.net/">https://restfulapi.net/</a></p></blockquote><h3 id="【接口设计】"><a href="#【接口设计】" class="headerlink" title="【接口设计】"></a>【接口设计】</h3><p>在Http协议传递过程中，URL可以选择param\json\path形式。**<font color="#FF774B">RestFul是一套HTTP协议的标准使用方案和风格，帮助用户完成设计：</font>**</p><ul><li>如何设计路径？</li><li>如何设计参数传递？</li><li>如何选择请求方式？</li></ul><ol><li><p><strong>接口设计</strong></p><table><thead><tr><th>功能</th><th>接口和请求方式</th><th>请求参数</th><th>返回值</th></tr></thead><tbody><tr><td>分页查询</td><td>GET  &#x2F;user</td><td>page&#x3D;1&amp;size&#x3D;10</td><td>{ 响应数据 }</td></tr><tr><td>用户添加</td><td>POST &#x2F;user</td><td>{ user 数据 }</td><td>{响应数据}</td></tr><tr><td>用户详情</td><td>GET &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>用户更新</td><td>PUT &#x2F;user</td><td>{ user 更新数据}</td><td>{响应数据}</td></tr><tr><td>用户删除</td><td>DELETE &#x2F;user&#x2F;1</td><td>路径参数</td><td>{响应数据}</td></tr><tr><td>条件模糊</td><td>GET &#x2F;user&#x2F;search</td><td>page&#x3D;1&amp;size&#x3D;10&amp;keywork&#x3D;关键字</td><td>{响应数据}</td></tr></tbody></table></li><li><p><strong>问题讨论</strong></p><p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p><p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！</p><p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p><ul><li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li><li>而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。<br>此外，还有一些通用的原则可以遵循：</li><li>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</li><li>请求参数应该限制在 10 个以内，过多的请求参数可能导致接口难以维护和使用。</li><li>对于敏感信息，最好使用 POST 和请求体来传递参数。</li></ul></li><li><p>代码实现</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * projectName: com.atguigu.controller</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * description: 用户模块的控制器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;user&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟分页查询业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="hljs-type">int</span> page,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="hljs-type">int</span> size)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;page = &quot;</span> + page + <span class="hljs-string">&quot;, size = &quot;</span> + size);<br>        System.out.println(<span class="hljs-string">&quot;分页查询业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟用户保存业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">saveUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>        System.out.println(<span class="hljs-string">&quot;用户保存业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟用户详情业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">detailUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);<br>        System.out.println(<span class="hljs-string">&quot;用户详情业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟用户更新业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>        System.out.println(<span class="hljs-string">&quot;用户更新业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟条件分页查询业务接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;search&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(name = &quot;page&quot;,required = false,defaultValue = &quot;1&quot;)</span><span class="hljs-type">int</span> page,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(name = &quot;size&quot;,required = false,defaultValue = &quot;10&quot;)</span><span class="hljs-type">int</span> size,</span><br><span class="hljs-params">                            <span class="hljs-meta">@RequestParam(name = &quot;keyword&quot;,required= false)</span>String keyword)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;page = &quot;</span> + page + <span class="hljs-string">&quot;, size = &quot;</span> + size + <span class="hljs-string">&quot;, keyword = &quot;</span> + keyword);<br>        System.out.println(<span class="hljs-string">&quot;条件分页查询业务!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><font color="#FF774B">GET和DELETE没有请求体，如果参数只有一个例如id，使用路径传递参数。如果参数有多个，使用param传参；POST和PUT有请求体，直接使用请求体传递json。</font></strong></p><h3 id="【响应代码规范】"><a href="#【响应代码规范】" class="headerlink" title="【响应代码规范】"></a>【响应代码规范】</h3><p>HTTP 定义了这些标准状态代码，可用于传达客户端请求的结果。状态代码分为五类。</p><ul><li><strong><a href="https://restfulapi.net/http-status-codes/#1xx">1xx：信息性</a></strong> – 传达传输协议级信息。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#2xx">2xx：成功</a></strong> – 表示客户端的请求已成功接受。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#3xx">3xx：重定向</a></strong> – 表示客户端必须执行一些额外的作才能完成其请求。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#4xx">4xx：客户端错误</a></strong> – 此类错误状态代码将矛头指向客户端。</li><li><strong><a href="https://restfulapi.net/http-status-codes/#5xx">5xx：服务器错误</a></strong> – 服务器对这些错误状态代码负责。</li></ul><h3 id="【Swagger】"><a href="#【Swagger】" class="headerlink" title="【Swagger】"></a>【Swagger】</h3><p>Swagger是一套基于 OpenAPI 规范（OAS）构建的开源工具，主要用于**<font color="#FF774B">生成、描述、调用和可视化RESTful风格的Web API</font>**。</p><h3 id="【Postman】"><a href="#【Postman】" class="headerlink" title="【Postman】"></a>【Postman】</h3><p>接口测试工具，可以模仿客户端向服务器发送接口请求，测试服务器接口的效果。</p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="【什么是-AJAX】"><a href="#【什么是-AJAX】" class="headerlink" title="【什么是 AJAX】"></a>【什么是 AJAX】</h3><p>AJAX（Asynchronous JavaScript and XML）是一种在<strong>不重新加载整个页面</strong>的情况下，从服务器获取数据并更新网页部分内容的技术。它不是一种新的编程语言，而是一种利用现有技术组合的交互方式。核心技术包括 JavaScript、HTML DOM、CSS，以及用于异步数据传输的 <code>XMLHttpRequest</code> 或 <code>Fetch</code> API。</p><p>AJAX 的出现，使得网页在用户操作时可以做到<strong>局部刷新</strong>，提升用户体验。例如，搜索引擎的搜索建议、社交平台的动态加载、地图应用的平滑拖动等，都是 AJAX 的典型应用。</p><h3 id="【AJAX-的特点】"><a href="#【AJAX-的特点】" class="headerlink" title="【AJAX 的特点】"></a>【AJAX 的特点】</h3><ul><li>异步通信：无需刷新整个页面即可与服务器交换数据</li><li>提高用户体验：局部更新页面，减少延迟感</li><li>数据格式多样：不仅可以使用 XML，还可以使用 JSON、HTML、纯文本等</li><li>基于已有标准：HTML、CSS、JavaScript、DOM、XMLHttpRequest</li><li>与服务器交互更灵活：支持 GET、POST 等多种 HTTP 方法</li></ul><h3 id="【AJAX-的工作原理】"><a href="#【AJAX-的工作原理】" class="headerlink" title="【AJAX 的工作原理】"></a>【AJAX 的工作原理】</h3><ol><li>用户在浏览器上触发事件（如点击按钮）</li><li>JavaScript 创建 AJAX 请求对象（XMLHttpRequest 或 Fetch）</li><li>浏览器向服务器发送 HTTP 请求（异步，不阻塞页面）</li><li>服务器接收请求并返回数据（JSON、XML、HTML 等）</li><li>浏览器接收响应数据，并由 JavaScript 更新 DOM 内容</li><li>页面局部刷新，而不是整个重新加载</li></ol><p>数据交互过程可简化为：浏览器事件 → 发送请求 → 服务器响应 → 前端更新</p><h3 id="【AJAX-的实现方法】"><a href="#【AJAX-的实现方法】" class="headerlink" title="【AJAX 的实现方法】"></a>【AJAX 的实现方法】</h3><ul><li><strong>XMLHttpRequest</strong>：早期的 AJAX 核心实现方式，功能全面但语法相对繁琐</li><li><strong>Fetch API</strong>：现代浏览器原生提供的异步请求方式，基于 Promise，更加简洁</li><li><strong>Axios</strong>：第三方 HTTP 库，支持 Promise，功能丰富，兼容性好，支持请求&#x2F;响应拦截等高级特性</li></ul><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><h3 id="【什么是跨域】"><a href="#【什么是跨域】" class="headerlink" title="【什么是跨域】"></a>【什么是跨域】</h3><p>跨域是指浏览器出于安全策略（同源策略，Same-Origin Policy）的限制，阻止网页向不同域名、协议或端口的服务器发送 AJAX 请求。</p><p>例如：</p><ul><li>页面地址：<a href="http://example.com/">http://example.com</a></li><li>请求地址：<a href="http://api.example.com/">http://api.example.com</a><br>因为域名不同，会触发跨域限制。</li></ul><p>常见的跨域解决方法：</p><ul><li><strong>CORS（跨域资源共享）</strong>：服务器在响应头中设置 <code>Access-Control-Allow-Origin</code> 来允许特定来源访问</li><li><strong>JSONP</strong>：利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性进行跨域（仅支持 GET 请求，已较少使用）</li><li><strong>服务器代理</strong>：通过服务器代理转发请求，前端请求同源服务器，由该服务器再访问目标接口</li><li><strong>WebSocket</strong>：双向通信协议，可绕过部分跨域限制</li></ul><blockquote><p><a href="https://www.yuque.com/tianyu-coder/openshare/aksmvpbebgw7savk">跨域问题梳理</a></p><p><a href="https://www.bilibili.com/video/BV1pT421k7yz/?spm_id_from=333.337.search-card.all.click&vd_source=ff414aaf189e3a685358d2a984fd4742">禹神：一小时彻底搞懂跨域&amp;解决方案_哔哩哔哩_bilibili</a></p></blockquote><p>跨域问题导致会话控制种的cookie和session都无法使用，因此目前最常用的会话控制都是token。</p><h3 id="【cookie跨域问题】"><a href="#【cookie跨域问题】" class="headerlink" title="【cookie跨域问题】"></a>【cookie跨域问题】</h3><ol><li>浏览器的同源策略限制</li></ol><ul><li><strong>同源策略（Same-Origin Policy）</strong> 要求：协议、域名、端口三者必须一致，Cookie 才会被浏览器自动携带给服务器。</li><li>如果前端页面是 <code>https://a.com</code>，而你请求的 API 是 <code>https://api.b.com</code>，即便两者都是你的服务，浏览器也<strong>不会</strong>自动把 <code>a.com</code> 的 Cookie 发给 <code>b.com</code>。</li></ul><ol start="2"><li>Cookie 的作用域由 <code>Domain</code> 决定</li></ol><ul><li><p>服务器在响应头中设置 Cookie 时，可以指定 <code>Domain</code>，它定义了 Cookie 属于哪个域。</p></li><li><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: sessionId=abc123; <span class="hljs-title class_">Domain</span>=a.<span class="hljs-property">com</span>; <span class="hljs-title class_">Path</span>=/<br></code></pre></td></tr></table></figure><p>这样设置的 Cookie 只会发送给 <code>a.com</code> 及其子域（<code>sub.a.com</code>），<strong>不会</strong>被发送给 <code>b.com</code>。</p></li><li><p>Cookie 无法直接跨顶级域（如 <code>.com</code> 和 <code>.cn</code>），因为浏览器会拒绝这样的设置以防信息泄露。</p></li></ul><ol start="3"><li><strong>安全策略（防止 CSRF）</strong></li></ol><ul><li><p>浏览器在跨域请求中默认 <strong>不发送 Cookie</strong>，除非你在 AJAX 请求中显式开启：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.b.com/data&#x27;</span>, &#123;<br>  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>即便这样做，后端还必须在响应中添加 CORS 允许携带凭证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Credentials</span>: <span class="hljs-literal">true</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//a.com</span><br></code></pre></td></tr></table></figure></li><li><p>这种额外的安全验证，就是为了防止第三方网站利用 Cookie 自动登录或冒充用户（CSRF 攻击）。</p></li></ul><h2 id="三种请求方法"><a href="#三种请求方法" class="headerlink" title="三种请求方法"></a>三种请求方法</h2><blockquote><p><a href="https://www.yuque.com/cuggz/feplus/ouwmxw3uk0vdnz8p#jYHEA">Fetch、Axios、Ajax、XHR</a></p></blockquote><h3 id="XMLHttpRequest（XHR）"><a href="#XMLHttpRequest（XHR）" class="headerlink" title="XMLHttpRequest（XHR）"></a>XMLHttpRequest（XHR）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 配置请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/api/user&#x27;</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置请求头</span><br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br><br><span class="hljs-comment">// 携带跨域凭据</span><br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 上传进度</span><br>xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`上传进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 下载进度</span><br>xhr.<span class="hljs-property">onprogress</span> = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`下载进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 响应类型</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&#x27;json&#x27;</span>;<br><br><span class="hljs-comment">// 超时设置</span><br>xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">5000</span>;<br>xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求超时&#x27;</span>);<br><br><span class="hljs-comment">// 成功回调</span><br>xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;响应数据:&#x27;</span>, xhr.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败:&#x27;</span>, xhr.<span class="hljs-property">status</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 错误回调</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;网络错误&#x27;</span>);<br><br><span class="hljs-comment">// 发送数据</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;));<br></code></pre></td></tr></table></figure><h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// GET 请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!res.<span class="hljs-property">ok</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP 错误: <span class="hljs-subst">$&#123;res.status&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err));<br><br><span class="hljs-comment">// POST JSON 数据</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/user&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;)<br>&#125;);<br><br><span class="hljs-comment">// 携带跨域凭据</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>, &#123; <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 取消请求（AbortController）</span><br><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/longtask&#x27;</span>, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求被取消:&#x27;</span>, err.<span class="hljs-property">name</span>));<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.<span class="hljs-title function_">abort</span>(), <span class="hljs-number">3000</span>);<br><br><span class="hljs-comment">// 流式读取下载数据</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/bigfile&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">body</span>.<span class="hljs-title function_">getReader</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">reader</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> reader.<span class="hljs-title function_">read</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">&#123; done, value &#125;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (done) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;下载完成&#x27;</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;接收数据块大小:&#x27;</span>, value.<span class="hljs-property">length</span>);<br>      <span class="hljs-keyword">return</span> reader.<span class="hljs-title function_">read</span>().<span class="hljs-title function_">then</span>(process);<br>    &#125;);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><blockquote><p><a href="https://axios.nodejs.cn/docs/intro">立即开始 | Axios 文档</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建实例</span><br><span class="hljs-keyword">const</span> api = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;/api&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span><br>&#125;);<br><br><span class="hljs-comment">// 请求拦截器</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">&#x27;Bearer token&#x27;</span>;<br>  <span class="hljs-keyword">return</span> config;<br>&#125;);<br><br><span class="hljs-comment">// 响应拦截器</span><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-property">data</span>,<br>  <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)<br>);<br><br><span class="hljs-comment">// GET 请求</span><br>api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));<br><br><span class="hljs-comment">// POST 请求</span><br>api.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 上传文件并监听进度</span><br><span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]);<br>api.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, formData, &#123;<br>  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">total</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`上传进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 下载文件并监听进度</span><br>api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/download&#x27;</span>, &#123;<br>  <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;blob&#x27;</span>,<br>  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">total</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`下载进度: <span class="hljs-subst">$&#123;(e.loaded / e.total * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">2</span>)&#125;</span>%`</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 取消请求</span><br><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>();<br>api.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/longtask&#x27;</span>, &#123; <span class="hljs-attr">signal</span>: controller.<span class="hljs-property">signal</span> &#125;);<br>controller.<span class="hljs-title function_">abort</span>();<br></code></pre></td></tr></table></figure><h4 id="Axios-配置项-请求报文对应关系"><a href="#Axios-配置项-请求报文对应关系" class="headerlink" title="Axios 配置项 &amp; 请求报文对应关系"></a>Axios 配置项 &amp; 请求报文对应关系</h4><table><thead><tr><th>Axios 配置项</th><th>作用位置</th><th>最终在 HTTP 请求中的表现</th><th>Node.js (Express) 里 <code>req</code> 的对应字段</th></tr></thead><tbody><tr><td><code>url</code></td><td>请求行</td><td><code>POST /user HTTP/1.1</code></td><td><code>req.url</code>、<code>req.path</code>、<code>req.query</code></td></tr><tr><td><code>method</code></td><td>请求行</td><td><code>POST /user HTTP/1.1</code></td><td><code>req.method</code></td></tr><tr><td><code>baseURL</code>+<code>url</code></td><td>请求行</td><td><code>http://localhost:3000/user</code></td><td><code>req.hostname</code>、<code>req.originalUrl</code></td></tr><tr><td><code>params</code></td><td>URL 查询</td><td><code>/user?id=123&amp;type=admin</code></td><td><code>req.query</code></td></tr><tr><td><code>data</code></td><td>请求体</td><td>JSON、form-data、x-www-form-urlencoded</td><td><code>req.body</code>（需 <code>body-parser</code>&#x2F;<code>express.json()</code> 中间件）</td></tr><tr><td><code>headers</code></td><td>请求头</td><td><code>Content-Type: application/json</code></td><td><code>req.headers</code></td></tr><tr><td><code>timeout</code></td><td>Axios 内部</td><td>不影响 HTTP 报文</td><td>不存在于 <code>req</code>，是 Axios 客户端行为</td></tr><tr><td><code>withCredentials</code></td><td>请求头</td><td><code>Cookie: ...</code></td><td><code>req.headers.cookie</code>、<code>req.cookies</code>（需 cookie-parser）</td></tr><tr><td><code>auth</code></td><td>请求头</td><td><code>Authorization: Basic xxx</code></td><td><code>req.headers.authorization</code></td></tr><tr><td><code>responseType</code></td><td>响应处理</td><td>不影响请求，只影响客户端解析</td><td>和 <code>req</code> 无关，是 Axios 客户端行为</td></tr></tbody></table><h4 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-comment">// 请求方法 (GET、POST、PUT、DELETE、PATCH...)</span><br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br><br>  <span class="hljs-comment">// 请求 URL</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br><br>  <span class="hljs-comment">// baseURL 会自动拼接在 url 前面</span><br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://api.example.com&#x27;</span>,<br><br>  <span class="hljs-comment">// 请求参数（拼接到 URL 上，GET 常用）</span><br>  <span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">123</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;admin&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求体数据（POST/PUT 常用）</span><br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;tom&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求头</span><br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>    <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer token123&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求超时时间（ms）</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br><br>  <span class="hljs-comment">// 跨域是否携带 Cookie</span><br>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>,<br><br>  <span class="hljs-comment">// 响应数据格式（默认 json，可选 text, blob, arraybuffer, stream 等）</span><br>  <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br><br>  <span class="hljs-comment">// 自定义状态码校验规则（默认 200–299 为成功）</span><br>  <span class="hljs-attr">validateStatus</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) &#123;<br>    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">400</span> <span class="hljs-comment">// 200~399 认为成功</span><br>  &#125;,<br><br>  <span class="hljs-comment">// 请求进度（上传/下载）</span><br>  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;上传进度:&#x27;</span>, progressEvent.<span class="hljs-property">loaded</span> / progressEvent.<span class="hljs-property">total</span>)<br>  &#125;,<br>  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;下载进度:&#x27;</span>, progressEvent.<span class="hljs-property">loaded</span> / progressEvent.<span class="hljs-property">total</span>)<br>  &#125;,<br><br>  <span class="hljs-comment">// 取消请求</span><br>  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> axios.<span class="hljs-title class_">CancelToken</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) &#123;<br>    <span class="hljs-comment">// 调用 cancel() 可取消请求</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 发起请求</span><br><span class="hljs-title function_">axios</span>(config).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="功能对比表"><a href="#功能对比表" class="headerlink" title="功能对比表"></a>功能对比表</h3><table><thead><tr><th>功能</th><th>XHR</th><th>Fetch</th><th>Axios</th></tr></thead><tbody><tr><td>GET&#x2F;POST&#x2F;PUT&#x2F;DELETE 支持</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>自定义请求头</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>跨域携带 Cookie</td><td>✔（withCredentials）</td><td>✔（credentials）</td><td>✔（withCredentials）</td></tr><tr><td>上传进度监听</td><td>✔</td><td>✘</td><td>✔</td></tr><tr><td>下载进度监听</td><td>✔</td><td>流式读取</td><td>✔</td></tr><tr><td>超时设置</td><td>✔</td><td>✘（需手动）</td><td>✔</td></tr><tr><td>取消请求</td><td>✘</td><td>✔（AbortController）</td><td>✔</td></tr><tr><td>JSON 自动解析</td><td>✘（需手动）</td><td>✘（需手动）</td><td>✔</td></tr><tr><td>请求拦截器</td><td>✘</td><td>✘</td><td>✔</td></tr><tr><td>响应拦截器</td><td>✘</td><td>✘</td><td>✔</td></tr><tr><td>API 简洁度</td><td>较低</td><td>中等</td><td>高</td></tr><tr><td>兼容性</td><td>极佳（IE5+）</td><td>现代浏览器</td><td>现代浏览器 + Node</td></tr></tbody></table><h2 id="方法对比"><a href="#方法对比" class="headerlink" title="方法对比"></a>方法对比</h2><table><thead><tr><th>特性</th><th>XMLHttpRequest</th><th>Fetch</th><th>Axios</th></tr></thead><tbody><tr><td>语法简洁性</td><td>较繁琐，需要手动监听状态</td><td>简洁，基于 Promise</td><td>简洁，基于 Promise</td></tr><tr><td>兼容性</td><td>广泛支持（IE5+）</td><td>现代浏览器（需 polyfill 兼容 IE）</td><td>广泛支持（含 Node.js）</td></tr><tr><td>错误处理</td><td>需检查 readyState 和 status</td><td>需手动检查 response.ok</td><td>自动抛出 HTTP 错误</td></tr><tr><td>请求&#x2F;响应拦截</td><td>不支持</td><td>不支持（需手动封装）</td><td>支持</td></tr><tr><td>自动 JSON 解析</td><td>不支持（需手动 JSON.parse）</td><td>不支持（需调用 response.json）</td><td>支持</td></tr><tr><td>取消请求</td><td>复杂</td><td>支持 AbortController</td><td>原生支持 cancel token</td></tr><tr><td>上传进度</td><td>支持</td><td>不直接支持</td><td>支持（需配置）</td></tr></tbody></table><p>总结：</p><ul><li>对于简单项目：推荐使用 Fetch（现代浏览器环境）</li><li>对于需要兼容性、丰富功能的项目：推荐使用 Axios</li><li>在老旧浏览器环境且无库支持：只能使用 XMLHttpRequest</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.JS的数据类型总结</title>
    <link href="/2025/12/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/3-JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2025/12/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/3-JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ol><li>JavaScript有哪些数据类型，它们的区别(堆和栈 &#x2F; 基础数据类型和引用数据类型 &#x2F; Symbol的用法）？</li><li>引用数据类型常用方法？ （Object &#x2F; Function &#x2F; Array &#x2F; Map &#x2F; Set &#x2F; Class）</li><li>数据类型判断的方式有哪些？</li><li><code>null</code>和<code>undefined</code>的区别？</li><li><code>typeof null</code>错误的原因是什么？</li><li><code>0.1+0.2 !== 0.3</code>的原因是什么？</li><li>如何获取安全的 undefined 值？</li><li>isNaN 和 Number.isNaN 函数的区别是什么？</li></ol><span id="more"></span><h2 id="JS的数据类型总结"><a href="#JS的数据类型总结" class="headerlink" title="JS的数据类型总结"></a>JS的数据类型总结</h2><h3 id="1-JavaScript的数据类型"><a href="#1-JavaScript的数据类型" class="headerlink" title="1.JavaScript的数据类型"></a>1.JavaScript的数据类型</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>);<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;id&#x27;</span>);<br>s1 !== s2;<br></code></pre></td></tr></table></figure><ul><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-number">9007199254740991n</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure><p>这些数据可以分为基本数据类型和引用数据类型：</p><ul><li>栈：基本数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由<strong>垃圾回收机制回收</strong>。</li></ul><h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h3><blockquote><p><a href="https://www.yuque.com/cuggz/feplus/cp4k8o">数组</a></p><p><a href="https://cxdlogver.github.io/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#Map">MAP &#x2F; SET</a></p><p><a href="https://www.yuque.com/cuggz/feplus/wgzgsv">循环遍历</a></p></blockquote><h3 id="3-数据类型检测的方式有哪些"><a href="#3-数据类型检测的方式有哪些" class="headerlink" title="3. 数据类型检测的方式有哪些"></a>3. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>);           <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object    </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);    <span class="hljs-comment">// function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，其内部运行机制是<strong>判断在其原型链中能否找到该类型的原型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);                    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);                <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);                <span class="hljs-comment">// false </span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);                    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);                   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3）</strong> <strong>constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-literal">true</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Boolean</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-string">&#x27;str&#x27;</span>).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">String</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(([]).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&#123;&#125;).<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;&#125;;<br> <br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br> <br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Fn</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-number">2</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-string">&#x27;str&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>([]));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(&#123;&#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，<code>obj.toString()</code>的结果和<code>Object.prototype.toString.call(obj)</code>的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><p><strong>数组类型判断的所有方式汇总</strong></p><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br></code></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArrray</span>(obj);<br></code></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure><ul><li>通过constructor判断</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><blockquote><p>一句话：typeof是根据类型标签来判断类型。null和object的类型标签都是000</p></blockquote><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">000</span>: object   - 当前存储的数据指向一个对象。<br>  <span class="hljs-number">1</span>: int      - 当前存储的数据是一个 <span class="hljs-number">31</span> 位的有符号整数。<br><span class="hljs-number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。<br><span class="hljs-number">100</span>: string   - 当前存储的数据指向一个字符串。<br><span class="hljs-number">110</span>: boolean  - 当前存储的数据是布尔值。<br></code></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-为什么0-1-0-2-0-3，如何让其相等"><a href="#6-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="6. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>6. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><p><strong>一句话：</strong>因为 <strong>JavaScript 用 IEEE-754 双精度浮点数</strong>存小数，很多十进制小数在二进制里是<strong>无限循环小数</strong>，只能近似存。<code>0.1</code> 和 <code>0.2</code> 实际存成了两段“近似值”，相加后得到的近似值稍微大于 <code>0.3</code>，显示为 <code>0.30000000000000004</code>，所以 <code>0.1 + 0.2 !== 0.3</code>。 相等的方法就是<code>toFixed</code>取舍。</p><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">0.1</span>, n2 = <span class="hljs-number">0.2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n1 + n2)  <span class="hljs-comment">// 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(n1 + n2).<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span><br></code></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的：</p><img src="/2025/12/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/3-JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/1603641384908-7958dffa-6d26-4e36-963e-b41c9e3ca8b0.png" class title="img"><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="hljs-number">10011.</span>..<br></code></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="hljs-number">2</span>^-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023&#x3D; -1022，e最大值是2046，则2046-1023&#x3D;1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023&#x3D; -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s&#x3D;0时表示正无穷，s&#x3D;1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 &#x3D; 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> <span class="hljs-number">1111111011</span> <span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2&#x3D;0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 &#x3D;&#x3D;&#x3D;0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numberepsilon</span>(<span class="hljs-params">arg1,arg2</span>)&#123;                   <br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(arg1 - arg2) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;        <br>&#125;        <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">numberepsilon</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="7-获取安全的-undefined-值？"><a href="#7-获取安全的-undefined-值？" class="headerlink" title="7. 获取安全的 undefined 值？"></a>7. 获取安全的 undefined 值？</h3><blockquote><ul><li>什么叫安全的<code>undefined</code>值</li><li><code>void</code> 和 undefined的区别</li><li><code>void</code> 的作用</li></ul></blockquote><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p><p>undefined并不是javascript中的保留字，我们可以使用undefined作为变量名字，然后给它赋值。void 0输出唯一的结果undefined，保证了不变性</p><h3 id="8-isNaN-和-Number-isNaN-函数的区别"><a href="#8-isNaN-和-Number-isNaN-函数的区别" class="headerlink" title="8. isNaN 和 Number.isNaN 函数的区别"></a>8. isNaN 和 Number.isNaN 函数的区别</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D; &#x3D; NaN 为 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>isNaN 和 Number.isNaN 函数的区别？</strong></p><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.JS面向对象编程</title>
    <link href="/2025/12/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/2-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/12/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/2-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ol><li>如何理解JS中的对象和函数？</li><li>构造函数和普通函数的区别是什么？</li><li><code>new</code>关键字的原理是什么？</li><li><code>instanceof</code>的原理是什么？</li></ol><span id="more"></span><h2 id="JS的面向对象编程"><a href="#JS的面向对象编程" class="headerlink" title="JS的面向对象编程"></a>JS的面向对象编程</h2><blockquote><p><a href="https://cxdlogver.github.io/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/#JavaScripe%E5%87%BD%E6%95%B0">JavaScript函数和对象</a></p></blockquote><h3 id="1-对象和函数"><a href="#1-对象和函数" class="headerlink" title="1.对象和函数"></a>1.对象和函数</h3><p>对象是对现实事物的一个抽象概述，面对对象编程就是将所有的程序封装成一个个对象,程序的运行过程就是一系列对象之间相互协作、消息传递的过程。</p><p>对象包括 属性和方法，表示事物的状态和动作。</p><blockquote><p>每个对象都有一个内部属性 <code>[[Prototype]]</code>（通常访问为 <code>__proto__</code>），它指向另一个对象，这个对象称为“原型”。当访问对象的某个属性时，如果对象本身没有这个属性，则会去它的原型对象上查找，这就是“原型链查找”机制。原型本身也是对象，也有原型，因此构成一个原型链，直到最顶层<code>null</code>终止.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><h4 id="【Object和Function】"><a href="#【Object和Function】" class="headerlink" title="【Object和Function】"></a>【<code>Object</code>和<code>Function</code>】</h4><p><strong><code>Object</code>和<code>Function</code>是构造器，而构造器本身也是一个实例对象。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>        <span class="hljs-comment">// Object 是由 Function 构造出来的</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>      <span class="hljs-comment">// Function 由自己构造出来</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// 函数对象的原型最终继承自 Object.prototype</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// 根据上面推导</span><br></code></pre></td></tr></table></figure><p>如何理解：</p><ul><li><code>Object</code> 是由 <code>Function</code> 构造出来的。<code>Function</code> 是由自己构造出来的。</li><li><code>Object.prototye</code>是所有对象的顶层原型，<code>Object.prototype.__proto__ === null</code>。 </li><li><code>Function.prototype</code> 是所有函数对象的原型（包括 <code>Object</code> 和 <code>Function</code> 自身）</li><li>函数本身也是对象，所以顶层原型在函数对象的原型链上。</li></ul><table><thead><tr><th>对象</th><th>说明</th></tr></thead><tbody><tr><td><code>Function</code></td><td>所有函数的构造器</td></tr><tr><td><code>Object</code></td><td>普通对象的构造器</td></tr><tr><td><code>Function</code> 本身</td><td>也是函数 → 也是 Function 的实例</td></tr><tr><td><code>Object</code> 本身</td><td>也是函数 → 也是 Function 的实例</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span><br>  ├── __proto__ → <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  │                   │<br>  │                   └── __proto__ → <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> → <span class="hljs-literal">null</span><br>  │<br><span class="hljs-title class_">Object</span><br>  └── __proto__ → <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><br></code></pre></td></tr></table></figure><p>函数对象和普通对象通过一些属性来区分，比如<code>typeof</code> 内部其实就是检测对象是否有 <code>[[Call]]</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> &#123;&#125;); <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;); <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure><p>在 JS 里，一个对象是不是某个构造器的实例，只看一件事：</p><blockquote><p><strong>这个构造器的 <code>prototype</code> 是否出现在该对象的原型链上</strong></p></blockquote><p>也就是 <code>instanceof</code> 的本质。</p><h3 id="2-构造函数和普通函数"><a href="#2-构造函数和普通函数" class="headerlink" title="2.构造函数和普通函数"></a>2.构造函数和普通函数</h3><ul><li><strong>构造函数</strong>：除了有 <code>[[Call]]</code>，还具备 <code>[[Construct]]</code> 内部方法，所以能用 <code>new</code>。</li><li><strong>普通函数</strong>：如果没有 <code>[[Construct]]</code>，用 <code>new</code> 会报错。</li></ul><h4 id="【创建方式】"><a href="#【创建方式】" class="headerlink" title="【创建方式】"></a>【创建方式】</h4><p>只有<code>function</code>和<code>class</code>创建的函数对象才有<code>Construct</code>构造器。</p><table><thead><tr><th>函数类型</th><th>是否有 <code>[[Call]]</code></th><th>是否有 <code>[[Construct]]</code></th><th>能否 <code>new</code></th></tr></thead><tbody><tr><td>普通函数 <code>function f()&#123;&#125;</code></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>class</td><td>❌（不能直接调用）</td><td>✅</td><td>✅</td></tr><tr><td>箭头函数 <code>() =&gt; &#123;&#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>方法简写 <code>&#123; foo()&#123;&#125; &#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>Function.prototype.bind</code> 返回的函数</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>Generator 函数 <code>function* f()&#123;&#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>Async 函数 <code>async function f()&#123;&#125;</code></td><td>✅</td><td>❌</td><td>❌</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();   <span class="hljs-comment">// OK</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bar</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>();             <span class="hljs-comment">// TypeError: bar is not a constructor</span><br></code></pre></td></tr></table></figure><h4 id="【constructor-属性】"><a href="#【constructor-属性】" class="headerlink" title="【constructor 属性】"></a>【constructor 属性】</h4><ul><li><p><code>constructor</code>是区分 构造器函数 和 普通函数 的标准。</p></li><li><p>构造器函数在创建时，都会自动获得一个 <code>prototype</code> 属性，指向一个原型对象。该原型对象上默认有一个 <code>constructor</code> 属性，指向函数本身。</p></li><li><p>实例对象通过原型链可以访问到这个 <code>constructor</code>。</p></li><li><p>普通函数没有<code>prototype</code>和<code>constructor</code>，但依然是实例对象，所有具备<code>__proto__</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br>[].<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span><br></code></pre></td></tr></table></figure><h4 id="【构造函数】"><a href="#【构造函数】" class="headerlink" title="【构造函数】"></a>【构造函数】</h4><ol><li><strong>构造函数</strong>是用 <code>new</code> 调用的函数，可以创建对象。</li><li><strong>类 (class)</strong> 是构造函数的语法糖，本质上还是函数。</li><li><strong>Function</strong> 是所有函数的构造器，它本身也是函数（自举特性）。<ul><li><code>Function instanceof Function</code> → true</li><li><code>Function instanceof Object</code> → true</li><li><code>Object instanceof Function</code> → true</li></ul></li><li>关系链可以画成这样：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span> (构造所有函数)<br>   ↑<br><span class="hljs-keyword">class</span> / 普通函数 (本质是 <span class="hljs-title class_">Function</span> 的实例)<br>   ↑<br>实例对象 (由构造函数 / <span class="hljs-keyword">class</span> 生成)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure><p>得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-new关键字"><a href="#3-new关键字" class="headerlink" title="3.new关键字"></a>3.new关键字</h3><p>理解到这一步，我们就可以理解new关键字原理中每一步的含义。</p><p>当你写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure><p>引擎内部大致做了 <strong>4 步</strong>：</p><ol><li><p><strong>创建一个空对象</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">let obj <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>把这个对象的原型指向构造函数的 <code>prototype</code></strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj.__proto__</span> = Person.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>执行构造函数，把 <code>this</code> 绑定到新对象</strong></p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">let</span> <span class="hljs-built_in">result</span> = <span class="hljs-type">Person</span>.call(obj, <span class="hljs-string">&quot;Alice&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>返回对象</strong></p><ul><li>如果构造函数返回的是一个 <strong>对象</strong>，则返回它；</li><li>否则，返回刚创建的 <code>obj</code>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">return</span> (typeof <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> &quot;object&quot; <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">!=</span><span class="hljs-operator">=</span> <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">result</span> : obj;<br></code></pre></td></tr></table></figure></li></ol><p>手写一个 <code>myNew</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">Constructor, ...args</span>) &#123;<br>  <span class="hljs-comment">// 1. 创建空对象，并链接原型</span><br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <br>  <span class="hljs-comment">// 2. 执行构造函数，绑定 this</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, args);<br>  <br>  <span class="hljs-comment">// 3. 返回对象</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; result !== <span class="hljs-literal">null</span>) ? result : obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&quot;Alice&quot;</span>);<br>p.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hi, I&#x27;m Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="4-intanceof-复现"><a href="#4-intanceof-复现" class="headerlink" title="4.intanceof 复现"></a>4.intanceof 复现</h3><p> instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left)<br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <br> <br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.浏览器中的跨域问题（Q1.Nginx配置）</title>
    <link href="/2025/12/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/1-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2025/12/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/1-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>浏览器跨域问题，跨域的作用，如何解决跨域问题，CORS策略，Nginx基本配置，Vite配置代理服务器。</p><span id="more"></span><p><strong>面试题：</strong></p><img src="/2025/12/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/1-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-20251213053437226.png" class title="image-20251213053437226"><h2 id="浏览器中的跨域问题-CORS策略-Nginx"><a href="#浏览器中的跨域问题-CORS策略-Nginx" class="headerlink" title="浏览器中的跨域问题 &#x2F; CORS策略 &#x2F; Nginx"></a>浏览器中的跨域问题 &#x2F; CORS策略 &#x2F; Nginx</h2><blockquote><p><a href="https://www.yuque.com/tianyu-coder/openshare/aksmvpbebgw7savk#AwdCU">跨域问题梳理</a></p></blockquote><p> 补充内容：</p><ol><li>跨域请求的作用是什么，举个例子？</li><li>为什么同一个域名的不同端口要规定成不同源？</li><li>什么是Nginx，Nginx的三大作用？</li><li>Web服务器的定义是什么？</li><li>写一个基础的Nginx代理服务器配置？</li><li>写一个基础的Vite脚手架服务器配置？</li></ol><blockquote><p><a href="https://github.com/cxDlogver/Front_End/tree/main/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/1.%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">示例代码：Front_End&#x2F;手写代码&#x2F;1.跨域问题 at main · cxDlogver&#x2F;Front_End</a></p></blockquote><h3 id="1-跨域请求的作用"><a href="#1-跨域请求的作用" class="headerlink" title="1.跨域请求的作用"></a>1.跨域请求的作用</h3><p>跨域问题<strong>只作用于浏览器</strong>，一个网页的 JS，不能读取另一个“源”的资源返回结果，防止越权读取其他网站的敏感数据，保护用户安全。</p><p>如果<strong>没有跨域限制</strong>，会发生什么？</p><p>假设场景（非常危险）</p><p>你登录了：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//bank.com</span><br></code></pre></td></tr></table></figure><p>浏览器自动保存了你的登录 Cookie。</p><p>此时你又访问了一个恶意网站：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//evil.com</span><br></code></pre></td></tr></table></figure><p>如果<strong>没有跨域限制</strong>，evil.com 可以在 JS 中直接：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">&quot;https://bank.com/api/account&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><p>浏览器会<strong>自动携带你的 bank.com Cookie</strong>，恶意网站就能读到你的银行信息</p><h3 id="2-同一个域名的不同端口"><a href="#2-同一个域名的不同端口" class="headerlink" title="2.同一个域名的不同端口"></a>2.同一个域名的不同端口</h3><table><thead><tr><th>地址</th><th>实际含义</th></tr></thead><tbody><tr><td><code>http://127.0.0.1:80</code></td><td>Web 服务（Nginx &#x2F; Apache）</td></tr><tr><td><code>http://127.0.0.1:3306</code></td><td>MySQL</td></tr><tr><td><code>http://127.0.0.1:6379</code></td><td>Redis</td></tr><tr><td><code>http://127.0.0.1:8080</code></td><td>后端 API</td></tr><tr><td><code>http://127.0.0.1:5173</code></td><td>前端开发服务器</td></tr></tbody></table><p><strong>同一个 IP，不同端口，通常是完全不同的程序、不同权限、不同信任级别</strong></p><p>浏览器如果只按 IP 判断“同源”，就等于说：“只要在同一台机器上跑的服务，网页就可以互相读数据” 这是非常危险的。</p><p>同一个 IP 的不同端口，在浏览器安全模型中被视为“不同应用、不同安全域”，必须隔离，否则任何网页都能攻击用户本地和内网服务。</p><h3 id="3-什么是Nginx，Nginx的三大作用？"><a href="#3-什么是Nginx，Nginx的三大作用？" class="headerlink" title="3.什么是Nginx，Nginx的三大作用？"></a>3.什么是Nginx，Nginx的三大作用？</h3><blockquote><p><a href="https://www.bilibili.com/video/BV1F5411J7vK/?spm_id_from=333.337.search-card.all.click&vd_source=ff414aaf189e3a685358d2a984fd4742">【狂神说】Nginx最新教程通俗易懂，40分钟搞定！_哔哩哔哩_bilibili</a></p></blockquote><p>Nginx 是一个高性能的 http 和 Web 服务器，Nginx 的三大作用：反向代理， 负载均衡， Web服务器（静态资源服务器）</p><h4 id="反向代理（Reverse-Proxy）"><a href="#反向代理（Reverse-Proxy）" class="headerlink" title="反向代理（Reverse Proxy）"></a>反向代理（Reverse Proxy）</h4><p>当一个项目面临高并发访问时，单台服务器的计算资源、网络带宽和连接数都存在上限，往往无法同时承载所有请求。为提升系统的并发处理能力和稳定性，实际工程中通常会将同一业务部署在多台服务器上，通过扩展来分摊访问压力。大型互联网平台如腾讯、阿里等，均采用多实例部署，而非依赖单一服务器。</p><p>在这种部署模式下，不同服务器通常对应不同的 IP 地址或端口号。如果直接由前端或用户指定访问目标服务器，将导致请求入口分散、调用方式不统一，既增加了前端复杂度，也不利于系统的统一管理与扩展。</p><p>因此，现代系统架构的核心思想是在客户端与后端服务之间引入一层统一的访问入口。这一中间层负责对外暴露稳定、规范的访问接口，对内完成请求转发、负载分配与服务隔离。客户端只需面向这一统一入口发起请求，而无需感知后端服务的数量、位置或变化情况。</p><p><strong>反向代理是 Nginx 最核心的功能</strong>。客户端访问的目标是 Nginx，由 Nginx 决定请求转发到哪一个后端服务。</p><p>主要作用包括：</p><ul><li>隐藏后端真实 IP 和端口</li><li>统一访问入口与域名</li><li>在前后端分离架构中解决跨域问题</li><li>为后端提供安全隔离</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> api.example.com;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户访问：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//api.example.com</span><br></code></pre></td></tr></table></figure><p>实际上是：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Nginx → http<span class="hljs-punctuation">:</span><span class="hljs-comment">//127.0.0.1:8080</span><br></code></pre></td></tr></table></figure><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>当你后端不止一个服务实例时：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backend &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.1:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.2:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.3:8080</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 可以在多个实例之间分配请求流量。轮询、加权轮询等调度策略，提升系统并发能力与稳定性。</p><h4 id="Web-服务器（静态资源服务）"><a href="#Web-服务器（静态资源服务）" class="headerlink" title="Web 服务器（静态资源服务）"></a>Web 服务器（静态资源服务）</h4><p>Nginx 可以直接向客户端提供静态资源，如 HTML、CSS、JavaScript、图片和文件下载。</p><p><strong>为什么不用后端语言来发静态文件？</strong></p><p>因为 Nginx本身的特点：</p><ul><li>Nginx 是 <strong>事件驱动 + 非阻塞 IO</strong></li><li>内存占用极低</li><li>并发能力极强</li></ul><table><thead><tr><th>模型</th><th>特点</th></tr></thead><tbody><tr><td>传统服务器</td><td>一个请求一个线程</td></tr><tr><td>Nginx</td><td>一个线程处理成千上万连接</td></tr></tbody></table><p>这也是它能扛 <strong>10 万级并发连接</strong> 的原因</p><h3 id="4-Web服务器的定义是什么？"><a href="#4-Web服务器的定义是什么？" class="headerlink" title="4.Web服务器的定义是什么？"></a>4.Web服务器的定义是什么？</h3><p><strong>Web 服务端</strong>是指<strong>通过 HTTP&#x2F;HTTPS 协议对外提供 Web 访问能力的服务程序</strong>，负责接收来自浏览器或客户端的请求，并返回符合 Web 协议规范的响应。</p><p>从定义上看，Web 服务端的核心特征是两点：</p><ol><li>对外监听 HTTP&#x2F;HTTPS 端口（如 80、443）</li><li>按 Web 协议格式处理请求与响应</li></ol><p><strong>一个程序要被称为 Web 服务器，必须满足以下条件：</strong></p><ol><li>长期运行、常驻进程</li><li>直接监听 HTTP&#x2F;HTTPS 端口（80&#x2F;443）</li><li>实现完整的 HTTP 协议处理</li><li>能独立向客户端返回合法的 HTTP 响应</li><li>以网络与协议处理为主要职责</li></ol><p>与之对应的是应用服务器：</p><p><strong>承载具体业务逻辑、数据处理和业务规则的服务进程或服务器</strong>，通常不直接面向公网用户。</p><p>后端服务器的核心职责包括：</p><ul><li>实现业务逻辑（计算、校验、流程控制）</li><li>数据读写（数据库、缓存、文件系统）</li><li>对外提供业务接口（API）</li></ul><p>常见的后端服务形态包括：</p><ul><li>Java 应用（Spring Boot）</li><li>Python 应用（Flask、FastAPI、Django）</li><li>Node.js 应用（Express、NestJS）</li></ul><p><strong>为什么要把两则分开？</strong></p><p>在早期或小型系统中，Web 服务端和后端服务器可能部署在同一进程或同一台服务器上。但在中大型系统中，通常将二者分离，原因包括：</p><ul><li>Web 层需要承受大量并发连接</li><li>后端业务层更关注计算与逻辑复杂度</li><li>职责分离有利于独立扩展和维护</li><li>提高系统整体稳定性与安全性</li></ul><p>这种分层设计体现的是“关注点分离”的工程思想。</p><h3 id="5-Nginx代理服务器示例"><a href="#5-Nginx代理服务器示例" class="headerlink" title="5.Nginx代理服务器示例"></a>5.Nginx代理服务器示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>;  <span class="hljs-comment"># 工作进程数，根据服务器性能调整</span><br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       mime.types; <span class="hljs-comment"># 包含 MIME 类型配置</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream; <span class="hljs-comment"># 默认 MIME 类型</span><br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;  <span class="hljs-comment"># 开启高效文件传输模式</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;  <span class="hljs-comment"># 保持连接超时时间，单位秒</span><br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8088</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br><br>        <span class="hljs-attribute">root</span> C:/client; <span class="hljs-comment"># 静态资源目录</span><br>        <span class="hljs-attribute">index</span> index.html; <span class="hljs-comment"># 将C:/client/index.html作为入口文件</span><br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>        &#125;<br><br>        <span class="hljs-section">location</span> /api/ &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:3000/; <span class="hljs-comment"># 目标服务器源</span><br>            <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-Vite代理服务器示例"><a href="#6-Vite代理服务器示例" class="headerlink" title="6.Vite代理服务器示例"></a>6.Vite代理服务器示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">5173</span>,<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&quot;&quot;</span>),<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django从0到1搭建</title>
    <link href="/2025/12/05/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Django%E4%BB%8E0%E5%88%B01/"/>
    <url>/2025/12/05/%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/Django%E4%BB%8E0%E5%88%B01/</url>
    
    <content type="html"><![CDATA[<p>实现一个Django从0到1的搭建过程。</p><span id="more"></span><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><h4 id="Django-DRF基础教程（前后端分离）"><a href="#Django-DRF基础教程（前后端分离）" class="headerlink" title="Django+DRF基础教程（前后端分离）"></a><a href="https://blog.csdn.net/m0_71273766/article/details/133218567">Django+DRF基础教程（前后端分离）</a></h4><h4 id="django框架向DRF框架演变过程详解"><a href="#django框架向DRF框架演变过程详解" class="headerlink" title="django框架向DRF框架演变过程详解"></a><a href="https://blog.csdn.net/qq_39208536/article/details/131701180">django框架向DRF框架演变过程详解</a></h4><h4 id="一文到底——Django使用教程"><a href="#一文到底——Django使用教程" class="headerlink" title="一文到底——Django使用教程"></a><a href="https://blog.csdn.net/Ans_min/article/details/123146335"><strong>一文到底——Django使用教程</strong></a></h4><h4 id="Django官方文档"><a href="#Django官方文档" class="headerlink" title="Django官方文档"></a><a href="https://docs.djangoproject.com/zh-hans/5.0/">Django官方文档</a></h4></blockquote><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h3 id="项目总览"><a href="#项目总览" class="headerlink" title="项目总览"></a>项目总览</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装</span><br>pip install django<br><span class="hljs-comment"># 创建项目</span><br>django-admin startproject mysite<br><span class="hljs-comment"># 创建APP应用</span><br>python manage.py startapp blog<br><span class="hljs-comment"># 目录结构</span><br>mysite/<br>    manage.py<br>    mysite/           <span class="hljs-comment"># 配置目录</span><br>        settings.py<br>        urls.py<br>        wsgi.py<br><span class="hljs-comment"># 运行项目</span><br>python manage.py runserver<br><span class="hljs-comment"># 浏览器访问</span><br>http://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8000</span>/ <span class="hljs-comment"># 默认</span><br></code></pre></td></tr></table></figure><blockquote><p>Django 采用 <strong>“一个项目 Project + 多个应用 App”</strong> 的结构。</p></blockquote><p><img src="/2025/12/05/后端学习/Django从0到1/1aICZBUzrgLgc5GoWuiFHcw.jpegutm_source=chatgpt.jpeg" alt="How to Structure Your Django Project" style="zoom: 50%;"><img src="/2025/12/05/后端学习/Django从0到1/1jRO4h3b3f8cmsxW81NCoig.pngutm_source=chatgpt-1764944514302-1.png" alt="Django Project Architecture: The best project skeleton ever. | by Mandanka  Rajan | Medium" style="zoom: 33%;"></p><h4 id="从0到1的一个Django示例"><a href="#从0到1的一个Django示例" class="headerlink" title="从0到1的一个Django示例"></a>从0到1的一个Django示例</h4><p><a href="https://github.com/cxDlogver/Front_End/tree/main/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/mysite">Front_End&#x2F;实战项目&#x2F;mysite at main · cxDlogver&#x2F;Front_End</a></p><h3 id="项目基本结构"><a href="#项目基本结构" class="headerlink" title="项目基本结构"></a>项目基本结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">mysite/<br>    manage.py<br>    mysite/<br>        __init__.py<br>        settings.py<br>        urls.py<br>        asgi.py<br>        wsgi.py<br>    blog/<br>        __init__.py<br>        admin.py<br>        apps.py<br>        models.py<br>        tests.py<br>        views.py<br>        migrations/<br>            __init__.py<br></code></pre></td></tr></table></figure><h4 id="1-manage-py"><a href="#1-manage-py" class="headerlink" title="1. manage.py"></a>1. manage.py</h4><p>位置：<code>mysite/manage.py</code></p><p>基本代码示例（创建后）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;mysite.settings&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">from</span> django.core.management <span class="hljs-keyword">import</span> execute_from_command_line<br>    <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-keyword">raise</span> ImportError(<br>            <span class="hljs-string">&quot;Couldn&#x27;t import Django.&quot;</span><br>        ) <span class="hljs-keyword">from</span> exc<br>    execute_from_command_line(sys.argv)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>作用</p><ul><li>整个 Django 项目的命令入口。</li><li>负责加载 <code>mysite.settings</code>，并执行各种 <code>manage.py</code> 子命令。</li><li>Django 的 <code>python manage.py &lt;command&gt;</code> 指令体系是<strong>由 manage.py 调用 Django 的命令框架（django.core.management）实现的</strong>。</li><li>Django 从两类位置加载命令： 内置 commands + INSTALLED_APPS 的 custom commands， 每个APP可以自定义命令。</li></ul><p>常用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py runserver          <span class="hljs-comment"># 启动开发服务器</span><br>python manage.py startapp blog      <span class="hljs-comment"># 创建应用</span><br>python manage.py makemigrations     <span class="hljs-comment"># 创建迁移文件</span><br>python manage.py migrate            <span class="hljs-comment"># 应用迁移到数据库</span><br>python manage.py createsuperuser    <span class="hljs-comment"># 创建后台管理员</span><br>python manage.py shell              <span class="hljs-comment"># 启动 Django shell</span><br></code></pre></td></tr></table></figure><blockquote><p>一般不修改此文件。</p></blockquote><h4 id="2-项目包-mysite"><a href="#2-项目包-mysite" class="headerlink" title="2. 项目包 mysite&#x2F;"></a>2. 项目包 mysite&#x2F;</h4><h5 id="2-1-mysite-init-py"><a href="#2-1-mysite-init-py" class="headerlink" title="2.1 mysite&#x2F;init.py"></a>2.1 mysite&#x2F;<strong>init</strong>.py</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 空文件，一般是空的或只做版本标记</span><br></code></pre></td></tr></table></figure><p>作用：标记 <code>mysite</code> 为一个 Python 包。一般不改。</p><hr><h5 id="2-2-mysite-settings-py"><a href="#2-2-mysite-settings-py" class="headerlink" title="2.2 mysite&#x2F;settings.py"></a>2.2 mysite&#x2F;settings.py</h5><p>项目的全局配置文件。</p><p>精简示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>BASE_DIR = Path(__file__).resolve().parent.parent<br><br>SECRET_KEY = <span class="hljs-string">&#x27;开发环境随机密钥&#x27;</span><br><br>DEBUG = <span class="hljs-literal">True</span><br><br>ALLOWED_HOSTS = []  <span class="hljs-comment"># 部署时改为域名 / IP</span><br><br>INSTALLED_APPS = [<br>    <span class="hljs-string">&#x27;django.contrib.admin&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.contenttypes&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.staticfiles&#x27;</span>,<br><br>    <span class="hljs-string">&#x27;blog&#x27;</span>,  <span class="hljs-comment"># 自己的应用</span><br>]<br><br>MIDDLEWARE = [<br>    <span class="hljs-string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,<br>    <span class="hljs-string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,<br>]<br><br>ROOT_URLCONF = <span class="hljs-string">&#x27;mysite.urls&#x27;</span><br><br>TEMPLATES = [<br>    &#123;<br>        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,<br>        <span class="hljs-string">&#x27;DIRS&#x27;</span>: [BASE_DIR / <span class="hljs-string">&#x27;templates&#x27;</span>],  <span class="hljs-comment"># 全局模板目录</span><br>        <span class="hljs-string">&#x27;APP_DIRS&#x27;</span>: <span class="hljs-literal">True</span>,                  <span class="hljs-comment"># 自动扫描各 app 的 templates/</span><br>        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;context_processors&#x27;</span>: [<br>                <span class="hljs-string">&#x27;django.template.context_processors.debug&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.template.context_processors.request&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,<br>                <span class="hljs-string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,<br>            ],<br>        &#125;,<br>    &#125;,<br>]<br><br>WSGI_APPLICATION = <span class="hljs-string">&#x27;mysite.wsgi.application&#x27;</span><br><br>DATABASES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.sqlite3&#x27;</span>,      <span class="hljs-comment"># 默认 sqlite</span><br>        <span class="hljs-string">&#x27;NAME&#x27;</span>: BASE_DIR / <span class="hljs-string">&#x27;db.sqlite3&#x27;</span>,<br>    &#125;<br>&#125;<br><br>AUTH_PASSWORD_VALIDATORS = [<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&#x27;</span>,&#125;,<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.MinimumLengthValidator&#x27;</span>,&#125;,<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.CommonPasswordValidator&#x27;</span>,&#125;,<br>    &#123;<span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;django.contrib.auth.password_validation.NumericPasswordValidator&#x27;</span>,&#125;,<br>]<br><br>LANGUAGE_CODE = <span class="hljs-string">&#x27;zh-hans&#x27;</span><br>TIME_ZONE = <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span><br>USE_I18N = <span class="hljs-literal">True</span><br>USE_TZ = <span class="hljs-literal">True</span><br><br>STATIC_URL = <span class="hljs-string">&#x27;static/&#x27;</span><br>STATICFILES_DIRS = [BASE_DIR / <span class="hljs-string">&#x27;static&#x27;</span>]   <span class="hljs-comment"># 全局静态目录</span><br><br>DEFAULT_AUTO_FIELD = <span class="hljs-string">&#x27;django.db.models.BigAutoField&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>指定项目的所有全局配置。</li><li>关键部分：<ul><li>INSTALLED_APPS：启用哪些应用</li><li>DATABASES：数据库类型和连接配置</li><li>TEMPLATES：模板引擎和模板目录</li><li>STATIC_URL &#x2F; STATICFILES_DIRS：静态文件设置</li><li>LANGUAGE_CODE &#x2F; TIME_ZONE：语言与时区</li><li>DEBUG &#x2F; ALLOWED_HOSTS：调试模式与安全相关设置</li></ul></li></ul><p><strong>常见改动</strong></p><ul><li><p>添加自己的 app：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS += [<span class="hljs-string">&#x27;blog&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li><p>切换数据库到 MySQL、PostgreSQL 等。</p></li><li><p>新增模板目录、静态目录、媒体文件配置等。</p></li></ul><hr><h5 id="2-3-mysite-urls-py"><a href="#2-3-mysite-urls-py" class="headerlink" title="2.3 mysite&#x2F;urls.py"></a>2.3 mysite&#x2F;urls.py</h5><p>全局 URL 路由入口。</p><p><strong>基本代码示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),        <span class="hljs-comment"># 后台站点</span><br>    path(<span class="hljs-string">&#x27;blog/&#x27;</span>, include(<span class="hljs-string">&#x27;blog.urls&#x27;</span>)),   <span class="hljs-comment"># 分发到 blog 应用</span><br>]<br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>接收浏览器请求的 URL，决定交给哪个应用处理。</li><li>每个应用有自己的 <code>urls.py</code>，通过 <code>include()</code> 引入。</li><li>常用模式：项目级 <code>urls.py</code> 里只做路由分发，不写业务逻辑。</li></ul><hr><h5 id="2-4-mysite-wsgi-py"><a href="#2-4-mysite-wsgi-py" class="headerlink" title="2.4 mysite&#x2F;wsgi.py"></a>2.4 mysite&#x2F;wsgi.py</h5><p>WSGI 部署入口，一般用于生产环境部署如 Gunicorn、uWSGI。</p><p><strong>基本代码示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> django.core.wsgi <span class="hljs-keyword">import</span> get_wsgi_application<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;mysite.settings&#x27;</span>)<br><br>application = get_wsgi_application()<br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>提供一个名为 <code>application</code> 的 WSGI 应用对象，供 Web 服务器调用。</li><li>部署时写在 Gunicorn &#x2F; uWSGI 的配置中。</li><li>开发阶段基本不改。</li></ul><hr><h5 id="2-5-mysite-asgi-py"><a href="#2-5-mysite-asgi-py" class="headerlink" title="2.5 mysite&#x2F;asgi.py"></a>2.5 mysite&#x2F;asgi.py</h5><p>ASGI 部署入口，用于异步支持（如 WebSocket）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> django.core.asgi <span class="hljs-keyword">import</span> get_asgi_application<br><br>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;mysite.settings&#x27;</span>)<br><br>application = get_asgi_application()<br></code></pre></td></tr></table></figure><p>作用类似 wsgi.py，只是用于 ASGI 服务器（如 uvicorn、daphne）。</p><h4 id="3-应用目录-blog"><a href="#3-应用目录-blog" class="headerlink" title="3. 应用目录 blog&#x2F;"></a>3. 应用目录 blog&#x2F;</h4><h5 id="3-1-blog-init-py"><a href="#3-1-blog-init-py" class="headerlink" title="3.1 blog&#x2F;init.py"></a>3.1 blog&#x2F;<strong>init</strong>.py</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 一般为空</span><br></code></pre></td></tr></table></figure><p>作用：标记 <code>blog</code> 为 Python 包。</p><hr><h5 id="3-2-blog-apps-py"><a href="#3-2-blog-apps-py" class="headerlink" title="3.2 blog&#x2F;apps.py"></a>3.2 blog&#x2F;apps.py</h5><p>应用配置类。</p><p><strong>默认代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.apps <span class="hljs-keyword">import</span> AppConfig<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogConfig</span>(<span class="hljs-title class_ inherited__">AppConfig</span>):<br>    default_auto_field = <span class="hljs-string">&#x27;django.db.models.BigAutoField&#x27;</span><br>    name = <span class="hljs-string">&#x27;blog&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li>标识 app 在项目中的配置名。</li><li>如果需要应用级别的启动逻辑（如信号注册），可以在这里扩展。</li><li>通常在 <code>INSTALLED_APPS </code> 中会看到 <code>&#39;blog.apps.BlogConfig&#39;</code> 或简写 <code>&#39;blog&#39;</code>。</li></ul><hr><h5 id="3-3-blog-models-py"><a href="#3-3-blog-models-py" class="headerlink" title="3.3 blog&#x2F;models.py"></a>3.3 blog&#x2F;models.py</h5><p>用于定义数据库表（模型，Model）。</p><p><strong>示例：定义文章模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>(models.Model):<br>    title = models.CharField(max_length=<span class="hljs-number">200</span>, verbose_name=<span class="hljs-string">&#x27;标题&#x27;</span>)<br>    content = models.TextField(verbose_name=<span class="hljs-string">&#x27;内容&#x27;</span>)<br>    created_at = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;创建时间&#x27;</span>)<br>    updated_at = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;更新时间&#x27;</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        ordering = [<span class="hljs-string">&#x27;-created_at&#x27;</span>]           <span class="hljs-comment"># 默认按时间倒序</span><br>        verbose_name = <span class="hljs-string">&#x27;文章&#x27;</span><br>        verbose_name_plural = <span class="hljs-string">&#x27;文章&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.title<br></code></pre></td></tr></table></figure><p><strong>作用</strong></p><ul><li><p>每个 Model 类对应数据库中的一张表。</p></li><li><p>字段（Field）对应表中的列，例如 CharField、TextField、DateTimeField 等。</p></li><li><p>定义好后通过：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py makemigrations<br>python manage.py migrate<br></code></pre></td></tr></table></figure><p>来生成并同步数据库结构。</p></li></ul><hr><h5 id="3-4-blog-migrations"><a href="#3-4-blog-migrations" class="headerlink" title="3.4 blog&#x2F;migrations&#x2F;"></a>3.4 blog&#x2F;migrations&#x2F;</h5><p>迁移文件目录。</p><ul><li><code>__init__.py</code> 标记为包。</li><li>每次 <code>makemigrations</code> 会生成类似 <code>0001_initial.py</code> 的文件。</li></ul><p>示例（自动生成，大概结构）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># blog/migrations/0001_initial.py</span><br><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> migrations, models<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Migration</span>(migrations.Migration):<br><br>    initial = <span class="hljs-literal">True</span><br><br>    dependencies = []<br><br>    operations = [<br>        migrations.CreateModel(<br>            name=<span class="hljs-string">&#x27;Article&#x27;</span>,<br>            fields=[<br>                (<span class="hljs-string">&#x27;id&#x27;</span>, models.BigAutoField(primary_key=<span class="hljs-literal">True</span>, serialize=<span class="hljs-literal">False</span>)),<br>                (<span class="hljs-string">&#x27;title&#x27;</span>, models.CharField(max_length=<span class="hljs-number">200</span>)),<br>                (<span class="hljs-string">&#x27;content&#x27;</span>, models.TextField()),<br>                (<span class="hljs-string">&#x27;created_at&#x27;</span>, models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>)),<br>            ],<br>        ),<br>    ]<br></code></pre></td></tr></table></figure><p>作用：记录数据库结构变更，可版本化管理、回滚。</p><hr><h5 id="3-5-blog-views-py"><a href="#3-5-blog-views-py" class="headerlink" title="3.5 blog&#x2F;views.py"></a>3.5 blog&#x2F;views.py</h5><p>视图函数或类视图，处理具体业务逻辑。</p><p>示例 1：最简单的 HttpResponse</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;Hello Django, this is blog hello page.&quot;</span>)<br></code></pre></td></tr></table></figure><p>示例 2：结合模板渲染</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Article<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    articles = Article.objects.<span class="hljs-built_in">all</span>()<br>    context = &#123;<span class="hljs-string">&quot;articles&quot;</span>: articles&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&quot;blog/index.html&quot;</span>, context)<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>接收请求对象 <code>request</code>；</li><li>调用 Model 查询数据；</li><li>渲染模板或返回 Json &#x2F; HttpResponse；</li><li>返回响应给浏览器。</li></ul><hr><h5 id="3-6-blog-urls-py"><a href="#3-6-blog-urls-py" class="headerlink" title="3.6 blog&#x2F;urls.py"></a>3.6 blog&#x2F;urls.py</h5><p>需要手动创建，用于定义 blog 应用内的路由。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;hello/&#x27;</span>, views.hello, name=<span class="hljs-string">&#x27;blog_hello&#x27;</span>),<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, views.index, name=<span class="hljs-string">&#x27;blog_index&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><p>然后在 <code>mysite/urls.py</code> 中 include：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;blog/&#x27;</span>, include(<span class="hljs-string">&#x27;blog.urls&#x27;</span>)),<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>把与 blog 相关的 URL 集中维护。</li><li>利于模块化和解耦。</li></ul><hr><h5 id="3-7-blog-admin-py"><a href="#3-7-blog-admin-py" class="headerlink" title="3.7 blog&#x2F;admin.py"></a>3.7 blog&#x2F;admin.py</h5><p>注册模型到 Django Admin 后台。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Article<br><br><span class="hljs-meta">@admin.register(<span class="hljs-params">Article</span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleAdmin</span>(admin.ModelAdmin):<br>    list_display = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;created_at&#x27;</span>)<br>    search_fields = (<span class="hljs-string">&#x27;title&#x27;</span>,)<br>    list_filter = (<span class="hljs-string">&#x27;created_at&#x27;</span>,)<br></code></pre></td></tr></table></figure><p><strong>作用：</strong></p><ul><li>控制对应模型在 <code>/admin/</code> 后台中的展示方式：<ul><li>列表显示哪些字段</li><li>支持搜索、过滤、排序等</li></ul></li><li>是快速构建后台管理界面的关键文件。</li></ul><hr><h5 id="3-8-blog-tests-py"><a href="#3-8-blog-tests-py" class="headerlink" title="3.8 blog&#x2F;tests.py"></a>3.8 blog&#x2F;tests.py</h5><p>编写单元测试。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.test <span class="hljs-keyword">import</span> TestCase<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Article<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArticleModelTest</span>(<span class="hljs-title class_ inherited__">TestCase</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_create_article</span>(<span class="hljs-params">self</span>):<br>        a = Article.objects.create(title=<span class="hljs-string">&quot;Test&quot;</span>, content=<span class="hljs-string">&quot;Content&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.assertEqual(a.title, <span class="hljs-string">&quot;Test&quot;</span>)<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>用于验证模型、视图等逻辑是否正确。</li><li>在持续集成、重构时尤其重要。</li></ul><h4 id="4-常见辅助目录"><a href="#4-常见辅助目录" class="headerlink" title="4. 常见辅助目录"></a>4. 常见辅助目录</h4><h5 id="4-1-templates"><a href="#4-1-templates" class="headerlink" title="4.1 templates&#x2F;"></a>4.1 templates&#x2F;</h5><p>项目根目录下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mysite/<br>    templates/<br>        blog/<br>            index.html<br></code></pre></td></tr></table></figure><p><code>index.html</code> 示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Blog Index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文章列表<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    &#123;% for a in articles %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; a.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; a.content|truncatechars:100 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>&#123;&#123; a.created_at &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    &#123;% empty %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>暂无文章<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    &#123;% endfor %&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>作用：存放 HTML 模板，配合 <code>render()</code> 使用。</p><hr><h5 id="4-2-static"><a href="#4-2-static" class="headerlink" title="4.2 static&#x2F;"></a>4.2 static&#x2F;</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mysite/<br>    <span class="hljs-keyword">static</span>/<br>        css/<br>            style.css<br></code></pre></td></tr></table></figure><p><code>style.css</code> 示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">font-family</span>: sans-serif; &#125;<br><span class="hljs-selector-tag">h1</span> &#123; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">24px</span>; &#125;<br></code></pre></td></tr></table></figure><p>模板里引用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;% load static %&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% static &#x27;css/style.css&#x27; %&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>作用：管理 CSS &#x2F; JS &#x2F; 图片 等静态资源。</p><h3 id="MVT结构"><a href="#MVT结构" class="headerlink" title="MVT结构"></a>MVT结构</h3><h4 id="1-什么是-Django-的-MVT-结构"><a href="#1-什么是-Django-的-MVT-结构" class="headerlink" title="1. 什么是 Django 的 MVT 结构"></a>1. 什么是 Django 的 MVT 结构</h4><p>Django 使用一种类似 MVC（Model–View–Controller）的架构，但强调 Web 开发中的模板渲染，因此称为 <strong>MVT（Model–View–Template）</strong>。</p><p>核心思想：</p><ul><li><strong>Model</strong>：负责数据层（数据库结构、ORM 操作）</li><li><strong>View</strong>：负责业务逻辑层（处理请求、数据处理、返回响应）</li><li><strong>Template</strong>：负责展示层（HTML 页面渲染）</li></ul><p>与 MVC 的不同点：</p><ul><li>Django 把“控制器”隐藏在框架内部（URL 分发器、模板渲染器），开发者无需手动写 Controller</li><li>视图函数（View）更接近 MVC 中的“Controller”</li></ul><p>因此 Django 实际结构：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">用户请求 → URL 路由 → <span class="hljs-built_in">View</span>(业务逻辑) ↔ <span class="hljs-built_in">Model</span>(数据库)<br>                                    ↓<br>                               <span class="hljs-built_in">Template</span>(页面)<br>                                    ↓<br>                               返回给浏览器<br></code></pre></td></tr></table></figure><hr><h4 id="2-部分的职责与代码位置"><a href="#2-部分的职责与代码位置" class="headerlink" title="2. 部分的职责与代码位置"></a>2. 部分的职责与代码位置</h4><h5 id="2-1-Model（模型层）"><a href="#2-1-Model（模型层）" class="headerlink" title="2.1. Model（模型层）"></a>2.1. Model（模型层）</h5><p>位置：<code>app/models.py</code></p><p>职责：</p><ul><li>定义数据库表结构（映射为 Python 类）</li><li>使用 Django ORM 提供增删改查（查询集 QuerySet）</li><li>承担业务实体的数据规则（字段类型、关系）</li></ul><p>模型的本质：</p><p><strong>数据库的一行记录 -&gt; 一个 Python 对象</strong></p><hr><h5 id="2-2-View（视图层）"><a href="#2-2-View（视图层）" class="headerlink" title="2.2. View（视图层）"></a>2.2. View（视图层）</h5><p>位置：<code>app/views.py</code></p><p>职责：</p><ul><li>接收 HTTP 请求</li><li>调用 Model 获取或处理数据</li><li>选择模板并渲染</li><li>返回 HTTP 响应（HTML、JSON 等）</li></ul><p>View 的本质：</p><p><strong>业务逻辑处理方法，是 Django 中最接近 MVC Controller 的部分</strong></p><hr><h5 id="2-3-Template（模板层）"><a href="#2-3-Template（模板层）" class="headerlink" title="2.3. Template（模板层）"></a>2.3. Template（模板层）</h5><p>位置：<code>templates/目录/*.html</code></p><p>职责：</p><ul><li>负责页面呈现（HTML、CSS）</li><li>不包含业务逻辑（仅渲染数据，不处理数据）</li><li>使用 Django 模板语言（DTL）</li></ul><p>Template 的本质：</p><p><strong>纯展示层，不做逻辑运算，只展示 View 传来的数据</strong></p><hr><h4 id="3-URL-路由（MVT-的入口）"><a href="#3-URL-路由（MVT-的入口）" class="headerlink" title="3. URL 路由（MVT 的入口）"></a>3. URL 路由（MVT 的入口）</h4><p>虽然不属于 MVT 三部分本身，但它是 MVT 的启动点。</p><p>位置：</p><ul><li>项目级：<code>mysite/urls.py</code></li><li>应用级：<code>blog/urls.py</code></li></ul><p>示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># blog/urls.py<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> <span class="hljs-type">path</span><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;articles/&#x27;</span>, views.article_list),<br>]<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>将 URL 与 View 对应起来</li><li>决定用户访问哪个页面时由哪个 View 来处理</li></ul><p>本质上 URL 分发器承担了传统 MVC 的 Controller 中的一部分工作。</p><hr><h4 id="4-MVT-与-MVC-的关系"><a href="#4-MVT-与-MVC-的关系" class="headerlink" title="4. MVT 与 MVC 的关系"></a>4. MVT 与 MVC 的关系</h4><p>Django 的 MVT 对应 MVC 的映射关系如下：</p><table><thead><tr><th>Django</th><th>MVC 对应</th><th>职责</th></tr></thead><tbody><tr><td>Model</td><td>Model</td><td>数据与业务实体</td></tr><tr><td>View</td><td>Controller</td><td>业务逻辑、响应请求</td></tr><tr><td>Template</td><td>View</td><td>展示 HTML 页面</td></tr><tr><td>URL Dispatcher（系统内部）</td><td>Controller</td><td>路由分发</td></tr></tbody></table><p>关键点：</p><ul><li>Django 框架自动处理了 Controller 的大量工作，因此你只需要写 View（业务逻辑）</li></ul><hr><h4 id="5-完整的数据流（面试常问）"><a href="#5-完整的数据流（面试常问）" class="headerlink" title="5. 完整的数据流（面试常问）"></a>5. 完整的数据流（面试常问）</h4><p>请求过程（从访问 URL 到页面显示）：</p><ol><li>浏览器访问 URL，例如 <code>/blog/articles/</code></li><li><code>urls.py</code> 匹配到对应 View，例如 <code>article_list()</code></li><li>View 调用 Model 查询数据库</li><li>View 将数据传给 Template 渲染</li><li>Template 生成 HTML</li><li>View 将 HTML 包装成 HttpResponse 返回给浏览器</li></ol><p>流程图（文字版）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">URL → <span class="hljs-keyword">View</span> → Model → 数据 → <span class="hljs-keyword">View</span> → <span class="hljs-keyword">Template</span> → HTML → Response → 用户<br></code></pre></td></tr></table></figure><blockquote><p>为什么 Django 使用 MVT 而不是 MVC？</p></blockquote><p>原因：</p><ol><li>Web 开发中 HTML 模板是核心部分，因此作为独立层 Template 更合理</li><li>Django 自动处理了传统 MVC 的 Controller，例如路由调度、模板渲染器</li><li>开发者关注点清晰：<ul><li>Model：数据</li><li>View：逻辑</li><li>Template：呈现</li></ul></li></ol><p>Django 提供了更高层封装，使 Web 开发更轻量和快速。</p><blockquote><p>Django 的 MVT 和 MVC 有什么区别？</p></blockquote><p><u>最大的区别即MVT提供了更高层封装，例如URL分发器等框架自动处理了 Controller 的大量工作，将重心放在的业务逻辑处理和页面渲染。</u></p><p>Django 采用 MVT 模式，它是对 MVC 的一种实现变体。三者的角色是：</p><ol><li><strong>Model</strong>：负责数据和业务实体部分，和 MVC 中的 Model 完全一致</li><li><strong>View（Django）</strong>：负责接收请求与业务逻辑，这部分更像 MVC 中的 Controller</li><li><strong>Template</strong>：负责页面展示逻辑，对应 MVC 中的 View</li></ol><p>换句话说：</p><ul><li>Django 把 Controller 的工作拆成两部分：<br>1）URL 分发器（由框架自动处理）<br>2）View（编写的业务逻辑函数或类）</li></ul><p>所以常见映射是：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">MVC              MVT(Django)</span><br><span class="hljs-section">--------------------------------------</span><br>Model     -&gt;     Model<br>View      -&gt;     Template<br>Controller-&gt;     View + URL Dispatcher<br></code></pre></td></tr></table></figure><p>举例说明（文章列表页）：</p><ul><li>在 MVC 里 Controller 负责调取文章数据，并让 View 显示</li><li>在 Django MVT 里 View 负责调取数据，然后把数据交给 Template 展示</li></ul><p>因此 MVT 本质上和 MVC 思想一致，只是名称和职责边界因 Django 的封装而有所不同。</p><h2 id="DRF"><a href="#DRF" class="headerlink" title="DRF"></a>DRF</h2><p>实现 Django REST 和前后端分离，本质上是把「Django 输出 HTML 页面」改成「Django 输出 JSON API」，由前端框架（Vue&#x2F;React 等）来渲染界面。需要调整的部分包括：</p><ol><li>Django REST + 前后端分离的核心是：<strong>后端不再渲染 HTML，只提供 JSON API</strong>，页面由前端框架负责。</li><li>后端需要：引入 DRF、使用 Serializer 和 APIView&#x2F;ViewSet、设计 RESTful URL、改用 Token&#x2F;JWT 认证、处理好 CORS 和 CSRF。</li><li>部署上：前端和后端解耦，往往分域名&#x2F;端口部署，通过 Nginx 或代理把 <code>/api/</code> 转给 Django，其它路径交给前端静态资源。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试资源</title>
    <link href="/2025/08/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2025/08/05/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>前端面试整理的相关资源链接</p><span id="more"></span><p><a href="https://github.com/febobo/web-interview">febobo&#x2F;web-interview: 语音打卡社群维护的前端面试题库，包含不限于Vue面试题，React面试题，JS面试题，HTTP面试题，工程化面试题，CSS面试题，算法面试题，大厂面试题，高频面试题</a></p><p><a href="https://www.mianshiya.com/bank/1810644471159848962">前端 JavaScript 基础面试题 - 面试鸭 - 程序员求职面试刷题神器</a></p><p><a href="https://github.com/lgwebdream/FE-Interview/tree/master">lgwebdream&#x2F;FE-Interview: 🔥🔥🔥 前端面试，独有前端面试题详解，前端面试刷题必备，1000+前端面试真题，Html、Css、JavaScript、Vue、React、Node、TypeScript、Webpack、算法、网络与安全、浏览器</a></p><p><a href="https://github.com/paddingme/Front-end-Web-Development-Interview-Question">paddingme&#x2F;Front-end-Web-Development-Interview-Question: 前端开发面试题大收集，前端面试集锦 :gift_heart: :cupid:</a></p><p><a href="https://www.bilibili.com/opus/379030881059278529">2025最新Web前端学习路线 - 哔哩哔哩</a></p>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/"/>
    <url>/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>对JavaScript知识总结。</p><span id="more"></span><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h2 id="JavaScript-专业词汇"><a href="#JavaScript-专业词汇" class="headerlink" title="JavaScript 专业词汇"></a>JavaScript 专业词汇</h2><ul><li><code>表达式</code></li><li><code>代码块</code></li><li><code>函数闭包</code></li></ul><h2 id="JavaScript-的数据类型"><a href="#JavaScript-的数据类型" class="headerlink" title="JavaScript 的数据类型"></a>JavaScript 的数据类型</h2><h3 id="【数据类型】"><a href="#【数据类型】" class="headerlink" title="【数据类型】"></a>【数据类型】</h3><p>JavaScript 中的数据类型分为 <strong>原始类型（Primitive Types）</strong> 和 <strong>引用类型（Reference Types）</strong>。</p><p><strong>1. 原始类型（7种）：</strong></p><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Number</code></td><td>数值，包括整数、浮点数、NaN、Infinity等</td><td><code>1</code>, <code>3.14</code>, <code>NaN</code></td></tr><tr><td><code>String</code></td><td>字符串类型</td><td><code>&#39;hello&#39;</code>, <code>&quot;world&quot;</code></td></tr><tr><td><code>Boolean</code></td><td>布尔类型</td><td><code>true</code>, <code>false</code></td></tr><tr><td><code>undefined</code></td><td>表示未定义的变量</td><td><code>let a;</code> <code>typeof a // &quot;undefined&quot;</code></td></tr><tr><td><code>null</code></td><td>表示空值，常用于对象占位</td><td><code>let a = null</code></td></tr><tr><td><code>Symbol</code></td><td>唯一值，用于对象属性名</td><td><code>Symbol(&#39;desc&#39;)</code></td></tr><tr><td><code>BigInt</code></td><td>表示大整数</td><td><code>12345678901234567890n</code></td></tr></tbody></table><ul><li>模板字符串：使用反单引号&#96; 来表示模板字符串模板字符串中可以嵌入变量</li></ul><p><strong>2. 引用类型（对象类型）：</strong></p><table><thead><tr><th>类型</th><th>示例</th></tr></thead><tbody><tr><td><code>Object</code></td><td><code>&#123;&#125;</code>、<code>&#123;name: &quot;JS&quot;&#125;</code></td></tr><tr><td><code>Array</code></td><td><code>[1, 2, 3]</code></td></tr><tr><td><code>Function</code></td><td><code>function() &#123;&#125;</code> 或箭头函数 <code>() =&gt; &#123;&#125;</code></td></tr><tr><td><code>Date</code></td><td><code>new Date()</code></td></tr><tr><td><code>RegExp</code></td><td><code>/abc/</code></td></tr><tr><td><code>Map</code> &#x2F; <code>Set</code></td><td><code>new Map()</code>, <code>new Set()</code></td></tr><tr><td><code>WeakMap</code> &#x2F; <code>WeakSet</code></td><td>稀疏结构，弱引用</td></tr></tbody></table><p><strong>3. 类型检测方法</strong></p><table><thead><tr><th>方法&#x2F;运算符</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>返回原始类型的字符串表示</td><td><code>typeof 123 // &quot;number&quot;</code></td></tr><tr><td><code>instanceof</code></td><td>判断对象是否为某个构造函数的实例</td><td><code>[] instanceof Array // true</code></td></tr><tr><td><code>Object.prototype.toString.call()</code></td><td>精确判断所有类型</td><td><code>Object.prototype.toString.call(null) // &quot;[object Null]&quot;</code></td></tr><tr><td><code>Array.isArray()</code></td><td>判断是否为数组</td><td><code>Array.isArray([]) // true</code></td></tr></tbody></table><h3 id="【类型转换方式】"><a href="#【类型转换方式】" class="headerlink" title="【类型转换方式】"></a>【类型转换方式】</h3><p>JavaScript 支持三种类型转换：</p><ol><li><strong>显式类型转换</strong></li></ol><p>使用内建函数进行强制转换。</p><table><thead><tr><th>目标类型</th><th>方法</th><th>示例</th></tr></thead><tbody><tr><td>转为字符串</td><td><code>String(value)</code> 或 <code>value.toString()</code></td><td><code>String(123) → &quot;123&quot;</code></td></tr><tr><td>转为数字</td><td><code>Number(value)</code> 或 <code>parseInt</code>, <code>parseFloat</code></td><td><code>Number(&quot;123&quot;) → 123</code></td></tr><tr><td>转为布尔值</td><td><code>Boolean(value)</code></td><td><code>Boolean(&quot;&quot;) → false</code></td></tr></tbody></table><ol start="2"><li><strong>隐式类型转换</strong></li></ol><blockquote><p><font color="#008B8B">弱类型语言</font>：在弱类型语言中，<strong>变量的数据类型可以隐式转换</strong>，而不是强制规定。JavaScript是一种典型的弱类型语言。</p></blockquote><p>JS 在运算时会自动进行类型转换。</p><table><thead><tr><th>情况</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>字符串拼接</td><td><code>&quot;1&quot; + 2 → &quot;12&quot;</code></td><td>数字被转为字符串</td></tr><tr><td>算术运算</td><td><code>&quot;5&quot; * &quot;2&quot; → 10</code></td><td>字符串被转为数字</td></tr><tr><td>布尔上下文</td><td><code>if (&quot;hello&quot;) &#123;...&#125;</code></td><td>非空字符串为 <code>true</code></td></tr><tr><td>与运算符 <code>==</code></td><td><code>null == undefined → true</code></td><td>非严格等于可能发生类型转换</td></tr></tbody></table><ol start="3"><li><strong>自动装箱（Boxing）与解箱（Unboxing）</strong></li></ol><p>原始值在需要对象时被自动包装为对象（如访问 <code>.length</code> 或调用方法时）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">length</span>); <span class="hljs-comment">// 自动装箱为 String 对象</span><br></code></pre></td></tr></table></figure><h2 id="JavaScript的运算符"><a href="#JavaScript的运算符" class="headerlink" title="JavaScript的运算符"></a>JavaScript的运算符</h2><p><strong>1.算术运算符（Arithmetic Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法 &#x2F; 字符串拼接</td><td><code>2 + 3</code></td><td><code>5</code></td></tr><tr><td><code>-</code></td><td>减法</td><td><code>5 - 2</code></td><td><code>3</code></td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>3 * 4</code></td><td><code>12</code></td></tr><tr><td><code>/</code></td><td>除法</td><td><code>10 / 2</code></td><td><code>5</code></td></tr><tr><td><code>%</code></td><td>取模（余数）</td><td><code>10 % 3</code></td><td><code>1</code></td></tr><tr><td><code>**</code></td><td>幂运算（ES6）</td><td><code>2 ** 3</code></td><td><code>8</code></td></tr><tr><td><code>++</code></td><td>自增</td><td><code>x++</code> &#x2F; <code>++x</code></td><td><code>x + 1</code></td></tr><tr><td><code>--</code></td><td>自减</td><td><code>x--</code> &#x2F; <code>--x</code></td><td><code>x - 1</code></td></tr></tbody></table><p><strong>2.赋值运算符（Assignment Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>等同于</th></tr></thead><tbody><tr><td><code>=</code></td><td>赋值</td><td><code>a = 5</code></td><td></td></tr><tr><td><code>+=</code></td><td>加后赋值</td><td><code>a += 2</code></td><td><code>a = a + 2</code></td></tr><tr><td><code>-=</code></td><td>减后赋值</td><td><code>a -= 1</code></td><td><code>a = a - 1</code></td></tr><tr><td><code>*=</code></td><td>乘后赋值</td><td><code>a *= 3</code></td><td><code>a = a * 3</code></td></tr><tr><td><code>/=</code></td><td>除后赋值</td><td><code>a /= 2</code></td><td><code>a = a / 2</code></td></tr><tr><td><code>%=</code></td><td>取模后赋值</td><td><code>a %= 3</code></td><td><code>a = a % 3</code></td></tr><tr><td><code>**=</code></td><td>幂后赋值（ES6）</td><td><code>a **= 2</code></td><td><code>a = a ** 2</code></td></tr><tr><td><code>??=</code></td><td>空赋值</td><td><code>null ??= defined</code></td><td></td></tr></tbody></table><blockquote><p><code>??=</code> 只有当变量的值为null或undefined时才会对变量进行赋值</p></blockquote><p><strong>3.比较运算符（Comparison Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果类型</th></tr></thead><tbody><tr><td><code>==</code></td><td>相等（类型转换）</td><td><code>&#39;5&#39; == 5</code></td><td><code>true</code></td></tr><tr><td><code>===</code></td><td>全等（值和类型）</td><td><code>&#39;5&#39; === 5</code></td><td><code>false</code></td></tr><tr><td><code>!=</code></td><td>不等</td><td><code>&#39;5&#39; != 5</code></td><td><code>false</code></td></tr><tr><td><code>!==</code></td><td>不全等</td><td><code>&#39;5&#39; !== 5</code></td><td><code>true</code></td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>5 &gt; 3</code></td><td><code>true</code></td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>2 &lt; 4</code></td><td><code>true</code></td></tr><tr><td><code>&gt;=</code></td><td>大于或等于</td><td><code>5 &gt;= 5</code></td><td><code>true</code></td></tr><tr><td><code>&lt;=</code></td><td>小于或等于</td><td><code>3 &lt;= 2</code></td><td><code>false</code></td></tr></tbody></table><blockquote><p>⚠️ 推荐使用 <code>===</code> 和 <code>!==</code>，避免隐式类型转换带来的 bug。</p></blockquote><p><strong>4.逻辑运算符（Logical Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>返回值类型</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>与（AND）</td><td><code>true &amp;&amp; false</code></td><td><code>false</code></td></tr><tr><td>&#96;</td><td></td><td>&#96;</td><td>或（OR）</td></tr><tr><td><code>!</code></td><td>非（NOT）</td><td><code>!true</code></td><td><code>false</code></td></tr><tr><td><code>??</code></td><td>空值合并</td><td><code>null ?? &#39;default&#39;</code></td><td><code>&#39;default&#39;</code></td></tr></tbody></table><blockquote><p><code>??</code> 是 ES2020 引入的，仅在左侧为 <code>null</code> 或 <code>undefined</code> 时返回右侧值。</p></blockquote><p><strong>5.位运算符（Bitwise Operators）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>5 &amp; 1 = 1</code></td></tr><tr><td>&#96;</td><td>&#96;</td><td>按位或</td></tr><tr><td><code>^</code></td><td>按位异或</td><td><code>5 ^ 1 = 4</code></td></tr><tr><td><code>~</code></td><td>按位非（取反）</td><td><code>~5 = -6</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>5 &lt;&lt; 1 = 10</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>有符号右移</td><td><code>5 &gt;&gt; 1 = 2</code></td></tr><tr><td><code>&gt;&gt;&gt;</code></td><td>无符号右移</td><td><code>-5 &gt;&gt;&gt; 1</code></td></tr></tbody></table><p><strong>6.字符串运算符</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>+</code></td><td>拼接字符串</td><td><code>&#39;a&#39; + &#39;b&#39;</code></td><td><code>&#39;ab&#39;</code></td></tr></tbody></table><p><strong>7.三元运算符（Ternary Operator）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">条件 ? 真值 : 假值<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> result = age &gt;= <span class="hljs-number">18</span> ? <span class="hljs-string">&#x27;adult&#x27;</span> : <span class="hljs-string">&#x27;minor&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><p><strong>8.类型运算符</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>返回变量的类型字符串</td><td><code>typeof 123 // &quot;number&quot;</code></td></tr><tr><td><code>instanceof</code></td><td>判断是否为某个构造函数的实例</td><td><code>[] instanceof Array // true</code></td></tr><tr><td><code>in</code></td><td>属性是否在对象中</td><td><code>&quot;name&quot; in obj</code></td></tr><tr><td><code>delete</code></td><td>删除对象的属性</td><td><code>delete obj.name</code></td></tr><tr><td><code>void</code></td><td>执行表达式但返回 <code>undefined</code></td><td><code>void 0 // undefined</code></td></tr></tbody></table><p><strong>9.扩展运算符（ES6+）</strong></p><table><thead><tr><th>运算符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>...</code></td><td>展开 &#x2F; 剩余运算符</td><td><code>[...arr]</code>, <code>&#123;...obj&#125;</code></td></tr><tr><td><code>?.</code></td><td>可选链运算符（ES2020）</td><td><code>user?.info?.name</code></td></tr></tbody></table><p><strong>10.运算符优先级（常见顺序）</strong></p><p>优先级从高到低（越上面越先执行）：</p><ol><li>括号 <code>()</code></li><li>成员访问 <code>.</code>、<code>[]</code></li><li>函数调用 <code>()</code></li><li>一元运算符 <code>!</code>, <code>typeof</code>, <code>++</code>, <code>--</code></li><li>幂运算 <code>**</code></li><li>乘、除、取模 <code>* / %</code></li><li>加、减 <code>+ -</code></li><li>位运算</li><li>比较运算符</li><li>逻辑运算符</li><li>三元运算符 <code>? :</code></li><li>赋值 <code>= += -=</code></li><li>逗号运算符 <code>,</code></li></ol><h2 id="JavaScript隐式类型转换"><a href="#JavaScript隐式类型转换" class="headerlink" title="JavaScript隐式类型转换"></a>JavaScript隐式类型转换</h2><h3 id="【转换规律】"><a href="#【转换规律】" class="headerlink" title="【转换规律】"></a>【转换规律】</h3><p>JavaScript 中的类型转换主要有三种方向：</p><ul><li><strong>转为字符串（ToString）</strong></li><li><strong>转为数字（ToNumber）</strong></li><li><strong>转为布尔值（ToBoolean）</strong></li></ul><ol><li><strong>转为布尔值（ToBoolean）</strong></li></ol><p>转换为 <code>false</code> 的值（称为“<strong>假值</strong>”）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">false</span><br><span class="hljs-number">0</span><br>-<span class="hljs-number">0</span><br><span class="hljs-number">0n</span>       <span class="hljs-comment">// BigInt 的 0</span><br><span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-literal">null</span><br><span class="hljs-literal">undefined</span><br><span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure><p>其余全部为 <code>true</code>（即便是空数组 <code>[]</code>、空对象 <code>&#123;&#125;</code> 也为真）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>([]) → <span class="hljs-literal">true</span><br><span class="hljs-title class_">Boolean</span>(&#123;&#125;) → <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>2. 转为数字（ToNumber）</strong></p><table><thead><tr><th>值</th><th>转换后</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>1</code></td></tr><tr><td><code>false</code></td><td><code>0</code></td></tr><tr><td><code>null</code></td><td><code>0</code></td></tr><tr><td><code>undefined</code></td><td><code>NaN</code></td></tr><tr><td><code>&#39;&#39;</code></td><td><code>0</code></td></tr><tr><td><code>&#39;123&#39;</code></td><td><code>123</code></td></tr><tr><td><code>&#39;123abc&#39;</code></td><td><code>NaN</code></td></tr><tr><td><code>[]</code></td><td><code>0</code></td></tr><tr><td><code>[123]</code></td><td><code>123</code></td></tr><tr><td><code>&#123;&#125;</code></td><td><code>NaN</code></td></tr></tbody></table><p><strong>3. 转为字符串（ToString）</strong></p><table><thead><tr><th>值</th><th>转换后</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>&quot;true&quot;</code></td></tr><tr><td><code>false</code></td><td><code>&quot;false&quot;</code></td></tr><tr><td><code>null</code></td><td><code>&quot;null&quot;</code></td></tr><tr><td><code>undefined</code></td><td><code>&quot;undefined&quot;</code></td></tr><tr><td><code>123</code></td><td><code>&quot;123&quot;</code></td></tr><tr><td><code>[]</code></td><td><code>&quot;&quot;</code></td></tr><tr><td><code>[1, 2]</code></td><td><code>&quot;1,2&quot;</code></td></tr><tr><td><code>&#123;&#125;</code></td><td><code>&quot;[object Object]&quot;</code></td></tr></tbody></table><h3 id="【隐式类型转换场景】"><a href="#【隐式类型转换场景】" class="headerlink" title="【隐式类型转换场景】"></a>【隐式类型转换场景】</h3><ol><li><strong>与运算符相关的转换</strong></li></ol><table><thead><tr><th>运算符</th><th>示例</th><th>转换说明</th></tr></thead><tbody><tr><td><code>+</code>（加法）</td><td><code>&#39;5&#39; + 3</code> → <code>&#39;53&#39;</code></td><td>若有字符串，先转为字符串拼接</td></tr><tr><td><code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></td><td><code>&#39;5&#39; - 2</code> → <code>3</code></td><td>将字符串转为数字运算</td></tr><tr><td><code>==</code>（宽松相等）</td><td><code>0 == false</code> → <code>true</code></td><td>进行值的转换后再比较</td></tr><tr><td><code>===</code>（严格相等）</td><td><code>0 === false</code> → <code>false</code></td><td>不进行类型转换</td></tr><tr><td><code>!</code>（逻辑非）</td><td><code>!0</code> → <code>true</code></td><td>转换为布尔值取反</td></tr></tbody></table><ol start="2"><li><strong>与条件判断相关的转换</strong></li></ol><p>在 <code>if</code>、<code>while</code>、三元运算符中，会将表达式转换为布尔值。</p><ol start="3"><li><strong>与对象相关的转换</strong></li></ol><p>当对象参与算术或比较运算时，会触发 <code>valueOf()</code> 或 <code>toString()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#125; + <span class="hljs-number">1</span>        <span class="hljs-comment">// &quot;[object Object]1&quot;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] + <span class="hljs-number">3</span>    <span class="hljs-comment">// &quot;1,23&quot;</span><br>&#123;&#125; == <span class="hljs-string">&quot;[object Object]&quot;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="【隐式转换规律总结】"><a href="#【隐式转换规律总结】" class="headerlink" title="【隐式转换规律总结】"></a>【隐式转换规律总结】</h3><p>基本规律一：优先转为字符串（尤其是 <code>+</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;2&#x27;</span> + <span class="hljs-number">1</span>        <span class="hljs-comment">// &quot;21&quot;</span><br><span class="hljs-literal">true</span> + <span class="hljs-string">&#x27;abc&#x27;</span>   <span class="hljs-comment">// &quot;trueabc&quot;</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + <span class="hljs-number">3</span>      <span class="hljs-comment">// &quot;1,23&quot;</span><br></code></pre></td></tr></table></figure><p>基本规律二：其他算术运算尝试转为数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;5&#x27;</span> - <span class="hljs-literal">true</span>     <span class="hljs-comment">// 4（&#x27;5&#x27;→5，true→1）</span><br><span class="hljs-literal">null</span> * <span class="hljs-number">8</span>       <span class="hljs-comment">// 0（null→0）</span><br><span class="hljs-string">&#x27;abc&#x27;</span> - <span class="hljs-number">1</span>      <span class="hljs-comment">// NaN（&#x27;abc&#x27; 转为数字失败）</span><br></code></pre></td></tr></table></figure><p>基本规律三：逻辑运算符返回的是<strong>原始值</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">false</span> || <span class="hljs-string">&#x27;hello&#x27;</span>     <span class="hljs-comment">// &quot;hello&quot;</span><br><span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">123</span>             <span class="hljs-comment">// 0</span><br><span class="hljs-literal">null</span> ?? <span class="hljs-string">&#x27;default&#x27;</span>    <span class="hljs-comment">// &quot;default&quot;</span><br></code></pre></td></tr></table></figure><h3 id="【易错点示例】"><a href="#【易错点示例】" class="headerlink" title="【易错点示例】"></a>【易错点示例】</h3><table><thead><tr><th>表达式</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td><code>NaN == NaN</code></td><td><code>false</code></td><td>NaN不和任何值相等，包括它自身</td></tr><tr><td><code>null == undefined</code></td><td><code>true</code></td><td>是相等的</td></tr><tr><td><code>[] == false</code></td><td><code>true</code></td><td><code>[] → &#39;&#39; → 0</code>，<code>false → 0</code></td></tr><tr><td><code>[] == ![]</code></td><td><code>true</code></td><td><code>![] → false</code>，<code>[] == false → true</code></td></tr><tr><td><code>&#123;&#125; + []</code></td><td><code>[object Object]</code></td><td>第一个 <code>&#123;&#125;</code> 被解释为块</td></tr></tbody></table><h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><h3 id="【函数形式】"><a href="#【函数形式】" class="headerlink" title="【函数形式】"></a>【函数形式】</h3><ol><li><strong>函数声明式（Function Declaration）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：可以在声明之前调用（函数提升）。</p><hr><ol start="2"><li><strong>函数表达式（Function Expression）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：必须先定义再调用。可以匿名或具名。</p><ol start="3"><li><strong>箭头函数（Arrow Function）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>更简洁；</li><li>没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code>；</li><li>不能作为构造函数（不能用 <code>new</code> 调用）；</li><li>不能使用 <code>yield</code>，即不能用作生成器函数。</li></ul><ol start="4"><li><strong>构造函数创建（Function 构造器）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>特点</strong>：动态创建函数，但不推荐使用（安全性差、性能差）。</p><h3 id="【参数与返回值】"><a href="#【参数与返回值】" class="headerlink" title="【参数与返回值】"></a>【参数与返回值】</h3><p>函数返回值必须是一个值，包括对象、表达式（如函数表达式），没有返回值默认返回<code>undefined</code>。</p><h3 id="【回调函数（Callback）】"><a href="#【回调函数（Callback）】" class="headerlink" title="【回调函数（Callback）】"></a>【回调函数（Callback）】</h3><p><strong>回调函数</strong>是指作为参数传递给另一个函数的函数，并在该函数内部在某个时刻被“调用”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Doing something...&quot;</span>);<br>  <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 调用传入的函数</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">doSomething</span>(sayHello); <span class="hljs-comment">// 输出：Doing something... 然后 Hello!</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>sayHello</code> 是一个 <strong>回调函数</strong>，它作为参数传递给 <code>doSomething</code>，并在内部被调用。</p><p><strong>事件监听</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>数组方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>异步操作（如定时器）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;延迟1秒执行&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>命名 vs 匿名回调函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 匿名回调</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;匿名函数&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 命名回调</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callbackFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;命名函数&quot;</span>);<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(callbackFn, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><strong>箭头函数也可以作为回调函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Arrow function callback&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/m0_46165586/article/details/143785628">为什么JavaScript中函数也能看成对象_js函数也是对象,怎么理解-CSDN博客</a></p></blockquote><h3 id="【window-对象】"><a href="#【window-对象】" class="headerlink" title="【window 对象】"></a>【window 对象】</h3><p>在浏览器中，<code>window</code> 是顶级对象，全局作用域下声明的变量和函数（<code>var</code>、<code>function</code>）都会变成 <code>window</code> 的属性或方法；而 <code>let</code> 和 <code>const</code> 则不会。</p><p><code>window</code> 是<strong>浏览器环境中的全局对象</strong>。表示整个浏览器窗口。它包含了：</p><ul><li><strong>浏览器提供的宿主对象</strong>（如 <code>alert</code>、<code>setTimeout</code>）</li><li><strong>JavaScript 的全局变量和函数</strong></li><li><strong>全局作用域中的变量（var 声明的）和函数</strong></li></ul><p>在浏览器中，所有全局作用域下的 <code>var</code> 变量和 <code>function</code> 声明都会被挂载到 <code>window</code> 上。</p><p><strong>访问方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hi&quot;</span>);   <span class="hljs-comment">// 通过 window 调用 alert 方法</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hi&quot;</span>);          <span class="hljs-comment">// 可省略 window，效果相同</span><br></code></pre></td></tr></table></figure><p><strong>全局变量与 <code>window</code> 的关系</strong></p><p>1.<code>var</code> 声明的变量会挂载在 <code>window</code> 上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>2.<code>let</code> 和 <code>const</code> 声明的变量 <strong>不会</strong>挂在 <code>window</code> 上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>3.没有使用 <code>var/let/const</code> 声明的变量也会挂在 <code>window</code> 上（不推荐，容易污染全局）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  undeclared = <span class="hljs-number">123</span>;<br>&#125;<br><span class="hljs-title function_">test</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">undeclared</span>); <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><ol start="4"><li>普通函数（使用 <code>function</code> 声明）自动挂载为 <code>window</code> 的方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 调用方式等同于 fn()</span><br></code></pre></td></tr></table></figure><p>常用 <code>window</code> 方法示例</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>alert()</code></td><td>弹出提示框</td></tr><tr><td><code>confirm()</code></td><td>弹出确认框（返回 true&#x2F;false）</td></tr><tr><td><code>prompt()</code></td><td>输入框，返回用户输入</td></tr><tr><td><code>setTimeout()</code></td><td>延时执行</td></tr><tr><td><code>setInterval()</code></td><td>定时重复执行</td></tr><tr><td><code>console.log()</code></td><td>控制台输出（也是 window 的一部分）</td></tr></tbody></table><h3 id="【变量和函数的提升】"><a href="#【变量和函数的提升】" class="headerlink" title="【变量和函数的提升】"></a>【变量和函数的提升】</h3><p><code>var</code>、<code>let</code>、函数在声明的时候会在代码开始执行之前声明，用于考虑内存分配。</p><p><strong><code>var</code> 声明的提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>相当于解释器处理成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a;          <span class="hljs-comment">// 提升：声明但不赋值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined</span><br>a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p> <strong><code>let</code> 的“暂时性死区”（TDZ）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 报错：Cannot access &#x27;b&#x27; before initialization</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ul><li><code>let</code> 声明虽然也“提升”（被识别），但不会初始化。</li><li>在 <code>let b = 10;</code> 之前的任何访问都会抛出 <code>ReferenceError</code>。</li></ul><p><strong>函数声明的提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 正常执行：alert(&quot;我是fn函数~&quot;)</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我是fn函数~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>函数声明（Function Declaration）</strong>：完整地被提升，包含函数体。</li></ul><p><strong>函数表达式不会被完整提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// fn2(); // 报错：fn2 is not a function</span><br><span class="hljs-keyword">var</span> fn2 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;匿名函数&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="【立即执行函数】"><a href="#【立即执行函数】" class="headerlink" title="【立即执行函数】"></a>【立即执行函数】</h3><p><strong>立即执行函数</strong>是定义好之后立即被调用的函数，它的语法形式是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;());<br></code></pre></td></tr></table></figure><p>也可以使用箭头函数写法（ES6+）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;)();<br></code></pre></td></tr></table></figure><p>JavaScript 中 <code>function</code> 声明默认是函数声明语句，<strong>不能直接执行</strong>。</p><p>将函数用 <code>()</code> 包裹后，<strong>变成表达式</strong>，表达式就可以立即执行。</p><p><strong>为什么要用 IIFE？</strong></p><ol><li><strong>创建私有作用域</strong>，防止变量污染全局命名空间。</li><li>代码模块化的一种早期手段（模块化之前的写法）。</li><li>常用于库、插件或立即执行的逻辑中。</li><li>可用于封装变量、函数，防止外部访问。</li></ol><p><strong>IIFE 模块化用途</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      count++;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;,<br>    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>      count = <span class="hljs-number">0</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reset&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;)();<br><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-title class_">Counter</span>.<span class="hljs-title function_">reset</span>();     <span class="hljs-comment">// reset</span><br></code></pre></td></tr></table></figure><h3 id="【函数的-this】"><a href="#【函数的-this】" class="headerlink" title="【函数的 this】"></a>【函数的 <code>this</code>】</h3><p><code>this</code> 是 JavaScript 函数执行时自动传入的一个 <strong>隐含参数</strong>，它的值取决于 <strong>函数的调用方式</strong>。</p><p><strong>基本规则</strong></p><table><thead><tr><th>调用方式</th><th><code>this</code> 指向</th></tr></thead><tbody><tr><td>普通函数调用</td><td>全局对象（浏览器中是 <code>window</code>） 在严格模式下是 <code>undefined</code></td></tr><tr><td>对象方法调用</td><td>调用该方法的对象（即 “点” 左边的对象）</td></tr><tr><td>构造函数调用（<code>new</code>）</td><td>新创建的实例对象</td></tr><tr><td>显式绑定（<code>call/apply/bind</code>）</td><td>显式指定的对象</td></tr><tr><td>箭头函数调用</td><td>**定义时所在作用域的 <code>this</code>**（不会改变）</td></tr></tbody></table><ol><li><strong>普通函数</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 浏览器中输出：window；严格模式下输出：undefined</span><br></code></pre></td></tr></table></figure><p><strong>2. 对象方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>    <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Tom&quot;，this 指向 obj</span><br></code></pre></td></tr></table></figure><p><strong>3. 构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;Alice&quot;，this 指向新建的对象 p</span><br></code></pre></td></tr></table></figure><p><strong>4. 显式绑定</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span> &#125;;<br>show.<span class="hljs-title function_">call</span>(user);   <span class="hljs-comment">// &quot;Bob&quot;</span><br>show.<span class="hljs-title function_">apply</span>(user);  <span class="hljs-comment">// &quot;Bob&quot;</span><br><br><span class="hljs-keyword">const</span> boundShow = show.<span class="hljs-title function_">bind</span>(user);<br><span class="hljs-title function_">boundShow</span>();       <span class="hljs-comment">// &quot;Bob&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>箭头函数</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>    <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        &#125;;<br>        <span class="hljs-title function_">arrow</span>();<br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Tom&quot;，箭头函数的 this 继承自 sayHello 的 this</span><br></code></pre></td></tr></table></figure><p><strong>注意点</strong></p><ol><li>箭头函数的 <code>this</code> <strong>不会根据调用方式改变</strong>，它始终指向其定义时的外部作用域。</li><li>在事件监听函数中，若使用普通函数，则 <code>this</code> 是触发事件的元素；若使用箭头函数，<code>this</code> 是定义时的上下文（可能是 <code>window</code> 或外部对象）。</li><li>构造函数中若不使用 <code>new</code>，<code>this</code> 将指向 <code>window</code>，可能导致错误。</li></ol><h3 id="【高阶函数】"><a href="#【高阶函数】" class="headerlink" title="【高阶函数】"></a>【高阶函数】</h3><p><strong>高阶函数</strong>是指<strong>接收函数作为参数</strong>，或者<strong>返回一个函数</strong>的函数。</p><ol><li>接收函数作为参数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processUserInput</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">callback</span>(name));<br>&#125;<br><br><span class="hljs-title function_">processUserInput</span>(greet); <span class="hljs-comment">// 输出: Hello, Alice!</span><br></code></pre></td></tr></table></figure><ol start="2"><li>返回一个函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiplier</span>(<span class="hljs-params">factor</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * factor;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> double = <span class="hljs-title function_">multiplier</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出: 10</span><br></code></pre></td></tr></table></figure><p>常见高阶函数（内置）</p><ul><li><code>Array.prototype.map()</code></li><li><code>Array.prototype.filter()</code></li><li><code>Array.prototype.reduce()</code></li><li><code>Array.prototype.forEach()</code></li><li><code>setTimeout</code>, <code>setInterval</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> doubled = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>); <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure><h3 id="【闭包】"><a href="#【闭包】" class="headerlink" title="【闭包】"></a>【闭包】</h3><p><strong>闭包</strong>是指<strong>一个函数可以访问其定义时的词法作用域，即使这个函数在其定义作用域之外被调用</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">outer</span>();<br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><ul><li><code>inner()</code> 函数访问了 <code>outer()</code> 中的局部变量 <code>count</code>。</li><li>即使 <code>outer()</code> 已经执行完，<code>inner()</code> 仍然“记住”了它的词法作用域——形成闭包。</li></ul><p>闭包和类的对比：</p><table><thead><tr><th>场景</th><th>推荐用闭包</th><th>推荐用类</th></tr></thead><tbody><tr><td>只需要几个函数操作内部状态</td><td>✅</td><td>🚫</td></tr><tr><td>有多个对象、共享行为（方法）</td><td>🚫</td><td>✅</td></tr><tr><td>需要完全私有变量</td><td>✅</td><td>✅（用 <code>#</code>）</td></tr><tr><td>多态、继承、原型链等 OOP 特性</td><td>🚫</td><td>✅</td></tr></tbody></table><ul><li><strong>闭包</strong>：每次调用 <code>createXXX</code> 函数会生成新的作用域，内存压力略大，不利于大规模实例化。</li><li><strong>类</strong>：方法可以挂在原型上，共享函数定义，<strong>更节省内存</strong>。</li></ul><h3 id="【argumen和可变参数】"><a href="#【argumen和可变参数】" class="headerlink" title="【argumen和可变参数】"></a>【argumen和可变参数】</h3><p><code>arguments</code></p><ul><li>在 <strong>函数内部</strong>，你可以使用内置的 <code>arguments</code> 对象来访问<strong>所有传入的实参</strong>。</li><li>它是一个<strong>类数组对象</strong>，包含调用函数时传入的所有参数。</li></ul><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 类数组：不是真正的数组</span><br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    total += <span class="hljs-variable language_">arguments</span>[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出: 10</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<code>arguments</code> 不能用于箭头函数（<code>=&gt;</code>），因为它没有自己的 <code>arguments</code> 对象。</p></blockquote><p><strong>可变参数（Rest Parameters）</strong></p><p>可变参数（Rest Parameters）使用 <code>...</code> 语法，将<strong>不定数量的参数</strong>收集到一个真正的数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> acc + cur, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出：6</span><br></code></pre></td></tr></table></figure><ul><li><code>args</code> 是一个<strong>真正的数组</strong>，可以使用数组方法（如 <code>map</code>、<code>reduce</code>、<code>filter</code> 等）；</li><li>可以与固定参数一起使用，但 <code>...rest</code> 必须是最后一个参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">name, ...messages</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(messages); <span class="hljs-comment">// messages 是数组</span><br>&#125;<br><br><span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 输出：Alice</span><br><span class="hljs-comment">//      [&quot;Hello&quot;, &quot;World&quot;]</span><br></code></pre></td></tr></table></figure><p><code>arguments</code> 和 <code>rest 参数</code> 的区别</p><table><thead><tr><th>比较项</th><th><code>arguments</code> 对象</th><th><code>...rest</code> 可变参数</th></tr></thead><tbody><tr><td>是否数组</td><td>❌ 类数组对象</td><td>✅ 真正的数组</td></tr><tr><td>是否能用数组方法</td><td>❌ 需要转化</td><td>✅ 直接可用</td></tr><tr><td>是否支持箭头函数</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>是否支持默认值</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>是否可以命名</td><td>❌ 只能用 <code>arguments</code></td><td>✅ 可自定义名字</td></tr><tr><td>ES版本</td><td>ES3 就有</td><td>ES6 新特性</td></tr></tbody></table><h3 id="【call-apply-bind】"><a href="#【call-apply-bind】" class="headerlink" title="【call,apply,bind】"></a>【<code>call</code>,<code>apply</code>,<code>bind</code>】</h3><p><code>call</code>、<code>apply</code>、<code>bind</code> 是 JavaScript 中用于<strong>改变函数 <code>this</code> 指向</strong>的三个非常重要的方法，常用于手动控制函数的执行上下文。</p><table><thead><tr><th>方法</th><th>作用</th><th>是否立即执行函数</th><th>参数传递方式</th></tr></thead><tbody><tr><td><code>call</code></td><td>改变 <code>this</code> 并执行函数</td><td>✅ 是</td><td>逐个传入参数</td></tr><tr><td><code>apply</code></td><td>改变 <code>this</code> 并执行函数</td><td>✅ 是</td><td><strong>数组</strong>传入参数</td></tr><tr><td><code>bind</code></td><td>改变 <code>this</code>，但<strong>不立即执行</strong>，返回新函数</td><td>❌ 否</td><td>逐个传入参数（可预设）</td></tr></tbody></table><p>示例函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, punctuation</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;greeting&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span><span class="hljs-subst">$&#123;punctuation&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span> &#125;;<br></code></pre></td></tr></table></figure><p><code>call(thisArg, arg1, arg2, ...)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>);<br><span class="hljs-comment">// 输出: Hello, Alice!</span><br></code></pre></td></tr></table></figure><p> <code>apply(thisArg, [arg1, arg2, ...])</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;...&#x27;</span>]);<br><span class="hljs-comment">// 输出: Hi, Alice...</span><br></code></pre></td></tr></table></figure><p> <code>bind(thisArg, arg1, arg2, ...)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> greetAlice = greet.<span class="hljs-title function_">bind</span>(person, <span class="hljs-string">&#x27;Hey&#x27;</span>);<br><span class="hljs-title function_">greetAlice</span>(<span class="hljs-string">&#x27;?&#x27;</span>); <span class="hljs-comment">// 输出: Hey, Alice?</span><br></code></pre></td></tr></table></figure><blockquote><p>箭头函数没有自身的this，它的this由外层作用域决定，也无法通过call apply 和 bind修改它的this</p></blockquote><h2 id="JavaScript面向对象编程"><a href="#JavaScript面向对象编程" class="headerlink" title="JavaScript面向对象编程"></a>JavaScript面向对象编程</h2><p><strong>面向对象编程（Object-Oriented Programming）</strong> 是一种编程思想，将现实世界中的事物抽象为对象，所以编写操作基于对象执行。通过 <strong>类（Class）</strong> 和 <strong>对象（Object）</strong> 来封装数据与行为，使程序更易于复用、扩展和维护。</p><p>OOP 三大特性：</p><ul><li><strong>封装</strong>：将数据与方法打包在对象中，隐藏内部实现。</li><li><strong>继承</strong>：子类可以继承父类的属性和方法，代码复用。</li><li><strong>多态</strong>：不同类的对象可以以统一方式调用同名方法（JavaScript中主要通过鸭子类型体现）。</li></ul><h3 id="【类与对象区别】"><a href="#【类与对象区别】" class="headerlink" title="【类与对象区别】"></a>【类与对象区别】</h3><table><thead><tr><th>分类</th><th>类（Class）</th><th>对象（Object）</th></tr></thead><tbody><tr><td>定义</td><td>模板、蓝图</td><td>类的具体实例</td></tr><tr><td>概念</td><td>定义属性和方法的抽象结构</td><td>通过类创建的实体</td></tr><tr><td>示例</td><td><code>class Person &#123;&#125;</code></td><td><code>let p = new Person()</code></td></tr><tr><td>关系</td><td>对象是由类实例化而来的</td><td>类是构造对象的基础</td></tr></tbody></table><ol><li>定义类</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 实例方法</span><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, I am <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">20</span>);<br>p1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Hello, I am Alice</span><br></code></pre></td></tr></table></figure><p>javascript对象分为三类</p><ul><li>内建对象：<code>Object</code>,<code>String</code>,<code>Array</code>等</li><li>宿主对象：由浏览器提供的对象，如<code>BOM</code>，<code>DOM</code></li><li>自定义对象：由开发人员自己创建的对象</li></ul><h3 id="【类的属性和方法】"><a href="#【类的属性和方法】" class="headerlink" title="【类的属性和方法】"></a>【类的属性和方法】</h3><p>1.实例属性与方法（在 constructor 或类体中定义，属于对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name; <span class="hljs-comment">// 实例属性</span><br>  &#125;<br><br>  <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> says woof!`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.静态属性与方法（用 static 关键字，属于类本身）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tool</span> &#123;<br>  <span class="hljs-keyword">static</span> version = <span class="hljs-string">&#x27;1.0.0&#x27;</span>; <span class="hljs-comment">// 静态属性</span><br><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">logInfo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Tool Version: <span class="hljs-subst">$&#123;Tool.version&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Tool</span>.<span class="hljs-title function_">logInfo</span>();  <span class="hljs-comment">// Tool Version: 1.0.0</span><br></code></pre></td></tr></table></figure><h3 id="【类的封装】"><a href="#【类的封装】" class="headerlink" title="【类的封装】"></a>【类的封装】</h3><p>封装是面向对象编程的三大特性之一，指的是<strong>将对象的属性和方法包装在类中，并隐藏内部实现细节，仅暴露对外的操作接口</strong>。</p><p><strong>封装的目标</strong>：</p><ol><li><strong>隐藏实现细节</strong>，保护数据安全；</li><li><strong>限制外部直接访问对象属性</strong>；</li><li><strong>通过方法控制属性的读写权限和校验逻辑</strong>。</li></ol><p><strong>如何实现封装（JavaScript 中）</strong></p><ol><li>使用 <code>class</code> 定义类</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ol start="2"><li>使用私有属性（<code>#</code>）</li></ol><blockquote><p>ES2022 引入的私有属性，语法是 <code>#属性名</code>，只能在类内部访问。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  #name;  <span class="hljs-comment">// 私有属性</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#name = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.#name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>提供 getter&#x2F;setter 方法（读写接口）</li></ol><p>方法式访问器（传统写法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;<br>&#125;<br><br><span class="hljs-title function_">setName</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">if</span> (name) <span class="hljs-variable language_">this</span>.#name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性式访问器（现代写法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;<br>&#125;<br><br><span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#name = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>p.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Jerry&quot;</span>;     <span class="hljs-comment">// set</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// get</span><br></code></pre></td></tr></table></figure><p><strong>封装的好处</strong></p><table><thead><tr><th>好处</th><th>说明</th></tr></thead><tbody><tr><td>数据保护</td><td>防止外部随意修改属性值</td></tr><tr><td>控制访问</td><td>通过 <code>getter/setter</code> 控制属性读写权限</td></tr><tr><td>降低耦合</td><td>外部不关心内部实现，提高类的独立性</td></tr><tr><td>便于调试</td><td>可以在访问器中添加调试信息和断点</td></tr></tbody></table><h3 id="【类的多态】"><a href="#【类的多态】" class="headerlink" title="【类的多态】"></a>【类的多态】</h3><p>多态是面向对象三大特性之一，指的是<strong>相同的接口或方法作用于不同的对象时，表现出不同的行为</strong>。</p><ul><li>JavaScript <strong>不检查类型</strong>，只要对象有需要的属性或方法，就能被使用。</li><li>常用表达方式是：<strong>传入不同对象、执行相同操作，结果行为各异</strong>。</li></ul><p>1.JavaScript 不检查类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, &quot;</span> + obj.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;悟空&quot;</span>)); <span class="hljs-comment">// Hello, 悟空</span><br><span class="hljs-title function_">sayHello</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>));    <span class="hljs-comment">// Hello, 旺财</span><br></code></pre></td></tr></table></figure><p>2.方法重写（Override）：在继承体系中，<strong>子类重写父类的方法</strong>，体现出不同的行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;动物发出声音&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;狗叫：汪汪&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;猫叫：喵喵&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> animals = [<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>()];<br><br>animals.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">animal</span> =&gt;</span> animal.<span class="hljs-title function_">speak</span>());<br></code></pre></td></tr></table></figure><ul><li>这就是通过<strong>同一个父类方法 <code>speak()</code>，由不同子类表现出不同行为</strong>，实现了<strong>经典的多态</strong>。</li></ul><p>3.函数参数多态（传入不同类型对象）:函数的参数可以是任何类型，这种特性让函数更通用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">describe</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">describe</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        obj.<span class="hljs-title function_">describe</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这个对象没有描述方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【类的继承】"><a href="#【类的继承】" class="headerlink" title="【类的继承】"></a>【类的继承】</h3><p>继承是面向对象编程三大特性之一，是<strong>子类继承父类的属性和方法，从而实现代码复用和扩展功能</strong>的机制。</p><p><strong>JavaScript 中的继承实现方式（ES6+）</strong></p><p>1.使用 <code>extends</code> 关键字实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;动物在叫~&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.<code>super</code> 的用法</p><table><thead><tr><th>场景</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>super(...)</code></td><td>子类构造函数中<strong>调用父类构造函数</strong>，必须写在第一行</td><td><code>super(name)</code></td></tr><tr><td><code>super.方法名()</code></td><td>在子类方法中调用<strong>父类的同名方法</strong></td><td><code>super.sayHello()</code></td></tr></tbody></table><p>3.示例（构造函数 + 方法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);      <span class="hljs-comment">// 调用父类构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 调用父类的方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;喵喵喵&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.方法重写（Override）</p><p>子类可以<strong>定义与父类同名的方法</strong>，用于覆盖父类的方法，实现多态行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;汪汪汪&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数继承注意事项</p><ul><li>如果<strong>子类定义了构造函数</strong>，必须在构造函数第一行调用 <code>super(...)</code>。</li><li>否则会报错：<code>ReferenceError: Must call super constructor in derived class before accessing &#39;this&#39;</code></li></ul><p><strong>继承的好处</strong></p><table><thead><tr><th>好处</th><th>说明</th></tr></thead><tbody><tr><td>代码复用</td><td>子类自动获得父类的属性和方法</td></tr><tr><td>易于维护</td><td>修改父类会自动影响所有子类</td></tr><tr><td>扩展能力强</td><td>子类可添加自己的属性或重写方法</td></tr><tr><td>遵守OCP</td><td>遵循开闭原则：对修改关闭，对扩展开放</td></tr></tbody></table><p><strong>关键点：</strong></p><table><thead><tr><th>概念</th><th>关键字</th><th>示例</th><th>作用</th></tr></thead><tbody><tr><td>继承</td><td><code>extends</code></td><td><code>class Dog extends Animal</code></td><td>让子类继承父类</td></tr><tr><td>调用父构造函数</td><td><code>super(...)</code></td><td><code>super(name)</code></td><td>子类构造函数中必须调用父类构造函数</td></tr><tr><td>调用父类方法</td><td><code>super.方法名()</code></td><td><code>super.sayHello()</code></td><td>子类中调用父类方法</td></tr><tr><td>方法重写</td><td>子类中定义与父类同名的方法</td><td><code>sayHello()</code></td><td>实现不同子类的特有行为（多态）</td></tr></tbody></table><h3 id="【原型对象】"><a href="#【原型对象】" class="headerlink" title="【原型对象】"></a>【原型对象】</h3><blockquote><p>每个对象都有一个内部属性 <code>[[Prototype]]</code>（通常访问为 <code>__proto__</code>），它指向另一个对象，这个对象称为“原型”。当访问对象的某个属性时，如果对象本身没有这个属性，则会去它的原型对象上查找，这就是“原型链查找”机制。原型本身也是对象，也有原型，因此构成一个原型链，直到最顶层<code>null</code>终止</p></blockquote><p><strong>1.查找顺序：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">obj = &#123;&#125;  <span class="hljs-comment">// obj = new Object()</span><br><span class="hljs-comment">// obj -&gt; obj.__proto__(Object.prototype) -&gt; null</span><br></code></pre></td></tr></table></figure><p><strong><font color="#008B8B">注意点：</font></strong></p><ul><li><code>obj</code> 的 <code>__proto__</code> 指向 <code>Object.prototype</code>。</li><li><code>Object.prototype</code> 是所有普通对象的顶层原型，<code>Object.prototype.__proto__ === null</code>。</li><li><code>Object</code>是所有对象的基类。</li><li>JS中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的<strong>实例</strong>，而所有类都默认继承<code>Object</code>基类。</li></ul><p><strong>2.类中的原型：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  &#125;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Animal</code>默认继承<code>Object</code>基类，<code>Animal</code>的原型就是<code>Object</code>实例。</li><li>类的静态属性<code>prototype</code>和对象的属性<code>__proto__</code>作用相同，都是获取原型对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === animal.<span class="hljs-property">__proto__</span> (<span class="hljs-title class_">Object</span>实例)<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === animal.<span class="hljs-property">__proto__</span>.<span class="hljs-property">proto__</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ul><li>原型就相当于是一个<strong>公共的区域</strong>，可以被所有该类实例访问,可以将该类实例中，所有的公共属性（方法）统一存储到原型中,这样我们只需要创建一个属性，即可被所有实例访问</li><li>对原型中的数据修改会影响所有包含该原型的对象实例。</li></ul><p><strong>3.对象结构</strong></p><p>对象中存储属性的区域实际有两个：对象自身和原型对象。</p><ol><li>直接通过对象所添加的属性，位于对象自身中，在类中通过 x &#x3D; y 的形式添加的属性，位于对象自身中。</li><li>在类中通过xxx(){}方式添加的方法和主动向原型中添加的属性或方法，位于原型中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  name = <span class="hljs-string">&#x27;Instance Property&#x27;</span>;<br><br>  <span class="hljs-comment">// 原型方法</span><br>  <span class="hljs-title function_">protoMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;protoMethod this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 实例函数表达式</span><br>  funcExpr = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;funcExpr this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;;<br><br>  <span class="hljs-comment">// 实例箭头函数</span><br>  arrowFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arrowFunc this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;;<br><br>  <span class="hljs-comment">// 静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;staticMethod this.name:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型对象中的数据：</p><ol><li>对象中的数据（属性、方法等）</li><li>constructor （对象的构造函数）</li></ol><p><code>constructor</code>实际就是类，保存所有静态属性和方法。</p><img src="/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/image-20250802233313942.png" class title="image-20250802233313942"><p><strong>4.访问方式</strong></p><ol><li><code>Object.getPrototypeOf(obj)</code> 返回对象的原型。</li><li><code>obj.__proto__</code> 是非标准访问方式，现代建议使用 <code>Object.getPrototypeOf</code>。</li><li><code>obj.hasOwnProperty(prop)</code> 判断属性是否在对象自身上。</li><li><code>Object.hasOwn(obj, prop) </code>（推荐使用）判断属性是否在对象自身上。</li><li><code>prop in obj</code> 判断属性是否存在（自身或原型链）。</li><li><code>instanceof</code> 检查的是对象的原型链上是否有该类实例</li></ol><blockquote><p>不建议直接对原型对象数据进行修改。</p></blockquote><h3 id="【this-的指向】"><a href="#【this-的指向】" class="headerlink" title="【this 的指向】"></a>【this 的指向】</h3><p>对象中方法的定义位置不同。</p><ol><li><strong>原型方法（<code>method() &#123;&#125;</code>）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;原型方法&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义位置：类的原型上（<code>MyClass.prototype.method</code>）</li><li>不是在构造函数中定义的</li><li>所有实例共享</li><li>正常调用（如 <code>obj.protoMethod()</code>），<code>this</code> 指向实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>obj.<span class="hljs-title function_">protoMethod</span>(); <span class="hljs-comment">// this === obj </span><br><br><span class="hljs-keyword">const</span> f = obj.<span class="hljs-property">funcExpr</span>;<br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// this === undefined（在严格模式下） this === window （非严格模式下）</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>实例方法（字段定义：<code>method = function() &#123;&#125;</code> 或 <code>method = () =&gt; &#123;&#125;</code>）</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  method1 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;函数表达式&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>定义位置：构造函数内部</p><blockquote><p>因为 JavaScript 会把这些“字段初始化器”转化为构造函数里的赋值语句</p></blockquote></li><li><p>每个实例一份，每次实例化的时候都会定义一次。</p></li><li><p><code>method2</code>（箭头函数）自动绑定 <code>this</code>，而 <code>method1</code> 不会</p></li><li><p><code>this</code>和原型方法一样。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  method2 = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">method2</span> = () = &gt;&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;箭头函数&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义位置：构造函数内部</li><li>每个实例一份，每次实例化的时候都会定义一次。</li><li><code>method2</code>（箭头函数）自动绑定 <code>this</code>，</li><li><code>this</code>根据外作用域决定，也就是<code>constructor</code>， <code>this === 实例对象</code>，因此无论怎么调用，<code>this</code> 都不会变</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><span class="hljs-keyword">const</span> f = obj.<span class="hljs-property">arrowFunc</span>;<br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// this === obj（永远是实例）</span><br></code></pre></td></tr></table></figure><p><strong>3. 静态方法（<code>static method() &#123;&#125;</code>）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;静态方法&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义位置：类本身（<code>MyClass.method</code>），而不是实例或构造函数里，只定义一次。</li><li>不是在构造函数中定义的</li><li>只能通过类调用，不能通过实例调用，<code>MyClass.staticMethod()</code>，此时 <code>this === MyClass</code></li></ul><table><thead><tr><th>方法类型</th><th>记忆口诀</th></tr></thead><tbody><tr><td>原型方法</td><td>谁调用我，我的 <code>this</code> 就是谁</td></tr><tr><td>实例函数表达式</td><td>和原型方法一样</td></tr><tr><td>箭头函数</td><td>定义时绑定 <code>this</code>，永不改变</td></tr><tr><td>静态方法</td><td>类调用它，<code>this</code> 是类对象</td></tr></tbody></table><h2 id="JavaScript-数组"><a href="#JavaScript-数组" class="headerlink" title="JavaScript 数组"></a>JavaScript 数组</h2><h3 id="【数组常用方法】"><a href="#【数组常用方法】" class="headerlink" title="【数组常用方法】"></a>【数组常用方法】</h3><ul><li><p><strong>Array.from()</strong><br>将类数组或 iterable 转为真正的数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;abc&#x27;</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Array.isArray()</strong><br>判断是否为数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Array.of()</strong><br>使用参数创建新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>concat()</strong><br>合并数组，返回新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">concat</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>copyWithin(target, start, end?)</strong><br>把一部分复制到另一部分（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// [1, 3, 4, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>every(callback)</strong><br>所有元素都满足条件返回 <code>true</code>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>entries()</strong><br>返回键值对迭代器  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [i, val] <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, val); <span class="hljs-comment">// 0 &#x27;a&#x27;, 1 &#x27;b&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>fill(value, start?, end?)</strong><br>用固定值填充（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// [0, 0, 0]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>filter(callback)</strong><br>过滤符合条件的元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>); <span class="hljs-comment">// [2, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>find(callback)</strong><br>找到第一个满足条件的元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p><strong>findIndex(callback)</strong><br>找到第一个满足条件元素的索引  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>flat(depth?)</strong><br>扁平化数组（默认一层）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]].<span class="hljs-title function_">flat</span>(); <span class="hljs-comment">// [1, 2, [3]]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>flatMap(callback)</strong><br>类似 <code>map().flat()</code>，返回新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> [x, x * <span class="hljs-number">2</span>]); <span class="hljs-comment">// [1, 2, 2, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>forEach(callback)</strong><br>遍历元素（无返回值）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x))<br></code></pre></td></tr></table></figure></li><li><p><strong>includes(value)</strong><br>判断数组是否包含某个值  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>indexOf(value, from?)</strong><br>找元素的首次索引  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>join(separator?)</strong><br>将数组转换为字符串  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">// &quot;1-2-3&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>lastIndexOf(value)</strong><br>找元素最后一次出现的索引  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li><li><p><strong>length</strong><br>数组长度（也可设置）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// arr = [1, 2]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>map(callback)</strong><br>转换每个元素，返回新数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>); <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>pop()</strong><br>移除最后一个元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 3, arr = [1, 2]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>push(…items)</strong><br>末尾添加元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// arr = [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>reduce(callback, initialValue)</strong><br>从左到右聚合数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li><li><p><strong>reduceRight(callback, initialValue)</strong><br>从右到左聚合数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b); <span class="hljs-comment">// &quot;cba&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>reverse()</strong><br>反转数组顺序（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">reverse</span>(); <span class="hljs-comment">// [3, 2, 1]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>shift()</strong><br>删除开头元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 1, arr = [2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>slice(start, end?)</strong><br>截取片段，不修改原数组  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>some(callback)</strong><br>至少有一个满足条件  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x &gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>sort(compareFn?)</strong><br>排序数组（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>splice(start, deleteCount, …items)</strong><br>删除&#x2F;替换&#x2F;添加（修改原数组）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// arr = [1, 9, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>toString()</strong><br>转换为字符串  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>unshift(…items)</strong><br>开头添加元素  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// arr = [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><p>不修改原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">at()</span><br><span class="hljs-comment">    - 可以根据索引获取数组中的指定元素</span><br><span class="hljs-comment">    - at可以接收负索引作为参数</span><br><span class="hljs-comment">concat()</span><br><span class="hljs-comment">    - 用来连接两个或多个数组</span><br><span class="hljs-comment">    - 非破坏性方法，不会影响原数组，而是返回一个新的数组</span><br><span class="hljs-comment">indexOf()</span><br><span class="hljs-comment">    - 获取元素在数组中第一次出现的索引</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 要查询的元素</span><br><span class="hljs-comment">        2. 查询的其实位置</span><br><span class="hljs-comment">lastIndexOf()</span><br><span class="hljs-comment">    - 获取元素在数组中最后一次出现的位置</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">        找到了则返回元素的索引，</span><br><span class="hljs-comment">        没有找到返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">join()</span><br><span class="hljs-comment">    - 将一个数组中的元素连接为一个字符串</span><br><span class="hljs-comment">    - [&quot;孙悟空&quot;, &quot;猪八戒&quot;, &quot;沙和尚&quot;, &quot;唐僧&quot;, &quot;沙和尚&quot;] -&gt; &quot;孙悟空,猪八戒,沙和尚,唐僧,沙和尚&quot;</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        指定一个字符串作为连接符</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">slice()</span><br><span class="hljs-comment">    - 用来截取数组（非破坏性方法）     </span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 截取的起始位置（包括该位置）</span><br><span class="hljs-comment">        2. 截取的结束位置（不包括该位置）   </span><br><span class="hljs-comment">            - 第二个参数可以省略不写，如果省略则会一直截取到最后</span><br><span class="hljs-comment">            - 索引可以是负值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）</span><br><span class="hljs-comment">**/</span><br></code></pre></td></tr></table></figure><p>修改原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">push()</span><br><span class="hljs-comment">    - 向数组的末尾添加一个或多个元素，并返回新的长度</span><br><span class="hljs-comment">pop()</span><br><span class="hljs-comment">    - 删除并返回数组的最后一个元素</span><br><span class="hljs-comment">unshift()</span><br><span class="hljs-comment">    - 向数组的开头添加一个或多个元素，并返回新的长度</span><br><span class="hljs-comment">shift()</span><br><span class="hljs-comment">    - 删除并返回数组的第一个元素</span><br><span class="hljs-comment">splice()</span><br><span class="hljs-comment">    - 可以删除、插入、替换数组中的元素</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 删除的起始位置</span><br><span class="hljs-comment">        2. 删除的数量</span><br><span class="hljs-comment">        3. 要插入的元素</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - 返回值：</span><br><span class="hljs-comment">        - 返回被删除的元素</span><br><span class="hljs-comment">reverse()</span><br><span class="hljs-comment">    - 反转数组</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;唐僧&quot;</span>, <span class="hljs-string">&quot;白骨精&quot;</span>)<br><br><span class="hljs-comment">// console.log(arr)</span><br><br>result = arr.<span class="hljs-title function_">pop</span>()<br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&quot;牛魔王&quot;</span>)<br>arr.<span class="hljs-title function_">shift</span>()<br><br><span class="hljs-comment">// console.log(arr)</span><br><br>arr = [<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;沙和尚&quot;</span>, <span class="hljs-string">&quot;唐僧&quot;</span>]<br><span class="hljs-comment">// result = arr.splice(1, 3)</span><br><span class="hljs-comment">// result = arr.splice(1, 1, &quot;牛魔王&quot;, &quot;铁扇公主&quot;, &quot;红孩儿&quot;)</span><br>result = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;牛魔王&quot;</span>, <span class="hljs-string">&quot;铁扇公主&quot;</span>, <span class="hljs-string">&quot;红孩儿&quot;</span>)<br><br><span class="hljs-comment">// console.log(result)</span><br><span class="hljs-comment">// console.log(arr)</span><br><br>arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]<br>arr.<span class="hljs-title function_">reverse</span>()<br></code></pre></td></tr></table></figure><p>数组内置的高阶函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">sort()</span><br><span class="hljs-comment">    - sort用来对数组进行排序（会对改变原数组）</span><br><span class="hljs-comment">    - sort默认会将数组升序排列</span><br><span class="hljs-comment">        注意：sort默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序</span><br><span class="hljs-comment">            可能会得到一个不正确的结果</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        - 可以传递一个回调函数作为参数，通过回调函数来指定排序规则</span><br><span class="hljs-comment">            (a, b) =&gt; a - b 升序排列</span><br><span class="hljs-comment">            (a, b) =&gt; b - a 降序排列</span><br><span class="hljs-comment">forEach()</span><br><span class="hljs-comment">    - 用来遍历数组</span><br><span class="hljs-comment">    - 它需要一个回调函数作为参数，这个回调函数会被调用多次</span><br><span class="hljs-comment">        数组中有几个元素，回调函数就会调用几次</span><br><span class="hljs-comment">        每次调用，都会将数组中的数据作为参数传递</span><br><span class="hljs-comment">    - 回调函数中有三个参数：</span><br><span class="hljs-comment">        element 当前的元素</span><br><span class="hljs-comment">        index 当前元素的索引</span><br><span class="hljs-comment">        array 被遍历的数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">filter()</span><br><span class="hljs-comment">    - 将数组中符合条件的元素保存到一个新数组中返回</span><br><span class="hljs-comment">    - 需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中</span><br><span class="hljs-comment">    - 非破坏性方法，不会影响原数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">map()</span><br><span class="hljs-comment">    - 根据当前数组生成一个新数组</span><br><span class="hljs-comment">    - 需要一个回调函数作为参数，</span><br><span class="hljs-comment">        回调函数的返回值会成为新数组中的元素</span><br><span class="hljs-comment">    - 非破坏性方法不会影响原数组</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">reduce()</span><br><span class="hljs-comment">    - 可以用来将一个数组中的所有元素整合为一个值</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 回调函数，通过回调函数来指定合并的规则</span><br><span class="hljs-comment">        2. 可选参数，初始值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">// arr.sort()</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<br><br><span class="hljs-comment">// console.log(arr)</span><br><br>arr = [<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;沙和尚&quot;</span>, <span class="hljs-string">&quot;唐僧&quot;</span>]<br><br><span class="hljs-comment">// arr.forEach((element, index, array) =&gt; &#123;</span><br><span class="hljs-comment">//     console.log(array)</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// arr.forEach((element, index) =&gt; console.log(index, element))</span><br><br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br><span class="hljs-comment">// 获取数组中的所有偶数</span><br><span class="hljs-keyword">let</span> result = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> ele &gt; <span class="hljs-number">5</span>)<br><br>result = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> ele * <span class="hljs-number">2</span>)<br><br>arr = [<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;沙和尚&quot;</span>]<br><br>result = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> <span class="hljs-string">&quot;&lt;li&gt;&quot;</span> + ele + <span class="hljs-string">&quot;&lt;/li&gt;&quot;</span>)<br><br>arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br>result = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        1, 2</span><br><span class="hljs-comment">        3, 3</span><br><span class="hljs-comment">        6, 4</span><br><span class="hljs-comment">        10, 5</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// console.log(a, b)</span><br><br>    <span class="hljs-keyword">return</span> a * b<br>&#125;)<br><br><span class="hljs-comment">// result = arr.reduce((a, b) =&gt; a + b, 10)</span><br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure><h3 id="【浅复制与深复制】"><a href="#【浅复制与深复制】" class="headerlink" title="【浅复制与深复制】"></a>【浅复制与深复制】</h3><p><strong>浅拷贝（shallow copy）</strong>通常对对象的拷贝都是浅拷贝对象的浅层进行复制（只复制一层）如果对象中存储的数据是原始值，那么拷贝的深浅是不重要进行复制，不会复制对象中的属性（或元素）</p><p><strong>数组复制方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> &#125;];<br><br><span class="hljs-comment">// 1. 使用 slice</span><br><span class="hljs-keyword">const</span> copy1 = arr.<span class="hljs-title function_">slice</span>();<br><br><span class="hljs-comment">// 2. 使用 concat</span><br><span class="hljs-keyword">const</span> copy2 = [].<span class="hljs-title function_">concat</span>(arr);<br><br><span class="hljs-comment">// 3. 使用展开运算符</span><br><span class="hljs-keyword">const</span> copy3 = [...arr];<br><br><span class="hljs-comment">// 修改嵌套对象会影响原始数组</span><br>copy1[<span class="hljs-number">2</span>].<span class="hljs-property">a</span> = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">2</span>].<span class="hljs-property">a</span>); <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><p><strong>对象复制方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; &#125;;<br><br><span class="hljs-comment">// 1. Object.assign</span><br><span class="hljs-keyword">const</span> shallowCopy1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj);<br><br><span class="hljs-comment">// 2. 展开运算符</span><br><span class="hljs-keyword">const</span> shallowCopy2 = &#123; ...obj &#125;;<br><br><span class="hljs-comment">// 修改嵌套对象会影响原对象</span><br>shallowCopy1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">99</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 99</span><br></code></pre></td></tr></table></figure><blockquote><p>… (展开运算符):可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递，最常用的浅复制方法。</p></blockquote><p><strong>深拷贝（deep copy）</strong>深拷贝指不仅复制对象本身，还复制对象中的属性和元素，因为性能问题，通常情况不太使用深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> clone = <span class="hljs-title function_">structuredClone</span>(value);<br></code></pre></td></tr></table></figure><blockquote><p>注意浅复制和引用不同，浅复制第一层是独立的。</p></blockquote><h1 id="JavaScript进阶"><a href="#JavaScript进阶" class="headerlink" title="JavaScript进阶"></a>JavaScript进阶</h1><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值是一种从<strong>数组或对象中提取数据</strong>并快速赋值给变量的语法糖，它让代码更简洁、结构更清晰，尤其适合函数参数、数据提取等场景。</p><h3 id="【数组解构赋值】"><a href="#【数组解构赋值】" class="headerlink" title="【数组解构赋值】"></a>【数组解构赋值】</h3><p> 基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">const</span> [a, b, c] = arr;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, c); <span class="hljs-comment">// 10 20 30</span><br></code></pre></td></tr></table></figure><p> 可跳过元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [first, , third] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first, third); <span class="hljs-comment">// 1 3</span><br></code></pre></td></tr></table></figure><p> 设置默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a = <span class="hljs-number">100</span>, b = <span class="hljs-number">200</span>] = [<span class="hljs-number">10</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// 10 200</span><br></code></pre></td></tr></table></figure><p>与 <code>rest</code> 参数结合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [head, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(head); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest); <span class="hljs-comment">// [2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="【对象解构赋值】"><a href="#【对象解构赋值】" class="headerlink" title="【对象解构赋值】"></a>【对象解构赋值】</h3><p>基本语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> &#123; name, age &#125; = obj;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// Alice 25</span><br></code></pre></td></tr></table></figure><p>重命名变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">name</span>: userName &#125; = obj;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userName); <span class="hljs-comment">// Alice</span><br></code></pre></td></tr></table></figure><p>默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; gender = <span class="hljs-string">&#x27;unknown&#x27;</span> &#125; = obj;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gender); <span class="hljs-comment">// unknown</span><br></code></pre></td></tr></table></figure><h3 id="【函数参数解构】"><a href="#【函数参数解构】" class="headerlink" title="【函数参数解构】"></a>【函数参数解构】</h3><p>对象参数解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">&#123; name, age &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>. You are <span class="hljs-subst">$&#123;age&#125;</span>.`</span>);<br>&#125;<br><br><span class="hljs-title function_">greet</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;);<br><span class="hljs-comment">// 输出：Hello, Bob. You are 30.</span><br></code></pre></td></tr></table></figure><p>数组参数解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">[a, b]</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="【嵌套解构】"><a href="#【嵌套解构】" class="headerlink" title="【嵌套解构】"></a>【嵌套解构】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">profile</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">contacts</span>: &#123;<br>      <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;tom@example.com&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> &#123;<br>  <span class="hljs-attr">profile</span>: &#123;<br>    <span class="hljs-attr">contacts</span>: &#123; email &#125;<br>  &#125;<br>&#125; = user;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(email); <span class="hljs-comment">// tom@example.com</span><br></code></pre></td></tr></table></figure><h3 id="【常见用途】"><a href="#【常见用途】" class="headerlink" title="【常见用途】"></a>【常见用途】</h3><p>快速交换变量值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>[a, b] = [b, a];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// 2 1</span><br></code></pre></td></tr></table></figure><p>快速提取 API 返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; data, code, message &#125; = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/info&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在 Vue&#x2F;React 中提取 props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;count&#x27;</span>]);<br><span class="hljs-keyword">const</span> &#123; title, count &#125; = props;<br></code></pre></td></tr></table></figure><h2 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h2><p><strong>对象序列化（Serialization）就是将 JavaScript 中的对象转换成可以存储或传输</strong>的格式（通常是字符串），最常见的是 <strong>JSON 字符串</strong>。</p><h3 id="【序列和反序列化】"><a href="#【序列和反序列化】" class="headerlink" title="【序列和反序列化】"></a>【序列和反序列化】</h3><p>常用的序列化方式：<code>JSON.stringify</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(value, replacer, space)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>value</code></td><td>要序列化的对象</td></tr><tr><td><code>replacer</code></td><td>可选，<strong>函数或数组</strong>，用于定制序列化过程</td></tr><tr><td><code>space</code></td><td>可选，格式化缩进用的空格数（调试时常用）</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonStr); <span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p> 反序列化：<code>JSON.parse</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;&#x27;</span>;<br><span class="hljs-keyword">const</span> parsed = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsed.<span class="hljs-property">name</span>); <span class="hljs-comment">// Alice</span><br></code></pre></td></tr></table></figure><p><code>JSON.stringify()</code> 的一些特点和陷阱</p><p><font color="#409eff"> 支持：</font></p><ul><li>数字、字符串、布尔值、数组、对象</li><li><code>null</code></li></ul><p><font color="#409eff">不支持或被忽略：</font></p><table><thead><tr><th>数据类型</th><th>序列化结果</th></tr></thead><tbody><tr><td><code>undefined</code></td><td>被忽略</td></tr><tr><td><code>function</code></td><td>被忽略</td></tr><tr><td><code>symbol</code></td><td>被忽略</td></tr><tr><td>循环引用</td><td>会报错</td></tr><tr><td>BigInt</td><td>会报错（<code>TypeError</code>）</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">c</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;x&quot;</span>)<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)); <span class="hljs-comment">// &#123;&quot;a&quot;:1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="【序列化进阶用法】"><a href="#【序列化进阶用法】" class="headerlink" title="【序列化进阶用法】"></a>【序列化进阶用法】</h3><p>1.自定义序列化（toJSON 方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-title function_">toJSON</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">userName</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user)); <span class="hljs-comment">// &#123;&quot;userName&quot;:&quot;Tom&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>2.使用 replacer（过滤或转换字段）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj, [<span class="hljs-string">&#x27;name&#x27;</span>])); <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;Tom&quot;&#125;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span><br>  <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> ? <span class="hljs-literal">undefined</span> : value<br>)); <span class="hljs-comment">// &#123;&quot;name&quot;:&quot;Tom&quot;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="【常见用途】-1"><a href="#【常见用途】-1" class="headerlink" title="【常见用途】"></a>【常见用途】</h3><blockquote><p>对象转换为字符串后，可以将字符串在不同的语言之间进行传递</p></blockquote><table><thead><tr><th>应用场景</th><th>示例</th></tr></thead><tbody><tr><td>浏览器存储</td><td><code>localStorage.setItem(&#39;user&#39;, JSON.stringify(obj))</code></td></tr><tr><td>数据传输</td><td>axios、fetch POST 时发送 JSON 字符串</td></tr><tr><td>深拷贝（有局限）</td><td><code>const newObj = JSON.parse(JSON.stringify(obj))</code></td></tr><tr><td>日志输出</td><td><code>console.log(JSON.stringify(error))</code></td></tr></tbody></table><h3 id="【手动编写JSON字符串】"><a href="#【手动编写JSON字符串】" class="headerlink" title="【手动编写JSON字符串】"></a>【手动编写JSON字符串】</h3><p>也可以手动的编写JSON字符串，在很多程序的配置文件就是使用JSON编写的</p><p>编写JSON的注意事项：</p><ol><li>JSON字符串有两种类型：JSON对象 <code>&#123;&#125;</code> &#x2F; JSON数组 <code>[]</code></li><li>JSON字符串的属性名必须使用双引号引起来</li><li>JSON中可以使用的属性值（元素）<ul><li>数字（Number）</li><li>字符串（String） 必须使用双引号</li><li>布尔值（Boolean）</li><li>空值（Null）</li><li>对象（Object {}）</li><li>数组（Array []）</li></ul></li><li>JSON的格式和JS对象的格式基本上一致的，<br>注意：JSON字符串如果属性是最后一个，则不要再加<code>,</code></li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><p><code>Map</code> 是 ES6 引入的一种新的数据结构，用于存储<strong>键值对</strong>。</p><blockquote><p>与普通对象不同的是，<code>Map</code> 的键可以是<strong>任何类型的值</strong>（包括对象、函数等）。</p></blockquote><h3 id="【Map与Object的区别】"><a href="#【Map与Object的区别】" class="headerlink" title="【Map与Object的区别】"></a>【<code>Map</code>与<code>Object</code>的区别】</h3><table><thead><tr><th>特性</th><th><code>Map</code></th><th><code>Object</code></th></tr></thead><tbody><tr><td>键的类型</td><td>任意类型（对象、函数等）</td><td>只能是字符串或 Symbol。其他类型的属性会自动转换字符串，</td></tr><tr><td>键的顺序</td><td><strong>有序</strong>（按插入顺序）</td><td>无序（某些实现可能有顺序）</td></tr><tr><td>遍历</td><td><code>map.forEach()</code>、<code>for...of</code>、<code>entries()</code></td><td><code>for...in</code>、<code>Object.keys()</code> 等</td></tr><tr><td>默认属性干扰</td><td>无（原型是 <code>null</code>）</td><td>有，继承自 <code>Object.prototype</code></td></tr><tr><td>性能</td><td>更适合频繁增删查操作</td><td>较适合静态结构的对象数据</td></tr></tbody></table><h3 id="【Map常见用法】"><a href="#【Map常见用法】" class="headerlink" title="【Map常见用法】"></a>【<code>Map</code>常见用法】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>set(key, value)</code></td><td>设置键值对</td></tr><tr><td><code>get(key)</code></td><td>获取指定键的值</td></tr><tr><td><code>has(key)</code></td><td>判断键是否存在</td></tr><tr><td><code>delete(key)</code></td><td>删除指定键</td></tr><tr><td><code>clear()</code></td><td>清空 Map</td></tr><tr><td><code>size</code></td><td>获取键值对数量</td></tr><tr><td><code>keys()</code></td><td>返回所有键的迭代器</td></tr><tr><td><code>values()</code></td><td>返回所有值的迭代器</td></tr><tr><td><code>entries()</code></td><td>返回所有键值对的迭代器</td></tr><tr><td><code>forEach(cb)</code></td><td>遍历每个键值对</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-comment">// 设置键值对</span><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Alice&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-number">42</span>, <span class="hljs-string">&#x27;numberKey&#x27;</span>);<br>map.<span class="hljs-title function_">set</span>(&#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;, <span class="hljs-string">&#x27;objectKey&#x27;</span>);<br><br><span class="hljs-comment">// 获取值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// Alice</span><br><br><span class="hljs-comment">// 检查是否存在键</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除键</span><br>map.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><br><span class="hljs-comment">// 清空所有键值对</span><br>map.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>遍历方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>]<br>]);<br><br><span class="hljs-comment">// for...of 遍历键值对</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;<br><br><span class="hljs-comment">// 遍历 keys</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">keys</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;key:&#x27;</span>, key);<br>&#125;<br><br><span class="hljs-comment">// 遍历 values</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;value:&#x27;</span>, value);<br>&#125;<br><br><span class="hljs-comment">// forEach 遍历</span><br>map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="【Map转换成数组】"><a href="#【Map转换成数组】" class="headerlink" title="【Map转换成数组】"></a>【<code>Map</code>转换成数组】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(map) <span class="hljs-comment">// [[&quot;name&quot;,&quot;孙悟空&quot;],[&quot;age&quot;,18]]</span><br><span class="hljs-keyword">const</span> arr = [...map]<br><br><span class="hljs-comment">// 数组转成Map，直接创建Map</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>],<br>  [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>]<br>]);<br></code></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h2><p><code>Set</code> 是一个<strong>无重复值的集合</strong>。它类似数组，但每个值只能出现一次，且值的顺序按插入顺序保存。</p><h3 id="【Set和Array的区别】"><a href="#【Set和Array的区别】" class="headerlink" title="【Set和Array的区别】"></a>【<code>Set</code>和<code>Array</code>的区别】</h3><table><thead><tr><th>特性</th><th><code>Set</code></th><th><code>Array</code></th></tr></thead><tbody><tr><td>是否允许重复值</td><td>❌ 不允许</td><td>✅ 允许</td></tr><tr><td>是否有序</td><td>✅ 插入顺序保留</td><td>✅ 有序</td></tr><tr><td>索引访问</td><td>❌ 不支持下标</td><td>✅ 支持</td></tr><tr><td>是否可迭代</td><td>✅</td><td>✅</td></tr></tbody></table><h3 id="【Set常见用法】"><a href="#【Set常见用法】" class="headerlink" title="【Set常见用法】"></a>【<code>Set</code>常见用法】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>add(value)</code></td><td>添加元素</td></tr><tr><td><code>delete(value)</code></td><td>删除元素</td></tr><tr><td><code>has(value)</code></td><td>是否存在</td></tr><tr><td><code>clear()</code></td><td>清空集合</td></tr><tr><td><code>size</code></td><td>元素数量</td></tr><tr><td><code>forEach(cb)</code></td><td>遍历集合</td></tr><tr><td><code>[...set]</code></td><td>转为数组</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><br><span class="hljs-comment">// 添加元素</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>set.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 重复的不会添加</span><br>set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set); <span class="hljs-comment">// Set(3) &#123;1, 2, &#x27;hello&#x27;&#125;</span><br><br><span class="hljs-comment">// 判断是否存在</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除元素</span><br>set.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(set.<span class="hljs-property">size</span>); <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 清空集合</span><br>set.<span class="hljs-title function_">clear</span>();<br><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br><br><span class="hljs-comment">// for...of</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> set) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><br><span class="hljs-comment">// forEach</span><br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item));<br><br><span class="hljs-comment">// 转成数组</span><br><span class="hljs-keyword">const</span> arr = [...set]; <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><br></code></pre></td></tr></table></figure><h3 id="【常见用途】-2"><a href="#【常见用途】-2" class="headerlink" title="【常见用途】"></a>【常见用途】</h3><ol><li>数组去重</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> uniqueArr = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(uniqueArr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>求交集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br><span class="hljs-keyword">const</span> intersection = [...set1].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> set2.<span class="hljs-title function_">has</span>(x));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(intersection); <span class="hljs-comment">// [2, 3]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>求差集</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> diff = [...set1].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !set2.<span class="hljs-title function_">has</span>(x));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(diff); <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a><code>Math</code></h2><p>JavaScript 中的 <code>Math</code> 是一个内置对象，提供了各种<strong>数学运算相关的常用方法和常量</strong>，可以帮助我们进行取整、取绝对值、三角函数、指数、对数等计算。</p><h3 id="【取整相关】"><a href="#【取整相关】" class="headerlink" title="【取整相关】"></a>【取整相关】</h3><table><thead><tr><th>方法</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Math.floor()</code></td><td>向下取整</td><td><code>Math.floor(4.7)</code> → <code>4</code></td></tr><tr><td><code>Math.ceil()</code></td><td>向上取整</td><td><code>Math.ceil(4.1)</code> → <code>5</code></td></tr><tr><td><code>Math.round()</code></td><td>四舍五入</td><td><code>Math.round(4.5)</code> → <code>5</code></td></tr><tr><td><code>Math.trunc()</code></td><td>去除小数部分（ES6）</td><td><code>Math.trunc(4.9)</code> → <code>4</code></td></tr></tbody></table><h3 id="【数值处理】"><a href="#【数值处理】" class="headerlink" title="【数值处理】"></a>【数值处理】</h3><table><thead><tr><th>方法</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Math.abs(x)</code></td><td>绝对值</td><td><code>Math.abs(-3)</code> → <code>3</code></td></tr><tr><td><code>Math.max(...args)</code></td><td>最大值</td><td><code>Math.max(1, 5, 3)</code> → <code>5</code></td></tr><tr><td><code>Math.min(...args)</code></td><td>最小值</td><td><code>Math.min(1, 5, 3)</code> → <code>1</code></td></tr><tr><td><code>Math.pow(x, y)</code></td><td>幂运算</td><td><code>Math.pow(2, 3)</code> → <code>8</code></td></tr><tr><td><code>Math.sqrt(x)</code></td><td>平方根</td><td><code>Math.sqrt(9)</code> → <code>3</code></td></tr><tr><td><code>Math.cbrt(x)</code></td><td>立方根</td><td><code>Math.cbrt(8)</code> → <code>2</code></td></tr></tbody></table><h3 id="【随机数】"><a href="#【随机数】" class="headerlink" title="【随机数】"></a>【随机数】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(); <span class="hljs-comment">// 返回 0 ~ 1 之间的随机小数（不包括1）</span><br></code></pre></td></tr></table></figure><p>示例：生成 1~10 的随机整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> n = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="【三角函数】"><a href="#【三角函数】" class="headerlink" title="【三角函数】"></a>【三角函数】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Math.sin(x)</code></td><td>正弦（x 是弧度）</td></tr><tr><td><code>Math.cos(x)</code></td><td>余弦</td></tr><tr><td><code>Math.tan(x)</code></td><td>正切</td></tr><tr><td><code>Math.asin(x)</code></td><td>反正弦</td></tr><tr><td><code>Math.acos(x)</code></td><td>反余弦</td></tr><tr><td><code>Math.atan(x)</code></td><td>反正切</td></tr></tbody></table><h3 id="【对数与指数】"><a href="#【对数与指数】" class="headerlink" title="【对数与指数】"></a>【对数与指数】</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Math.log(x)</code></td><td>自然对数（以 e 为底）</td></tr><tr><td><code>Math.log10(x)</code></td><td>以 10 为底的对数（ES6）</td></tr><tr><td><code>Math.exp(x)</code></td><td>e 的 x 次幂</td></tr></tbody></table><h3 id="【常用-Math-常量】"><a href="#【常用-Math-常量】" class="headerlink" title="【常用 Math 常量】"></a>【常用 Math 常量】</h3><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>Math.PI</code></td><td>3.14159…</td><td>圆周率</td></tr><tr><td><code>Math.E</code></td><td>2.71828…</td><td>自然对数底数</td></tr><tr><td><code>Math.SQRT2</code></td><td>√2</td><td></td></tr><tr><td><code>Math.SQRT1_2</code></td><td>√(1&#x2F;2)</td><td></td></tr><tr><td><code>Math.LN2</code></td><td>ln(2)</td><td></td></tr><tr><td><code>Math.LN10</code></td><td>ln(10)</td><td></td></tr></tbody></table><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a><code>Date</code></h2><blockquote><p><code>Date</code> 是 JavaScript 中处理<strong>时间与日期的核心类</strong>，可以创建、格式化、比较和操作时间值。</p></blockquote><h3 id="【创建-Date-实例的方式】"><a href="#【创建-Date-实例的方式】" class="headerlink" title="【创建 Date 实例的方式】"></a>【创建 <code>Date</code> 实例的方式】</h3><p>获取当前时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now); <span class="hljs-comment">// 当前本地时间</span><br></code></pre></td></tr></table></figure><p>通过时间字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2025-08-04T10:00:00&quot;</span>);<br><span class="hljs-keyword">const</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;08/04/2025 10:00:00&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过参数（年, 月, 日, 时, 分, 秒, 毫秒）</p><blockquote><p>注意：月从 0 开始（0 &#x3D; 一月）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2025</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 2025年8月4日10:30</span><br></code></pre></td></tr></table></figure><p>通过时间戳（1970 年以来的毫秒数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1691136000000</span>); <span class="hljs-comment">// 指定时间戳</span><br></code></pre></td></tr></table></figure><h3 id="【常用方法】"><a href="#【常用方法】" class="headerlink" title="【常用方法】"></a>【常用方法】</h3><p>获取时间信息</p><table><thead><tr><th>方法</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>getFullYear()</code></td><td>获取年</td><td><code>date.getFullYear()</code></td></tr><tr><td><code>getMonth()</code></td><td>获取月（0-11）</td><td><code>date.getMonth()</code></td></tr><tr><td><code>getDate()</code></td><td>获取日（1-31）</td><td><code>date.getDate()</code></td></tr><tr><td><code>getDay()</code></td><td>获取星期几（0 &#x3D; 周日）</td><td><code>date.getDay()</code></td></tr><tr><td><code>getHours()</code></td><td>获取小时（0-23）</td><td><code>date.getHours()</code></td></tr><tr><td><code>getMinutes()</code></td><td>获取分钟</td><td><code>date.getMinutes()</code></td></tr><tr><td><code>getSeconds()</code></td><td>获取秒</td><td><code>date.getSeconds()</code></td></tr><tr><td><code>getMilliseconds()</code></td><td>毫秒</td><td><code>date.getMilliseconds()</code></td></tr><tr><td><code>getTime()</code></td><td>时间戳（1970 至今的毫秒数）</td><td><code>date.getTime()</code></td></tr></tbody></table><p>设置时间信息</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>setFullYear(y)</code></td><td>设置年份</td></tr><tr><td><code>setMonth(m)</code></td><td>设置月份（0-11）</td></tr><tr><td><code>setDate(d)</code></td><td>设置日期（1-31）</td></tr><tr><td><code>setHours(h)</code></td><td>设置小时（0-23）</td></tr><tr><td><code>setMinutes(min)</code></td><td>设置分钟</td></tr><tr><td><code>setSeconds(s)</code></td><td>设置秒</td></tr><tr><td><code>setTime(ms)</code></td><td>设置时间戳</td></tr></tbody></table><p><code>Date.now()</code> 获取当前的时间戳</p><h3 id="【格式化输出】"><a href="#【格式化输出】" class="headerlink" title="【格式化输出】"></a>【格式化输出】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2025</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toString</span>());        <span class="hljs-comment">// 本地完整时间字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toDateString</span>());    <span class="hljs-comment">// 仅日期部分</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toTimeString</span>());    <span class="hljs-comment">// 仅时间部分</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toISOString</span>());     <span class="hljs-comment">// ISO 标准时间（常用于后端传参）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toLocaleString</span>());  <span class="hljs-comment">// 本地格式日期+时间字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toLocaleDateString</span>());  <span class="hljs-comment">// 本地格式日期字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(date.<span class="hljs-title function_">toLocaleTimeString</span>());  <span class="hljs-comment">// 本地格式时间字符串</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">toLocaleString()</span><br><span class="hljs-comment">    - 可以将一个日期转换为本地时间格式的字符串</span><br><span class="hljs-comment">    - 参数：</span><br><span class="hljs-comment">        1. 描述语言和国家信息的字符串</span><br><span class="hljs-comment">            zh-CN 中文中国</span><br><span class="hljs-comment">            zh-HK 中文香港</span><br><span class="hljs-comment">            en-US 英文美国</span><br><span class="hljs-comment">        2. 需要一个对象作为参数，在对象中可以通过对象的属性来对日期的格式进行配置</span><br><span class="hljs-comment">                dateStyle 日期的风格</span><br><span class="hljs-comment">                timeStyle 时间的风格</span><br><span class="hljs-comment">                    full</span><br><span class="hljs-comment">                    long</span><br><span class="hljs-comment">                    medium</span><br><span class="hljs-comment">                    short</span><br><span class="hljs-comment">                hour12 是否采用12小时值</span><br><span class="hljs-comment">                    true</span><br><span class="hljs-comment">                    false</span><br><span class="hljs-comment">                weekday 星期的显示方式</span><br><span class="hljs-comment">                    long</span><br><span class="hljs-comment">                    short</span><br><span class="hljs-comment">                    narrow</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                year</span><br><span class="hljs-comment">                    numeric</span><br><span class="hljs-comment">                    2-digit </span><br><span class="hljs-comment">*/</span><br>result = d.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&quot;zh-CN&quot;</span>, &#123;<br>    <span class="hljs-attr">year</span>: <span class="hljs-string">&quot;numeric&quot;</span>,<br>    <span class="hljs-attr">month</span>: <span class="hljs-string">&quot;long&quot;</span>,<br>    <span class="hljs-attr">day</span>: <span class="hljs-string">&quot;2-digit&quot;</span>,<br>    <span class="hljs-attr">weekday</span>: <span class="hljs-string">&quot;short&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>JavaScript 的<strong>包装类</strong>是对<strong>基本数据类型</strong>（如 <code>string</code>、<code>number</code>、<code>boolean</code>）的<strong>对象封装</strong>，让它们可以像对象一样调用方法。</p><h3 id="【包装类定义】"><a href="#【包装类定义】" class="headerlink" title="【包装类定义】"></a>【包装类定义】</h3><p>包装类包括：</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>string</code></td><td><code>String</code></td></tr><tr><td><code>number</code></td><td><code>Number</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table><p>还有一些不太常见的包装类：</p><table><thead><tr><th>类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>symbol</code></td><td><code>Symbol</code>（本身是对象）</td></tr><tr><td><code>bigint</code></td><td><code>BigInt</code>（本身是对象）</td></tr><tr><td><code>null/undefined</code></td><td>没有包装类</td></tr></tbody></table><p>为什么需要包装类？</p><p>虽然像 <code>&quot;abc&quot;</code> 是字符串字面量，但我们可以写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;abc&quot;</span>.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// &quot;ABC&quot;</span><br></code></pre></td></tr></table></figure><p>这是因为 JavaScript 在背后自动进行了<strong>临时装箱（装入包装类对象）</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实际发生的过程（等效于）：</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>).<span class="hljs-title function_">toUpperCase</span>();<br></code></pre></td></tr></table></figure><blockquote><p><strong>执行完后，临时对象立即销毁</strong>。</p></blockquote><p>手动使用包装类，虽然我们通常<strong>不需要手动 new 包装类对象</strong>，但你可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">const</span> numObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>);<br><span class="hljs-keyword">const</span> boolObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> strObj); <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> numObj); <span class="hljs-comment">// object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> boolObj); <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：这会变成真正的对象，和原始类型不再相等：因此包装类通常不要手动创建，而是解释器隐式使用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;abc&quot;</span>);         <span class="hljs-comment">// string</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>());  <span class="hljs-comment">// object</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;abc&quot;</span> === <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// ❌ false</span><br></code></pre></td></tr></table></figure><h3 id="【String-包装类】"><a href="#【String-包装类】" class="headerlink" title="【String 包装类】"></a>【<code>String</code> 包装类】</h3><p>字符串其本质就是一个字符数组，<font color="#409eff">数组很多方法字符串都可以通用的</font>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">//&quot;hello&quot; --&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span><br>s.<span class="hljs-title function_">toUpperCase</span>();       <span class="hljs-comment">// &quot;HELLO&quot;</span><br>s.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;he&quot;</span>);      <span class="hljs-comment">// true</span><br>s.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">1</span>);           <span class="hljs-comment">// &quot;e&quot;</span><br>s.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);   <span class="hljs-comment">// &quot;hexlo&quot;</span><br>s.<span class="hljs-property">length</span>;              <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><ul><li><p><strong><code>charAt(index)</code></strong><br>获取指定索引处的字符。<br><code>&quot;hello&quot;.charAt(1)</code> → <code>&quot;e&quot;</code></p></li><li><p><strong><code>charCodeAt(index)</code></strong><br>获取指定字符的 UTF-16 编码（十进制）。<br><code>&quot;ABC&quot;.charCodeAt(0)</code> → <code>65</code></p></li><li><p><strong><code>concat(str1, str2, ...)</code></strong><br>拼接多个字符串（等效于 <code>+</code>）。<br><code>&quot;Hello&quot;.concat(&quot; &quot;, &quot;World&quot;)</code> → <code>&quot;Hello World&quot;</code></p></li><li><p><strong><code>endsWith(searchString[, length])</code></strong><br>判断字符串是否以某个子串结尾。<br><code>&quot;test.js&quot;.endsWith(&quot;.js&quot;)</code> → <code>true</code></p></li><li><p><strong><code>includes(searchString[, position])</code></strong><br>判断是否包含某个子串。<br><code>&quot;hello world&quot;.includes(&quot;world&quot;)</code> → <code>true</code></p></li><li><p><strong><code>indexOf(searchValue[, fromIndex])</code></strong><br>返回子串首次出现的位置，找不到返回 <code>-1</code>。<br><code>&quot;banana&quot;.indexOf(&quot;a&quot;)</code> → <code>1</code></p></li><li><p><strong><code>lastIndexOf(searchValue[, fromIndex])</code></strong><br>返回子串最后一次出现的位置。<br><code>&quot;banana&quot;.lastIndexOf(&quot;a&quot;)</code> → <code>5</code></p></li><li><p><strong><code>match(regex)</code></strong><br>根据正则表达式匹配内容，返回数组或 <code>null</code>。<br><code>&quot;abc123&quot;.match(/\d+/)</code> → <code>[&quot;123&quot;]</code></p></li><li><p><strong><code>matchAll(regex)</code></strong><br>返回所有正则匹配（需加 <code>g</code>），返回迭代器。<br><code>[...(&quot;a1b2&quot;.matchAll(/\d/g))]</code> → <code>[[&quot;1&quot;], [&quot;2&quot;]]</code></p></li><li><p><strong><code>normalize([form])</code></strong><br>Unicode 正规化（用于特殊字符对比）。<br><code>&quot;é&quot;.normalize(&quot;NFD&quot;)</code></p></li><li><p><strong><code>padEnd(targetLength[, padString])</code></strong><br>在字符串末尾补全到指定长度。<br><code>&quot;5&quot;.padEnd(3, &quot;0&quot;)</code> → <code>&quot;500&quot;</code></p></li><li><p><strong><code>padStart(targetLength[, padString])</code></strong><br>在字符串开头补全到指定长度。<br><code>&quot;5&quot;.padStart(3, &quot;0&quot;)</code> → <code>&quot;005&quot;</code></p></li><li><p><strong><code>repeat(count)</code></strong><br>返回重复多次的字符串。<br><code>&quot;ha&quot;.repeat(3)</code> → <code>&quot;hahaha&quot;</code></p></li><li><p><strong><code>replace(searchValue, replaceValue)</code></strong><br>替换匹配的子串。<br><code>&quot;foo123&quot;.replace(/\d+/, &quot;***&quot;)</code> → <code>&quot;foo***&quot;</code></p></li><li><p><strong><code>replaceAll(searchValue, replaceValue)</code></strong><br>替换<strong>所有</strong>匹配项（ES2021）。<br><code>&quot;a-b-c&quot;.replaceAll(&quot;-&quot;, &quot;_&quot;)</code> → <code>&quot;a_b_c&quot;</code></p></li><li><p><strong><code>search(regex)</code></strong><br>返回正则首次匹配的索引。<br><code>&quot;abc123&quot;.search(/\d/)</code> → <code>3</code></p></li><li><p><strong><code>slice(start[, end])</code></strong><br>截取字符串的一部分（不修改原字符串）。<br><code>&quot;abcdef&quot;.slice(1, 4)</code> → <code>&quot;bcd&quot;</code></p></li><li><p><strong><code>split(separator[, limit])</code></strong><br>按分隔符拆分为数组。<br><code>&quot;a,b,c&quot;.split(&quot;,&quot;)</code> → <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></p></li><li><p><strong><code>startsWith(searchString[, position])</code></strong><br>判断字符串是否以指定子串开始。<br><code>&quot;hello&quot;.startsWith(&quot;he&quot;)</code> → <code>true</code></p></li><li><p><strong><code>substring(start[, end])</code></strong><br>提取从 <code>start</code> 到 <code>end</code> 之间的子串。<br><code>&quot;abcdef&quot;.substring(2, 5)</code> → <code>&quot;cde&quot;</code></p></li><li><p><strong><code>toLowerCase()</code></strong><br>转换为小写字母。<br><code>&quot;HeLLo&quot;.toLowerCase()</code> → <code>&quot;hello&quot;</code></p></li><li><p><strong><code>toUpperCase()</code></strong><br>转换为大写字母。<br><code>&quot;HeLLo&quot;.toUpperCase()</code> → <code>&quot;HELLO&quot;</code></p></li><li><p><strong><code>trim()</code></strong><br>去除首尾空白字符。<br><code>&quot;  hello  &quot;.trim()</code> → <code>&quot;hello&quot;</code></p></li><li><p><strong><code>trimStart()</code> &#x2F; <code>trimLeft()</code></strong><br>去除开头空白。<br><code>&quot;  hi&quot;.trimStart()</code> → <code>&quot;hi&quot;</code></p></li><li><p><strong><code>trimEnd()</code> &#x2F; <code>trimRight()</code></strong><br>去除结尾空白。<br><code>&quot;hi  &quot;.trimEnd()</code> → <code>&quot;hi&quot;</code></p></li><li><p><strong><code>valueOf()</code></strong><br>返回原始字符串值（用于隐式类型转换）。<br><code>&quot;abc&quot;.valueOf()</code> → <code>&quot;abc&quot;</code></p></li></ul><h3 id="【Number-包装类】"><a href="#【Number-包装类】" class="headerlink" title="【Number 包装类】"></a>【<code>Number</code> 包装类】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> n = <span class="hljs-number">123.456</span>;<br>n.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);          <span class="hljs-comment">// &quot;123.46&quot;</span><br>n.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);         <span class="hljs-comment">// &quot;1111011&quot;（转为二进制）</span><br></code></pre></td></tr></table></figure><h3 id="【Boolean-包装类】"><a href="#【Boolean-包装类】" class="headerlink" title="【Boolean 包装类】"></a>【<code>Boolean</code> 包装类】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>);            <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&quot;hello&quot;</span>);      <span class="hljs-comment">// true</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 是对象，始终为 truthy！</span><br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（Regular Expression）是一种用来描述字符串<strong>匹配规则</strong>的工具，本质是<strong>匹配模式</strong>，可用来检索和替换文本。也是一个对象。格式是<code>/正则/匹配模式</code></p><h3 id="【创建方式】"><a href="#【创建方式】" class="headerlink" title="【创建方式】"></a>【创建方式】</h3><p>方式 1：使用字面量（常用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/abc\d/i</span>;<br></code></pre></td></tr></table></figure><p>方式 2：使用 <code>RegExp</code> 构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;abc\\d&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="【匹配规则】"><a href="#【匹配规则】" class="headerlink" title="【匹配规则】"></a>【匹配规则】</h3><table><thead><tr><th>字符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>.</code></td><td>任意单个字符（除换行）</td><td><code>/a.b/</code> 匹配 <code>a+b</code>, <code>a-b</code></td></tr><tr><td><code>\d</code></td><td>一个数字（0-9）</td><td><code>/\d/</code> 匹配 <code>&quot;3&quot;</code></td></tr><tr><td><code>\w</code></td><td>单词字符（字母、数字、下划线）</td><td><code>/\w/</code> 匹配 <code>&quot;a&quot;</code>, <code>&quot;5&quot;</code></td></tr><tr><td><code>\s</code></td><td>空白字符（空格、换行、制表）</td><td><code>/\s/</code></td></tr><tr><td><code>\D</code></td><td>非数字</td><td><code>/\D/</code></td></tr><tr><td><code>\W</code></td><td>非单词字符</td><td><code>/\W/</code></td></tr><tr><td><code>\S</code></td><td>非空白字符</td><td><code>/\S/</code></td></tr></tbody></table><h3 id="【量词（重复次数）】"><a href="#【量词（重复次数）】" class="headerlink" title="【量词（重复次数）】"></a>【量词（重复次数）】</h3><table><thead><tr><th>量词</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>0 次或多次</td><td><code>/a*/</code> 匹配 <code>&quot;&quot;</code>, <code>&quot;a&quot;</code>, <code>&quot;aaa&quot;</code></td></tr><tr><td><code>+</code></td><td>1 次或多次</td><td><code>/a+/</code> 匹配 <code>&quot;a&quot;</code>, <code>&quot;aaa&quot;</code></td></tr><tr><td><code>?</code></td><td>0 次或 1 次</td><td><code>/a?/</code> 匹配 <code>&quot;&quot;</code>, <code>&quot;a&quot;</code></td></tr><tr><td><code>&#123;n&#125;</code></td><td>恰好 n 次</td><td><code>/a&#123;3&#125;/</code> 匹配 <code>&quot;aaa&quot;</code></td></tr><tr><td><code>&#123;n,&#125;</code></td><td>至少 n 次</td><td><code>/a&#123;2,&#125;/</code> 匹配 <code>&quot;aa&quot;</code>, <code>&quot;aaaa&quot;</code></td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>n 到 m 次</td><td><code>/a&#123;2,4&#125;/</code> 匹配 <code>&quot;aa&quot;</code>, <code>&quot;aaa&quot;</code></td></tr></tbody></table><h3 id="【字符集合与分组】"><a href="#【字符集合与分组】" class="headerlink" title="【字符集合与分组】"></a>【字符集合与分组】</h3><table><thead><tr><th>语法</th><th>含义</th></tr></thead><tbody><tr><td><code>[abc]</code></td><td>匹配 a 或 b 或 c 中的任意一个</td></tr><tr><td><code>[^abc]</code></td><td>除了 a&#x2F;b&#x2F;c 以外的任意字符</td></tr><tr><td><code>(abc)</code></td><td>分组，整体匹配</td></tr><tr><td>&#96;a</td><td>b&#96;</td></tr><tr><td><code>^</code></td><td>匹配开头</td></tr><tr><td><code>$</code></td><td>匹配结尾</td></tr></tbody></table><ul><li>[a-z] 任意的小写字母</li><li>[A-Z] 任意的大写字母</li><li>[a-zA-Z] 任意的字母</li><li>[0-9]任意数字</li></ul><h3 id="【常用修饰符（flags）】"><a href="#【常用修饰符（flags）】" class="headerlink" title="【常用修饰符（flags）】"></a>【常用修饰符（flags）】</h3><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td><code>i</code></td><td>忽略大小写</td></tr><tr><td><code>g</code></td><td>全局匹配（多次匹配）</td></tr><tr><td><code>m</code></td><td>多行匹配（影响 <code>^</code> 和 <code>$</code>）</td></tr></tbody></table><h3 id="【常用方法】-1"><a href="#【常用方法】-1" class="headerlink" title="【常用方法】"></a>【常用方法】</h3><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><code>test(str)</code></td><td><code>Boolean</code></td><td>是否匹配字符串</td></tr><tr><td><code>exec(str)</code></td><td><code>Match对象或null</code></td><td>返回<strong>第一个匹配内容及位置</strong></td></tr></tbody></table><p>示例：<code>test()</code> 用于判断字符串是否匹配正则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;abc123&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(regex.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;abc&quot;</span>));    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>示例：<code>exec()</code> 用于提取详细匹配信息，每调一次匹配一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-keyword">const</span> result = regex.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&quot;abc123def&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);     <br><span class="hljs-comment">// [&quot;123&quot;, index: 3, input: &quot;abc123def&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><p>JS 字符串与正则结合使用最常见的方式，用于查找、替换、提取等：</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td><code>match(regex)</code></td><td>匹配结果数组或 null</td><td>查找匹配内容</td></tr><tr><td><code>matchAll(regex)</code></td><td>可迭代对象</td><td>匹配多个（需 <code>g</code>）</td></tr><tr><td><code>search(regex)</code></td><td>索引或 -1</td><td>查找第一次匹配的位置</td></tr><tr><td><code>replace(regex, 替换值)</code></td><td>新字符串</td><td>替换匹配内容</td></tr><tr><td><code>split(regex)</code></td><td>字符串数组</td><td>用正则切割字符串</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">//match()：查找匹配内容</span><br><span class="hljs-string">&quot;abc123xyz&quot;</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d+/</span>); <span class="hljs-comment">// [&quot;123&quot;]</span><br><span class="hljs-comment">//matchAll()：获取所有匹配（配合 g 修饰符）</span><br><span class="hljs-keyword">const</span> matches = <span class="hljs-string">&quot;a1b2c3&quot;</span>.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/\d/g</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...matches]); <span class="hljs-comment">// [&#123; 0: &quot;1&quot; &#125;, &#123; 0: &quot;2&quot; &#125;, &#123; 0: &quot;3&quot; &#125;]</span><br><span class="hljs-comment">//search()：返回第一个匹配的索引</span><br><span class="hljs-string">&quot;hello123&quot;</span>.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/\d/</span>); <span class="hljs-comment">// 5</span><br><span class="hljs-comment">//replace()：替换匹配的内容</span><br><span class="hljs-string">&quot;abc123xyz&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d+/</span>, <span class="hljs-string">&quot;***&quot;</span>); <span class="hljs-comment">// &quot;abc***xyz&quot;</span><br><span class="hljs-string">&quot;abc123xyz&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d/g</span>, <span class="hljs-string">&quot;*&quot;</span>);   <span class="hljs-comment">// 全局替换，多个 * </span><br><span class="hljs-comment">//split()：基于正则切割字符串</span><br><span class="hljs-string">&quot;a,b;c.d&quot;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[,;.]/</span>); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="【常用示例】"><a href="#【常用示例】" class="headerlink" title="【常用示例】"></a>【常用示例】</h3><p>验证手机号（中国大陆）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">/^<span class="hljs-number">1</span>[<span class="hljs-number">3</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">9</span>&#125;$/<br></code></pre></td></tr></table></figure><p>验证邮箱地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">/^[\w.-]+@[a-zA-Z\d.-]+\.[a-zA-Z]&#123;<span class="hljs-number">2</span>,&#125;$/<br></code></pre></td></tr></table></figure><p>仅匹配数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">/^\d+$/   <span class="hljs-comment">// 正整数</span><br><span class="hljs-regexp">/^-?\d+$/</span> <span class="hljs-comment">// 可带负号</span><br></code></pre></td></tr></table></figure><p>提取数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;价格是 ¥88 元&quot;</span>;<br><span class="hljs-keyword">const</span> match = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d+/</span>); <span class="hljs-comment">// [&quot;88&quot;]</span><br></code></pre></td></tr></table></figure><h1 id="JavaScript-DOM"><a href="#JavaScript-DOM" class="headerlink" title="JavaScript DOM"></a>JavaScript DOM</h1><h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><p>DOM，全称Document Object Model，<font color="#409eff">中文翻译为文档对象模型</font>。DOM属于Web API的一部分。Web API中定义了非常多的对象，通过这些对象可以完成对网页的各种操作（添加删除元素、发送请求、操作浏览器等）。它将网页结构以<strong>“树状结构”</strong>的方式表示出来，每个 HTML 标签、文本、注释都对应成一“节点（Node）”。</p><p>DOM中的D意为Document，即文档。所谓文档就是指整个网页，换言之，DOM是用来操作网页的。O意为Object，即对象。<font color="#409eff">DOM将网页中的每一部分内容都转换为了对象</font>，div有div的对象，input有input的对象，甚至一段文本，一段注释也有其所对应的对象。转换为对象干什么？还记得面向对象吗？转换对象以后，我们就可以以面向对象的方式去操作网页，想要操作哪个元素就获取哪个元素的对象，然后通过调用其方法或属性完成各种操作。M意为Model，即模型。模型用来表示对象之间的关系，也就是父子元素、祖先后代、兄弟元素等，明确关系后我们便可以通过任意一个对象去获取其他的对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>A Heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Link Text<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220808135838431.png" class title="img"><h3 id="【节点（Node）】"><a href="#【节点（Node）】" class="headerlink" title="【节点（Node）】"></a>【节点（Node）】</h3><p>在DOM标准下，<strong>网页中的每一个部分都会转换为对象。这些对象有一个共同的称呼——节点（Node）</strong>。一个页面将会由多个节点构成，虽然都称为节点，但是它们却有着不同的类型：</p><ol><li>文档节点</li><li>元素节点</li><li>文本节点</li><li>属性节点</li><li>…</li></ol><p>每一个节点都有其不同的作用，文档节点表示整个网页，元素节点表示某个标签，文本节点表示网页中的文本内容，属性节点表示标签中的各种属性。如果从对象的结构上来讲，这些对象都有一个共同的父类Node。总的来说，都是属于节点，但是具体类型不同。</p><h3 id="【关系】"><a href="#【关系】" class="headerlink" title="【关系】"></a>【关系】</h3><ul><li>祖先 —— 包含后代元素的元素是祖先元素</li><li>后代 —— 被祖先元素包含的元素是后代元素</li><li>父 —— 直接包含子元素的元素是父元素</li><li>子 —— 直接被父元素包含的元素是子元素</li><li>兄弟 —— 拥有相同父元素的元素是兄弟元素</li></ul><h2 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a><code>Document对象</code></h2><p>在 JavaScript 中，<code>document</code> 是访问 <strong>DOM（文档对象模型）</strong> 的<strong>入口对象</strong>，它代表整个网页，也叫 <strong>文档对象</strong>。通过它，你可以获取页面上的元素、创建节点、绑定事件、修改结构等。</p><p><code>document</code> 是浏览器提供的一个全局对象，它表示当前加载的 HTML 页面，是 <code>window</code> 对象的属性之一。</p><p>DOM就是一种宿主对象，即由运行环境（浏览器）提供的对象。对象的复杂程度也开始提升，我们先来看看document的继承关系：</p><img src="/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220808141848408.png" class title="img"><p>在标准中，Document继承了Node，Node继承了EventTarget，换言之EventTarget、Node以及Document中所定义的方法document都可以调用，它在浏览器中的实际结构会更复杂一些，这里我们暂时不过多的赘述。</p><blockquote><p>document对象的原型链 HTMLDocument -&gt; Document -&gt; Node -&gt; EventTarget -&gt; Object.prototype -&gt; null</p></blockquote><p>凡是再原型链中存在的对象的属性和方法都可以调用。</p><p><strong>部分属性：</strong></p><table><thead><tr><th>属性&#x2F;方法</th><th>含义</th></tr></thead><tbody><tr><td><code>document.documentElement</code></td><td>获取 <code>&lt;html&gt;</code> 元素</td></tr><tr><td><code>document.body</code></td><td>获取 <code>&lt;body&gt;</code> 元素</td></tr><tr><td><code>document.head</code></td><td>获取 <code>&lt;head&gt;</code> 元素</td></tr><tr><td><code>document.title</code></td><td>获取&#x2F;设置网页标题</td></tr><tr><td><code>document.URL</code></td><td>当前页面完整 URL</td></tr><tr><td><code>document.domain</code></td><td>当前页面的域名</td></tr><tr><td><code>document.cookie</code></td><td>读取&#x2F;设置 cookie 值</td></tr><tr><td><code>document.readyState</code></td><td>加载状态：<code>loading</code>、<code>interactive</code>、<code>complete</code></td></tr></tbody></table><h2 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h2><p>在网页中所有的元素（标签）都是一个Element对象。Element对象的继承关系和Document类似：</p><img src="/2025/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/JavaScript%E6%A0%B8%E5%BF%83%E6%80%BB%E7%BB%93/20220808210844195.png" class title="img"><table><thead><tr><th>特性</th><th><code>Node</code></th><th><code>Element</code></th></tr></thead><tbody><tr><td>类型</td><td>基类</td><td>HTML 元素的专用子类</td></tr><tr><td>包含哪些</td><td>文本、注释、元素等</td><td>只有 HTML 元素</td></tr><tr><td>常用方法</td><td>appendChild 等</td><td>innerHTML、style、classList 等</td></tr></tbody></table><p>可以通过Document或其他元素直接获取已有的Element对象，也可以使用Document来创建新的Element对象。我们先来看看如何通过document获取已有的Element对象。</p><ul><li><code>document.documentElement</code> 获取html根元素</li><li><code>document.body</code> 获取body元素</li><li><code>document.getElementByID()</code> 根据id获取一个元素</li><li><code>document.getElementsByClassName()</code> 根据class属性获取元素（实时更新列表）</li><li><code>document.getElementsByTagName()</code> 根据标签名获取元素（实时更新列表）</li><li><code>document.getElementsByName()</code> 根据name属性获取元素（实时更新列表）</li><li><code>document.querySelector()</code> 根据选择器获取一个元素</li><li><code>document.querySelectorAll()</code> 根据选择器获取一组元素</li></ul><p>通过其他元素获取已有的Element对象：</p><ul><li><code>element.children</code></li><li><code>element.parentNode</code></li><li><code>element.firstElementChild</code></li><li><code>element.lastElementChild</code></li><li>……</li></ul><p>创建Element对象：</p><ul><li><code>document.createElement()</code> 根据标签名创建元素节点对象</li></ul><h3 id="【文本操作】"><a href="#【文本操作】" class="headerlink" title="【文本操作】"></a>【文本操作】</h3><p>在DOM中，文本内容也是一个节点对象（Text），可以通过获取文本对象然后完成对它的各种操作，但这种做法会使得事情变得复杂，并不建议这么做。在大部分场景下，可以通过元素的属性来操作其中的文本内容，比如有如下文本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div中的文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设我们已经获取到了div的元素节点对象，我们可以通过以下的属性来完成对文本的操作：</p><table><thead><tr><th>属性&#x2F;方法</th><th>作用</th></tr></thead><tbody><tr><td><code>innerHTML</code></td><td>获取&#x2F;设置 HTML 内容（会解析标签）</td></tr><tr><td><code>textContent</code></td><td>获取&#x2F;设置纯文本内容（不解析 HTML）</td></tr><tr><td><code>innerText</code></td><td>类似于 <code>textContent</code>，受 CSS 影响</td></tr></tbody></table><h3 id="【属性操作】"><a href="#【属性操作】" class="headerlink" title="【属性操作】"></a>【属性操作】</h3><p>属性也是一个节点对象（Attr），和文本一样，通常我们不会去直接获取节点对象，而是通过元素来完成对属性的操作：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getAttribute(name)</code></td><td>获取属性</td></tr><tr><td><code>setAttribute(name, value)</code></td><td>设置属性</td></tr><tr><td><code>removeAttribute(name)</code></td><td>删除属性</td></tr><tr><td><code>hasAttribute(name)</code></td><td>检查属性是否存在</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;box&#x27;</span>);<br>element.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="【类名操作】"><a href="#【类名操作】" class="headerlink" title="【类名操作】"></a>【类名操作】</h3><p>使用 <code>classList</code> 操作类名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;hidden&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;dark&#x27;</span>); <span class="hljs-comment">// 有则删，无则加</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;dark&#x27;</span>); <span class="hljs-comment">// 检查类名是否存在</span><br></code></pre></td></tr></table></figure><h3 id="【样式操作】"><a href="#【样式操作】" class="headerlink" title="【样式操作】"></a>【样式操作】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>element.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;yellow&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p><code>element.style</code> 是操作内联样式，不影响 class 设置的样式。</p></blockquote><h2 id="事件（event）"><a href="#事件（event）" class="headerlink" title="事件（event）"></a>事件（event）</h2><p>事件指用户和网页之间发生的交互行为。比如点击按钮、移动鼠标、改变窗口大小、表单输入等等等等，用户的所有操作都可以被当成是一个事件。JS中通过为事件绑定回调函数来处理事件，绑定回调函数后，事件触发后回调函数便会执行，以此来响应用户的行为，所以事件的回调函数我们也称其为事件的响应函数。</p><h3 id="【绑定回调函数】"><a href="#【绑定回调函数】" class="headerlink" title="【绑定回调函数】"></a>【绑定回调函数】</h3><ol><li>通过标签的事件属性</li><li>通过元素对象的事件属性</li><li>通过元素addEventListener()方法</li></ol><p>方式一：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;按钮被点了！&#x27;)&quot;</span>&gt;</span>点我一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点击了！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>方式三：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>&#125;) <span class="hljs-comment">// 可以绑定多个事件</span><br></code></pre></td></tr></table></figure><h2 id="文档加载事件"><a href="#文档加载事件" class="headerlink" title="文档加载事件"></a>文档加载事件</h2><p>在网页中编写DOM代码时，如果依然将script标签编写到head中，会有无法获取DOM对象情况出现。这是因为网页的加载是自上向下依次加载的，如果将代码写在前边会导致代码执行时网页还没有加载，DOM对象也就无法获取了。</p><p>如何解决这个问题呢？有这么几种方案：</p><ol><li>将script标签写在body的最后</li><li>将js代码编写到window.onload事件的回调函数中</li><li>将js代码编写到document对象的DOMContentLoaded事件的回调函数中</li><li>将js代码编写到外部的js文件中，引入时为script标签添加defer属性</li></ol><p>方式一：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点我一下<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)</span><br><span class="language-javascript">            btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)</span><br><span class="language-javascript">            &#125;)</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码编写到了body的最后，代码执行时网页已经加载完毕了，不会出现无法获取DOM对象的问题。</p><p>方式二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>将js代码编写到window的load事件的回调函数中，load事件会在页面加载完毕后触发，同样可以避免上述问题。</p><p>方式三：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>)<br>    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;按钮被点了&quot;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>将js代码编写到document的DOMContentLoaded事件的回调函数中，代码会在当前文档加载完毕后执行也可以避免上述情况。（相较于load事件，DOMContentLoaded事件的执行更早一些）</p><p>方式四：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置defer后，脚本将会在文档解析之后加载，同样可以避免上述问题。（执行时机早于DOMContentLoaded）</p><h2 id="Element操作"><a href="#Element操作" class="headerlink" title="Element操作"></a>Element操作</h2><h3 id="【增删改查】"><a href="#【增删改查】" class="headerlink" title="【增删改查】"></a>【增删改查】</h3><table><thead><tr><th>操作</th><th>含义</th><th>关键词</th></tr></thead><tbody><tr><td>查</td><td>查询&#x2F;获取元素</td><td><code>getElementById</code>、<code>querySelector</code> 等</td></tr><tr><td>增</td><td>新增元素（创建并添加）</td><td><code>createElement</code> + <code>appendChild</code></td></tr><tr><td>改</td><td>修改内容&#x2F;属性&#x2F;样式</td><td><code>textContent</code>、<code>style</code>、<code>setAttribute</code></td></tr><tr><td>删</td><td>删除已有元素</td><td><code>removeChild()</code> 或 <code>remove()</code></td></tr></tbody></table><p><strong>查（Read）：获取元素</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;id&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;class&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;css选择器&#x27;</span>);      <span class="hljs-comment">// 返回第一个匹配</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;css选择器&#x27;</span>);   <span class="hljs-comment">// 返回所有匹配</span><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> title = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>);<br><span class="hljs-keyword">const</span> listItems = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;ul li&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>增（Create）：新增元素</strong></p><p>创建元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> newDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>newDiv.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;我是新元素&#x27;</span>;<br></code></pre></td></tr></table></figure><p>插入元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(newDiv);              <span class="hljs-comment">// 添加到 body 最后</span><br>parent.<span class="hljs-title function_">insertBefore</span>(newDiv, referenceNode);     <span class="hljs-comment">// 插入到某个子元素前</span><br>list.<span class="hljs-title function_">insertAdjacentElement</span>(<span class="hljs-string">&quot;afterend&quot;</span>, li)<br><span class="hljs-comment">//insertAdjacentElement()可以向元素的任意位置添加元素</span><br><span class="hljs-comment">//两个参数：1.要添加的位置 2.要添加的元素</span><br><span class="hljs-comment">// beforeend 标签的最后 afterbegin 标签的开始  </span><br><span class="hljs-comment">// beforebegin 在元素的前边插入元素（兄弟元素） afterend 在元素的后边插入元素（兄弟元素）</span><br><span class="hljs-comment">// 容易被xss攻击</span><br></code></pre></td></tr></table></figure><p>创建并插入多个元素（推荐使用 DocumentFragment）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>  li.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;项 &#x27;</span> + (i + <span class="hljs-number">1</span>);<br>  fragment.<span class="hljs-title function_">appendChild</span>(li);<br>&#125;<br>ul.<span class="hljs-title function_">appendChild</span>(fragment);<br></code></pre></td></tr></table></figure><p><strong>改（Update）：修改元素内容&#x2F;样式&#x2F;属性</strong></p><p>修改内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;新文本内容&#x27;</span>;<br>element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;strong&gt;新内容&lt;/strong&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>修改样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;hidden&#x27;</span>);<br></code></pre></td></tr></table></figure><p>修改属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;提示文字&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>删（Delete）：删除元素</strong></p><p>方法一：从父元素中移除子元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">parent.<span class="hljs-title function_">removeChild</span>(child);<br></code></pre></td></tr></table></figure><p>方法二：直接删除（现代写法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">remove</span>();  <span class="hljs-comment">// ES6+</span><br></code></pre></td></tr></table></figure><h3 id="【节点复制】"><a href="#【节点复制】" class="headerlink" title="【节点复制】"></a>【节点复制】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> newNode = node.<span class="hljs-title function_">cloneNode</span>(deep);<br></code></pre></td></tr></table></figure><p><code>deep</code>（布尔值）：</p><ul><li><code>true</code>：深拷贝，复制节点本身 <strong>及其所有子节点</strong></li><li><code>false</code>：浅拷贝，只复制当前节点，不复制其子节点</li></ul><p>复制后的节点是<strong>新的节点对象</strong>，你可以对它进行修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> copy = original.<span class="hljs-title function_">cloneNode</span>(<span class="hljs-literal">true</span>);<br>copy.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;copy&#x27;</span>;                       <span class="hljs-comment">// 改 ID</span><br>copy.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;span&#x27;</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;JS&#x27;</span>; <span class="hljs-comment">// 改内部内容</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(copy);<br></code></pre></td></tr></table></figure><table><thead><tr><th>注意点</th><th>说明</th></tr></thead><tbody><tr><td>不会复制事件</td><td>事件监听器不会被克隆（必须手动添加）</td></tr><tr><td>不会复制绑定的数据</td><td>自定义属性、数据绑定等框架状态不会复制</td></tr><tr><td>不会插入页面</td><td><code>cloneNode()</code> 只是创建节点，需 <code>appendChild()</code> 或 <code>insertBefore()</code> 插入页面</td></tr></tbody></table><h3 id="【样式修改】"><a href="#【样式修改】" class="headerlink" title="【样式修改】"></a>【样式修改】</h3><p>两种常见方式</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>element.style</code></td><td>修改<strong>行内样式</strong></td></tr><tr><td><code>element.classList</code></td><td>通过<strong>类名</strong>控制样式</td></tr></tbody></table><p>使用 <code>element.style</code> 直接修改样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.样式名 = <span class="hljs-string">&#x27;值&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>注意：JS 中的样式名使用 <strong>驼峰命名</strong>，如 <code>backgroundColor</code>、<code>fontSize</code>。</p></blockquote><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;box&#x27;</span>);<br><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;              <span class="hljs-comment">// 设置字体颜色</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;yellow&#x27;</span>; <span class="hljs-comment">// 设置背景</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&#x27;20px&#x27;</span>;          <span class="hljs-comment">// 设置字体大小</span><br>box.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;1px solid black&#x27;</span>; <span class="hljs-comment">// 设置边框</span><br></code></pre></td></tr></table></figure><p>清除样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">box.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 清除 color 样式</span><br></code></pre></td></tr></table></figure><p><strong>使用 <code>className</code> 或 <code>classList</code> 控制样式（推荐）</strong></p><p>相比 <code>element.style</code>，使用类名控制样式更整洁、易维护。</p><p>设置整个类名（不推荐直接覆盖）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;box active&#x27;</span>; <span class="hljs-comment">// 替换所有类名</span><br></code></pre></td></tr></table></figure><p>推荐使用 <code>element.classList</code>（常用）</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>add(&#39;class&#39;)</code></td><td>添加类名</td></tr><tr><td><code>remove(&#39;class&#39;)</code></td><td>删除类名</td></tr><tr><td><code>toggle(&#39;class&#39;)</code></td><td>有则删，无则加（切换）</td></tr><tr><td><code>contains(&#39;class&#39;)</code></td><td>检查类名是否存在</td></tr></tbody></table><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;hidden&#x27;</span>);<br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;dark-mode&#x27;</span>);<br><span class="hljs-keyword">if</span> (element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;active&#x27;</span>)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前处于激活状态&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>🔁 <code>toggle()</code> 可配合按钮实现样式切换。</p></blockquote><p><strong>完整例子：点击切换样式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.highlight</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>点按钮改变我<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>切换样式<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      text.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>动态修改多个样式</strong></p><p>你可以一次性修改多个样式属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(element.<span class="hljs-property">style</span>, &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;white&#x27;</span>,<br>  <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;10px&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>或者使用 CSS 变量配合样式切换。</p><p>如果你想<font color="#409eff">获取实际生效的样式</font>，而不是行内的，可以用<code>getComputedStyle</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> styles = <span class="hljs-title function_">getComputedStyle</span>(element);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(styles.<span class="hljs-property">color</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(styles.<span class="hljs-property">fontSize</span>);<br></code></pre></td></tr></table></figure><p><strong>style 与 classList 的区别</strong></p><table><thead><tr><th>对比项</th><th><code>element.style</code></th><th><code>element.classList</code></th></tr></thead><tbody><tr><td>修改方式</td><td>直接操作行内样式</td><td>添加&#x2F;删除类名</td></tr><tr><td>可读性</td><td>差</td><td>高</td></tr><tr><td>可维护性</td><td>差</td><td>高（CSS 中集中管理）</td></tr><tr><td>适合情况</td><td>动态计算样式、动画</td><td>常规样式控制、主题切换</td></tr></tbody></table><p><strong>常见坑与注意事项</strong></p><ol><li><p><strong>样式名要用驼峰写法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> <span class="hljs-comment">// 而不是 background-color</span><br></code></pre></td></tr></table></figure></li><li><p><strong>缺单位的值会无效</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&#x27;20px&#x27;</span>; <span class="hljs-comment">// 不要忘记 px</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不要直接覆盖 className（容易丢类）</strong></p></li><li><p><strong>事件触发修改样式</strong>时注意不要写错引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><p><strong>根据属性获取样式</strong></p><table><thead><tr><th>属性</th><th>包括哪些部分</th><th>常用于</th></tr></thead><tbody><tr><td><code>clientWidth</code></td><td>内容区 + padding</td><td>可视内容宽度</td></tr><tr><td><code>offsetWidth</code></td><td>内容区 + padding + border（+ 滚动条）</td><td>元素总宽度</td></tr><tr><td><code>scrollWidth</code></td><td>所有内容宽度（即使不可见）</td><td>内容溢出检测、横向滚动</td></tr><tr><td><code>offsetParent</code></td><td>离元素最近的设置了定位的祖先元素</td><td>定位计算</td></tr><tr><td><code>offsetTop</code></td><td>元素顶部相对于 <code>offsetParent</code> 的距离</td><td>绝对&#x2F;相对定位偏移计算</td></tr><tr><td><code>scrollTop</code></td><td>元素垂直滚动偏移量</td><td>滚动判断、回滚顶部&#x2F;底部控制</td></tr></tbody></table><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>事件对象是浏览器在事件触发时自动传递给事件监听函数的<strong>包含事件详细信息的对象</strong>。浏览器在创建事件对象后，会将事件对象作为响应函数的参数传递，所以我们可以在事件的回调函数中定义一个形参来接收事件对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event); <span class="hljs-comment">// 输出事件对象</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>在函数中通常会用 <code>e</code> 或 <code>event</code> 表示该对象。这个对象中<font color="#409eff">封装了事件相关的各种信息.</font></p><h3 id="【基本结构】"><a href="#【基本结构】" class="headerlink" title="【基本结构】"></a>【基本结构】</h3><p>事件对象是各种事件类型的基类对象（如 <code>MouseEvent</code>、<code>KeyboardEvent</code>、<code>InputEvent</code>），都继承自 <code>Event</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">event &#123;<br>  type,          <span class="hljs-comment">// 事件类型，例如 &#x27;click&#x27;</span><br>  target,        <span class="hljs-comment">// 触发事件的元素</span><br>  currentTarget, <span class="hljs-comment">// 当前绑定事件的元素</span><br>  bubbles,       <span class="hljs-comment">// 是否支持冒泡</span><br>  cancelable,    <span class="hljs-comment">// 是否可以取消默认行为</span><br>  timeStamp,     <span class="hljs-comment">// 事件发生时间</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【常用方法属性】"><a href="#【常用方法属性】" class="headerlink" title="【常用方法属性】"></a>【常用方法属性】</h3><p><strong>多种事件对象有一个共同的祖先 Event</strong></p><ol><li><code>event.type</code></li></ol><p>返回事件的类型（如 <code>&quot;click&quot;</code>, <code>&quot;keydown&quot;</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">type</span>); <span class="hljs-comment">// 输出 &#x27;click&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>event.target</code> 和 <code>event.currentTarget</code></li></ol><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>target</code></td><td>实际触发事件的元素</td></tr><tr><td><code>currentTarget</code></td><td>当前绑定事件的元素</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;target:&#x27;</span>, event.<span class="hljs-property">target</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;currentTarget:&#x27;</span>, event.<span class="hljs-property">currentTarget</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li><code>event.preventDefault()</code></li></ol><p>阻止事件的默认行为（如点击链接不跳转）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">link.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">preventDefault</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="4"><li><code>event.stopPropagation()</code></li></ol><p>阻止事件继续冒泡（向上冒泡被中断）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>鼠标事件特有属性（<code>MouseEvent</code>）</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>clientX</code></td><td>鼠标点击时，视口内 X 坐标</td></tr><tr><td><code>clientY</code></td><td>鼠标点击时，视口内 Y 坐标</td></tr><tr><td><code>pageX</code></td><td>相对于页面的 X 坐标</td></tr><tr><td><code>button</code></td><td>哪个鼠标键触发了事件（0 左，1 中，2 右）</td></tr></tbody></table><p><strong>键盘事件特有属性（<code>KeyboardEvent</code>）</strong></p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>key</code></td><td>被按下的键的字符</td></tr><tr><td><code>code</code></td><td>键盘的物理按键代码</td></tr><tr><td><code>ctrlKey</code></td><td>是否按下 Ctrl</td></tr><tr><td><code>shiftKey</code></td><td>是否按下 Shift</td></tr></tbody></table><h3 id="【事件冒泡】"><a href="#【事件冒泡】" class="headerlink" title="【事件冒泡】"></a>【事件冒泡】</h3><p><strong>事件冒泡（Event Bubbling）</strong> 是 DOM 中的一种事件传播机制，指的是：</p><blockquote><p>当一个元素上的事件被触发时，<strong>该事件会从最深层的目标元素向上传播</strong>，依次经过它的父元素、祖先元素，直到 <code>document</code> 根节点。</p></blockquote><p>这就像水泡从水底冒到水面一样，所以称为 “<strong>冒泡</strong>“。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;<br>js复制编辑<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;child&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;子元素被点击&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;parent&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父元素被点击&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">子元素被点击<br>父元素被点击<br></code></pre></td></tr></table></figure><p>因为事件会先在目标元素（<code>child</code>）触发，然后 <strong>冒泡到父元素</strong>（<code>parent</code>）。</p><p><strong>事件传播的三个阶段</strong></p><ol><li><strong>捕获阶段</strong>（Capture）：<ul><li>从 <code>window</code> 一直向下捕获到目标元素，但此阶段默认不会触发监听器。</li></ul></li><li><strong>目标阶段</strong>（Target）：<ul><li>事件在目标元素上触发。</li></ul></li><li><strong>冒泡阶段</strong>（Bubble）：<ul><li>从目标元素向上冒泡到 <code>document</code>，依次触发祖先元素上的监听器（如果有）。</li></ul></li></ol><p> <strong>可视图：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">window<br>  ↓<br>document<br>  ↓<br>&lt;html&gt;<br>  ↓<br>&lt;body&gt;<br>  ↓<br>&lt;div id=&quot;parent&quot;&gt;     ← 父元素监听器触发<br>  ↓<br>&lt;button id=&quot;child&quot;&gt;   ← 目标元素监听器触发<br></code></pre></td></tr></table></figure><p>如何阻止事件冒泡？</p><p>使用 <code>event.stopPropagation()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;child&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件冒泡到 parent</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了子元素&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这时点击按钮只会输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">点击了子元素<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>并不是所有事件都支持冒泡，如 <code>blur</code> 和 <code>focus</code> 不冒泡。</li><li>如果用 <code>addEventListener(event, handler, true)</code>，则监听器会在捕获阶段触发。 一般情况下我们不希望事件在捕获阶段触发，所有通常都不需要设置第三个参数</li></ul><p><code>eventPhase</code> 表示事件触发的阶段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">box1.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;1&quot;</span> + event.<span class="hljs-property">eventPhase</span>) <span class="hljs-comment">// eventPhase 表示事件触发的阶段</span><br>                <span class="hljs-comment">//1 捕获阶段 2 目标阶段 3 冒泡阶段</span><br>            &#125;)<br></code></pre></td></tr></table></figure><h3 id="【事件委托】"><a href="#【事件委托】" class="headerlink" title="【事件委托】"></a>【事件委托】</h3><p><strong>事件委托</strong> 是指：将事件监听器绑定在某个父元素上，<strong>通过事件冒泡机制</strong>，统一处理其子元素的事件。</p><p>换句话说，你<strong>不用给每个子元素都绑定事件</strong>，只需要在<strong>父元素上监听一次</strong>，然后判断事件是从哪个子元素触发的。</p><table><thead><tr><th>传统写法问题</th><th>事件委托的优势</th></tr></thead><tbody><tr><td>子元素多，逐个绑定低效</td><td>父元素只绑定一次，节省内存</td></tr><tr><td>子元素可能是动态创建的，无法事先绑定事件</td><td>委托可处理未来创建的子元素</td></tr><tr><td>修改结构需重新绑定事件</td><td>委托天然支持新增 DOM</td></tr></tbody></table><p>点击 <code>&lt;ul&gt;</code> 中的 <code>&lt;li&gt;</code> 项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 错误方式（对每个 li 都绑定事件）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;#list li&#x27;</span>);<br>items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">li</span> =&gt;</span> &#123;<br>  li.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了&#x27;</span>, li.<span class="hljs-property">textContent</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>不支持动态添加的 <code>li</code></li><li>性能差，代码冗余</li></ul><p>正确方式：使用事件委托</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br><br>list.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击了&#x27;</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>利用了事件冒泡，<code>e.target</code> 就是实际点击的子元素。</p><p>动态添加项也能触发！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>li.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;新增项&#x27;</span>;<br>list.<span class="hljs-title function_">appendChild</span>(li); <span class="hljs-comment">// 无需绑定事件，自动生效</span><br></code></pre></td></tr></table></figure><p>因为事件绑定在 <code>ul</code> 上，<strong>后添加的子元素也能响应点击</strong>。</p><p><strong>常见应用场景</strong></p><table><thead><tr><th>应用场景</th><th>委托监听的父元素</th><th>子元素判断条件</th></tr></thead><tbody><tr><td>表格中点击某一行</td><td><code>tbody</code></td><td><code>e.target.tagName === &#39;TD&#39;</code></td></tr><tr><td>列表点击删除按钮</td><td><code>ul</code> &#x2F; <code>div.list</code></td><td><code>e.target.classList.contains(&#39;delete-btn&#39;)</code></td></tr><tr><td>表单中输入实时校验</td><td><code>form</code></td><td><code>e.target.name === &#39;email&#39;</code></td></tr><tr><td>整体布局中捕获所有按钮</td><td><code>document.body</code></td><td><code>e.target.matches(&#39;button&#39;)</code></td></tr></tbody></table><p><strong>常用判断方法</strong></p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td><code>e.target.tagName</code></td><td>判断具体 HTML 标签名</td></tr><tr><td><code>e.target.classList.contains()</code></td><td>判断是否有某个类名</td></tr><tr><td><code>e.target.matches(&#39;选择器&#39;)</code></td><td>判断是否符合某个 CSS 选择器</td></tr><tr><td><code>e.target.closest(&#39;选择器&#39;)</code></td><td>向上查找符合的父元素</td></tr></tbody></table><h2 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h2><p><strong>BOM（浏览器对象模型）</strong> 是 JavaScript 与浏览器交互的一套对象结构，允许我们控制浏览器窗口和与之相关的功能（如地址栏、历史记录、导航、定时器、弹窗等）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span><br>├── location       → 地址栏相关<br>├── history        → 浏览记录<br>├── navigator      → 浏览器信息<br>├── screen         → 屏幕信息<br>├── <span class="hljs-variable language_">document</span>       → 网页内容（<span class="hljs-variable constant_">DOM</span>）<br>├── <span class="hljs-title function_">alert</span>(), <span class="hljs-built_in">setTimeout</span>() 等全局方法<br></code></pre></td></tr></table></figure><p><code>window</code> 对象（BOM 的核心）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>); <span class="hljs-comment">// 全局窗口对象</span><br></code></pre></td></tr></table></figure><ul><li>JS 中的全局变量和函数都是 <code>window</code> 的属性</li><li>访问 <code>window.x</code> 等价于访问 <code>x</code></li></ul><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;你好&quot;</span>); <span class="hljs-comment">// 弹窗</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;定时&quot;</span>), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><code>location</code> 对象（地址栏相关）</li></ol><p>用于访问和修改浏览器的地址栏信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">href</span>);   <span class="hljs-comment">// 当前地址</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hostname</span>); <span class="hljs-comment">// 主机名</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">pathname</span>); <span class="hljs-comment">// 路径名</span><br><br><span class="hljs-comment">// 跳转页面</span><br>location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;https://www.google.com&quot;</span>;<br><br><span class="hljs-comment">// 重新加载</span><br>location.<span class="hljs-title function_">reload</span>();<br></code></pre></td></tr></table></figure><ol start="3"><li><code>history</code> 对象（浏览历史）</li></ol><p>操作用户的访问历史记录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">history.<span class="hljs-title function_">back</span>();    <span class="hljs-comment">// 后退</span><br>history.<span class="hljs-title function_">forward</span>(); <span class="hljs-comment">// 前进</span><br>history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回前一个页面</span><br></code></pre></td></tr></table></figure><p>📌 注意：不能直接查看访问记录内容（出于安全）</p><ol start="4"><li><code>navigator</code> 对象（浏览器信息）</li></ol><p>返回浏览器和系统的相关信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(navigator.<span class="hljs-property">userAgent</span>);     <span class="hljs-comment">// 浏览器标识，用来描述浏览器信息的字符串。 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(navigator.<span class="hljs-property">language</span>);      <span class="hljs-comment">// 当前语言</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(navigator.<span class="hljs-property">platform</span>);      <span class="hljs-comment">// 操作系统平台</span><br></code></pre></td></tr></table></figure><ol start="5"><li><code>screen</code> 对象（屏幕分辨率）</li></ol><p>返回客户端屏幕相关信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(screen.<span class="hljs-property">width</span>);      <span class="hljs-comment">// 屏幕宽度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(screen.<span class="hljs-property">height</span>);     <span class="hljs-comment">// 屏幕高度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(screen.<span class="hljs-property">availWidth</span>); <span class="hljs-comment">// 可用宽度（除去任务栏）</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>DOM（文档对象模型）</th><th>BOM（浏览器对象模型）</th></tr></thead><tbody><tr><td>操作内容</td><td>网页内容</td><td>浏览器窗口及相关功能</td></tr><tr><td>代表对象</td><td><code>document</code></td><td><code>window</code>、<code>location</code> 等</td></tr><tr><td>用途</td><td>操作文档结构</td><td>控制导航、弹窗、定时器等</td></tr><tr><td>是否标准</td><td>是（W3C 标准）</td><td>否（由浏览器厂商定义）</td></tr></tbody></table><h3 id="【常用-BOM-方法（弹窗-定时器）】"><a href="#【常用-BOM-方法（弹窗-定时器）】" class="headerlink" title="【常用 BOM 方法（弹窗&#x2F;定时器）】"></a>【常用 BOM 方法（弹窗&#x2F;定时器）】</h3><p><strong>弹窗类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;提示信息&quot;</span>);<br><span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;你确定要删除吗？&quot;</span>);  <span class="hljs-comment">// 返回 true/false</span><br><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入你的名字&quot;</span>);     <span class="hljs-comment">// 返回用户输入的字符串</span><br></code></pre></td></tr></table></figure><p><strong>定时器类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;一次性定时器&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-keyword">let</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;每秒一次&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 清除</span><br><span class="hljs-built_in">clearTimeout</span>(timer);<br><span class="hljs-built_in">clearInterval</span>(interval);<br></code></pre></td></tr></table></figure><p><code>window.open()</code> 打开新窗口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;https://www.example.com&quot;</span>, <span class="hljs-string">&quot;_blank&quot;</span>);<br></code></pre></td></tr></table></figure><p>现代浏览器常常会屏蔽这种行为，除非用户是主动点击触发。</p><p><strong>浏览器尺寸与滚动</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>);  <span class="hljs-comment">// 浏览器内容区宽度</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">scrollY</span>);     <span class="hljs-comment">// 页面滚动的垂直距离</span><br></code></pre></td></tr></table></figure><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在 JavaScript 中，理解 <strong>调用栈（Call Stack）</strong> 和 <strong>消息队列（Message Queue &#x2F; Task Queue）</strong> 是掌握<strong>异步编程、事件循环（Event Loop）</strong>、<code>setTimeout</code>、<code>Promise</code> 等机制的核心基础。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vb">      ┌───────────────┐<br>      │    调用栈     │ ← 执行同步代码<br>      └────┬──────────┘<br>           │<br>           ▼<br>  ┌─────────────────────┐<br>  │   Web APIs / 回调注册 │ ← setTimeout、DOM事件等交给浏览器处理<br>  └────┬────────────────┘<br>       │（等待完成）<br>       ▼<br> ┌────────────┐<br> │ 消息队列    │ ← 异步回调排队等执行<br> └────┬───────┘<br>      │<br>      ▼<br><span class="hljs-keyword">Event</span> <span class="hljs-keyword">Loop</span> 检查调用栈空 → 把队列中的回调推进栈中执行<br></code></pre></td></tr></table></figure><h3 id="【调用栈（Call-Stack）】"><a href="#【调用栈（Call-Stack）】" class="headerlink" title="【调用栈（Call Stack）】"></a>【调用栈（Call Stack）】</h3><p>调用栈是 JS 引擎用来跟踪函数执行过程的数据结构，<strong>遵循 LIFO（后进先出）</strong> 原则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">bar</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>执行过程：</p><ol><li><code>foo()</code> 进栈</li><li><code>bar()</code> 进栈</li><li><code>console.log()</code> 进栈并执行</li><li><code>console.log()</code> 出栈 → <code>bar()</code> 出栈 → <code>foo()</code> 出栈</li></ol><p>小结：</p><ul><li><strong>同步代码</strong>是依次进入调用栈中执行的</li><li>调用栈满时，不能执行任何新的代码（也不能处理异步）</li></ul><h3 id="【消息队列（Message-Queue）】"><a href="#【消息队列（Message-Queue）】" class="headerlink" title="【消息队列（Message Queue）】"></a>【消息队列（Message Queue）】</h3><p>消息队列是一个等待执行的<strong>异步任务回调列表</strong>，当调用栈清空后，<strong>事件循环（Event Loop）</strong> 会从队列中取出任务并执行。</p><p><strong>包含内容：</strong></p><ul><li><code>setTimeout</code>、<code>setInterval</code> 的回调</li><li>DOM 事件（如点击、键盘）</li><li>网络请求（如 Ajax 回调）</li><li><code>Promise.then()</code>（微任务，不在主消息队列，详见后）</li></ul><h3 id="【事件循环（Event-Loop）】"><a href="#【事件循环（Event-Loop）】" class="headerlink" title="【事件循环（Event Loop）】"></a>【事件循环（Event Loop）】</h3><p>事件循环的核心职责：</p><blockquote><p>💡 “不断地检查调用栈是否为空，如果为空，就从消息队列中取出一个回调执行”。</p></blockquote><p>这是 JS 实现异步非阻塞编程的关键机制。</p><p>经典例子：setTimeout</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);<br></code></pre></td></tr></table></figure><p>setInterval() 没间隔一段时间就将函数添加到消息队列中但是如果函数执行的速度比较慢，它是无法确保每次执行的间隔都是一样的</p><h3 id="输出顺序："><a href="#输出顺序：" class="headerlink" title="输出顺序："></a>输出顺序：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>原因：</p><ul><li><code>console.log(&quot;1&quot;)</code> 进入栈并立即执行</li><li><code>setTimeout(...)</code> 把回调注册到 Web API，并排入<strong>消息队列</strong></li><li><code>console.log(&quot;3&quot;)</code> 进入栈并立即执行</li><li>调用栈清空，事件循环从消息队列中取出 <code>console.log(&quot;2&quot;)</code> 执行</li></ul><h3 id="【微任务队列（Microtask-Queue）】"><a href="#【微任务队列（Microtask-Queue）】" class="headerlink" title="【微任务队列（Microtask Queue）】"></a>【微任务队列（Microtask Queue）】</h3><p>JavaScript 还有一个比消息队列<strong>优先级更高</strong>的队列叫：<strong>微任务队列</strong>。</p><p>常见的微任务来源：</p><ul><li><code>Promise.then()</code>, <code>catch()</code>, <code>finally()</code></li><li><code>MutationObserver</code></li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start&quot;</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">start<br>end<br>promise<br></code></pre></td></tr></table></figure><p>原因：微任务在当前宏任务执行完后、下一个宏任务前执行。</p><p><strong>宏任务 vs 微任务</strong></p><table><thead><tr><th>分类</th><th>举例</th></tr></thead><tbody><tr><td>宏任务</td><td><code>setTimeout</code>, <code>setInterval</code>, <code>fetch</code>, <code>DOM事件</code></td></tr><tr><td>微任务</td><td><code>Promise.then</code>, <code>queueMicrotask</code>, <code>MutationObserver</code></td></tr></tbody></table><blockquote><p><strong>调用栈</strong>负责执行同步任务，<strong>消息队列</strong>存放异步回调，<strong>事件循环</strong>协调两者，确保 JavaScript 在单线程下实现异步编程。</p></blockquote><h3 id="【图解执行顺序（带-Promise）】"><a href="#【图解执行顺序（带-Promise）】" class="headerlink" title="【图解执行顺序（带 Promise）】"></a>【图解执行顺序（带 Promise）】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;C&quot;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;D&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="输出顺序：-1"><a href="#输出顺序：-1" class="headerlink" title="输出顺序："></a>输出顺序：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span><br>D<br>C   ← 微任务先于宏任务<br><span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><blockquote><p><a href="https://lilichao.com/?p=6402">jQuery – 李立超 | lilichao.com</a></p></blockquote><h2 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h2><p>jQuery是一个快速的、小型的、具有丰富功能的JavaScript库。<strong>它的出现使得网页中的DOM、事件、动画、Ajax等操作变得更加简单</strong>。“写更少的代码，做更多的事儿”是jQuery一直坚信的开发理念。</p><p>库就是一组代码，这组代码中包含了一些已经定义好的对象和函数。只需要将库引入到页面中，即可直接使用这些对象和函数。库中的代码通常是为了解决一些我们开发中的一些不便。jQuery中的代码就是为了简化原生JS的操作，同样一个功能使用原生JS你也许要编写五行代码，使用jQuery一行就可以搞定，同时jQuery还可以帮助我们处理掉浏览器的兼容问题。</p><h3 id="【jQuery-——-一个过时的库】"><a href="#【jQuery-——-一个过时的库】" class="headerlink" title="【jQuery —— 一个过时的库】"></a>【jQuery —— 一个过时的库】</h3><p>所有的库都是为了解决我们开发时的痛点而存在的。jQuery解决的问题主要有两个：<font color="#409eff">简化DOM操作、解决浏览器兼容问题</font>。然而随着前端的发展、DOM标准的更新、IE的消亡。DOM操作和浏览器兼容性早已不是什么大问题了，再加上React、Vue、Angular这些大型框架的出现，在实际项目中使用jQuery的机会可以说是少之又少。这是不是就意味着我们没有必要在学习jQuery了呢？是的，确实没有学习jQuery的必要了。所以如果是比较赶时间的同学，完全可以跳过jQuery的学习，不需要再继续听下边的内容了。</p><p><strong>CDN</strong></p><p>使用公共cdn比较简单，以字节跳动静态资源为例，要引入3.x版本的jQuery，只需要将如下代码粘贴到网页中即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者这个：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完整：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="jQuery核心函数"><a href="#jQuery核心函数" class="headerlink" title="jQuery核心函数"></a>jQuery核心函数</h2><p>引入jQuery后，它会自动在全局作用域添加一个名为<code>jQuery</code>的新函数，新函数还有一个别名<code>$</code>。换句话说，通过<code>jQuery</code>和<code>$</code>都可以访问到这个函数，这个函数我们称为jQuery的核心函数。我们引入jQuery目的就是得到这个函数，学习jQuery也就是在学习这个核心函数。</p><p>可以通过两种方式来使用核心函数，一种是将其作为对象使用，此时它是一个工具类，在其中封装了一些属性和方法。</p><ul><li>jQuery.contains()</li><li>jQuery.isArray()</li><li>jQuery.isFunction()</li><li>jQuery.isNumeric()</li><li>……</li></ul><p>另一种是将其作为函数调用，根据参数的不同可以会发挥不同的作用。</p><ul><li>jQuery(函数)</li><li>jQuery(选择器)</li><li>jQuery(DOM对象)</li><li>jQuery(HTML代码)</li></ul><p>注意：上述编写代码时可以使用$代替jQuery。</p><h3 id="【函数作为参数】"><a href="#【函数作为参数】" class="headerlink" title="【函数作为参数】"></a>【函数作为参数】</h3><p>当使用函数作为jQuery的参数时，jQuery会使该函数在文档加载完毕后执行，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="【选择器字符串作为参数】"><a href="#【选择器字符串作为参数】" class="headerlink" title="【选择器字符串作为参数】"></a>【选择器字符串作为参数】</h3><p>如果将一个选择器字符串作为参数传递给核心函数，则jQuery会根据选择器去页面中查询元素，并将查询到的元素返回，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> $box1 = $(<span class="hljs-string">&quot;#box1&quot;</span>) <span class="hljs-comment">// 获取id为box1的元素</span><br><span class="hljs-keyword">var</span> $news = $(<span class="hljs-string">&quot;.news&quot;</span>) <span class="hljs-comment">// 获取class为news的元素</span><br><span class="hljs-keyword">var</span> $hello = $(<span class="hljs-string">&quot;[title=hello]&quot;</span>) <span class="hljs-comment">// 获取title属性为hello的元素</span><br></code></pre></td></tr></table></figure><p>注意！通过jQuery核心函数获取到的对象并不是我们所熟悉的DOM对象，而是一个由jQuery定义的新对象，为了和我们熟悉的DOM对象做区分，这个对象我们称之为jQuery对象。<font color="#409eff">记住！通过jQuery核心函数获取到的对象是jQuery对象。</font></p><p>DOM对象本身存在着一些不足，比如兼容问题、操作不方便等，为了解决这些问题，jQuery设计了一个新的对象，jQuery对象。可以将jQuery对象理解为DOM对象的升级版，为DOM对象增加了许多功能，同时解决了DOM对象的兼容性问题，关于jQuery对象的细节后续讲解。</p><h3 id="【DOM对象作为参数】"><a href="#【DOM对象作为参数】" class="headerlink" title="【DOM对象作为参数】"></a>【DOM对象作为参数】</h3><p>如果将一个DOM对象作为参数，核心函数会将其转换为jQuery对象并返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> box1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;box1&quot;</span>) <span class="hljs-comment">// 获取DOM对象</span><br><span class="hljs-keyword">var</span> $box1 = $(box1) <span class="hljs-comment">// 转换为jQuery对象</span><br></code></pre></td></tr></table></figure><h3 id="【HTML代码作为参数】"><a href="#【HTML代码作为参数】" class="headerlink" title="【HTML代码作为参数】"></a>【HTML代码作为参数】</h3><p>如果将一段HTML代码作为参数，核心函数会根据HTML代码创建jQuery对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> $div = $(<span class="hljs-string">&quot;&lt;div/&gt;&quot;</span>)<br><span class="hljs-keyword">var</span> $span = $(<span class="hljs-string">&quot;&lt;span&gt;这是一个span&lt;/span&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h2><p>如上所述，jQuery对象时jQuery中新定义的对象，它像是一个用来存储DOM对象的数组（类型并不是Array）。可以通过length来获取其中DOM元素的数量，也可以通过索引来获取其中的某个元素。但是jQuery对象又并不是那么的简单，在它里边为我们提供了很多好用的方法，使我们可以快速的操作其中的DOM对象。</p><p>使用jQuery对象进行DOM操作时，无需再调用原生DOM的方法，直接调用jQuery对象的方法即可。通过jQuery对象进行修改操作时，会同时修改jQuery对象中的所有DOM对象，举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script/jquery/jquery-3.6.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>孙悟空<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>猪八戒<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沙和尚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>唐僧<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>       <br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">            $(<span class="hljs-string">&quot;li&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;新值&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上例中，页面中有四个li，<code>$(&quot;li&quot;)</code>通过选择器获取页面中的所有li，<code>text()</code>是jQuery对象的方法用于获取或修改元素内部的文本内容。<code>$(&quot;li&quot;).text(&quot;新值&quot;)</code>调用后会修改所有的li中的文本内容。</p><p>这一特性被称为隐式迭代，隐式迭代的存在使得我们在修改多个DOM元素时不再需要遍历，一个方法即可修改所有元素。但是隐式迭代并不意外着不迭代不遍历，实际的遍历操作在jQuery对象内部完成。</p><p>jQuery对象的大部分方法都会将jQuery对象自身作为返回值，这意味着通过jQuery对象调用方法后，可以继续调用其他的方法，比如这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./script/jquery/jquery-3.6.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>孙悟空<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>猪八戒<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沙和尚<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>唐僧<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript">            $(<span class="hljs-string">&quot;li&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;新的内容&quot;</span>).<span class="hljs-title function_">css</span>(&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>$(&quot;li&quot;).text(&quot;新的内容&quot;).css(&#123;color:&quot;red&quot;&#125;)</code>在修改文本后继续修改jQuery对象的样式，这一特性被称为链式调用，通过链式调用可以一次性对jQuery对象做多个操作。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>addClass()</p><ul><li>为jQuery对象添加一个或多个class</li></ul><p>hasClass()</p><ul><li>检查jQuery对象是否含有某个class</li></ul><p>removeClass()</p><ul><li>删除jQuery对象的指定class</li></ul><p>toggleClass()</p><ul><li>切换jQuery对象的指定class</li></ul><hr><p>clone()</p><ul><li>复制jQuery元素</li></ul><hr><p>unwrap()</p><ul><li>去除父元素</li></ul><p>wrap()</p><ul><li>添加父元素</li></ul><p>wrapAll()</p><ul><li>添加父元素</li></ul><p>wrapInner()</p><ul><li>在元素内部增加一层</li></ul><hr><p>append()</p><ul><li>添加子元素</li></ul><p>appendTo()</p><ul><li>添加到父元素</li></ul><p>prepend()</p><ul><li>向前添加子元素</li></ul><p>prependTo()</p><ul><li>添加到父元素前</li></ul><p>html()</p><ul><li>读取或设置html代码</li></ul><p>text()</p><ul><li>读取或设置文本内容</li></ul><hr><p>after()</p><ul><li>向后边添加元素</li></ul><p>insertAfter()</p><ul><li>将元素添加到某元素的后边</li></ul><p>before()</p><ul><li>向前边添加元素</li></ul><p>insertBefore()</p><ul><li>将元素添加到某元素的前边</li></ul><hr><p>detach()</p><ul><li>删除元素（保留元素上的事件）</li></ul><p>empty()</p><ul><li>删除所有子元素</li></ul><p>remove()</p><ul><li>删除元素</li></ul><hr><p>replaceAll()</p><ul><li>替换某个元素</li></ul><p>replaceWith()</p><ul><li>被某个元素替换</li></ul><hr><p>attr()</p><ul><li>设置&#x2F;获取元素的指定属性</li><li>布尔值属性会返回实际值</li></ul><p>prop()</p><ul><li>设置&#x2F;获取元素的指定属性</li><li>布尔值属性会返回布尔值</li></ul><p>removeAttr()</p><ul><li>移除属性</li></ul><p>removeProp()</p><ul><li>移除属性</li></ul><p>val()</p><ul><li>设置&#x2F;获取元素的value属性</li></ul><hr><p>css()</p><ul><li>读取&#x2F;设置元素的css样式</li></ul><p>height()</p><ul><li>读取&#x2F;设置元素的高度</li></ul><p>width()</p><ul><li>读取&#x2F;设置元素的宽度</li></ul><p>innerHeight()</p><ul><li>读取&#x2F;设置元素的内部高度</li></ul><p>innerWidth()</p><ul><li>读取&#x2F;设置元素的内部宽度</li></ul><p>outerHeight()</p><ul><li>读取&#x2F;设置元素可见框的高度</li></ul><p>outerWidth()</p><ul><li>读取&#x2F;设置元素可见框的宽度</li></ul><p>offset()</p><ul><li>读取&#x2F;设置元素的偏移量</li></ul><p>position()</p><ul><li>读取元素相当于包含块的偏移量</li></ul><p>scrollLeft()</p><ul><li>读取&#x2F;设置元素水平滚动条的位置</li></ul><p>scrollTop()</p><ul><li>读取&#x2F;设置元素垂直滚动条的位置</li></ul><hr><p>eq()</p><ul><li>获取指定索引的元素</li></ul><p>even()</p><ul><li>获取索引为偶数的元素</li></ul><p>odd()</p><ul><li>获取索引为奇数的元素</li></ul><p>filter()</p><ul><li>筛选元素</li></ul><p>first()</p><ul><li>获取第一个元素</li></ul><p>last()</p><ul><li>获取最后一个元素</li></ul><p>has()</p><ul><li>获取含有指定后代的元素</li></ul><p>is()</p><ul><li>检查是否含有某元素</li></ul><p>map()</p><ul><li>获取对象中的指定数据</li></ul><p>slice()</p><ul><li>截取元素（切片）</li></ul><hr><p>add()</p><ul><li>创建包含当前元素的新的jQuery对象</li></ul><p>addBack()</p><ul><li>将之前操作的集合中的元素添加到当前集合中</li></ul><p>contents()</p><ul><li>获取当前jQuery对象的所有子节点（包括文本节点）</li></ul><p>end()</p><ul><li>将筛选过的列表恢复到之前的状态</li></ul><p>not()</p><ul><li>从列表中去除符合条件的元素</li></ul><hr><p>children()</p><ul><li>获取子元素</li></ul><p>closest()</p><ul><li>获取离当前元素最近的指定元素</li></ul><p>find()</p><ul><li>查询指定的后代元素</li></ul><p>next()</p><ul><li>获取后一个兄弟元素</li></ul><p>nextAll()</p><ul><li>获取后边所有的兄弟元素</li></ul><p>nextUntil()</p><ul><li>获取后边指定位置的兄弟元素</li></ul><p>offsetParent()</p><ul><li>获取定位父元素</li></ul><p>parent()</p><ul><li>获取父元素</li></ul><p>parents()</p><ul><li>获取所有的祖先元素</li></ul><p>parensUntil()</p><ul><li>获取指定的祖先元素</li></ul><p>prev()</p><ul><li>获取前边的兄弟元素</li></ul><p>prevAll()</p><ul><li>获取前边所有的兄弟元素</li></ul><p>prevUntil()</p><ul><li>获取指定的兄弟元素</li></ul><p>siblings()</p><ul><li>获取所有的兄弟元素</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端三件套</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYVUE3-2025-07-23</title>
    <link href="/2025/07/23/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/MYVUE3-2025-07-23/"/>
    <url>/2025/07/23/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/MYVUE3-2025-07-23/</url>
    
    <content type="html"><![CDATA[<p>本项目基于【尚硅谷-硅谷甄选】项目复现学习VUE3和TypeScript。</p><span id="more"></span><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><p>临时决定将项目复现过程记录下来，由于项目配置之前已经配置完成，直接将代码贴出。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="【tsconfig-json】"><a href="#【tsconfig-json】" class="headerlink" title="【tsconfig.json】"></a>【<code>tsconfig.json</code>】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;files&quot;</span>: [],<br>  <span class="hljs-string">&quot;references&quot;</span>: [<br>    &#123; <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./tsconfig.app.json&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./tsconfig.node.json&quot;</span> &#125;<br>  ],<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;verbatimModuleSyntax&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-comment">// 解析非相对模块的基地址，默认是当前目录</span><br>    <span class="hljs-string">&quot;paths&quot;</span>: &#123; <span class="hljs-comment">//路径映射，相对于baseUrl</span><br>      <span class="hljs-string">&quot;@/*&quot;</span>: [<span class="hljs-string">&quot;src/*&quot;</span>] <br>    &#125;<br>  &#125;,<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="【tsconfig-app-json】"><a href="#【tsconfig-app-json】" class="headerlink" title="【tsconfig.app.json】"></a>【<code>tsconfig.app.json</code>】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;extends&quot;</span>: <span class="hljs-string">&quot;@vue/tsconfig/tsconfig.dom.json&quot;</span>,<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;tsBuildInfoFile&quot;</span>: <span class="hljs-string">&quot;./node_modules/.tmp/tsconfig.app.tsbuildinfo&quot;</span>,<br>    <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-comment">// 解析非相对模块的基地址，默认是当前目录</span><br>    <span class="hljs-comment">/* Linting */</span><br>    <span class="hljs-string">&quot;verbatimModuleSyntax&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;erasableSyntaxOnly&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noUncheckedSideEffectImports&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;composite&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;paths&quot;</span>: &#123; <span class="hljs-comment">//路径映射，相对于baseUrl</span><br>      <span class="hljs-string">&quot;@/*&quot;</span>: [<span class="hljs-string">&quot;src/*&quot;</span>] <br>    &#125;<br>  &#125;,<br>    <span class="hljs-string">&quot;include&quot;</span>: [<br>    <span class="hljs-string">&quot;src/**/*.ts&quot;</span>,<br>    <span class="hljs-string">&quot;src/**/*.tsx&quot;</span>,<br>    <span class="hljs-string">&quot;src/**/*.vue&quot;</span>,<br>    <span class="hljs-string">&quot;src/**/*.d.ts&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;exclude&quot;</span>: [<br>    <span class="hljs-string">&quot;node_modules&quot;</span>,<br>    <span class="hljs-string">&quot;**/*.spec.ts&quot;</span><br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【tsconfig-node-json】"><a href="#【tsconfig-node-json】" class="headerlink" title="【tsconfig.node.json】"></a>【<code>tsconfig.node.json</code>】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;tsBuildInfoFile&quot;</span>: <span class="hljs-string">&quot;./node_modules/.tmp/tsconfig.node.tsbuildinfo&quot;</span>,<br>    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;ES2023&quot;</span>,<br>    <span class="hljs-string">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;ES2023&quot;</span>],<br>    <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;ESNext&quot;</span>,<br>    <span class="hljs-string">&quot;skipLibCheck&quot;</span>: <span class="hljs-literal">true</span>,<br><br>    <span class="hljs-comment">/* Bundler mode */</span><br>    <span class="hljs-string">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;bundler&quot;</span>,<br>    <span class="hljs-string">&quot;allowImportingTsExtensions&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;verbatimModuleSyntax&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;moduleDetection&quot;</span>: <span class="hljs-string">&quot;force&quot;</span>,<br>    <span class="hljs-string">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;composite&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">/* Linting */</span><br>    <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;erasableSyntaxOnly&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;noUncheckedSideEffectImports&quot;</span>: <span class="hljs-literal">true</span><br>    <br>  &#125;,<br>  <span class="hljs-string">&quot;include&quot;</span>: [<span class="hljs-string">&quot;vite.config.ts&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【vite-config-ts"><a href="#【vite-config-ts" class="headerlink" title="【vite.config.ts]"></a>【<code>vite.config.ts</code>]</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><br><span class="hljs-comment">// https://vite.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>),<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-comment">// vite.config.js</span><br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>      <span class="hljs-attr">scss</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@use &quot;@/styles/variable.scss&quot; as *;`</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="【vite-env-d-ts"><a href="#【vite-env-d-ts" class="headerlink" title="【vite-env.d.ts]"></a>【<code>vite-env.d.ts</code>]</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;*.vue&#x27;</span> &#123;<br>  <span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">DefineComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">component</span>: <span class="hljs-title class_">DefineComponent</span>&lt;&gt;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> component<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h1><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><h3 id="【src-router-index-ts"><a href="#【src-router-index-ts" class="headerlink" title="【src/router/index.ts]"></a>【<code>src/router/index.ts</code>]</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过vue-router插件实现模板路由配置</span><br><span class="hljs-keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">import</span> &#123;commonRoutes&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./routes&#x27;</span><br><br><span class="hljs-comment">// 定义路由</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>:<span class="hljs-title function_">createWebHistory</span>(),<br>   <br>  <span class="hljs-attr">routes</span>:[<br>    ...commonRoutes,<br>  ]<br>&#125;)<br><br><span class="hljs-comment">// 导出路由</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><h3 id="【src-router-routers-ts"><a href="#【src-router-routers-ts" class="headerlink" title="【src/router/routers.ts]"></a>【<code>src/router/routers.ts</code>]</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> commonRoutes = [<br>  &#123;<br>    <span class="hljs-attr">alias</span>: [<span class="hljs-string">&#x27;/index&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>],<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/home/index.vue&#x27;</span>),<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;首页&#x27;</span>,<br>      <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/login/index.vue&#x27;</span>),<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;登录&#x27;</span>,<br>      <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>]<br><span class="hljs-keyword">export</span> &#123;commonRoutes&#125;<br></code></pre></td></tr></table></figure><h3 id="【main-ts】"><a href="#【main-ts】" class="headerlink" title="【main.ts】"></a>【<code>main.ts</code>】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-comment">// 引入路由</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-comment">// 引入状态管理库</span><br><span class="hljs-keyword">import</span> pinia <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-comment">// 引入全局样式</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/styles/index.scss&#x27;</span><br><br><span class="hljs-comment">// 引入element-plus</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-title function_">use</span>(pinia)<br>app.<span class="hljs-title function_">use</span>(router) <br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="模拟用户请求接口"><a href="#模拟用户请求接口" class="headerlink" title="模拟用户请求接口"></a>模拟用户请求接口</h2><h3 id="【src-api-user-ts】"><a href="#【src-api-user-ts】" class="headerlink" title="【src/api/user.ts】"></a><code>【src/api/user.ts】</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 没有接口，模拟接口函数。</span><br><br><span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">UserInfo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/type&quot;</span><br><br><span class="hljs-comment">// 登录请求接口</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RequireLogin</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">data:UserInfo</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (data.<span class="hljs-property">username</span> === <span class="hljs-string">&#x27;cxdlogver&#x27;</span> &amp;&amp; data.<span class="hljs-property">password</span> === <span class="hljs-string">&#x27;123456&#x27;</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span>,<br>          <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;ADMIN_TOKEN&#x27;</span>,<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">400</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;登录失败&#x27;</span>,<br>        &#125;)<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 用户信息请求接口</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">RequireUserInfoFromToken</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">token:string</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (token === <span class="hljs-string">&#x27;ADMIN_TOKEN&#x27;</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;用户信息获取成功&#x27;</span>,<br>          <span class="hljs-attr">userInfo</span>: &#123;<br>            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;cxdlogver&#x27;</span>,<br>            <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>          &#125;<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(&#123;<br>          <span class="hljs-attr">code</span>: <span class="hljs-number">400</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;用户信息获取失败&#x27;</span>,<br>        &#125;)<br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-title class_">RequireLogin</span>, <span class="hljs-title class_">RequireUserInfoFromToken</span> &#125;<br></code></pre></td></tr></table></figure><p>模拟两个接口 用户登录接口 和 用户信息请求接口。</p><h2 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- eslint-disable @typescript-eslint/no-explicit-any --&gt;<br>&lt;!-- 具名插槽 --&gt;<br>&lt;!-- el-row 布局 --&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;login_container&quot;&gt;<br>    &lt;el-row&gt;<br>      &lt;el-col :span=&quot;12&quot; :xs=&quot;0&quot;&gt;&lt;/el-col&gt;<br>      &lt;el-col :span=&quot;12&quot; :xs=&quot;24&quot;&gt;<br>        &lt;el-form ref=&quot;formRef&quot; class=&quot;login_form&quot; :model=&quot;user&quot; :rules=&quot;rules&quot;&gt;<br>          &lt;h1 class=&quot;title&quot;&gt;Hello&lt;/h1&gt;<br>          &lt;h2 class=&quot;sub_title&quot;&gt;欢迎来到项目管理系统&lt;/h2&gt;<br>          &lt;el-form-item prop=&quot;username&quot;&gt;<br>            &lt;el-input<br>              v-model=&quot;user.username&quot;<br>              placeholder=&quot;请输入用户名&quot;<br>              type=&quot;text&quot;<br>              clearable<br>            &gt;<br>              &lt;template v-slot:prefix&gt;<br>                &lt;el-icon&gt;&lt;User /&gt;&lt;/el-icon&gt;<br>              &lt;/template&gt;<br>            &lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>          &lt;el-form-item prop=&quot;password&quot;&gt;<br>            &lt;el-input<br>              v-model=&quot;user.password&quot;<br>              :prefix-icon=&quot;Lock&quot;<br>              placeholder=&quot;请输入密码&quot;<br>              type=&quot;password&quot;<br>              show-password<br>            &gt;&lt;/el-input&gt;<br>          &lt;/el-form-item&gt;<br>          &lt;el-form-item&gt;<br>            &lt;el-button<br>              :loading=&quot;loading&quot;<br>              type=&quot;primary&quot;<br>              @click=&quot;login&quot;<br>              size=&quot;default&quot;<br>              style=&quot;width: 100%&quot;<br>            &gt;<br>              登录<br>            &lt;/el-button&gt;<br>          &lt;/el-form-item&gt;<br>        &lt;/el-form&gt;<br>      &lt;/el-col&gt;<br>    &lt;/el-row&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123; reactive, ref &#125; from &#x27;vue&#x27;;<br>import &#123; User, Lock &#125; from &#x27;@element-plus/icons-vue&#x27;;<br>import &#123; useRouter &#125; from &#x27;vue-router&#x27;;<br>import &#123; useRoute &#125; from &#x27;vue-router&#x27;;<br>import &#123; ElNotification &#125; from &#x27;element-plus&#x27;;<br>import &#123; getTime &#125; from &#x27;@/utils/time&#x27;;<br>import &#123; useUserStore &#125; from &#x27;@/store/user&#x27;;<br>import &#123; RequireLogin &#125; from &#x27;@/api/user&#x27;;<br><br>// 用户信息<br>const user = reactive(&#123;<br>  username: &#x27;cxdlogver&#x27;,<br>  password: &#x27;123456&#x27;,<br>&#125;);<br>const loading = ref(false); // 登录loading<br>const router = useRouter(); // 路由实例<br>const route = useRoute(); // 路由参数<br>const userStore = useUserStore()<br>// 校验规则<br>const validatorUserName = (rule: any, value: any, callback: any) =&gt; &#123;<br>  if (!value) &#123;<br>    callback(new Error(&#x27;请输入用户名&#x27;));<br>  &#125; else if (value.length &lt; 6) &#123;<br>    callback(new Error(&#x27;用户名长度不能小于6位&#x27;));<br>  &#125; else &#123;<br>    callback();<br>  &#125;<br>&#125;;<br><br>const validatorPassword = (rule: any, value: any, callback: any) =&gt; &#123;<br>  if (!value) &#123;<br>    callback(new Error(&#x27;请输入密码&#x27;));<br>  &#125; else if (value.length &lt; 6) &#123;<br>    callback(new Error(&#x27;密码长度不能小于6位&#x27;));<br>  &#125; else &#123;<br>    callback();<br>  &#125;<br>&#125;;<br><br>const rules = reactive(&#123;<br>  username: [&#123; validator: validatorUserName, trigger: &#x27;change&#x27; &#125;],<br>  password: [&#123; validator: validatorPassword, trigger: &#x27;change&#x27; &#125;],<br>&#125;);<br><br>// 校验函数<br>const formRef = ref();<br><br>// 登录按钮<br>const login = async () =&gt; &#123;<br>  await formRef.value.validate();<br>  // 加载效果<br>  loading.value = true;<br>  //点击登录按钮以后干什么?<br>  //通知仓库发登录请求<br>  //请求成功-&gt;首页展示数据的地方<br>  //请求失败-&gt;弹出登录失败信息<br>  const res:any = await RequireLogin(user) <br>  if (res.code === 200)&#123;<br>    await userStore.GetUserInfoFromToken(res.token || &quot;&quot;)<br>    ElNotification(&#123;<br>      type: &#x27;success&#x27;,<br>      message: &#x27;欢迎回来&#x27;,<br>      title: `HI,$&#123;getTime()&#125;好`,<br>    &#125;);<br>    //登录成功加载效果也消失<br>    loading.value = false;<br>    const redirect = route.query.redirect;<br>    if (redirect) &#123;<br>      router.push(redirect as string);<br>    &#125; else &#123;<br>      router.push(&#x27;/home&#x27;);<br>    &#125;<br>  &#125;else &#123;<br>    ElNotification(&#123;<br>      type: &#x27;error&#x27;,<br>      message: &#x27;用户名或密码错误&#x27;,<br>      title: `登录失败`,<br>    &#125;);<br>    //登录失败加载效果也消失<br>    loading.value = false;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br>&lt;style scoped lang=&quot;scss&quot;&gt;<br>.login_container &#123;<br>  width: 100%;<br>  height: 100vh;<br>  background: url(&#x27;@/assets/images/background.jpg&#x27;) no-repeat;<br>  background-size: cover;<br><br>  .login_form &#123;<br>    position: relative;<br>    width: 80%;<br>    top: 30vh;<br>    background: url(&#x27;@/assets/images/login_form.png&#x27;) no-repeat;<br>    background-size: cover;<br>    padding: 40px;<br><br>    h1 &#123;<br>      color: white;<br>      font-size: 40px;<br>    &#125;<br><br>    h2 &#123;<br>      font-size: 20px;<br>      color: white;<br>      margin: 20px 0px;<br>    &#125;<br><br>    .login_btn &#123;<br>      width: 100%;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>主要的重点在于Form的规则验证</p></blockquote><h3 id="【Form规则校验】"><a href="#【Form规则校验】" class="headerlink" title="【Form规则校验】"></a>【<code>Form</code>规则校验】</h3><p>登录注册页面通过在 Vue 中做表单规则校验，通常会使用 UI 框架（如 Element Plus、Naive UI、Ant Design Vue）内置的 <strong>表单验证机制</strong>。</p><ol><li><code>el-form</code>的<code>rules</code>属性渲染规则。</li><li><code>el-form</code>的<code>prop</code>属性根据值加载规则。</li></ol><p>主要分为三部分。</p><p><strong>1. 校验规则</strong></p><blockquote><p>Element Plus 的 <code>rules</code> 是基于 <a href="https://github.com/yiminghe/async-validator"><code>async-validator</code></a> 实现的，所以校验规则属性来源于它。</p></blockquote><table><thead><tr><th>属性名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>required</code></td><td><code>boolean</code></td><td>是否必填</td></tr><tr><td><code>message</code></td><td><code>string</code></td><td>校验失败时提示的信息</td></tr><tr><td><code>trigger</code></td><td>&#96;’blur’</td><td>‘change’&#96;</td></tr><tr><td><code>min</code></td><td><code>number</code></td><td>字符串或数组的最小长度</td></tr><tr><td><code>max</code></td><td><code>number</code></td><td>字符串或数组的最大长度</td></tr><tr><td><code>type</code></td><td><code>string</code></td><td>类型校验，如 <code>string</code>、<code>number</code>、<code>boolean</code>、<code>array</code>、<code>email</code> 等</td></tr><tr><td><code>pattern</code></td><td><code>RegExp</code></td><td>正则表达式</td></tr><tr><td><code>len</code></td><td><code>number</code></td><td>字符串或数组的长度必须等于该值</td></tr><tr><td><code>enum</code></td><td><code>array</code></td><td>值必须为列举中的某一个</td></tr><tr><td><code>whitespace</code></td><td><code>boolean</code></td><td>是否允许全空格字符串（一般用于字符串 <code>required: true</code> 时控制空格）</td></tr><tr><td><code>validator</code></td><td><code>Function</code></td><td><code>AsyncFunction</code></td></tr><tr><td><code>fields</code></td><td><code>object</code></td><td>嵌套对象的字段校验规则（多用于嵌套表单对象）</td></tr><tr><td><code>defaultField</code></td><td><code>object</code></td><td>用于数组中的每一项校验</td></tr></tbody></table><p><strong>2. 自定义校验函数</strong></p><p>如果你要做复杂校验，比如密码确认或异步校验用户名是否重复：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> rules = &#123;<br>  <span class="hljs-attr">confirmPassword</span>: [<br>    &#123;<br>      <span class="hljs-attr">validator</span>: <span class="hljs-function">(<span class="hljs-params">rule, value, callback</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (value !== form.<span class="hljs-property">value</span>.<span class="hljs-property">password</span>) &#123;<br>          <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;两次输入的密码不一致&#x27;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 校验通过</span><br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span><br>    &#125;<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以用 async&#x2F;await 的 <code>async-validator</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">validator</span>: <span class="hljs-title function_">async</span> (rule, value) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> <span class="hljs-title function_">checkUsernameExist</span>(value);<br>    <span class="hljs-keyword">if</span> (exists) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;用户名已存在&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 校验方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> formRef = <span class="hljs-title function_">ref</span>() <span class="hljs-comment">// 获取el-form实例</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">validate</span> = (<span class="hljs-params"></span>) =&gt; &#123; <span class="hljs-comment">// 校验方法</span><br>  formRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (valid) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;submit!&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;error submit!!&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Pinia配置"><a href="#Pinia配置" class="headerlink" title="Pinia配置"></a>Pinia配置</h2><h3 id="【src-user-ts】"><a href="#【src-user-ts】" class="headerlink" title="【src/user.ts】"></a>【<code>src/user.ts</code>】</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span><br><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">UserInfo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/type&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">RequireUserInfoFromToken</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/api/user&quot;</span><br><br><span class="hljs-comment">// 创建用户仓库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">/** store */</span><br>  <span class="hljs-keyword">const</span> user = reactive&lt;<span class="hljs-title class_">UserInfo</span>&gt;(&#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">token</span>: <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>) || <span class="hljs-string">&quot;&quot;</span><br>  &#125;)<br><br>  <span class="hljs-comment">/** action */</span><br>  <span class="hljs-comment">// 更新用户信息</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">UpdateUserInfo</span> = (<span class="hljs-params">userInfo: UserInfo</span>)=&gt;&#123;<br>    user.<span class="hljs-property">username</span> = userInfo.<span class="hljs-property">username</span><br>    user.<span class="hljs-property">password</span> = userInfo.<span class="hljs-property">password</span><br>    user.<span class="hljs-property">token</span> = userInfo.<span class="hljs-property">token</span><br>    <br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, userInfo.<span class="hljs-property">token</span> <span class="hljs-keyword">as</span> string)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;更新用户信息&quot;</span>,userInfo);<br>  &#125;<br>  <span class="hljs-comment">// 根据token获取用户信息</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">GetUserInfoFromToken</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">token: string</span>)=&gt;&#123;<br>    <span class="hljs-keyword">if</span> (token != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      <span class="hljs-comment">// 需要写一个根据token请求用户信息的接口</span><br>      <span class="hljs-comment">// 这里需要根据token请求用户信息</span><br>      <span class="hljs-comment">// 假设请求成功后，将用户信息赋值给user</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">res</span>:any = <span class="hljs-keyword">await</span> <span class="hljs-title class_">RequireUserInfoFromToken</span>(token)<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title class_">UpdateUserInfo</span>(&#123;<br>          <span class="hljs-attr">username</span>: res.<span class="hljs-property">userInfo</span>.<span class="hljs-property">username</span>,<br>          <span class="hljs-attr">password</span>: res.<span class="hljs-property">userInfo</span>.<span class="hljs-property">password</span>,<br>          <span class="hljs-attr">token</span>: token<br>        &#125;)<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>    &#125;    <br>    user.<span class="hljs-property">username</span> = <span class="hljs-string">&quot;&quot;</span><br>    user.<span class="hljs-property">password</span> = <span class="hljs-string">&quot;&quot;</span><br>    user.<span class="hljs-property">token</span> = <span class="hljs-string">&quot;&quot;</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    user, <span class="hljs-title class_">UpdateUserInfo</span>, <span class="hljs-title class_">GetUserInfoFromToken</span><br>  &#125;<br>&#125;  <br>)<br></code></pre></td></tr></table></figure><blockquote><p>上述是已经完成的部分，简短记录。</p></blockquote><h1 id="首页界面"><a href="#首页界面" class="headerlink" title="首页界面"></a>首页界面</h1><h2 id="用户信息判断"><a href="#用户信息判断" class="headerlink" title="用户信息判断"></a>用户信息判断</h2><p>根据<code>localStorage</code>判断是否保存<code>token</code>，没有跳转到<code>login</code>界面，有则根据<code>token</code>获取用户信息。</p><p><strong><code>src/home/index.vue</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()<br>userStore.<span class="hljs-title class_">GetUserInfoFromToken</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>) || <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">// 用户信息</span><br><span class="hljs-keyword">const</span> user = userStore.<span class="hljs-property">user</span><br><br><span class="hljs-comment">// 路由实例</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()<br><span class="hljs-keyword">if</span> (user.<span class="hljs-property">token</span> === <span class="hljs-string">&quot;&quot;</span>) &#123; <br>  <span class="hljs-comment">// 如果用户不存在， 跳转到登录界面</span><br>  router.<span class="hljs-title function_">push</span>(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">query</span>:&#123;<br>      <span class="hljs-attr">redirect</span>:router.<span class="hljs-property">currentRoute</span>.<span class="hljs-property">value</span>.<span class="hljs-property">fullPath</span> <br>      <span class="hljs-comment">// 将当前路由路径作为参数传递给登录界面</span><br>    &#125;<br>  &#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 如果用户存在， 显示用户信息</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><img src="/2025/07/23/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/MYVUE3-2025-07-23/image-20250723171112308.png" class title="image-20250723171112308"><p>利用<code>el-container</code>、<code>el-aside</code>、<code>el-header</code>、<code>el-main</code>进行页面布局。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layout_container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-aside</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layout_left&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Menu</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Menu</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-aside</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layout_right&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">el-header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layout_header&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span> 页面布局 <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-header</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">el-main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layout_main&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-main</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2025/07/23/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/MYVUE3-2025-07-23/image-20250723171257295.png" class title="image-20250723171257295"><p><strong>初步效果图</strong></p><img src="/2025/07/23/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/MYVUE3-2025-07-23/image-20250725014441834.png" class title="image-20250725014441834"><h2 id="菜单设计"><a href="#菜单设计" class="headerlink" title="菜单设计"></a>菜单设计</h2><blockquote><p><font color="#409eff"><strong>知识点总结</strong></font></p></blockquote><p>1.icon图标显示必须先全局引入所有Element Plus图标</p><p>2.菜单配置项中path属性必须以’&#x2F;‘开头, 如果不是’&#x2F;‘开头，会替换当前url的最后一个</p><p>例如 当前url为 <code>/acl/usr</code>, 菜单配置项中path属性为 ‘home’, 则会替换为 <code>/acl/home</code></p><p>3.菜单配置项中path属性如果以’&#x2F;‘开头，会直接替换当前url</p><p>例如 当前url为 <code>/acl/usr</code>, 菜单配置项中path属性为 <code>/home</code>, 则会替换为 <code>/home</code></p><p>4.重点了解如何将NavMenu菜单项根据Routes路由项展示。</p><p>5.<code>&lt;component :is=&quot;item.children[0].meta.icon&quot; /&gt; </code>动态组件</p><p>6.递归调用自身,需要定义组件名,否则会报错</p><p>7.ref和reactive定义对象和数组的区别</p><p><strong><code>src/view/layout/menu/index.vue</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in menuList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.path&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.children &amp;&amp; !item.meta.hidden&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 如果没有children属性，本身就是菜单项 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;item.path&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span></span><br><span class="language-xml">          &#123;&#123; item.meta.title &#125;&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;item.children &amp;&amp; item.children.length === 1&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 如果有一个children属性，children作为el-menu-item菜单项 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;item.children[0].path&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.children[0].meta.icon&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span></span><br><span class="language-xml">          &#123;&#123; item.children[0].meta.title &#125;&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;item.children &amp;&amp; item.children.length &gt; 1&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-comment">&lt;!-- 如果有多个children属性，children作为el-menu-submenu子菜单 --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-sub-menu</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;item.path&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">title</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span> /&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">          &#123;&#123; item.meta.title &#125;&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Menu</span> <span class="hljs-attr">:menuList</span>=<span class="hljs-string">&quot;item.children&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-sub-menu</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Menu&#x27;</span> &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineProps</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">menuList</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong><code>src/router/routes.ts</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> commonRoutes = [<br>  &#123;<br>    <span class="hljs-attr">alias</span>: [<span class="hljs-string">&#x27;/layout&#x27;</span>],<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/layout/index.vue&#x27;</span>),<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;layout&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;布局&#x27;</span>,<br>      <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//代表路由标题在菜单中是否隐藏  true:隐藏 false:不隐藏</span><br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">//菜单文字左侧的图标,支持element-plus全部图标</span><br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/home/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;首页&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;HomeFilled&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/login/index.vue&#x27;</span>),<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;登录&#x27;</span>,<br>      <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;Promotion&#x27;</span>, <span class="hljs-comment">//菜单文字左侧的图标,支持element-plus全部图标</span><br>    &#125;,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/acl&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/layout/index.vue&#x27;</span>),<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;acl&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;权限管理&#x27;</span>,<br>      <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;Lock&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/acl/user&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/acl/user/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;用户管理&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/acl/role&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/acl/role/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Role&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;角色管理&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;UserFilled&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/acl/permission&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/acl/permission/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Permission&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;菜单管理&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;Monitor&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/layout/index.vue&#x27;</span>),<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Product&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;商品管理&#x27;</span>,<br>      <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;Goods&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/product/trademark&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/trademark&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/product/trademark/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Trademark&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;品牌管理&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;ShoppingCartFull&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/attr&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/product/attr/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Attr&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;属性管理&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;ChromeFilled&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/spu&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/product/spc/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Spu&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;SPU管理&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;Calendar&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/sku&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/product/sku/index.vue&#x27;</span>),<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Sku&#x27;</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;SKU管理&#x27;</span>,<br>          <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;Orange&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/screen&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/view/screen/index.vue&#x27;</span>),<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Screen&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">hidden</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;数据大屏&#x27;</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;Platform&#x27;</span>,<br>    &#125;,<br>  &#125;,<br>];<br><br><span class="hljs-keyword">export</span> &#123; commonRoutes &#125;;<br></code></pre></td></tr></table></figure><h2 id="头部组件"><a href="#头部组件" class="headerlink" title="头部组件"></a>头部组件</h2><blockquote><p><strong><font color="#409eff">知识点总结</font></strong></p></blockquote><ol><li><code>route.matched</code>作用：返回当前路由路径所匹配的路由记录数组</li></ol><p>2.<code>useRoute()</code>和<code>useRouter()</code>api的大致了解。</p><p>3.<code>el-breadcrumb</code>、<code>el-popover</code>、<code>el-dropdown</code>、<code>el-color-picke</code>的使用。</p><p><strong><code>src/view/layout/header/index.vue</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-row</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header_container&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:sm</span>=<span class="hljs-string">&quot;14&quot;</span> <span class="hljs-attr">:xs</span>=<span class="hljs-string">&quot;19&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header_left&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-breadcrumb</span> <span class="hljs-attr">separator-icon</span>=<span class="hljs-string">&quot;ArrowRight&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in route.matched&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">el-breadcrumb-item</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!item.meta.hidden&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: item.path &#125;&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;item.meta.icon&quot;</span> /&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">              &#123;&#123; item.meta.title &#125;&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">el-breadcrumb-item</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-breadcrumb</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-col</span> <span class="hljs-attr">:sm</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">:xs</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header_right&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">icon</span>=<span class="hljs-string">&quot;Refresh&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">circle</span></span></span><br><span class="hljs-tag"><span class="language-xml">          @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;Refresh&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">icon</span>=<span class="hljs-string">&quot;FullScreen&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">circle</span></span></span><br><span class="hljs-tag"><span class="language-xml">          @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;FullScreen&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-popover</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">placement</span>=<span class="hljs-string">&quot;bottom&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;主题设置&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">:width</span>=<span class="hljs-string">&quot;300&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;click&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          <span class="hljs-comment">&lt;!-- 表单元素 --&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">el-form</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;主题颜色&quot;</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-color-picker</span></span></span><br><span class="hljs-tag"><span class="language-xml">                @<span class="hljs-attr">active-change</span>=<span class="hljs-string">&quot;SetColor&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;color&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">show-alpha</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">:predefine</span>=<span class="hljs-string">&quot;PredefineColors&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;暗黑模式&quot;</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-switch</span></span></span><br><span class="hljs-tag"><span class="language-xml">                @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;ChangeDark&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;dark&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mt-2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-left: 24px&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">inline-prompt</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">active-icon</span>=<span class="hljs-string">&quot;MoonNight&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">inactive-icon</span>=<span class="hljs-string">&quot;Sunny&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">reference</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">icon</span>=<span class="hljs-string">&quot;Setting&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">circle</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-popover</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">el-dropdown</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right_item&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">            cx</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;el-icon--right&quot;</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">arrow-down</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">dropdown</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">el-dropdown-menu</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">el-dropdown-item</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;Logout&quot;</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">el-dropdown-item</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">el-dropdown-menu</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">el-dropdown</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-col</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">el-row</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Header&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">/**</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> * 1.route.matched 作用：返回当前路由路径所匹配的路由记录数组</span></span></span><br><span class="hljs-comment"><span class="language-javascript"><span class="language-xml"> */</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useRouter, useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useUserStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store/user&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>();</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>();</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> color = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;#409eff&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> dark = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 切换暗黑模式</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ChangeDark</span> = (<span class="hljs-params">val: boolean</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  dark.<span class="hljs-property">value</span> = val;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 切换主题颜色</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">SetColor</span> = (<span class="hljs-params">val: string</span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  color.<span class="hljs-property">value</span> = val;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(color.<span class="hljs-property">value</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 预定义颜色</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title class_">PredefineColors</span> = [</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#409eff&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#ff4949&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#ff9900&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#ffcc00&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#99cc00&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#00cc66&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#0099cc&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#0066cc&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#6600cc&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#cc00cc&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#ff0099&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-string">&#x27;#ff0000&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">];</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 刷新</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Refresh</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 全屏</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">FullScreen</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">fullscreenElement</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">exitFullscreen</span>();</span></span><br><span class="language-javascript"><span class="language-xml">  &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">requestFullscreen</span>();</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 退出登录</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Logout</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  userStore.<span class="hljs-title class_">ClearUserInfo</span>();</span></span><br><span class="language-javascript"><span class="language-xml">  router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span> &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.header_container</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">justify-content</span>: space-between;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.el-col</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.header_left</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">justify-content</span>: flex-start;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.header_right</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">justify-content</span>: flex-end;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">margin</span>: auto;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-selector-class">.right_item</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>;</span></span><br><span class="language-css"><span class="language-xml">    &#125;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="主组件"><a href="#主组件" class="headerlink" title="主组件"></a>主组件</h2><blockquote><p><strong><font color="#409eff">知识点总结</font></strong></p></blockquote><p>1.router-view 插槽</p><p>2.transition 渲染</p><p>3.watch 监听函数</p><p><code>src/view/layout/main/index.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;!-- 路由组件出口的位置 --&gt;<br>  &lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;<br>    &lt;transition name=&quot;slide-right&quot;&gt;<br>      &lt;!-- 渲染layout一级路由组件的子路由 --&gt;<br>      &lt;component :is=&quot;Component&quot; v-if=&quot;flag&quot; /&gt;<br>    &lt;/transition&gt;<br>  &lt;/router-view&gt;<br>&lt;/template&gt;<br>&lt;script lang=&quot;ts&quot;&gt;<br>export default &#123;<br>  name: &#x27;Main&#x27;,<br>&#125;;<br>&lt;/script&gt;<br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123; useLayoutSettingStore &#125; from &#x27;@/store/layoutSetting&#x27;;<br>import &#123; watch, ref, nextTick &#125; from &#x27;vue&#x27;;<br>const layoutSettingStore = useLayoutSettingStore();<br>/**<br> * 1.transition 渲染layout一级路由组件的子路由<br> * 2.router-view 插槽<br> * 3.watch 监听函数<br> */<br><br>//控制当前组件是否销毁重建<br>let flag = ref(true);<br><br>//监听仓库内部数据是否发生变化,如果发生变化，说明用户点击过刷新按钮<br>watch(<br>  () =&gt; layoutSettingStore.isRefresh,<br>  () =&gt; &#123;<br>    //点击刷新按钮:路由组件销毁<br>    flag.value = false;<br>    nextTick(() =&gt; &#123;<br>      flag.value = true;<br>    &#125;);<br>  &#125;,<br>);<br>&lt;/script&gt;<br>&lt;style scoped&gt;<br>.fade-enter-from &#123;<br>  opacity: 0;<br>  transform: scale(0);<br>&#125;<br><br>.fade-enter-active &#123;<br>  transition: all 0.3s;<br>&#125;<br><br>.fade-enter-to &#123;<br>  opacity: 1;<br>  transform: scale(1);<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><blockquote><p><font color="#409eff"><strong>知识点总结</strong></font></p></blockquote><p>vue3组件通信方式</p><p>需要完成以下两个功能：</p><ol><li><code>header</code>组件设置按钮实现<code>menu</code>收起和展开的效果。</li><li><code>header</code>组件点击刷新按钮实现<code>main</code>组件内容重置。</li></ol><p>这两个功能实现需要几个组件之间进行通信。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/** 通信方式 */</span><br><span class="hljs-comment">/** 1. props */</span><br><span class="hljs-comment">/** 2. 自定义事件 */</span><br><span class="hljs-comment">/** 3. pinia通信 */</span><br><span class="hljs-comment">/** 4. provide, inject */</span><br><span class="hljs-comment">/** 5. ref和parent */</span><br><span class="hljs-comment">/** 6. mitt */</span><br><br><span class="hljs-comment">/** 用pinia通信 */</span><br><span class="hljs-keyword">import</span> &#123; useLayoutSettingStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store/layoutSetting&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; storeToRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;<br><span class="hljs-keyword">const</span> layoutSettingStore = <span class="hljs-title function_">useLayoutSettingStore</span>();<br><span class="hljs-keyword">const</span> isCollapse = <span class="hljs-title function_">storeToRefs</span>(layoutSettingStore).<span class="hljs-property">isCollapse</span>;<br><br><span class="hljs-comment">/** props */</span><br><span class="hljs-comment">// const isRefresh = ref(false);</span><br><span class="hljs-comment">// const isCollapse = ref(false);</span><br><span class="hljs-comment">// const SwitchCollapse = () =&gt; &#123;</span><br><span class="hljs-comment">//   isCollapse.value = !isCollapse.value;</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-comment">// const SwitchRefresh = () =&gt; &#123;</span><br><span class="hljs-comment">//   isRefresh.value = !isRefresh.value;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">/** 自定义事件 */</span><br><span class="hljs-comment">// const isRefresh = ref(false);</span><br><span class="hljs-comment">// const isCollapse = ref(false);</span><br><span class="hljs-comment">// const SwitchCollapse = (val: boolean) =&gt; &#123;</span><br><span class="hljs-comment">//   isCollapse.value = val;</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-comment">// const SwitchRefresh = (val: boolean) =&gt; &#123;</span><br><span class="hljs-comment">//   isRefresh.value = val;</span><br><span class="hljs-comment">// &#125;;</span><br><br><span class="hljs-comment">/** provide, inject */</span><br><span class="hljs-comment">// import &#123; provide &#125; from &#x27;vue&#x27;;</span><br><span class="hljs-comment">// const isCollapse = ref(false);</span><br><span class="hljs-comment">// const SwitchCollapse = () =&gt; &#123;</span><br><span class="hljs-comment">//   isCollapse.value = !isCollapse.value;</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-comment">// provide(&#x27;collapse&#x27;, &#123; isCollapse, SwitchCollapse &#125;);</span><br><br><span class="hljs-comment">/** refs和parent */</span><br><span class="hljs-comment">// import &#123; computed &#125; from &#x27;vue&#x27;;</span><br><span class="hljs-comment">// let headerRef = ref();</span><br><span class="hljs-comment">// const isCollapse = computed(() =&gt; headerRef.value?.isCollapse);</span><br><span class="hljs-comment">// const isCollapse = ref(false);</span><br><span class="hljs-comment">// defineExpose(isCollapse);</span><br></code></pre></td></tr></table></figure><p>最终以<code>pinia</code>作为通信方式，创建<code>useLayoutSettingStore</code>仓库。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useLayoutSettingStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;layoutSetting&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 是否折叠</span><br>  <span class="hljs-keyword">const</span> isCollapse = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 是否刷新</span><br>  <span class="hljs-keyword">const</span> isRefresh = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">return</span> &#123;<br>    isCollapse,<br>    isRefresh,<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MYVUE3项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识</title>
    <link href="/2024/09/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/09/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="Java的基础用法"><a href="#Java的基础用法" class="headerlink" title="Java的基础用法"></a>Java的基础用法</h1><h2 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h2><table><thead><tr><th>操作</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>输出</strong></td><td><code>System.out.println()</code></td><td>输出内容并换行</td></tr><tr><td></td><td><code>System.out.print()</code></td><td>输出内容但不换行</td></tr><tr><td></td><td><code>System.out.printf()</code></td><td>格式化输出</td></tr><tr><td><strong>输入</strong></td><td><code>Scanner scanner = new Scanner(System.in);</code></td><td>创建输入扫描器</td></tr><tr><td></td><td><code>scanner.nextLine()</code></td><td>读取一行文本</td></tr><tr><td></td><td><code>scanner.next()</code></td><td>读取下一个单词</td></tr><tr><td></td><td><code>scanner.nextInt()</code></td><td>读取整数</td></tr><tr><td></td><td><code>scanner.nextDouble()</code></td><td>读取双精度浮点数</td></tr><tr><td></td><td><code>scanner.nextFloat()</code></td><td>读取单精度浮点数</td></tr><tr><td></td><td><code>scanner.nextBoolean()</code></td><td>读取布尔值</td></tr><tr><td></td><td><code>scanner.nextLong()</code></td><td>读取长整型数</td></tr><tr><td></td><td><code>scanner.nextShort()</code></td><td>读取短整型数</td></tr></tbody></table><h2 id="Map键值对"><a href="#Map键值对" class="headerlink" title="Map键值对"></a>Map键值对</h2><p>以下是Java中<code>Map</code>常见用法的表格总结：</p><table><thead><tr><th>操作</th><th>方法&#x2F;示例</th><th>描述</th></tr></thead><tbody><tr><td><strong>创建 Map</strong></td><td><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</code></td><td>创建一个 HashMap</td></tr><tr><td><strong>添加元素</strong></td><td><code>map.put(&quot;apple&quot;, 1);</code></td><td>添加键值对 “apple” -&gt; 1</td></tr><tr><td><strong>获取元素</strong></td><td><code>int value = map.get(&quot;apple&quot;);</code></td><td>获取键为 “apple” 的值</td></tr><tr><td><strong>检查键</strong></td><td><code>boolean hasKey = map.containsKey(&quot;banana&quot;);</code></td><td>检查是否包含键 “banana”</td></tr><tr><td><strong>检查值</strong></td><td><code>boolean hasValue = map.containsValue(2);</code></td><td>检查是否包含值 2</td></tr><tr><td><strong>删除元素</strong></td><td><code>map.remove(&quot;banana&quot;);</code></td><td>删除键为 “banana” 的键值对</td></tr><tr><td><strong>遍历 Map</strong></td><td><code>for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; ... &#125;</code></td><td>遍历所有键值对</td></tr><tr><td></td><td><code>for (String key : map.keySet()) &#123; ... &#125;</code></td><td>遍历所有键</td></tr><tr><td></td><td><code>for (Integer value : map.values()) &#123; ... &#125;</code></td><td>遍历所有值</td></tr><tr><td><strong>清空 Map</strong></td><td><code>map.clear();</code></td><td>清空所有键值对</td></tr><tr><td><strong>获取大小</strong></td><td><code>int size = map.size();</code></td><td>获取 Map 中的键值对数量</td></tr><tr><td><strong>有序 Map</strong></td><td><code>Map&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;();</code></td><td>创建一个有序 TreeMap</td></tr><tr><td></td><td><code>Map&lt;String, Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</code></td><td>创建一个保持插入顺序的 LinkedHashMap</td></tr></tbody></table><p><strong>三种子类Map</strong></p><table><thead><tr><th>类名</th><th>顺序</th><th>时间复杂度</th><th>允许 null 键</th><th>线程安全</th></tr></thead><tbody><tr><td><strong>HashMap</strong></td><td>不保证顺序</td><td>O(1)</td><td>允许</td><td>不安全</td></tr><tr><td><strong>TreeMap</strong></td><td>有序</td><td>O(log n)</td><td>不允许 null 键</td><td>不安全</td></tr><tr><td><strong>LinkedHashMap</strong></td><td>保持插入顺序</td><td>O(1)</td><td>允许</td><td>不安全</td></tr></tbody></table><h2 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h2><p>在Java中，<code>List</code> 接口的常用实现类是 <code>ArrayList</code> 和 <code>LinkedList</code>。以下是一些常用的 <code>List</code> 方法及其用途：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>add(E element)</code></td><td>在列表末尾添加元素。</td></tr><tr><td><code>add(int index, E element)</code></td><td>在指定位置插入元素。</td></tr><tr><td><code>get(int index)</code></td><td>获取指定位置的元素。</td></tr><tr><td><code>set(int index, E element)</code></td><td>替换指定位置的元素。</td></tr><tr><td><code>remove(int index)</code></td><td>移除指定位置的元素，并返回被移除的元素。</td></tr><tr><td><code>remove(Object o)</code></td><td>移除首次出现的指定元素。</td></tr><tr><td><code>size()</code></td><td>返回列表中元素的数量。</td></tr><tr><td><code>isEmpty()</code></td><td>判断列表是否为空。</td></tr><tr><td><code>contains(Object o)</code></td><td>判断列表是否包含指定元素。</td></tr><tr><td><code>indexOf(Object o)</code></td><td>返回指定元素在列表中首次出现的位置。</td></tr><tr><td><code>lastIndexOf(Object o)</code></td><td>返回指定元素在列表中最后一次出现的位置。</td></tr><tr><td><code>clear()</code></td><td>移除列表中的所有元素。</td></tr><tr><td><code>subList(int fromIndex, int toIndex)</code></td><td>返回列表中指定范围的子列表。</td></tr><tr><td><code>toArray()</code></td><td>将列表转换为数组。</td></tr><tr><td><code>iterator()</code></td><td>返回列表元素的迭代器。</td></tr><tr><td><code>forEach(Consumer&lt;? super E&gt; action)</code></td><td>使用指定的操作对每个元素执行一次。</td></tr></tbody></table><h2 id="String字符串方法"><a href="#String字符串方法" class="headerlink" title="String字符串方法"></a>String字符串方法</h2><p>在Java中，<code>String</code> 类提供了多种常用的方法来处理字符串。以下是一些常见的字符串方法及其用途：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>length()</code></td><td>返回字符串的长度（字符数）。</td></tr><tr><td><code>charAt(int index)</code></td><td>返回指定位置的字符。</td></tr><tr><td><code>substring(int beginIndex)</code></td><td>返回从指定索引到字符串末尾的子字符串。</td></tr><tr><td><code>substring(int beginIndex, int endIndex)</code></td><td>返回从 <code>beginIndex</code> 到 <code>endIndex</code> 的子字符串。</td></tr><tr><td><code>indexOf(String str)</code></td><td>返回子字符串 <code>str</code> 在字符串中首次出现的位置。</td></tr><tr><td><code>lastIndexOf(String str)</code></td><td>返回子字符串 <code>str</code> 在字符串中最后出现的位置。</td></tr><tr><td><code>equals(Object anObject)</code></td><td>判断字符串内容是否相等。</td></tr><tr><td><code>equalsIgnoreCase(String anotherString)</code></td><td>忽略大小写判断字符串内容是否相等。</td></tr><tr><td><code>toLowerCase()</code></td><td>返回一个所有字符均为小写的新字符串。</td></tr><tr><td><code>toUpperCase()</code></td><td>返回一个所有字符均为大写的新字符串。</td></tr><tr><td><code>trim()</code></td><td>返回去除前后空格的新字符串。</td></tr><tr><td><code>split(String regex)</code></td><td>根据正则表达式分割字符串，并返回字符串数组。</td></tr><tr><td><code>replace(char oldChar, char newChar)</code></td><td>替换字符串中的字符。</td></tr><tr><td><code>replaceAll(String regex, String replacement)</code></td><td>使用正则表达式替换所有匹配的部分。</td></tr><tr><td><code>startsWith(String prefix)</code></td><td>判断字符串是否以指定前缀开始。</td></tr><tr><td><code>endsWith(String suffix)</code></td><td>判断字符串是否以指定后缀结束。</td></tr><tr><td><code>contains(CharSequence sequence)</code></td><td>判断字符串是否包含指定的字符序列。</td></tr><tr><td><code>isEmpty()</code></td><td>判断字符串是否为空（长度为0）。</td></tr></tbody></table><h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>以下是字符串、数组和 <code>Map</code> 的常见遍历方法的总结表格：</p><table><thead><tr><th>数据类型</th><th>遍历方法</th><th>示例代码</th></tr></thead><tbody><tr><td><strong>String</strong></td><td><code>charAt(int index)</code></td><td><code>for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); &#125;</code></td></tr><tr><td></td><td><code>toCharArray()</code></td><td><code>for (char c : str.toCharArray()) &#123; ... &#125;</code></td></tr><tr><td></td><td><code>String.split(String regex)</code></td><td><code>for (String s : str.split(&quot;,&quot;)) &#123; ... &#125;</code></td></tr><tr><td><strong>Array</strong></td><td>增强型 <code>for</code> 循环</td><td><code>for (int element : array) &#123; ... &#125;</code></td></tr><tr><td></td><td><code>for</code> 循环</td><td><code>for (int i = 0; i &lt; array.length; i++) &#123; int element = array[i]; &#125;</code></td></tr><tr><td></td><td><code>Arrays.stream(array)</code></td><td><code>Arrays.stream(array).forEach(element -&gt; &#123; ... &#125;);</code></td></tr><tr><td><strong>Map</strong></td><td><code>entrySet()</code></td><td><code>for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123; ... &#125;</code></td></tr><tr><td></td><td><code>keySet()</code></td><td><code>for (K key : map.keySet()) &#123; V value = map.get(key); &#125;</code></td></tr><tr><td></td><td><code>values()</code></td><td><code>for (V value : map.values()) &#123; ... &#125;</code></td></tr><tr><td></td><td><code>forEach(BiConsumer)</code></td><td><code>map.forEach((key, value) -&gt; &#123; ... &#125;);</code></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DATABASE</title>
    <link href="/2024/09/18/DATABASE/"/>
    <url>/2024/09/18/DATABASE/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="MYSQL数据库知识汇总"><a href="#MYSQL数据库知识汇总" class="headerlink" title="MYSQL数据库知识汇总"></a>MYSQL数据库知识汇总</h1><h2 id="MySQL数据类型汇总"><a href="#MySQL数据类型汇总" class="headerlink" title="MySQL数据类型汇总"></a>MySQL数据类型汇总</h2><p><font color="yellow">MySQL与Java数据类型的对应关系：</font></p><p><strong>1. 数值类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td><code>byte</code></td><td>范围：-128 到 127</td></tr><tr><td><code>SMALLINT</code></td><td><code>short</code></td><td>范围：-32,768 到 32,767</td></tr><tr><td><code>MEDIUMINT</code></td><td><code>int</code></td><td>范围：-8,388,608 到 8,388,607</td></tr><tr><td><code>INT</code> &#x2F; <code>INTEGER</code></td><td><code>int</code></td><td>范围：-2^31 到 2^31-1</td></tr><tr><td><code>BIGINT</code></td><td><code>long</code></td><td>范围：-2^63 到 2^63-1</td></tr><tr><td><code>DECIMAL(p, s)</code></td><td><code>java.math.BigDecimal</code></td><td>精确的定点数值，可以用于处理货币等需要高精度的值</td></tr><tr><td><code>FLOAT</code></td><td><code>float</code></td><td>单精度浮点数</td></tr><tr><td><code>DOUBLE</code></td><td><code>double</code></td><td>双精度浮点数</td></tr><tr><td><code>BIT</code></td><td><code>boolean</code> 或 <code>byte</code></td><td>用于布尔值或位字段，Java中常用 <code>boolean</code></td></tr></tbody></table><p><strong>2. 字符串类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>CHAR(n)</code></td><td><code>String</code></td><td>固定长度的字符串</td></tr><tr><td><code>VARCHAR(n)</code></td><td><code>String</code></td><td>可变长度的字符串</td></tr><tr><td><code>TEXT</code></td><td><code>String</code></td><td>长文本数据</td></tr><tr><td><code>TINYTEXT</code></td><td><code>String</code></td><td>最多255字节的文本</td></tr><tr><td><code>MEDIUMTEXT</code></td><td><code>String</code></td><td>最多16,777,215字节的文本</td></tr><tr><td><code>LONGTEXT</code></td><td><code>String</code></td><td>最多4GB的文本</td></tr></tbody></table><p><strong>3. 日期和时间类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>DATE</code></td><td><code>java.sql.Date</code></td><td>只包含日期，格式为<code>YYYY-MM-DD</code></td></tr><tr><td><code>DATETIME</code></td><td><code>java.sql.Timestamp</code> 或 <code>java.util.Date</code></td><td>日期和时间，格式为<code>YYYY-MM-DD HH:MM:SS</code></td></tr><tr><td><code>TIMESTAMP</code></td><td><code>java.sql.Timestamp</code></td><td>带有时区的日期时间戳</td></tr><tr><td><code>TIME</code></td><td><code>java.sql.Time</code></td><td>只包含时间，格式为<code>HH:MM:SS</code></td></tr><tr><td><code>YEAR</code></td><td><code>int</code></td><td>仅年份，范围为 1901 到 2155</td></tr></tbody></table><p><strong>4. 二进制数据类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>BINARY(n)</code></td><td><code>byte[]</code></td><td>固定长度的二进制数据</td></tr><tr><td><code>VARBINARY(n)</code></td><td><code>byte[]</code></td><td>可变长度的二进制数据</td></tr><tr><td><code>BLOB</code></td><td><code>byte[]</code></td><td>二进制大对象，最大长度64KB</td></tr><tr><td><code>TINYBLOB</code></td><td><code>byte[]</code></td><td>最大255字节的二进制数据</td></tr><tr><td><code>MEDIUMBLOB</code></td><td><code>byte[]</code></td><td>最大16MB的二进制数据</td></tr><tr><td><code>LONGBLOB</code></td><td><code>byte[]</code></td><td>最大4GB的二进制数据</td></tr></tbody></table><p><strong>5. 布尔和枚举类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>BOOLEAN</code></td><td><code>boolean</code></td><td><code>BOOLEAN</code> 实际上是 <code>TINYINT(1)</code>，1表示<code>true</code>，0表示<code>false</code></td></tr><tr><td><code>ENUM</code></td><td><code>String</code></td><td>枚举类型，对应Java中的字符串</td></tr></tbody></table><p><strong>6. JSON 数据类型</strong></p><table><thead><tr><th>MySQL 数据类型</th><th>Java 数据类型</th><th>说明</th></tr></thead><tbody><tr><td><code>JSON</code></td><td><code>String</code> 或 <code>org.json.JSONObject</code></td><td>JSON格式的数据，通常在Java中作为<code>String</code>处理，或者通过第三方库（如<code>org.json.JSONObject</code>）处理</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-ElementUI表单</title>
    <link href="/2024/08/07/2024-08-07/"/>
    <url>/2024/08/07/2024-08-07/</url>
    
    <content type="html"><![CDATA[<p>文章记录了ElementUI中表单的用法。</p><span id="more"></span><h1 id="前端学习-ElementUI表单"><a href="#前端学习-ElementUI表单" class="headerlink" title="前端学习-ElementUI表单"></a>前端学习-ElementUI表单</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><p><strong>官网：<a href="https://element.eleme.cn/#/zh-CN/component/form">https://element.eleme.cn/#/zh-CN/component/form</a></strong></p><h2 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;FormContainer&quot;&gt;<br>    &lt;el-form :model=&quot;user&quot; :rules=&quot;rules&quot; ref=&quot;form&quot;&gt;<br>      &lt;el-form-item label=&quot;用户名&quot; prop=&quot;username&quot;&gt;<br>        &lt;el-input type=&quot;text&quot; v-model=&quot;user.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt;<br>        &lt;el-input type=&quot;password&quot; v-model=&quot;user.password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;<br>      &lt;/el-form-item&gt;<br>      &lt;el-button class=&quot;submit&quot; type=&quot;primary&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;<br>    &lt;/el-form&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    name:&quot;UIForm&quot;,<br>    data()&#123;<br>      return &#123;<br>        user:&#123;&#125;,<br>        rules: &#123;<br>      username: [<br>        &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;<br>      ],<br>      password: [<br>        &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;<br>      ]<br>    &#125;<br>      &#125;<br>    &#125;,<br>    methods:&#123;<br>      login() &#123;<br>    this.$refs.form.validate((valid) =&gt; &#123;<br>      if (valid) &#123;<br>        // 表单验证通过<br>        console.log(&quot;表单验证成功&quot;);<br>      &#125; else &#123;<br>        // 表单验证失败<br>        console.error(&quot;表单验证失败&quot;);<br>        return false;<br>      &#125;<br>    &#125;);<br>  &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.FormContainer &#123;<br>  width: 100vw;<br>  height: 100vh;<br>  background: #222222;<br>  position: relative;<br>  .el-form&#123;<br>    width: 500px;<br>    height: 500px;<br>    position: absolute;<br>    padding: 50px;<br>    top: 0;<br>    left: 0;<br>    right: 0;<br>    bottom: 0;<br>    margin: auto;<br>    background: #FFFFFF;<br>    border: 2px solid #00bfff;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/07/2024-08-07/%E5%9B%BE1.png" class title="图1"><p>上述示例是一个简单的登录表单界面。但涵盖了ElementUI中表单的基本用法。</p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a><font color="yellow">重点：</font></h3><ol><li><p>表单结构如上述所示，有一个<code>el-form</code>和一个或者多个<code>el-form-item</code>和按钮组成。</p></li><li><p><code>el-form</code>中<font color="yellow"><code>model</code></font>是表单数据项，当用户输入数据时，数据会更新到 <code>model</code> 中；当 <code>model</code> 更新时，表单控件的显示也会随之更新。<font color="yellow">它的作用在于记录当前表单的数据项，用于后面的表单验证。</font></p></li><li><p><code>el-form</code>中的<font color="yellow"><code>rules</code></font>是表单规则，规定了数据项需要满足哪些条件。编码规则如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-attr">username</span>: [<br>        &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入用户名&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>    ],<br>    <span class="hljs-attr">password</span>: [<br>        &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入密码&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>表单项想要使用规则需要以<code>&lt;el-form-item prop=&quot;username&quot;&gt;</code>的方式声明，<font color="yellow"><code>prop</code></font>是表单域 model 字段</p></li><li><p><font color="yellow"><code>lable</code></font>是数据项标签。标签的相关配置项可以看官方文档，</p></li><li><p><font color="yellow"><code>validate</code></font>是表单验证方法，它的原理是检查<code>el-form</code>的<code>model</code>，将<code>model</code>中的每一个字段和<code>rules</code>中的字段对应，观察是否满足规则，如果全部满足则返回true，否则返回false。如果<code>rules</code>中的字段在<code>model</code>中没有找到，也会返回false。<font color="yellow">因此<code>validate</code>表单验证是首先看数据项中是否用了规则，然后观察<code>model</code>中的数据是否满足规则，所有<code>model</code>是必须有的。</font></p></li><li><p>数据项出现提示，并不是<code>validate</code>方法，而是<font color="yellow"><code>validate</code>事件</font>，它不在乎是否有<code>model</code>数据项，而是观察数据项中的<code>v-model=username</code>是否满足规则。<font color="yellow">如果输入框没有<code>v-model=username</code>，数据是无法输入的</font>，因为输入的数据检测不到。</p></li></ol><h2 id="rules基本配置项"><a href="#rules基本配置项" class="headerlink" title="rules基本配置项"></a><code>rules</code>基本配置项</h2><ol><li><p><strong><code>required</code></strong>:</p><ul><li><strong>类型</strong>: <code>Boolean</code></li><li><strong>描述</strong>: 是否为必填项。如果设置为 <code>true</code>，字段必须有值才能通过验证。</li><li><strong>示例</strong>: <code>&#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>message</code></strong>:</p><ul><li><strong>类型</strong>: <code>String</code></li><li><strong>描述</strong>: 验证失败时显示的错误消息。</li><li><strong>示例</strong>: <code>&#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>trigger</code></strong>:</p><ul><li><strong>类型</strong>: <code>String</code> | <code>Array</code></li><li><strong>描述</strong>: 触发验证的事件。例如，<code>blur</code>（失去焦点时）、<code>change</code>（值改变时）、<code>input</code>（每次输入时）等。</li><li><strong>示例</strong>: <code>&#123; required: true, message: &#39;请输入用户名&#39;, trigger: [&#39;blur&#39;, &#39;change&#39;] &#125;</code></li></ul></li><li><p><strong><code>min</code></strong>:</p><ul><li><strong>类型</strong>: <code>Number</code></li><li><strong>描述</strong>: 对于字符串或数组，表示最小长度。对于数字，表示最小值。</li><li><strong>示例</strong>: <code>&#123; min: 3, message: &#39;用户名长度不能少于3个字符&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>max</code></strong>:</p><ul><li><strong>类型</strong>: <code>Number</code></li><li><strong>描述</strong>: 对于字符串或数组，表示最大长度。对于数字，表示最大值。</li><li><strong>示例</strong>: <code>&#123; max: 10, message: &#39;用户名长度不能超过10个字符&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>pattern</code></strong>:</p><ul><li><strong>类型</strong>: <code>RegExp</code></li><li><strong>描述</strong>: 正则表达式，用于验证字段值是否符合某种模式。</li><li><strong>示例</strong>: <code>&#123; pattern: /^[a-zA-Z0-9]&#123;6,12&#125;$/, message: &#39;密码长度为6到12位的字母或数字&#39;, trigger: &#39;blur&#39; &#125;</code></li></ul></li><li><p><strong><code>validator</code></strong>:</p><ul><li><strong>类型</strong>: <code>Function</code></li><li><strong>描述</strong>: 自定义验证函数，用于实现更复杂的验证逻辑。函数接受 <code>rule</code>、<code>value</code> 和 <code>callback</code> 三个参数。</li><li><strong>示例</strong>:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">validator</span>: <span class="hljs-function">(<span class="hljs-params">rule, value, callback</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> &lt; <span class="hljs-number">6</span>) &#123;<br>      <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;密码长度不能少于6个字符&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">callback</span>();<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="validate方法"><a href="#validate方法" class="headerlink" title="validate方法"></a><code>validate</code>方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">form</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (valid) &#123;<br>    <span class="hljs-comment">// 表单验证通过</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;表单验证成功&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 表单验证失败</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;表单验证失败&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>valid是返回的Boolean值，如果满足规则返回true，否则返回false。</p><h2 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h2><p>使用<code>validator</code>可以自定义验证函数。官网中的案例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form :model=&quot;ruleForm&quot; status-icon :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;<br>  &lt;el-form-item label=&quot;密码&quot; prop=&quot;pass&quot;&gt;<br>    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.pass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;checkPass&quot;&gt;<br>    &lt;el-input type=&quot;password&quot; v-model=&quot;ruleForm.checkPass&quot; autocomplete=&quot;off&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;年龄&quot; prop=&quot;age&quot;&gt;<br>    &lt;el-input v-model.number=&quot;ruleForm.age&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item&gt;<br>    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;提交&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;resetForm(&#x27;ruleForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>&lt;/el-form&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      var checkAge = (rule, value, callback) =&gt; &#123;<br>        if (!value) &#123;<br>          return callback(new Error(&#x27;年龄不能为空&#x27;));<br>        &#125;<br>        setTimeout(() =&gt; &#123;<br>          if (!Number.isInteger(value)) &#123;<br>            callback(new Error(&#x27;请输入数字值&#x27;));<br>          &#125; else &#123;<br>            if (value &lt; 18) &#123;<br>              callback(new Error(&#x27;必须年满18岁&#x27;));<br>            &#125; else &#123;<br>              callback();<br>            &#125;<br>          &#125;<br>        &#125;, 1000);<br>      &#125;;<br>      var validatePass = (rule, value, callback) =&gt; &#123;<br>        if (value === &#x27;&#x27;) &#123;<br>          callback(new Error(&#x27;请输入密码&#x27;));<br>        &#125; else &#123;<br>          if (this.ruleForm.checkPass !== &#x27;&#x27;) &#123;<br>            this.$refs.ruleForm.validateField(&#x27;checkPass&#x27;);<br>          &#125;<br>          callback();<br>        &#125;<br>      &#125;;<br>      var validatePass2 = (rule, value, callback) =&gt; &#123;<br>        if (value === &#x27;&#x27;) &#123;<br>          callback(new Error(&#x27;请再次输入密码&#x27;));<br>        &#125; else if (value !== this.ruleForm.pass) &#123;<br>          callback(new Error(&#x27;两次输入密码不一致!&#x27;));<br>        &#125; else &#123;<br>          callback();<br>        &#125;<br>      &#125;;<br>      return &#123;<br>        ruleForm: &#123;<br>          pass: &#x27;&#x27;,<br>          checkPass: &#x27;&#x27;,<br>          age: &#x27;&#x27;<br>        &#125;,<br>        rules: &#123;<br>          pass: [<br>            &#123; validator: validatePass, trigger: &#x27;blur&#x27; &#125;<br>          ],<br>          checkPass: [<br>            &#123; validator: validatePass2, trigger: &#x27;blur&#x27; &#125;<br>          ],<br>          age: [<br>            &#123; validator: checkAge, trigger: &#x27;blur&#x27; &#125;<br>          ]<br>        &#125;<br>      &#125;;<br>    &#125;,<br>    methods: &#123;<br>      submitForm(formName) &#123;<br>        this.$refs[formName].validate((valid) =&gt; &#123;<br>          if (valid) &#123;<br>            alert(&#x27;submit!&#x27;);<br>          &#125; else &#123;<br>            console.log(&#x27;error submit!!&#x27;);<br>            return false;<br>          &#125;<br>        &#125;);<br>      &#125;,<br>      resetForm(formName) &#123;<br>        this.$refs[formName].resetFields();<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/07/2024-08-07/%E5%9B%BE2.png" class title="图2"><p>本例还使用<font color="yellow"><code>status-icon</code>属性</font>为输入框添加了表示校验结果的反馈图标。通过自定义规则，实现确认密码的验证和文本类型的判断。</p><h2 id="官网案例"><a href="#官网案例" class="headerlink" title="官网案例"></a>官网案例</h2><h3 id="典型表单"><a href="#典型表单" class="headerlink" title="典型表单"></a>典型表单</h3><img src="/2024/08/07/2024-08-07/%E5%9B%BE3.png" class title="图3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;80px&quot;&gt;<br>  &lt;el-form-item label=&quot;活动名称&quot;&gt;<br>    &lt;el-input v-model=&quot;form.name&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动区域&quot;&gt;<br>    &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;<br>      &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;<br>      &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;<br>    &lt;/el-select&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动时间&quot;&gt;<br>    &lt;el-col :span=&quot;11&quot;&gt;<br>      &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;form.date1&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt;<br>    &lt;/el-col&gt;<br>    &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;<br>    &lt;el-col :span=&quot;11&quot;&gt;<br>      &lt;el-time-picker placeholder=&quot;选择时间&quot; v-model=&quot;form.date2&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt;<br>    &lt;/el-col&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;即时配送&quot;&gt;<br>    &lt;el-switch v-model=&quot;form.delivery&quot;&gt;&lt;/el-switch&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动性质&quot;&gt;<br>    &lt;el-checkbox-group v-model=&quot;form.type&quot;&gt;<br>      &lt;el-checkbox label=&quot;美食/餐厅线上活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>      &lt;el-checkbox label=&quot;地推活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>      &lt;el-checkbox label=&quot;线下主题活动&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>      &lt;el-checkbox label=&quot;单纯品牌曝光&quot; name=&quot;type&quot;&gt;&lt;/el-checkbox&gt;<br>    &lt;/el-checkbox-group&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;特殊资源&quot;&gt;<br>    &lt;el-radio-group v-model=&quot;form.resource&quot;&gt;<br>      &lt;el-radio label=&quot;线上品牌商赞助&quot;&gt;&lt;/el-radio&gt;<br>      &lt;el-radio label=&quot;线下场地免费&quot;&gt;&lt;/el-radio&gt;<br>    &lt;/el-radio-group&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item label=&quot;活动形式&quot;&gt;<br>    &lt;el-input type=&quot;textarea&quot; v-model=&quot;form.desc&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item&gt;<br>    &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;立即创建&lt;/el-button&gt;<br>    &lt;el-button&gt;取消&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>&lt;/el-form&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      return &#123;<br>        form: &#123;<br>          name: &#x27;&#x27;,<br>          region: &#x27;&#x27;,<br>          date1: &#x27;&#x27;,<br>          date2: &#x27;&#x27;,<br>          delivery: false,<br>          type: [],<br>          resource: &#x27;&#x27;,<br>          desc: &#x27;&#x27;<br>        &#125;<br>      &#125;<br>    &#125;,<br>    methods: &#123;<br>      onSubmit() &#123;<br>        console.log(&#x27;submit!&#x27;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="动态增减表单项"><a href="#动态增减表单项" class="headerlink" title="动态增减表单项"></a>动态增减表单项</h3><img src="/2024/08/07/2024-08-07/%E5%9B%BE4.png" class title="图4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-form :model=&quot;dynamicValidateForm&quot; ref=&quot;dynamicValidateForm&quot; label-width=&quot;100px&quot; class=&quot;demo-dynamic&quot;&gt;<br>  &lt;el-form-item<br>    prop=&quot;email&quot;<br>    label=&quot;邮箱&quot;<br>    :rules=&quot;[<br>      &#123; required: true, message: &#x27;请输入邮箱地址&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>      &#123; type: &#x27;email&#x27;, message: &#x27;请输入正确的邮箱地址&#x27;, trigger: [&#x27;blur&#x27;, &#x27;change&#x27;] &#125;<br>    ]&quot;<br>  &gt;<br>    &lt;el-input v-model=&quot;dynamicValidateForm.email&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item<br>    v-for=&quot;(domain, index) in dynamicValidateForm.domains&quot;<br>    :label=&quot;&#x27;域名&#x27; + index&quot;<br>    :key=&quot;domain.key&quot;<br>    :prop=&quot;&#x27;domains.&#x27; + index + &#x27;.value&#x27;&quot;<br>    :rules=&quot;&#123;<br>      required: true, message: &#x27;域名不能为空&#x27;, trigger: &#x27;blur&#x27;<br>    &#125;&quot;<br>  &gt;<br>    &lt;el-input v-model=&quot;domain.value&quot;&gt;&lt;/el-input&gt;&lt;el-button @click.prevent=&quot;removeDomain(domain)&quot;&gt;删除&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item&gt;<br>    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;dynamicValidateForm&#x27;)&quot;&gt;提交&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;addDomain&quot;&gt;新增域名&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;resetForm(&#x27;dynamicValidateForm&#x27;)&quot;&gt;重置&lt;/el-button&gt;<br>  &lt;/el-form-item&gt;<br>&lt;/el-form&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    data() &#123;<br>      return &#123;<br>        dynamicValidateForm: &#123;<br>          domains: [&#123;<br>            value: &#x27;&#x27;<br>          &#125;],<br>          email: &#x27;&#x27;<br>        &#125;<br>      &#125;;<br>    &#125;,<br>    methods: &#123;<br>      submitForm(formName) &#123;<br>        this.$refs[formName].validate((valid) =&gt; &#123;<br>          if (valid) &#123;<br>            alert(&#x27;submit!&#x27;);<br>          &#125; else &#123;<br>            console.log(&#x27;error submit!!&#x27;);<br>            return false;<br>          &#125;<br>        &#125;);<br>      &#125;,<br>      resetForm(formName) &#123;<br>        this.$refs[formName].resetFields();<br>      &#125;,<br>      removeDomain(item) &#123;<br>        var index = this.dynamicValidateForm.domains.indexOf(item)<br>        if (index !== -1) &#123;<br>          this.dynamicValidateForm.domains.splice(index, 1)<br>        &#125;<br>      &#125;,<br>      addDomain() &#123;<br>        this.dynamicValidateForm.domains.push(&#123;<br>          value: &#x27;&#x27;,<br>          key: Date.now()<br>        &#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-CSS绘制多边形</title>
    <link href="/2024/08/06/2024-08-06/"/>
    <url>/2024/08/06/2024-08-06/</url>
    
    <content type="html"><![CDATA[<p>文章记录了CSS绘制多边形的方法，特别是利用border设计对话框的三角行。</p><span id="more"></span><h1 id="前端学习-CSS绘制多边形"><a href="#前端学习-CSS绘制多边形" class="headerlink" title="前端学习-CSS绘制多边形"></a>前端学习-CSS绘制多边形</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><h2 id="CSS绘制三角形"><a href="#CSS绘制三角形" class="headerlink" title="CSS绘制三角形"></a>CSS绘制三角形</h2><p>在 CSS 中绘制三角形通常是通过<font color="yellow">利用 <code>border</code> 属性的技巧来实现的</font>。这种方法利用了元素的边框设置来创建一个透明的区域，从而形成三角形的视觉效果。</p><h3 id="1-向上的三角形"><a href="#1-向上的三角形" class="headerlink" title="1. 向上的三角形"></a>1. <strong>向上的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Up Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-up</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-up&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>width</code> 和 <code>height</code> 设置为 <code>0</code>，让元素本身没有实际的宽度和高度。</li><li><code>border-left</code> 和 <code>border-right</code> 设为 <code>20px solid transparent</code>，创建透明的边框。</li><li><code>border-bottom</code> 设为 <code>20px solid blue</code>，创建底部的边框颜色，形成向上的三角形。</li></ul><h3 id="2-向下的三角形"><a href="#2-向下的三角形" class="headerlink" title="2. 向下的三角形"></a>2. <strong>向下的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Down Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-down</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-down&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>border-top</code> 设为 <code>20px solid red</code>，创建顶部的边框颜色，形成向下的三角形。</li></ul><h3 id="3-向左的三角形"><a href="#3-向左的三角形" class="headerlink" title="3. 向左的三角形"></a>3. <strong>向左的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Left Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-left</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid green;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>border-right</code> 设为 <code>20px solid green</code>，创建右侧的边框颜色，形成向左的三角形。</li></ul><h3 id="4-向右的三角形"><a href="#4-向右的三角形" class="headerlink" title="4. 向右的三角形"></a>4. <strong>向右的三角形</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Right Triangle<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.triangle-right</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-left</span>: <span class="hljs-number">20px</span> solid yellow;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;triangle-right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="CSS绘制任意图像"><a href="#CSS绘制任意图像" class="headerlink" title="CSS绘制任意图像"></a>CSS绘制任意图像</h2><p><code>clip-path</code> 属性允许你定义一个裁剪区域，从而创建各种形状，包括多边形。常用的多边形有四边形、五边形、六边形等。利用<code>poligon()</code>函数进行裁剪。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(x1 y1, x2 y2, x3 y3, ...);<br></code></pre></td></tr></table></figure><p>绘制一个五边形：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Polygon<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.polygon</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;</span><br><span class="language-css">      <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> <span class="hljs-number">38%</span>, <span class="hljs-number">82%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">18%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0%</span> <span class="hljs-number">38%</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;polygon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/basic-shape/polygon">https://developer.mozilla.org/zh-CN/docs/Web/CSS/basic-shape/polygon</a></p></blockquote><h2 id="CSS绘制对话框实例"><a href="#CSS绘制对话框实例" class="headerlink" title="CSS绘制对话框实例"></a>CSS绘制对话框实例</h2><img src="/2024/08/06/2024-08-06/%E5%9B%BE1.png" class title="图1"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>绘制多边形<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 图标绘制 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../favicon.ico&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 多边形绘制 --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 绘制对话框 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog dialog1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>          绘制三角形样式:<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poligon&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget triangle1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget triangle2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget triangle3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 绘制多边形 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>            绘制多边形样式:<br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poligon&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget square&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget pentagon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;widget other&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-number">#111111</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">20%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">  <span class="hljs-selector-class">.icon</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">101</span>, <span class="hljs-number">179</span>, <span class="hljs-number">205</span>, <span class="hljs-number">0.6</span>);</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-selector-class">.img</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">    <span class="hljs-attribute">justify-content</span>: space-around;</span><br><span class="language-css">    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">130px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-selector-class">.dialog</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: <span class="hljs-number">#2e485a</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">      <span class="hljs-selector-class">.triangle1</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制三角形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">100%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.triangle2</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制三角形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">0</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">50%</span> <span class="hljs-number">100%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.triangle3</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制三角形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">100%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">100%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.pentagon</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制五边形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> <span class="hljs-number">38%</span>, <span class="hljs-number">82%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">18%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0%</span> <span class="hljs-number">38%</span>);</span><br><span class="language-css">        &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.square</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制四边形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">50%</span>,<span class="hljs-number">50%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">50%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.other</span> &#123;</span><br><span class="language-css">          <span class="hljs-comment">/* 使用polygon函数绘制任意图形 */</span></span><br><span class="language-css">          <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">0</span> <span class="hljs-number">0%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">0%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">10%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">20%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">30%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">40%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">50%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">60%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">70%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">80%</span>,<span class="hljs-number">51%</span> <span class="hljs-number">90%</span>,<span class="hljs-number">100%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">0%</span> <span class="hljs-number">100%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">90%</span>,<span class="hljs-number">0</span> <span class="hljs-number">80%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">70%</span>,<span class="hljs-number">0</span> <span class="hljs-number">60%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">50%</span>,<span class="hljs-number">0</span> <span class="hljs-number">40%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">30%</span>,<span class="hljs-number">0</span> <span class="hljs-number">20%</span>,<span class="hljs-number">49%</span> <span class="hljs-number">10%</span>);</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.dialog1</span><span class="hljs-selector-pseudo">::before</span>&#123;</span><br><span class="language-css">      <span class="hljs-comment">/* 模仿三角形边框 */</span></span><br><span class="language-css">      <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">left</span>: -<span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.dialog1</span><span class="hljs-selector-pseudo">::after</span> &#123;</span><br><span class="language-css">      <span class="hljs-comment">/* 模仿三角形填充 */</span></span><br><span class="language-css">      <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-top</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">20px</span> solid transparent;</span><br><span class="language-css">      <span class="hljs-attribute">border-right</span>: <span class="hljs-number">20px</span> solid <span class="hljs-number">#2e485a</span>;</span><br><span class="language-css">      <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">      <span class="hljs-attribute">left</span>: -<span class="hljs-number">18px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.title</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      <span class="hljs-attribute">font</span>: <span class="hljs-number">700</span> <span class="hljs-number">20px</span> <span class="hljs-string">&quot;STZhongsong&quot;</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.poligon</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">70px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">      <span class="hljs-attribute">justify-content</span>: space-between;</span><br><span class="language-css">      <span class="hljs-selector-class">.widget</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFFFFF</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>前端三件套</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-Vue组件之间的交互</title>
    <link href="/2024/08/04/2024-08-04/"/>
    <url>/2024/08/04/2024-08-04/</url>
    
    <content type="html"><![CDATA[<p>文章记录Vue组件之间交互的几种方式，包括父组件和子组件之间的数据传参和事件触发。</p><span id="more"></span><h1 id="前端学习-Vue组件之间的交互"><a href="#前端学习-Vue组件之间的交互" class="headerlink" title="前端学习-Vue组件之间的交互"></a>前端学习-Vue组件之间的交互</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><p>组件的<code>props</code>配置项用于接收由父组件向该组件传递的参数。<font color="yellow">数据的传递是父组件——&gt;子组件</font>。</p><p>使用方法：父组件在子组件的DOM节点中给定参数。子组件通过<code>props</code>接收参数。</p><p>接收数据：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">props</span>:&#123;<br><span class="hljs-attr">name</span>:&#123;<br><span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">//类型</span><br><span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//必要性</span><br><span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;老王&#x27;</span> <span class="hljs-comment">//默认值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>      &lt;!-- 传递父组件的arr参数，子组件接收的变量为newArr --&gt;<br>    &lt;ChildComponent v-if=&quot;showComponent&quot; :newArr=&quot;arr&quot;&gt;&lt;/ChildComponent&gt; <br>    &lt;ChildComponent v-if=&quot;showComponent&quot; :newArr=&quot;arr&quot;&gt;&lt;/ChildComponent&gt;<br>    &lt;el-button @click=&quot;()=&gt;&#123;arr.push(data++)&#125;&quot;&gt;更改数组&lt;/el-button&gt;<br>    &#123;&#123; data &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>  data() &#123;<br>    return &#123;<br>      arr : [&quot;父组件初始数据&quot;],<br>      data : 0,<br>      showComponent : true,<br>    &#125;<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="#FFFF00">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>    &#123;&#123; arr &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props:&#123;<br>    newArr:&#123;<br>      type: Array,<br>      default: ()=&gt;[&quot;初始参数&quot;]<br>    &#125;<br>  &#125;,<br>  data()&#123;<br>    return&#123;<br>      arr:[&quot;子组件初始数据&quot;],<br>    &#125;<br>  &#125;,<br>  created()&#123;<br>    this.arr = this.newArr<br>    this.arr.push(&quot;子组件数据&quot;)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>  font-size: 30px;<br>  font-family: &quot;STZhongsong&quot;;<br>  color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/04/2024-08-04/%E5%9B%BE1.png" class title="图1"><p><font color="yellow">注意点：</font></p><ol><li><code>props</code>接收的参数是<font color="yellow">不支持更改的</font>。如果需要改动数据，需要复制一份到<code>data</code>配置项中的变量中。例如上述<code>this.arr=this.newArr</code>。</li><li>在传递数组和对象是，<font color="yellow"><code>props</code>参数传递方式是引用传递</font>。也就是说不同子组件和父组件数组指向的是同一个数组。在上诉代码中，<code>this.arr=this.newArr</code>也是浅复制，两个子组件的<code>this.arr</code>和父组件的<code>this.arr</code>指向的都是同一个数组，所以当一个子组件更改数组数据时，会对另一个子组件的数组造成影响，因此上诉“子组件数据”字符串插入了两次。<font color="yellow">在对象和数组的复制操作中，我们需要保证是否需要进行深复制</font>。</li></ol><p>使用 <code>v-bind</code> 指令可以将父组件的数据绑定到子组件的 <code>props</code> 上。这适用于动态绑定 <code>props</code> 或传递多个 <code>props</code>。</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ChildComponent v-bind=&quot;parentProps&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br><br>export default &#123;<br>  components: &#123; ChildComponent &#125;,<br>  data() &#123;<br>    return &#123;<br>      parentProps: &#123;<br>        message: &#x27;Hello from parent&#x27;,<br>        count: 42<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    message: String,<br>    count: Number<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">注意点：</font></p><ul><li>父组件<code>parentProps</code>中的keys值需要和子组件<code>props</code>中的keys值对应起来。</li></ul><p>除了data数据，<font color="yellow">父组件可以将方法作为 <code>props</code> 传递给子组件</font>。子组件可以在其方法中调用这些 <code>props</code> 传递过来的方法。</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;ChildComponent :parentMethod=&quot;handleParentMethod&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br><br>export default &#123;<br>  components: &#123; ChildComponent &#125;,<br>  methods: &#123;<br>    handleParentMethod(message) &#123;<br>      console.log(&#x27;Parent method called with message:&#x27;, message);<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;button @click=&quot;callParentMethod&quot;&gt;Call Parent Method&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    parentMethod: &#123;<br>      type: Function,<br>      required: true<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    callParentMethod() &#123;<br>      this.parentMethod(&#x27;Hello from child&#x27;);<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">注意点：</font></p><ul><li>通过方法我们可以将子组件的数据传递给父组件，实现<font color="#FFFF00">子组件——&gt;父组件</font>。</li></ul><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=66">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=66</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="mixin混入"><a href="#mixin混入" class="headerlink" title="mixin混入"></a>mixin混入</h2><p>在 Vue.js 中，<code>mixin</code> 是一种复用组件逻辑的机制。通过 <code>mixin</code>，你可以将多个组件共享的逻辑提取到一个独立的 <code>mixin</code> 对象中，然后在多个组件中使用它们。<code>mixin</code> 允许你将共享的逻辑、数据、生命周期钩子等封装在一起，以便重用。</p><p><font color="yellow">定义 Mixin：</font></p><p>一个 <code>mixin</code> 对象可以包含组件的选项，如 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>、<code>lifecycle hooks</code> 等。以下是一个 <code>mixin</code> 的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// myMixin.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myMixin = &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">mixinData</span>: <span class="hljs-string">&#x27;This is mixin data&#x27;</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">mixinMethod</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is a method from mixin&#x27;</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Mixin created hook&#x27;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><font color="yellow"> 在组件中使用 Mixin：</font></p><p>要在组件中使用 <code>mixin</code>，你需要在组件的 <code>mixins</code> 选项中引入定义好的 <code>mixin</code> 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; mixinData &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;mixinMethod&quot;&gt;Call Mixin Method&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import &#123; myMixin &#125; from &#x27;./myMixin&#x27;;<br><br>export default &#123;<br>  mixins: [myMixin],<br>  data() &#123;<br>    return &#123;<br>      componentData: &#x27;This is component data&#x27;<br>    &#125;;<br>  &#125;,<br>  created() &#123;<br>    console.log(&#x27;Component created hook&#x27;);<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">注意点：</font></p><ol><li><strong>数据合并</strong>：<code>mixin</code> 中的 <code>data</code> 会与组件中的 <code>data</code> 合并。如果 <code>data</code> 中有同名属性，组件中的属性会覆盖 <code>mixin</code> 中的属性。</li><li><strong>方法合并</strong>：<code>mixin</code> 中的 <code>methods</code> 会与组件中的 <code>methods</code> 合并。如果 <code>methods</code> 中有同名方法，组件中的方法会覆盖 <code>mixin</code> 中的方法。</li><li><strong>生命周期钩子合并</strong>：<code>mixin</code> 中的生命周期钩子会与组件中的生命周期钩子合并。如果存在同名钩子函数，它们会被合并为一个函数，在执行时按定义的顺序依次调用。</li><li><strong>全局混入</strong>：在<code>main.js</code>中使用<code>Vue.mixin(myMixin)</code>可以实现全局混入。</li></ol><img src="/2024/08/04/2024-08-04/%E5%9B%BE2.png" class title="图2"><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=67">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=67</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:#FFFF00">父组件 ——&gt; 子组件</strong> 。</p><h3 id="默认插槽-具名插槽"><a href="#默认插槽-具名插槽" class="headerlink" title="默认插槽 &#x2F; 具名插槽"></a>默认插槽 &#x2F; 具名插槽</h3><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;ChildComponent&gt;<br>      &lt;template slot=&quot;first&quot;&gt;<br>        &lt;div&gt;<br>          &lt;h3&gt; 插槽数据-FIRST &lt;/h3&gt;<br>        &lt;/div&gt;<br>      &lt;/template&gt;<br>      &lt;template slot=&quot;second&quot;&gt;<br>        &lt;div&gt;<br>          &lt;h3&gt; 插槽数据-SECOND &lt;/h3&gt;<br>        &lt;/div&gt;<br>      &lt;/template&gt;<br>    &lt;/ChildComponent&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>    &lt;slot name=&quot;first&quot;&gt;&lt;/slot&gt;<br>    &lt;slot name=&quot;second&quot;&gt;&lt;/slot&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>  font-size: 30px;<br>  font-family: &quot;STZhongsong&quot;;<br>  color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/04/2024-08-04/%E5%9B%BE3.png" class title="图3"><p>在子组件中定义<code>&lt;slot name=&quot;&quot;&gt;&lt;/slot&gt;</code>插槽，在父组件可以定义HTML结构并插入到子组件中。如果只有一个插槽则无需设置name，用默认插槽即可。</p><p><font color="yellow">注意点：</font></p><ul><li>插槽结构的样式既可以在父组件中定义，也可以在子组件中定义。</li></ul><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p><span style="color:yellow">数据在子组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在子组件中，但使用数据所遍历出来的结构由父组件决定）</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>&lt;ChildComponent&gt;<br>&lt;template v-slot:default=&quot;scopeData&quot;&gt;<br>&lt;!-- 生成的是ul列表 --&gt;<br>&lt;ul&gt;<br>&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/template&gt;<br>&lt;/ChildComponent&gt;<br><br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>      &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;<br>      &lt;el-button @click=&quot;changeGames&quot;&gt;修改数组&lt;/el-button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>      //数据在子组件自身<br>      data() &#123;<br>          return &#123;<br>              games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]<br>          &#125;<br>      &#125;,<br>      methods:&#123;<br>        changeGames()&#123;<br>          this.games.push(&quot;LOL&quot;);<br>        &#125;        <br>      &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/04/2024-08-04/%E5%9B%BE4.png" class title="图4"><p><font color="yellow">注意点：</font></p><ul><li>父组件不能直接“保持”或“保存”作用域插槽传递过来的参数，因为作用域插槽是由子组件提供的，父组件只能使用这些数据，而不能直接修改它们。</li><li>和<code>props</code>参数传参一样，当使用的参数数据变化时，会重写渲染页面。</li></ul><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=102">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=102</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>在 Vue 中，自定义事件是一种使子组件与父组件进行通信的机制。自定义事件允许子组件向父组件传递信息或通知父组件某些操作。传递方向是<font color="yellow">子组件——&gt;父组件</font></p><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:#FFFF00">事件的回调在A中</span>）。</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>&lt;ChildComponent v-on:singal=&quot;slotFunction&quot;&gt;<br>&lt;/ChildComponent&gt;<br><br>&lt;ChildComponent ref=&quot;child&quot;&gt;<br>&lt;/ChildComponent&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>methods:&#123;<br>slotFunction(params)&#123;<br>console.log(params)<br>alert(&quot;回调函数调用 &quot;+params);<br>&#125;<br>&#125;,<br>mounted()&#123;<br>this.$refs.child.$on(&quot;singal&quot;, this.slotFunction);<br>&#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>      &lt;el-button @click=&quot;triggerFunction&quot;&gt;触发信号&lt;/el-button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    methods:&#123;<br>      triggerFunction()&#123;<br>        this.$emit(&quot;singal&quot;,&quot;params&quot;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>  font-size: 30px;<br>  font-family: &quot;STZhongsong&quot;;<br>  color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="具体流程如下"><a href="#具体流程如下" class="headerlink" title="具体流程如下"></a>具体流程如下</h3><p><font color="yellow">第一步：</font>在父组件中创建回调函数，当子组件触发信号的时候，该函数被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">slotFunction</span>(<span class="hljs-params">params</span>)&#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;回调函数调用 &quot;</span>+params);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="yellow">第二步：</font>父组件为子组件绑定一个自定义事件，使子组件可以通过触发该事件而调用父组件的回调函数。有两种绑定方式。</p><ol><li><p>在父组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ChildComponent v-on:singal=&quot;slotFunction&quot;&gt;&lt;/ChildComponent&gt;<br>//或者<br>&lt;ChildComponent @singal=&quot;slotFunction&quot;&gt;&lt;/ChildComponent&gt;<br></code></pre></td></tr></table></figure></li><li><p>在父组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ChildComponent ref=&quot;child&quot;&gt;&lt;/ChildComponent&gt;<br>mounted()&#123;<br>this.$refs.child.$on(&quot;singal&quot;, this.slotFunction);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>为子组件绑定了<code>singal</code>事件，通过<code>singal</code>事件触发<code>slotFunction</code>回调函数。</p><p><font color="yellow">第三步：</font>子组件触发事件。可以传递多个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>  <span class="hljs-title function_">triggerFunction</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;singal&quot;</span>,<span class="hljs-string">&quot;params&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol><li><p>当不再需要使用组件时，最好手动解绑事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.$off(<span class="hljs-string">&quot;singal&quot;</span>)<br><span class="hljs-comment">//解绑当前组件的所有事件</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.$off()<br></code></pre></td></tr></table></figure></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。没有修饰符会默认是自定义事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ChildComponent @click.native=&quot;slotFunction&quot;&gt;&lt;/ChildComponent&gt;<br></code></pre></td></tr></table></figure></li><li><p>其他的修饰符包括</p><ul><li><code>.stop</code>：调用 <code>event.stopPropagation()</code>，阻止事件冒泡。需要阻止事件从子组件冒泡到父组件时。</li><li><code>.prevent</code>：调用 <code>event.preventDefault()</code>，阻止默认行为。</li><li><code>.once</code>：事件只会触发一次。</li></ul></li><li><p>通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:yellow">要么配置在methods中</span>，<span style="color:yellow">要么用箭头函数</span>，否则this指向会出问题！</p></li></ol><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=80">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=80</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="全局事件"><a href="#全局事件" class="headerlink" title="全局事件"></a>全局事件</h2><p>将自定义事件扩展到能够进行<font color="yellow">任意组件间的通信</font>。</p><ol><li><p>安装全局事件总线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>......<br><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-variable language_">this</span> <span class="hljs-comment">//安装全局事件总线，$bus就是当前应用的vm</span><br>&#125;,<br>    ......<br>&#125;) <br></code></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:#FFFF00">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">methods</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title function_">demo</span>(<span class="hljs-params">data</span>)&#123;......&#125;<br>&#125;<br>......<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;xxxx&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">demo</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:#FFFF00">当前组件所用到的</span>事件。</p></li></ol><blockquote><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=84">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=84</a></p><p>SpringBoot+VUE快速入门.md</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong><font color="yellow">路由中的<code>&lt;router-view ref=&quot;main&quot;&gt;&lt;/router-view&gt;</code>也是子组件，可以绑定事件。</font></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-08-02学习总结</title>
    <link href="/2024/08/02/2024-08-02/"/>
    <url>/2024/08/02/2024-08-02/</url>
    
    <content type="html"><![CDATA[<p>本文记录了一些前端学习的知识点</p><span id="more"></span><h1 id="前端学习记录"><a href="#前端学习记录" class="headerlink" title="前端学习记录"></a>前端学习记录</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><h2 id="CSS常见属性的继承性"><a href="#CSS常见属性的继承性" class="headerlink" title="CSS常见属性的继承性"></a>CSS常见属性的继承性</h2><h3 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h3><p>这些属性的值会自动从父元素继承到子元素，除非显式地为子元素设置了其他值。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>color</code></td><td>文本的颜色。</td></tr><tr><td><code>font-family</code></td><td>字体系列。</td></tr><tr><td><code>font-size</code></td><td>字体大小。</td></tr><tr><td><code>font-style</code></td><td>字体样式（如斜体）。</td></tr><tr><td><code>font-weight</code></td><td>字体粗细。</td></tr><tr><td><code>line-height</code></td><td>行高。</td></tr><tr><td><code>text-align</code></td><td>文本对齐方式。</td></tr><tr><td><code>text-indent</code></td><td>文本缩进。</td></tr><tr><td><code>text-transform</code></td><td>文本转换（如大写、小写）。</td></tr><tr><td><code>letter-spacing</code></td><td>字符间距。</td></tr><tr><td><code>word-spacing</code></td><td>单词间距。</td></tr><tr><td><code>text-shadow</code></td><td>文本阴影。</td></tr><tr><td><code>white-space</code></td><td>空白符处理。</td></tr><tr><td><code>visibility</code></td><td>元素可见性。</td></tr><tr><td><code>list-style</code></td><td>列表样式。</td></tr><tr><td><code>border-collapse</code></td><td>边框折叠方式（在表格中）。</td></tr><tr><td><code>border-spacing</code></td><td>边框间距（在表格中）。</td></tr></tbody></table><h3 id="不可继承属性"><a href="#不可继承属性" class="headerlink" title="不可继承属性"></a>不可继承属性</h3><p>这些属性不会自动从父元素继承到子元素，每个元素需要单独设置这些属性的值。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>background</code></td><td>背景颜色、背景图片等。</td></tr><tr><td><code>border</code></td><td>边框的宽度、样式和颜色。</td></tr><tr><td><code>margin</code></td><td>外边距。</td></tr><tr><td><code>padding</code></td><td>内边距。</td></tr><tr><td><font color="#FFFF00"><code>width</code></font></td><td>元素的宽度。</td></tr><tr><td><font color="yellow"><code>height</code></font></td><td>元素的高度。</td></tr><tr><td><code>position</code></td><td>元素的定位方式。</td></tr><tr><td><code>display</code></td><td>元素的显示类型（如块级、行内、隐藏等）。</td></tr><tr><td><code>overflow</code></td><td>内容溢出处理方式。</td></tr><tr><td><code>z-index</code></td><td>元素的堆叠顺序。</td></tr><tr><td><code>box-shadow</code></td><td>盒子阴影。</td></tr><tr><td><code>opacity</code></td><td>元素的不透明度。</td></tr><tr><td><code>float</code></td><td>元素的浮动方式。</td></tr><tr><td><code>clear</code></td><td>清除浮动。</td></tr><tr><td><code>flex</code></td><td>Flexbox 布局属性。</td></tr><tr><td><code>grid</code></td><td>Grid 布局属性。</td></tr><tr><td><code>transform</code></td><td>元素的变换（如旋转、缩放）。</td></tr><tr><td><code>transition</code></td><td>过渡效果。</td></tr><tr><td><code>animation</code></td><td>动画效果。</td></tr></tbody></table><h3 id="继承机制的管理"><a href="#继承机制的管理" class="headerlink" title="继承机制的管理"></a>继承机制的管理</h3><p>对于不可继承的属性，可以使用 <code>inherit</code>, <code>initial</code>, <code>unset</code> 和 <code>revert</code> 值来管理继承行为：</p><ul><li>**<code>inherit</code>**：强制子元素继承父元素的属性值。</li><li>**<code>initial</code>**：将属性值设置为其初始值。</li><li>**<code>unset</code>**：将属性值设置为其继承值或初始值，取决于属性是否继承。</li><li>**<code>revert</code>**：将属性值恢复为由用户代理（浏览器）默认样式表所定义的值。</li></ul><p><font color="#FFFF00">容器设置百分比相对长宽时，由于<code>width</code>和<code>height</code>不会继承，需要保证父容器设置了长宽。</font></p><h2 id="CSS选择器的优先级"><a href="#CSS选择器的优先级" class="headerlink" title="CSS选择器的优先级"></a>CSS选择器的优先级</h2><p><font color="#FFFF00"> 简单描述：<code>!important</code>&gt;行内样式&gt;ID选择器&gt;类选择器&gt;元素选择器&gt;通用选择器(*)&gt;继承样式</font></p><p>详细描述：计算权重。每个选择器，都可计算出一组权重，格式为： (a,b,c)，权重相同则后来者居上。</p><ul><li>a：ID选择器和个数。</li><li>b：类、伪类、属性选择器的个数。</li><li>c：元素、伪元素选择器的个数。</li></ul><blockquote><p><a href="https://www.bilibili.com/video/BV1p84y1P7Z5/?p=86">https://www.bilibili.com/video/BV1p84y1P7Z5/?p=86</a></p><p>《CSS2笔记》 P15</p></blockquote><h2 id="媒体查询和响应式布局"><a href="#媒体查询和响应式布局" class="headerlink" title="媒体查询和响应式布局"></a>媒体查询和响应式布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> &#123;媒体类型 / 媒体特性&#125; <span class="hljs-selector-attr">[ &#123;运算符&#125; &#123;媒体类型 / 媒体特性&#125;  ]</span>&#123;<br>    CSS样式<br>&#125; <br><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">1000px</span>) &#123; <span class="hljs-comment">/* 当媒体为屏幕且视口宽度小于等于1000px时，采用下面的样式 */</span><br>    <span class="hljs-selector-class">.el-aside</span> &#123;<br>        <span class="hljs-attribute">position</span>: fixed;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>        <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1000</span>;<br><br>        &amp;<span class="hljs-selector-class">.hide-aside</span> &#123;<br>            <span class="hljs-attribute">left</span>: -<span class="hljs-number">250px</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>all</td><td>检测所有设备</td></tr><tr><td>screen</td><td>检查电子屏幕</td></tr><tr><td>print</td><td>监测打印机</td></tr></tbody></table><h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>width</td><td>检测视口宽度</td></tr><tr><td>max-width</td><td>检测视口最大宽度</td></tr><tr><td>min-width</td><td>检测视口最小宽度</td></tr><tr><td>height&#x2F;max-height&#x2F;min-height</td><td>类似宽度</td></tr><tr><td>device-width&#x2F;max-device-width&#x2F;min-device-width</td><td>检测<font color="yellow">屏幕</font>宽度&#x2F;最大宽度&#x2F;最小宽度</td></tr><tr><td>orientation</td><td>检测视口的旋转方向（是否横屏）<br>1.<code>portrait</code>：视口处于纵向，即高度大于等于宽度。<br>2.<code>landscape</code>：视口处于横向，即宽度大于高度。</td></tr></tbody></table><p>完整列表请参考：<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media</a></strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>and</td><td>并且</td></tr><tr><td>, 或者 or</td><td>或</td></tr><tr><td>not</td><td>非</td></tr><tr><td>only</td><td>是（加载@media后，某些低版本IE浏览器不检测媒体特性和运算符，避免混乱）</td></tr></tbody></table><blockquote><p><a href="https://www.bilibili.com/video/BV1p84y1P7Z5?p=197">https://www.bilibili.com/video/BV1p84y1P7Z5?p=197</a></p><p>《CSS3笔记》 P29</p></blockquote><h2 id="Sass编译器安装"><a href="#Sass编译器安装" class="headerlink" title="Sass编译器安装"></a>Sass编译器安装</h2><p><strong>Sass是一种CSS预处理器。</strong>Sass提供了一种更简单、更优雅的语法来描述CSS，并支持变量、混合器等功能，使CSS开发更加灵活和高效。Sass源码可以通过编译器转换成标准的CSS代码。</p><p>首次安装：首先全局安装。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install sass -g<br></code></pre></td></tr></table></figure><p>vue终端敲下面代码（电脑上之前全局安装过Sass，不需要第一步操作，直接在项目上安装依赖）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install --save-dev sass-loader<br></code></pre></td></tr></table></figure><h2 id="scoped属性和-deep-v-deep-深度选择器"><a href="#scoped属性和-deep-v-deep-深度选择器" class="headerlink" title="scoped属性和:deep(::v-deep)深度选择器"></a>scoped属性和:deep(::v-deep)深度选择器</h2><h3 id="scoped属性"><a href="#scoped属性" class="headerlink" title="scoped属性"></a>scoped属性</h3><p>vue中的<code>scoped</code>属性用来实现组件级样式封装的一个功能，它确保样式仅作用于当前组件，而不会影响到其他组件。它的渲染规则有：</p><ol><li><code>scoped</code>给当前组件中HTML的所有DOM节点添加一个相同且与其他组件不重复的<code>data属性</code>，来表示组件的唯一性。</li><li>css选择器编译后，会更改为其末尾添加当前组的data属性的属性选择器来私有化样式。</li><li>如果组件内部包含子组件，子组件作为HTML的一个DOM节点会添加data属性，但子组件的子组件不会添加属性。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;div&gt;<br>      &lt;div&gt;<br>        &lt;div&gt;<br>          &lt;div style=&quot;color:#FFFFFF&quot;&gt; scoped原理分析 &lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;el-tabs&gt;<br>      &lt;el-tab-pane label=&quot;标签1&quot;&gt;<br>        &lt;div style=&quot;color:#FFFF00&quot;&gt;标签内容&lt;/div&gt;<br>      &lt;/el-tab-pane&gt;<br>    &lt;/el-tabs&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>  .el-tabs&#123;<br>    background:#000000;<br>    border: 1px solid #FFFFFF;<br>      .el-tabs__content&#123;<br>      background-color: #FFFFFF;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/08/02/2024-08-02/%E5%9B%BE1.png" class title="图1"><p>这个例子我们使用了<code>Element-UI</code>组件来渲染页面。<code>Element-UI</code>组件实现了很多控件功能，而每一个控件都是由一个或多个组件实现的。例如<code>el-tabs</code>标签栏，我们可以看到包含了4个组件。</p><img src="/2024/08/02/2024-08-02/%E5%9B%BE2.png" class title="图2"><p>打开控制台分析页面结构。</p><img src="/2024/08/02/2024-08-02/%E5%9B%BE3.png" class title="图3"><p><font color="yellow">根据第一条规则</font>，组件HTML的所有DOM节点都会添加相同的属性<code>data-v-1f2b5af6</code>，计算有多重div容器也会全部添加。</p><p><font color="#FFFF00">根据第三条规则</font>，ElTabs是当前组件的子组件，也会添加属性。但是TabNav、TabBar、ElTabPane是ElTabs组件的子组件，不会添加data属性。</p><img src="/2024/08/02/2024-08-02/%E5%9B%BE4.png" class title="图4"><img src="/2024/08/02/2024-08-02/%E5%9B%BE5.png" class title="图5"><p><font color="yellow">根据第二条规则</font>，<code>.container&#123;&#125;</code>选择器在经过编译以后变成了<code>.container[data-v-1f2b5af6]&#123;&#125;</code>属性选择器。<code>.container .el-tabs&#123;&#125;</code>选择器编程以后成为了<code>.container .el-tabs[data-v-1f2b5af6]</code>选择器。</p><p>那么同理，<code>.container .el-tabs .tabs__content&#123;&#125;</code>选择器编译会成为<code>.container .el-tabs .el-tabs__content[data-v-1f2b5af6]&#123;&#125;</code>。但是由于<code>el.tabs__content</code>并没有添加data属性，<font color="yellow">所以选择器不起作用，背景颜色未改变</font>。</p><p>为了解决这个问题，我们需要使用<code>:deep / ::v-deep</code>深度选择器。</p><h3 id="deep-v-deep"><a href="#deep-v-deep" class="headerlink" title=":deep / ::v-deep"></a><code>:deep / ::v-deep</code></h3><p>在 Vue.js 中，<code>:deep</code> 是一个用于穿透 <code>scoped</code> 样式封装的特殊选择器。它允许你在父组件中应用样式到子组件的内部元素，从而实现样式的深层次影响。</p><p>我们修改上述选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 原选择器 */</span><br><span class="hljs-selector-class">.el-tabs__content</span>&#123;<br>   <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFFFFF</span>;<br>&#125;<br><span class="hljs-comment">/* 更改后选择器 */</span><br>:<span class="hljs-built_in">deep</span>(.el-tabs__content)&#123;<br>   <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FFFFFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/08/02/2024-08-02/%E5%9B%BE6.png" class title="图6"><p>背景色改变，我们看到<font color="yellow"><code>.container .el-tabs .tabs__content&#123;&#125;</code>选择器编译变成了<code>.container .el-tabs[data-v-1f2b5af6] .el-tabs__content&#123;&#125;</code></font>。</p><blockquote><p><a href="https://blog.csdn.net/wgh4318/article/details/128711849">https://blog.csdn.net/wgh4318/article/details/128711849</a></p><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=69">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=69</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>每日总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-Vue 组件生命周期</title>
    <link href="/2024/07/31/2024-07-31/"/>
    <url>/2024/07/31/2024-07-31/</url>
    
    <content type="html"><![CDATA[<p>本文记录了Vue组件生命周期流程，Vue中的异步问题，以及this.$nextTick的使用。</p><span id="more"></span><h1 id="前端学习-Vue-组件生命周期"><a href="#前端学习-Vue-组件生命周期" class="headerlink" title="前端学习-Vue 组件生命周期"></a>前端学习-Vue 组件生命周期</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><h2 id="组件生命周期流程"><a href="#组件生命周期流程" class="headerlink" title="组件生命周期流程"></a>组件生命周期流程</h2><p>Vue 组件的生命周期包括一系列的钩子函数，这些函数在组件的不同阶段被调用。了解这些生命周期钩子可以帮助你在合适的时机执行特定的操作。</p><img src="/2024/07/31/2024-07-31/%E5%9B%BE1.png" class title="图1"><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><ol><li>**<code>beforeCreate()</code>**：当组件实例被创建之后，此时数据观测和事件配置都还未进行，例如<code>watch</code>事件此时也还未开始监听数据。此时 <code>data</code> 和 <code>methods</code> 尚不可用。</li><li>**<code>created()</code>**： 组件实例创建完成，数据观测和事件配置已经完成，此时 <code>data</code> 和 <code>methods</code> 可用。可以在这里进行数据初始化和 API 请求。如果<code>watch</code>监听事件使用了<code>immediate:true</code>属性，那么<code>handler</code>已经调用完成。</li></ol><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ol><li><strong><code>beforeMount()</code></strong>: 组件挂载之前调用，此时模板已编译完成，<code>render</code> 函数已被调用，Vue 已经生成了组件的虚拟 DOM，但实际的 DOM 元素还没有生成和被插入到页面中。</li><li><strong><code>mounted</code></strong>: 组件挂载完成，此时 真实DOM 已经被插入到页面中。可以在这里进行 DOM 操作、第三方库初始化等操作。</li></ol><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ol><li><strong><code>beforeUpdate</code></strong>: 数据发生变化后，DOM 更新之前调用。Vue 已经更新了组件的虚拟 DOM，可以在这里进行数据处理或保存当前状态。</li><li><strong><code>updated</code></strong>: DOM 更新完成后调用。可以在这里执行依赖于最新 DOM 状态的操作。</li></ol><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a><strong>销毁阶段</strong></h3><ol><li><strong><code>beforeDestroy</code></strong>: 组件销毁之前调用。可以在这里进行清理操作，如取消定时器、解绑事件监听等。</li><li><strong><code>destroyed</code></strong>: 组件销毁完成后调用。此时组件的所有子组件都已销毁，DOM 也被删除。</li></ol><p><font color="yellow">注意点：</font></p><ul><li>创建阶段和销毁阶段是对应的。挂载和更新是类似的，挂载是在组件在创建的时候执行，因为需要将DOM插入到页面中，更新阶段只有新的DOM节点会插入的页面中，已有的DOM节点不会动。</li><li>渲染包括是指将组件的模板转化为实际的 DOM 元素。这个过程包括生成虚拟 DOM 和最终将其转换为真实的 DOM。因此渲染既存在挂载也存在更新阶段。<font color="yellow">渲染并不直接对应钩子函数。</font></li></ul><blockquote><p><a href="https://blog.csdn.net/m0_65335111/article/details/125610342">https://blog.csdn.net/m0_65335111/article/details/125610342</a></p></blockquote><h2 id="父组件与子组件的生命周期流程"><a href="#父组件与子组件的生命周期流程" class="headerlink" title="父组件与子组件的生命周期流程"></a>父组件与子组件的生命周期流程</h2><p>首先以下面代码为例。</p><p><font color="yellow">父组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;ChildComponent v-if=&quot;showComponent&quot; :newArr=&quot;arr&quot;&gt;&lt;/ChildComponent&gt;<br>    &lt;el-button @click=&quot;addData&quot;&gt;增加父组件数据&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;()=&gt;&#123;showComponent=!showComponent&#125;&quot;&gt;控制组件&lt;/el-button&gt;<br>    &lt;el-button @click=&quot;()=&gt;&#123;arr.push(&#x27;newdata&#x27;)&#125;&quot;&gt;更改数组&lt;/el-button&gt;<br>    &#123;&#123; data &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import ChildComponent from &#x27;./ChildComponent.vue&#x27;;<br>export default &#123;<br>  components:&#123;ChildComponent&#125;,<br>  data() &#123;<br>    return &#123;<br>      arr : [&quot;父组件初始数据&quot;],<br>      data : 0,<br>      showComponent : true,<br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    addData()&#123;<br>      this.data++;<br>    &#125;<br>  &#125;,<br>  beforeCreate()&#123;<br>    console.log(&quot;父组件beforeCreate方法调用&quot;);<br>  &#125;,<br>  created()&#123;<br>    console.log(&quot;父组件created方法调用&quot;);<br>  &#125;,<br>  beforeMount()&#123;<br>    console.log(&quot;父组件beforeMount方法调用&quot;);<br>  &#125;,<br>  mounted()&#123;<br>    console.log(&quot;父组件mounted方法调用&quot;);<br>  &#125;,<br>  beforeDestroy()&#123;<br>    console.log(&quot;父组件beforeDestroy方法调用&quot;);<br>  &#125;,<br>  destroyed()&#123;<br>    console.log(&quot;父组件destroyed方法调用&quot;);<br>  &#125;,<br>  beforeUpdate()&#123;<br>    console.log(&quot;父组件beforeUpdate方法调用&quot;);<br>  &#125;,<br>  updated()&#123;<br>    console.log(&quot;父组件updated方法调用&quot;);<br>  &#125;,<br>  deactivated()&#123;<br>    console.log(&quot;父组件deactivated方法调用&quot;);<br>  &#125;,<br>  activated()&#123;<br>    console.log(&quot;父组件activated方法调用&quot;);<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;scss&quot; scoped&gt;<br>.container &#123;<br>  height: 100vh;<br>  width: 100vw;<br>  background: #080E19;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><font color="yellow">子组件：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;child-container&quot;&gt;<br>    &lt;el-button @click=&quot;addData&quot;&gt;增加数据&lt;/el-button&gt;<br>    &#123;&#123; data &#125;&#125;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  props:&#123;<br>    newArr:&#123;<br>      type: Array,<br>      default: ()=&gt;[&quot;初始参数&quot;]<br>    &#125;<br>  &#125;,<br>  data()&#123;<br>    return&#123;<br>      arr:[&quot;子组件初始数据&quot;],<br>      data:0,<br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    addData()&#123;<br>      console.log(&quot;addData方法&quot;)<br>      this.data++;<br>    &#125;<br>  &#125;,<br>  watch:&#123;<br>    newArr()&#123;<br>      console.log(&quot;监听事件调用&quot;)<br>    &#125;<br>  &#125;,<br>  beforeCreate()&#123;<br>    console.log(&quot;子组件beforeCreate方法调用&quot;);<br>  &#125;,<br>  created()&#123;<br>    console.log(&quot;子组件created方法调用&quot;);<br>    console.log(this.arr)<br>    console.log(this.newArr)<br>    console.log(this.data)<br>  &#125;,<br>  beforeMount()&#123;<br>    console.log(&quot;子组件beforeMount方法调用&quot;);<br>  &#125;,<br>  mounted()&#123;<br>    console.log(&quot;子组件mounted方法调用&quot;);<br>  &#125;,<br>  beforeDestroy()&#123;<br>    console.log(&quot;子组件beforeDestroy方法调用&quot;);<br>  &#125;,<br>  destroyed()&#123;<br>    console.log(&quot;子组件destroyed方法调用&quot;);<br>  &#125;,<br>  beforeUpdate()&#123;<br>    console.log(&quot;子组件beforeUpdate方法调用&quot;);<br>  &#125;,<br>  updated()&#123;<br>    console.log(&quot;子组件updated方法调用&quot;);<br>  &#125;,<br>  deactivated()&#123;<br>    console.log(&quot;子组件deactivated方法调用&quot;);<br>  &#125;,<br>  activated()&#123;<br>    console.log(&quot;子组件activated方法调用&quot;);<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style land=&quot;scss&quot; scoped&gt;<br>.child-container &#123;<br>  height: 30%;<br>  width: 30%;<br>  background: #00b8b8;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><img src="/2024/07/31/2024-07-31/%E5%9B%BE2.png" class title="图2"><p><strong>组件创建的生命周期如下：</strong></p><p>父组件<code>beforeCreate</code>——&gt;（父组件数据和事件开始初始化）——&gt; 父组件<code>created</code>——&gt;（此时父组件数据和事件都初始化完成，data数据已经准备好，虚拟DOM开始创建）——&gt; 父组件<code>beforeMount</code>——&gt;（虚拟DOM已经创建，页面渲染开始，真实DOM创建并开始挂载到页面，直到渲染到子组件DOM）——&gt; 子组件<code>beforeCreate</code>——&gt;（子组件数据和事件开始初始化，包括传递的参数props，初始化的数据watch还没有开始监听）——&gt; 子组件<code>created</code>——&gt;（此时子组件数据初始化完成，watch已经开始监听，虚拟DOM开始创建）——&gt; 子组件<code>beforeMount</code>——&gt;（虚拟DOM已经创建，页面渲染开始，真实DOM创建并开始挂载到页面）——&gt; 子组件<code>mounted</code>——&gt; （子组件挂载完成，返回到父组件继续渲染）——&gt; 父组件<code>mounted</code>——&gt;（父组件挂载完成）</p><p><font color="yellow">注意点：</font></p><ul><li>销毁周期和创建周期是相同的。组件的创建生命周期是深度优先遍历的顺序，如果子组件还有子组件，会先创建最深层的子组件。</li></ul><img src="/2024/07/31/2024-07-31/%E5%9B%BE3.png" class title="图3"><p><font color="yellow">注意点：</font></p><ul><li><code>beforeUpdate</code>和<code>updated</code>生命周期钩子的执行时间和<code>beforeMounte</code>和<code>mounted</code>是类似的。因此上述流程很好理解了。 </li><li><code>beforeUpdate</code>和<code>updated</code>生命周期钩子<font color="yellow">只在页面需要重写渲染的时候才会执行，而与数据变化无关</font>，如果数据改变但不影响页面，页面无需更新，则不会重写渲染。</li></ul><h2 id="Vue中的异步问题"><a href="#Vue中的异步问题" class="headerlink" title="Vue中的异步问题"></a>Vue中的异步问题</h2><p>Vue.js是一款渐进式JavaScript框架，专注于构建用户界面。在Vue中，常见的异步操作包括数据请求、路由导航、生命周期钩子函数等。Vue提供了一些方法来处理这些异步操作，最常见的是使用<code>Promise</code>对象。</p><ul><li><p><strong>同步</strong>指的是代码按顺序执行，前一个任务完成后才会执行下一个任务。在同步操作中，代码的执行是阻塞的，即一个操作完成后，才会继续执行下一个操作。</p></li><li><p><strong>异步</strong>指的是代码的执行不一定按顺序进行，任务可以在后台执行，允许主线程继续处理其他任务。异步操作是非阻塞的，即代码可以在后台执行而不阻塞主线程。</p></li></ul><h3 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a><code>Promise</code>对象</h3><p><code>Promise</code> 是 JavaScript 中用于处理异步操作的对象。<font color="yellow">它代表了一个尚未完成但计划中的操作，并允许你在操作完成时处理结果或错误。</font><code>Promise</code> 是异步编程中的一个重要概念，使得异步操作的处理更加清晰和可维护。</p><p>先不谈<code>Promise</code>对象的创建和属性方法，先明白以下几点。</p><ul><li><code>promise</code>是一个对象，用于处理异步操作。</li><li>JS中所有的异步操作都是在<code>Promise</code>对象中执行的，而函数最终会返回这个<code>Promise</code>对象。</li><li><code>Promise</code> 提供了 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 方法来处理操作结果和错误。</li></ul><p><strong>以下是一个简单的 <code>Promise</code> 示例，模拟异步操作（例如数据请求）：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> success = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 模拟操作成功或失败</span><br>      <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Data fetched successfully&#x27;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Data fetch failed&#x27;</span>);<br>      &#125;<br>    &#125;, <span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟延迟2秒</span><br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// &#x27;Data fetched successfully&#x27;</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error); <span class="hljs-comment">// &#x27;Data fetch failed&#x27;</span><br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Fetch attempt completed&#x27;</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><p><strong>真实的一个数据请求操作实例：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;./api/data&quot;</span>) <span class="hljs-comment">//返回一个Promise对象。</span><br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 处理数据</span><br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 处理错误</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a><code>async</code>和<code>await</code></h3><p><code>async</code> 和 <code>await</code> 是 JavaScript 中用于处理异步操作的关键字，提供了更简洁和易读的异步代码写法。它们是基于 <code>Promise</code> 的，允许你以同步的方式编写异步代码。</p><p>在数据请求中，我们需要获取数据以后才能进行数据处理，通过在<code>.then()</code>方法中操作。但是如果数据操作比较复杂，例如需要将得到的数据作为下一个数据请求的参数，这样会导致过多的重叠。而<font color="yellow"><code>async</code>和<code>await</code>允许你以同步的方式编写异步代码就是解决这个问题</font>。</p><ul><li><code>async</code> 函数是一个返回 <code>Promise</code> 对象的函数。在 <code>async</code> 函数中，你可以使用 <code>await</code> 关键字来暂停函数的执行，直到 <code>Promise</code> 对象的异步操作完成。</li><li><code>await</code> 用于等待一个 <code>Promise</code> 对象解析完成。在 <code>await</code> 之前的代码会暂停执行，直到 <code>Promise</code> 被解析，返回的是<code>promise</code>解析结果，而不是<code>promise</code>对象，然后继续执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">getDayWeather</span>: <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//注意：这里有 async 用来完成异步操作</span><br>    <span class="hljs-comment">// 获取逐小时预报</span><br>    <span class="hljs-comment">// 根据城市名或者经纬度获取城市id</span><br>    <span class="hljs-keyword">let</span> httpUrl = <span class="hljs-string">`https://geoapi.qweather.com/v2/city/lookup?location=<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.city&#125;</span>&amp;key=<span class="hljs-subst">$&#123;key&#125;</span>`</span><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(httpUrl)<br>    <span class="hljs-keyword">let</span> result = res.<span class="hljs-title function_">json</span>()<br>    <span class="hljs-keyword">let</span> id = result.<span class="hljs-property">location</span>[<span class="hljs-number">0</span>].<span class="hljs-property">id</span><br>    <span class="hljs-comment">// 根据城市id获取具体的天气</span><br>    <span class="hljs-keyword">let</span> httpUrl1 = <span class="hljs-string">`https://devapi.qweather.com/v7/grid-weather/24h?location=<span class="hljs-subst">$&#123;id&#125;</span>&amp;key=<span class="hljs-subst">$&#123;key&#125;</span>`</span><br>    <span class="hljs-keyword">let</span> res1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(httpUrl1)<br>    <span class="hljs-keyword">let</span> result1 = res1.<span class="hljs-title function_">json</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dayClimate</span> = result1.<span class="hljs-property">hourly</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;小时天气&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">dayClimate</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>上述使用和风天气API获取未来24小时的数据请求，包括两个请求，首先是通过根据城市名或者经纬度获取城市id，然后根据城市id获取具体的天气。在这里，<code>await</code>用于等待异步处理返回，也就是数据请求完成并返回，只有数据返回后，才能进行数据处理。<font color="yellow">而<code>await</code>只能在<code>async</code>函数中使用</font></p><p>类似于下述代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> httpUrl = <span class="hljs-string">`https://geoapi.qweather.com/v2/city/lookup?location=<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.city&#125;</span>&amp;key=<span class="hljs-subst">$&#123;key&#125;</span>`</span><br>    <span class="hljs-title function_">fetch</span>(httpUrl)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> result = res.<span class="hljs-title function_">json</span>()<br>        <span class="hljs-keyword">let</span> id = result.<span class="hljs-property">location</span>[<span class="hljs-number">0</span>].<span class="hljs-property">id</span><br>    <span class="hljs-keyword">let</span> httpUrl1 = <span class="hljs-string">`https://devapi.qweather.com/v7/grid-weather/24h?location=<span class="hljs-subst">$&#123;id&#125;</span>&amp;key=<span class="hljs-subst">$&#123;key&#125;</span>`</span><br>        <span class="hljs-title function_">fetch</span>(httpUrl1)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res1</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">let</span> result1 = res1.<span class="hljs-title function_">json</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dayClimate</span> = result1.<span class="hljs-property">hourly</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;小时天气&quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">dayClimate</span>)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="yellow">但需要注意的是，并且async函数本身也返回一个Promise对象，也就是说整个函数本身也是一个异步处理函数。</font></p><blockquote><p><a href="https://blog.csdn.net/qqq1994_0810/article/details/135133857">https://blog.csdn.net/qqq1994_0810/article/details/135133857</a></p></blockquote><h2 id="异步问题对生命周期的影响"><a href="#异步问题对生命周期的影响" class="headerlink" title="异步问题对生命周期的影响"></a>异步问题对生命周期的影响</h2><p>在 Vue.js 中，生命周期钩子函数本身是<strong>同步的</strong>，即它们按照特定的顺序执行，并在生命周期的特定阶段被调用。然而，生命周期钩子函数中可以包含异步操作，如数据请求、定时器等。以下是有关生命周期钩子函数的详细信息：</p><p>生命周期钩子的同步行为:</p><ul><li><strong>同步执行</strong>：生命周期钩子函数（如 <code>created</code>、<code>mounted</code>、<code>updated</code> 等）是同步执行的，即它们会按照定义的顺序被调用，并在生命周期的特定阶段完成执行。</li><li><strong>顺序调用</strong>：Vue.js 会在组件生命周期的不同阶段调用这些钩子函数，从组件实例的创建、挂载到更新和销毁，每个钩子函数都有特定的调用时机。</li></ul><p><font color="yellow">尽管生命周期钩子函数本身是同步的，但可以在这些钩子函数中执行异步操作。这些异步操作不会影响钩子函数的同步执行，但可能会影响组件的状态和视图更新。</font></p><h3 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick()"></a><code>this.$nextTick()</code></h3><p>当你更新一个响应式数据，Vue 不会立即同步更新 DOM。相反，Vue 会等到事件循环的下一个 “tick” 才执行这些更新，以进行批量处理和优化。<code>this.$nextTick()</code> 的作用就是在这个更新完成之后，执行你指定的回调函数。<font color="yellow">使用 <code>this.$nextTick()</code> 的关键是确保在需要等待 Vue 更新 DOM 后再执行的场景下使用</font></p><p><strong>异步执行</strong>：<code>this.$nextTick()</code> 的回调函数是异步执行的，因此它不会阻塞主线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p ref=&quot;paragraph&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;updateMessage&quot;&gt;Update Message&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      message: &quot;Hello, Vue!&quot;<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    updateMessage() &#123;<br>      this.message = &quot;Hello, World!&quot;;<br>      this.$nextTick(() =&gt; &#123;<br>        console.log(this.$refs.paragraph.offsetHeight); // 获取的是更新后的 DOM 高度<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>/* 样式 */<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>上述例子如果没有<code>this.$nextTick()</code>，当点击按钮后，<code>this.message</code> 更新为 “Hello, World!”，但是 <code>console.log(this.$refs.paragraph.offsetHeight);</code> 可能获取的是更新前的 <code>p</code> 元素的高度，因为此时 DOM 还未更新。</p><p>虽然没有使用 <code>this.$nextTick()</code>，Vue 仍会更新 DOM，但是在数据更新后立即访问 DOM 时，可能会获取到更新前的状态。使用 <code>this.$nextTick()</code> 能够确保你的操作在 DOM 更新后执行，获取到最新的 DOM 状态，从而保证操作的准确性和一致性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模-数学建模入门指南</title>
    <link href="/2024/07/24/2024-07-24/"/>
    <url>/2024/07/24/2024-07-24/</url>
    
    <content type="html"><![CDATA[<p>文章介绍数学建模的入门指南，梳理数学建模概念。</p><span id="more"></span><h1 id="数学建模入门指南"><a href="#数学建模入门指南" class="headerlink" title="数学建模入门指南"></a>数学建模入门指南</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><p>数学建模是一个将<font color="#00F7B4">现实世界的复杂问题转化成数学形式来对问题进行分析和求解的过程</font>。这个过程涉及将实际问题中的复杂因素简化为数学结构，并用数学语言描述这些因素及其相互关系。</p><blockquote><p><strong>引入经典问题：长方形（四角连线呈长方形）的椅子可以在地面上放稳吗？</strong></p></blockquote><p>这是一个现实世界的问题，数学建模的过程就是需要将其转化成数学形式进行分析和求解。主要分为以下五个步骤。</p><h2 id="建模过程"><a href="#建模过程" class="headerlink" title="建模过程"></a>建模过程</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>大家可能会想,题目不是已经给出问题了吗? 是的,但是这里的提出问题是指用数学语言去表达。</p><p>首先<font color="yellow">分析问题</font>，列出问题中涉及的变量，包括适当的单位。经过分析，我们可以用变量表示椅子的位置，用函数表示椅子四脚与地面的距离，进而用数学语言把问题表达出来.</p><p>接着<font color="yellow">模型假设</font>，我们要抛开一些非主干的问题，因此需要对问题做一些假设。模型假设是我们对问题增加的约束条件，在做模型假设是我们要考虑假设的合理性和特殊性。例如我们不能假设地面时完全水平的或是阶梯，这种假设没有意义。</p><ol><li>假设椅子的四条腿一样长，椅子腿与地面接触处抽象为一个点，，四脚的连线呈长方形。</li><li>地面高度是连续变化的，沿周围任意方向都不会出现间断 (高度突变)，即地面是连续曲面。这个假设相当于给出了椅子能放稳的必要条件。</li><li>对于椅子脚的间距和椅子腿的长度而言，地面是相对平坦的，使椅子在任何位置至少有三只脚同时着地。</li></ol><p>然后<font color="yellow">数学表达</font>，根据模型假设和涉及的变量将问题数学化。这一步通常要结合考虑我们可能会用到的模型。</p><p>我们知道，当椅脚与地面的竖直距离为零时，椅脚就着地了，而当这个距离大于零时，椅脚不着地。假设椅子的四脚记作A，B，C，D。根据假设3至少由三只脚同时着地，那么椅子在地面上移动对问题没有影响，只考虑椅子旋转的情况。因此我们假设某一时刻A，B，C着地，以AC与BD连线的交点为原点，AC为X轴建立平面直角坐标系，设OA与X轴的夹角为θ，因为长方形的旋转可代表椅子位置的改变，则旋转角度θ这一变量可表示椅子的位置。A、B两脚与地面竖直距离之和为f（θ），C、D两脚与地面竖直距离之和为g（θ），其中θ∈[0，π]。</p><img src="/2024/07/24/2024-07-24/18b98e4f898657c25044739c34870862.png" class title="图1"><p>在更多复杂的现实问题中，我们在问题分析和模型假设之前，可能还需要进行<font color="yellow">数据集处理</font>工作。例如我们希望建立模型来预测房价，需要进行一下工作：</p><ol><li>数据收集：通过各个平台收集包含多个房屋特征的数据集，例如房屋面积、卧室数量、位置、房价等。</li><li>数据清洗：收集的数据集可能存在很多问题，数据清洗的目标是处理数据中的问题，使数据质量达到可用的标准。包括<ul><li>缺失值处理：比如数据集中有些房屋的“面积”特征缺失，可以用均值、中位数或最频繁值填充缺失值，或者使用插值方法填补缺失值。</li><li>异常值处理：比如发现一些房屋的“面积”值异常大，可能是录入错误，通过统计分析（如箱线图）识别异常值，并根据业务规则决定是否删除或修正这些值。</li><li>重复数据处理：比如数据集中存在重复的房屋记录。我们要删除重复记录，以确保每个房屋只有一个数据条目。</li><li>数据标准化：房屋价格可能使用了不同的货币单位。我们要统一所有价格数据的单位，以便进行比较和分析。</li></ul></li><li>特征工程：目标是从原始数据中提取有用的信息，创建新的特征，或者转换现有特征，以提高模型的性能。<ul><li>特征提取：例如数据集中没有包含房屋的“楼层”信息，但这可能对房价有影响。可以从房屋的描述字段中提取出“楼层”信息，并作为一个新特征添加到数据集中。</li><li>特征归一化：一些特征（如房屋面积和房龄）具有不同的量纲，这可能会影响模型训练。可以对特征进行标准化或归一化，以确保所有特征在相同的尺度上。</li></ul></li></ol><p>最终房屋价格可能与房屋面积、卧室数量、位置、房价、楼层等特征因素有关，我们再列出变量和数学关系。</p><h3 id="选择建模方法"><a href="#选择建模方法" class="headerlink" title="选择建模方法"></a>选择建模方法</h3><p>选择解决问题的一个一般的求解方法。一般地，这一步需要有一定的数学建模经验和技巧。同时需要熟悉相关的文献。要求我们对常见的数学模型和算法有一定的了解。下图列出来针对不同问题的常见模型。</p><h4 id="常用模型"><a href="#常用模型" class="headerlink" title="常用模型"></a>常用模型</h4><img src="/2024/07/24/2024-07-24/%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB.jpg" class title="图2"><p>例如回归拟合预测模型就是房价预测中常用的一种方法。它通过建立一个数学模型来描述房价与其他特征变量（房屋面积、卧室数量、位置、房价、楼层）之间的关系，从而进行预测。</p><h4 id="常用的十大算法："><a href="#常用的十大算法：" class="headerlink" title="常用的十大算法："></a>常用的十大算法：</h4><ol><li><font color="yellow">蒙特卡罗算法</font>(该算法又称随机性模拟算法，是通过计算机仿真来解决问题的算法，同时可以通过模拟可以来检验自己模型的正确性，是比赛时必用的方法)</li><li><font color="yellow">数据拟合、参数估计、插值等数据处理算法</font>(比赛中通常会遇到大量的数据需要处理，而处理数据的关键就在于这些算法，通常使用Matlab作为工具)</li><li><font color="yellow">线性规划、整数规划、多元规划、二次规划等规划类问题</font>(建模竞赛大多数问题属于最优化问题，很多时候这些问题可以用数学规划算法来描述，通常使用Lindo、Lingo软件实现)</li><li><font color="yellow">图论算法</font>(这类算法可以分为很多种，包括最短路、网络流、二分图等算法，涉及到图论的问题可以用这些方法解决需要认真准备)</li><li><font color="yellow">动态规划、回溯搜索、分治算法、分支定界等计算机算法</font>(这些算法是算法设计中比较常用的方法，很多场合可以用到竞赛中）</li><li><font color="yellow">最优化理论的三大非经典算法:模拟退火法、神经网络、遗传算法</font>(这些问题是用来解决一些较困难的最优化问题的算法，对于有些问题非常有帮助，但是算法的实现比较困难，需慎重使用)</li><li><font color="yellow">网格算法和穷举法</font>(网格算法和穷举法都是暴力搜索最优点的算法，在很多竞赛题中有应用，当重点讨论模型本身而轻视算法的时候，可以使用这种暴力方案，最好使用一些高级语言作为编程工具)</li><li><font color="yellow">一些连续离散化方法</font>(很多问题都是实际来的，数据可以是连续的，而计算机只认的是离散的数据，因此将其离散化后进行差分代替微分、求和代替积分等思想是非常重要的)</li><li><font color="yellow">数值分析算法</font>(如果在比赛中采用高级语言进行编程的话，那一些数值分析中常用的算法比如方程组求解、矩阵运算、函数积分等算法就需要额外编写库函数进行调用)</li><li><font color="yellow">图象处理算法</font>(赛题中有一类问题与图形有关，即使与图形无关，论文中也应该要不乏图片的，这些图形如何展示以及如何处理就是需要解决的问题。</li></ol><h4 id="模型和算法之间的关系"><a href="#模型和算法之间的关系" class="headerlink" title="模型和算法之间的关系"></a>模型和算法之间的关系</h4><ol><li><strong>模型使用算法来实现和优化</strong>：<ul><li><strong>实现模型</strong>：许多模型的实现依赖于算法。例如，支持向量机（SVM）模型需要通过算法来找到最优的分割超平面。</li><li><strong>优化模型</strong>：优化模型中的参数或结构通常使用算法。例如，线性回归模型通过最小二乘算法来确定回归系数。</li></ul></li><li><strong>模型定义了问题，算法提供了解决方案</strong>：<ul><li><strong>模型定义</strong>：模型描述了问题的结构和关系。它定义了要分析的变量、参数及其相互作用。</li><li><strong>算法解决</strong>：算法提供了解决模型中问题的方法和步骤。例如，决策树模型定义了分类规则，而构建决策树的算法（如ID3或C4.5）决定了如何生成树结构。</li></ul></li><li><strong>模型和算法的结合</strong>：<ul><li><strong>模型构建</strong>：在构建模型时，需要选择和设计合适的算法来实现模型的功能。例如，在机器学习中，选择模型（如神经网络）时，需要应用相应的训练算法（如反向传播算法）。</li><li><strong>模型评估和优化</strong>：模型的效果可以通过算法来评估和优化。例如，交叉验证算法可以用来评估模型的性能，超参数优化算法（如网格搜索、随机搜索）可以用来调整模型的参数。</li></ul></li></ol><h3 id="推导模型的公式"><a href="#推导模型的公式" class="headerlink" title="推导模型的公式"></a>推导模型的公式</h3><p>将第一步中得到的问题重新表达成第二步选定的建模方法所需要的形式，从而<font color="yellow">构建模型</font>，确保第一步中的变量名与第二步的一致。记下任何补充假设，这些假设是为了使第一步中描述的问题与第二步中选定的数学结构相适应而做出的。</p><p>在椅子平稳性问题中，数学模型构建：已知f（θ）和g（θ）是θ的非负连续函数，对∀θ，f（θ）•g(θ)＝0，证明：∃θ0∈[0，π]，使得f（θ0）＝g（θ0）＝0成立。</p><p>在房价预测问题中，数学模型构建：通过线性函数用于建模多个自变量 x1,x2,……xp 和一个因变量 y 之间的线性关系。</p><img src="/2024/07/24/2024-07-24/image-20240724224309134.png" class title="图3"><p>其中自变量X可以表示房屋面积、卧室数量、位置、房价、楼层等特征变量，y是房价。</p><h3 id="求解模型"><a href="#求解模型" class="headerlink" title="求解模型"></a>求解模型</h3><p>将第二步中所选方法应用于第三步得到的表达式，再求解过程中注意数学推导，确保推导过程无误且结果有意义。并采用适当的方法扩大解决问题的范围并减少计算错误。</p><p>在椅子平稳性问题中，①若f（0）＝g（0）＝0，那么结论成立。②若f（0）与g（0）不同时为零，不妨设f（0）＞0，g（0）＝0。将长方形ABCD绕点O逆时针旋转角度π后，A，B与C，D互换，但长方形ABCD在地面上所处的位置不变，由此可知，f（π）＝g（0），g（π）＝f（0）.∴f（0）＞0，g（0）＝0 → g（π）＞0，f（π）＝0。</p><p>令h（θ）＝f(θ)－g（θ），由f(θ)和g(θ)的连续性知h(θ)也是连续函数。又h（0）＝f(0)－g（0）＞0，h（π）＝f(π)－g（π）＜0，根据连续函数介值定理，必存在θ0∈（0，π）使得h（θ0）＝0，即f（θ0）＝g（θ0） ；又因为f（θ0）•g（θ0）＝0，所以f（θ0）＝g（θ0）＝0。即四只脚同时着地，稳定。</p><p>在预测房价问题中，需要是预测的房价和真实的房价的误差趋于最小，使用最小二乘法作为损失函数优化模型，即使图中Q值趋于最小。也就是当梯度为零的时候取最小值。</p><img src="/2024/07/24/2024-07-24/image-20240724225420896.png" class title="图4"><img src="/2024/07/24/2024-07-24/image-20240724225449385.png" class title="图5"><p>这一过程需要对建模工具有一定的掌握。</p><ol><li><p>统计模型：SPSS,Eviews，Stata 。</p></li><li><p>数据分析：R，数据库SQL Server，IBM，DB2</p></li><li><p>微分方程：Maple, Mathematic, MATLAB</p></li><li><p>运筹规划：Matlab，Lingo</p></li><li><p>智能算法：Matlab，R</p></li><li><p>时间序列：R，Matlab</p></li><li><p>图像处理：Matlab，C++</p></li></ol><h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><p>最终在论文中我们需要用非技术性的语言将第四步的结果重新表述，表述过程中需要避免数学符号和术语。这部分是对你整篇论文成果的总结，一定要写的有深度。除此之外，通常还要写上一些灵敏度分析，如果是统计模型的话，要有模型检验。论文通常会需要画一些图表，可以使用Matlab、R等软件来画跟数据有关的图，使用Visio或者PPT画流程图之类的图。</p><p>在椅子平稳性问题中，椅子在旋转过程中，至少存在一个点能使椅子能在不平的地面上放稳。</p><p>在预测房价问题中，根据我们推导出的模型，当已知特征变量时，能够预测房屋价格。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在建模的五步法中，整个建模需要的工作包括：</p><ol><li>数据收集：要构建有效的模型，首先需要获得相关的数据。这些数据可以来自多种渠道。</li><li>数据清理：原始数据往往包含噪声、缺失值和异常值，因此在建模之前必须对数据进行清理。数据清理的过程包括：</li><li>特征工程：特征工程是指从原始数据中提取和构造有助于模型预测的特征</li><li>模型选择与建立：根据问题的性质和数据的特点，选择合适的数学或统计模型。常见的模型类型包括：</li><li>模型求解：在模型建立之后，需要对模型进行求解、训练和验证。</li><li>模型评估：评估模型的性能是检验模型有效性的重要步骤。</li><li>问题回答：用非技术语言解释模型的预测结果和模型的原理和假设等</li></ol><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><ul><li><font color="yellow">高数、线性代数和概率论与统计基础。</font>在数学建模过程中我们要能够掌握函数的变化、极值、导数、积分等概念，对于优化问题和动态系统建模非常重要。而矩阵运算、特征值、特征向量、线性方程组等概念在处理数据、优化问题和统计分析中至关重要。同时还需要处理不确定性和随机性，涉及概率分布、期望值、方差、假设检验等问题。</li><li><font color="yellow">掌握常见模型和算法。</font>只有对常见模型和算法有一定的了解，才能在选择解决问题的一个一般的求解方法时，找到合适和模型。不一定要对模型有很深的了解，但要知道不同模型能够用在哪些问题上。</li></ul><h3 id="编程代码"><a href="#编程代码" class="headerlink" title="编程代码"></a>编程代码</h3><ul><li><strong>Matlab</strong>：交互式编程软件，将海量算法或工具进行封存，能仿真、能绘图、能求解，可直接调用。</li><li><strong>Python</strong>：主要针对机器学习算法和深度学习，以及数据分析是非常方便的。</li><li><strong>SPSS</strong>：专业的统计数据分析软件，有大量统计模型可直接使用。</li><li><strong>Lingo</strong>：交互式的线性和通用优化求解器，可以用于求解各类规划模型。</li></ul><h3 id="写作排版"><a href="#写作排版" class="headerlink" title="写作排版"></a>写作排版</h3><ul><li><strong>WORD(或WPS)</strong>:论文写作专用，并可以导成PDF格式</li><li><strong>EXCEL</strong>:分析数据、并绘制数据走势图等精美图片Mathtype:公式编辑器，用于编写各类数学公式和特殊符号</li><li><strong>Mathpix</strong>:公式提取软件，用于将其他论文的公式提取到自己论文中</li><li><strong>Checker</strong>:英文文章语言免费检查软件，可分析语法、拼写等错误</li><li><strong>LaTeX</strong>:论文排版软件，主要利用编程语言对论文进行排版</li></ul><h3 id="文献检索"><a href="#文献检索" class="headerlink" title="文献检索"></a>文献检索</h3><p>文献检索也是很重要的，数模竞赛题目往往具有一定的专业性，需要学会查到相关领域的论文并加以利用。</p><h2 id="建模比赛"><a href="#建模比赛" class="headerlink" title="建模比赛"></a>建模比赛</h2><p>只有参加比赛在实践中才能帮助我们快速提升，通过比赛熟悉从数据收集、建立模型到论文撰写的整个流程；提示文献查阅、工具使用和代码编写的能力；感受团队协作、学术讨论、全力以赴的氛围。刚开始的时候要端正好心态，不要盲目的追求获奖，以学习练兵为目标。</p><h3 id="如何组队"><a href="#如何组队" class="headerlink" title="如何组队"></a>如何组队</h3><p>建模比赛都是是三个人组队，一般来说为：一人负责编程、一人负责建模、一人负责论文。</p><p>队长通常由建模手担任，需要具备的是<strong>领导力、沟通协调能力、时间管理能力和决策能力</strong>。他不仅要掌控比赛进度，建立有效的沟通机制，合理分配各阶段的任务和时间，还要激发团队士气，综合团队意见，做出明智的决策。</p><p>建模手的首要任务深入解析题目要求，确保对问题的全面准确理解。随后需<strong>广泛搜集并研读相关领域的最新文献</strong>，提炼出关键的研究方法和理论框架。基于这些资料<strong>设计并构建数学模型</strong>，明确模型假设、参数设定及逻辑推导过程，形成模型初稿。在编程手和写作手的反馈下不断<strong>迭代优化模型</strong>，确保其既符合题目要求又便于编程实现和论文撰写。</p><p>赛前，写作手要<strong>熟悉论文写作规范</strong>，准备好论文模板和必要的写作工具（如Word、LaTeX）。根据建模手提供的模型初稿和深入分析，展开详细的论述，包括背景介绍、文献综述、模型构建、结果分析等多个部分，确保论文内容充实、逻辑严谨。在编程手完成编程工作后，将<strong>结合编程结果和模型理论</strong>，进行深入的分析和讨论，提升论文的学术价值和说服力。最后<strong>全面审查论文</strong>，修正语法错误、优化排版布局，确保论文的整洁美观。</p><p>编程要<strong>做好技术准备</strong>，赛前熟练掌握至少一种编程语言（如Python、MATLAB）并安装调试好运行环境。在明确建模手M的模型求解需求后，要<strong>迅速制定编程方案</strong>，编写高效、准确的代码来实现模型求解。在编程过程中应<strong>注重代码的可读性和可维护性</strong>，并在适当位置添加注释和输出中间结果，以便于调试和后续分析。在编程完成后，<strong>整理编程结果</strong>，并将其转化为易于理解和分析的表格、图形等形式，为写作手提供有力的数据支持。</p><h3 id="数学建模比赛"><a href="#数学建模比赛" class="headerlink" title="数学建模比赛"></a>数学建模比赛</h3><img src="/2024/07/24/2024-07-24/ed05abae7f4a47958d3243172a469d29_%E7%9C%8B%E5%9B%BE%E7%8E%8B.png" class title="图6"><blockquote><p>图片来源：<a href="https://blog.csdn.net/weixin_61644243/article/details/136262876">https://blog.csdn.net/weixin_61644243/article/details/136262876</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>数学分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习-ECharts使用（2）</title>
    <link href="/2024/07/23/2024-07-23/"/>
    <url>/2024/07/23/2024-07-23/</url>
    
    <content type="html"><![CDATA[<p>文章介绍了EChats图表构建中Axis、Grid、Legend、Tooltip的常见用法。</p><span id="more"></span><h1 id="前端学习-ECharts的使用（2）"><a href="#前端学习-ECharts的使用（2）" class="headerlink" title="前端学习-ECharts的使用（2）"></a>前端学习-ECharts的使用（2）</h1><blockquote><p>个人学习总结，可能存在错误。</p></blockquote><hr><p>本文以下面代码为初始状态进行分析ECharts配置项的基本使用，我们总结了常用的配置项，并尽量总结了它们之间的联系，<font color="yellow">当然在使用的时候我们还是需要结合官方的API文档和配置项文档使用</font>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> dataX=[];<br><span class="hljs-keyword">let</span> dataY1=[];<br><span class="hljs-keyword">let</span> dataY2=[];<br><span class="hljs-keyword">let</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;count&lt;<span class="hljs-number">20</span>;count++)&#123;<br>  dataX.<span class="hljs-title function_">push</span>((count+<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>());<br>  dataY2.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());<br>  dataY1.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());<br>&#125;<br><br>option=&#123;<br>  <span class="hljs-attr">textStyle</span>:&#123;<br>    <span class="hljs-attr">fontFamily</span>:<span class="hljs-string">&quot;STZhongsong&quot;</span>,<br>    <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;white&quot;</span>,<br>  &#125;,<br>  <span class="hljs-attr">title</span>:&#123;<br>    <span class="hljs-attr">text</span>:<span class="hljs-string">&quot;2024-07-23&quot;</span>,<br>    <span class="hljs-attr">textStyle</span>:&#123;<br>      <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;yellow&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">subtext</span>:<span class="hljs-string">&quot;-- by Xiang&quot;</span><br>  &#125;,<br>  <span class="hljs-comment">//XY轴</span><br>  <span class="hljs-attr">xAxis</span>:&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">data</span>:dataX,<br>  &#125;,<br>  <span class="hljs-attr">yAxis</span>:[<br>    &#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>    <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>    <span class="hljs-attr">max</span>:<span class="hljs-number">2</span>,<br>    &#125;,<br>  ],<br>  <span class="hljs-comment">//数据系列</span><br>  <span class="hljs-attr">series</span>:[<br>    &#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;line1&quot;</span>,<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;line&#x27;</span>,<br>      <span class="hljs-attr">data</span>:dataY1,<br>      <span class="hljs-attr">smooth</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">areaStyle</span>:&#123;&#125;<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;line2&quot;</span>,<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;line&quot;</span>,<br>      <span class="hljs-attr">data</span>:dataY2,<br>      <span class="hljs-attr">smooth</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">areaStyle</span>:&#123;&#125;<br>    &#125;<br>  ],<br>  <span class="hljs-comment">//图例</span><br>  <span class="hljs-attr">legend</span>:&#123;<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;grey&quot;</span>,<br>    <span class="hljs-attr">data</span>:[<span class="hljs-string">&quot;line1&quot;</span>,<span class="hljs-string">&#x27;line2&#x27;</span>],<br>    <span class="hljs-attr">textStyle</span>:&#123;<br>      <span class="hljs-attr">fontSize</span>:<span class="hljs-number">20</span>,<br>      <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">//提示框</span><br>  <span class="hljs-attr">tooltip</span>:&#123;<br>    <span class="hljs-attr">trigger</span>:<span class="hljs-string">&quot;axis&quot;</span>,<br>    <span class="hljs-attr">axisPointer</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;cross&quot;</span>,<br>      <span class="hljs-attr">label</span>:&#123;<br>        <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;grey&quot;</span>,<br>        <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>      &#125;<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>得到效果图如下：</p><img src="/2024/07/23/2024-07-23/%E5%9B%BE1.png" class title="图1"><h2 id="ECharts-Axis配置项"><a href="#ECharts-Axis配置项" class="headerlink" title="ECharts Axis配置项"></a>ECharts Axis配置项</h2><p><font color="yellow">Axis常用配置项的汇总如下：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>type</code></td><td><code>string</code></td><td>坐标轴类型：’value’（数值轴）、’category’（类目轴）、’time’（时间轴）、’log’（对数轴）。<font color="yellow">横坐标通常是用’category’，纵坐标更多使用’value’</font>。</td></tr><tr><td><code>position</code></td><td><code>string</code></td><td>坐标轴的位置：’top’、’bottom’、’left’、’right’。</td></tr><tr><td><code>name</code></td><td><code>string</code></td><td>坐标轴的名称。</td></tr><tr><td><code>nameLocation</code></td><td><code>string</code></td><td>坐标轴名称显示位置：’start’、’middle’、’end’。</td></tr><tr><td><code>nameTextStyle</code></td><td><code>Object</code></td><td>坐标轴名称的文字样式。</td></tr><tr><td><code>nameGap</code></td><td><code>number</code></td><td>坐标轴名称与轴线之间的距离。</td></tr><tr><td><code>nameRotate</code></td><td><code>number</code></td><td>坐标轴名字旋转角度。</td></tr><tr><td><code>inverse</code></td><td><code>boolean</code></td><td>是否是反向坐标轴。</td></tr><tr><td><code>boundaryGap</code></td><td><code>boolean</code>&#x2F;<code>Array</code></td><td>类目轴中类目之间的间距或数值轴的起始和结束位置。<font color="yellow">横坐标设置boundratGap为false，则图表紧贴y坐标轴。</font></td></tr><tr><td><code>min</code></td><td><code>number</code>&#x2F;<code>string</code>&#x2F;<code>Function</code></td><td>坐标轴刻度最小值。可以设置具体值，或设置为 ‘dataMin’。</td></tr><tr><td><code>max</code></td><td><code>number</code>&#x2F;<code>string</code>&#x2F;<code>Function</code></td><td>坐标轴刻度最大值。可以设置具体值，或设置为 ‘dataMax’。</td></tr><tr><td><code>scale</code></td><td><code>boolean</code></td><td>只在数值轴中（type: ‘value’）有效，是否是脱离 0 值比例。</td></tr><tr><td><code>splitNumber</code></td><td><code>number</code></td><td>坐标轴的分割段数。</td></tr><tr><td><code>minInterval</code></td><td><code>number</code></td><td>自动计算的坐标轴最小间隔大小。</td></tr><tr><td><code>maxInterval</code></td><td><code>number</code></td><td>自动计算的坐标轴最大间隔大小。</td></tr><tr><td><code>interval</code></td><td><code>number</code></td><td>强制设置坐标轴分割间隔。</td></tr><tr><td><code>logBase</code></td><td><code>number</code></td><td>对数轴的底数，只在对数轴中（type: ‘log’）有效。</td></tr><tr><td><code>silent</code></td><td><code>boolean</code></td><td>坐标轴是否静默。<font color="yellow">当设置为 <code>true</code> 时，该元素将不响应任何交互事件。</font></td></tr><tr><td><code>triggerEvent</code></td><td><code>boolean</code></td><td>坐标轴的标签是否触发鼠标事件。</td></tr><tr><td><code>axisLine</code></td><td><code>Object</code></td><td>坐标轴轴线的相关设置。</td></tr><tr><td><code>axisTick</code></td><td><code>Object</code></td><td>坐标轴刻度相关设置。</td></tr><tr><td><code>axisLabel</code></td><td><code>Object</code></td><td>坐标轴刻度标签的相关设置。</td></tr><tr><td><code>splitLine</code></td><td><code>Object</code></td><td>坐标轴在 grid 区域中的分隔线。</td></tr><tr><td><code>splitArea</code></td><td><code>Object</code></td><td>坐标轴在 grid 区域中的分隔区域，默认不显示。</td></tr><tr><td><code>data</code></td><td><code>Array</code></td><td>类目数据，在类目轴（type: ‘category’）中有效。</td></tr><tr><td><code>axisPointer</code></td><td><code>Object</code></td><td>坐标轴指示器配置项。</td></tr><tr><td><code>zlevel</code></td><td><code>number</code></td><td>组件的所有图形的 zlevel 值。</td></tr><tr><td><code>z</code></td><td><code>number</code></td><td>组件的所有图形的 z 值。</td></tr></tbody></table><h3 id="图片翻转"><a href="#图片翻转" class="headerlink" title="图片翻转"></a>图片翻转</h3><ul><li>配置项<code>inverse</code></li></ul><img src="/2024/07/23/2024-07-23/%E5%9B%BE2.png" class title="图2"><p>我们修改上述代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">yAxis</span>:[<br>    &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>        <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>        <span class="hljs-attr">max</span>:<span class="hljs-number">2</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>        <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>        <span class="hljs-attr">max</span>:<span class="hljs-number">2</span>,<br>        <span class="hljs-attr">inverse</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//反向第二条坐标轴</span><br>    &#125;<br>],<br><span class="hljs-attr">series</span>:[<br>    &#123;...&#125;,<br>    &#123;...<br>    <span class="hljs-attr">yAxisIndex</span>:<span class="hljs-number">1</span>, <span class="hljs-comment">//将数据系列二绑定在第二条坐标轴，实现系列二反转。</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="坐标旋转"><a href="#坐标旋转" class="headerlink" title="坐标旋转"></a>坐标旋转</h3><img src="/2024/07/23/2024-07-23/%E5%9B%BE3.png" class title="图3"><p><font color="yellow">只需互换xAxis和yAxis即可。</font></p><h3 id="分割段设置"><a href="#分割段设置" class="headerlink" title="分割段设置"></a>分割段设置</h3><ul><li>配置项：<code>splitLine</code>、<code>interval</code>、<code>splitnumber</code></li></ul><img src="/2024/07/23/2024-07-23/%E5%9B%BE4.png" class title="图4"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">xAxis</span>:&#123;<br>    <span class="hljs-attr">splitLine</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">interval</span>:<span class="hljs-number">3</span>, <span class="hljs-comment">//设置两根分割段之间的间隔</span><br>        <span class="hljs-attr">spliteNumber</span>: <span class="hljs-number">4</span>,<span class="hljs-comment">//分割段数量，与interval可能发生冲突</span><br>        <span class="hljs-attr">lineStyle</span>:&#123; <span class="hljs-comment">//样式设计</span><br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>splitArea的用法和splitLine相似。</p><h3 id="坐标轴渲染"><a href="#坐标轴渲染" class="headerlink" title="坐标轴渲染"></a>坐标轴渲染</h3><p>配置项：<code>axisTick</code>、<code>axisLine</code>、<code>axisLabel</code>、<code>name</code>、<code>nameStyle</code>、<code>nameLocation</code></p><p>坐标轴的渲染包括坐标轴刻度线、坐标轴轴线、坐标轴轴标签以及坐标轴名字的渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">xAxis</span>:&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;横坐标&quot;</span>，<br>    <span class="hljs-attr">nameLocation</span>:<span class="hljs-string">&quot;middle&quot;</span> <span class="hljs-comment">//名字位置在中间</span><br>    <span class="hljs-attr">nameGap</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">//名字与轴标签的距离</span><br>    <span class="hljs-attr">nameRotate</span>:<span class="hljs-number">45</span>, <span class="hljs-comment">//名字旋转角度</span><br>    <span class="hljs-attr">nameStyle</span>:&#123;<br>        <span class="hljs-comment">//样式</span><br>        <span class="hljs-attr">padding</span>:<span class="hljs-number">20</span>,<br>    &#125;<br>    <span class="hljs-comment">//坐标轴刻度线。</span><br>    <span class="hljs-attr">axisTick</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">inside</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">//标签是否向内部</span><br>        <span class="hljs-attr">length</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">//刻度线长度</span><br>        <span class="hljs-attr">alignWithLabel</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//刻度线是否需标签对齐</span><br>        <span class="hljs-attr">inverval</span>:<span class="hljs-string">&quot;auto&quot;</span>，<span class="hljs-comment">//刻度线分布</span><br>        <span class="hljs-attr">lineStyle</span>:&#123; <span class="hljs-comment">//样式设置</span><br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;yellow&quot;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//坐标轴轴线</span><br>    <span class="hljs-attr">axisLine</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">lineStyle</span>:&#123;<br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>, <br>        &#125;<br>        <span class="hljs-attr">symbol</span>:<span class="hljs-string">&quot;arrow&quot;</span> <span class="hljs-comment">//箭头</span><br>    &#125;<br>    <span class="hljs-comment">//坐标轴轴标签</span><br>    <span class="hljs-attr">axisLabel</span>:&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">interval</span>:<span class="hljs-string">&quot;auto&quot;</span>，<span class="hljs-comment">//标签分布。</span><br>        <span class="hljs-attr">textStyle</span>:&#123;<br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><img src="/2024/07/23/2024-07-23/%E5%9B%BE5.png" class title="图5"><p>更加详细的配置项如下：</p><p><font color="yellow"><strong><code>axisTick</code> 配置项总结表：</strong></font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示坐标轴刻度。</td></tr><tr><td><code>alignWithLabel</code></td><td><code>boolean</code></td><td>刻度线和标签对齐。仅在类目轴中有效。</td></tr><tr><td><code>interval</code></td><td><code>string</code>&#x2F;<code>number</code>&#x2F;<code>Function</code></td><td>坐标轴刻度的显示间隔，默认为 ‘auto’。</td></tr><tr><td><code>inside</code></td><td><code>boolean</code></td><td>坐标轴刻度是否朝内。</td></tr><tr><td><code>length</code></td><td><code>number</code></td><td>坐标轴刻度的长度。</td></tr><tr><td><code>lineStyle</code></td><td><code>Object</code></td><td>坐标轴刻度的样式，包括颜色、宽度、类型等。</td></tr></tbody></table><p><font color="yellow"><strong><code>axisLine</code> 配置项总结表：</strong></font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示坐标轴轴线。</td></tr><tr><td><code>onZero</code></td><td><code>boolean</code></td><td>X 轴 Y 轴相交于 0 刻度。仅在双数值轴中有效。</td></tr><tr><td><code>onZeroAxisIndex</code></td><td><code>number</code></td><td>使用的另一个坐标轴的 axisIndex。仅在双数值轴中有效。</td></tr><tr><td><code>symbol</code></td><td><code>string</code>&#x2F;<code>Array</code></td><td>轴线两头的箭头。 <code>&#39;circle&#39;</code>：圆形；<code>&#39;rect&#39;</code>：矩形；<code>&#39;roundRect&#39;</code>：圆角矩形；<code>&#39;triangle&#39;</code>：三角形；<code>&#39;diamond&#39;</code>：菱形；<code>&#39;pin&#39;</code>：图钉形状；<code>&#39;arrow&#39;</code>：箭头形状；<code>&#39;path://...&#39;</code>：自定义路径</td></tr><tr><td><code>symbolSize</code></td><td><code>Array</code></td><td>轴线两头箭头的大小。</td></tr><tr><td><code>symbolOffset</code></td><td><code>Array</code></td><td>轴线两头箭头的偏移。</td></tr><tr><td><code>lineStyle</code></td><td><code>Object</code></td><td>坐标轴线的样式，包括颜色、宽度、类型等。</td></tr></tbody></table><p><font color="yellow"><strong><code>axisLabel</code> 配置项总结表：</strong></font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示坐标轴刻度标签。</td></tr><tr><td><code>interval</code></td><td><code>string</code>&#x2F;<code>number</code>&#x2F;<code>Function</code></td><td>坐标轴刻度标签的显示间隔，默认为 ‘auto’。</td></tr><tr><td><code>inside</code></td><td><code>boolean</code></td><td>坐标轴刻度标签是否朝内。</td></tr><tr><td><code>rotate</code></td><td><code>number</code></td><td>坐标轴刻度标签的旋转角度。</td></tr><tr><td><code>margin</code></td><td><code>number</code></td><td>刻度标签与轴线之间的距离。</td></tr><tr><td><code>formatter</code></td><td><code>string</code>&#x2F;<code>Function</code></td><td>刻度标签的内容格式器。</td></tr><tr><td><code>showMinLabel</code></td><td><code>boolean</code></td><td>是否显示最小刻度标签。</td></tr><tr><td><code>showMaxLabel</code></td><td><code>boolean</code></td><td>是否显示最大刻度标签。</td></tr><tr><td><code>color</code></td><td><code>string</code></td><td>刻度标签文字的颜色。</td></tr><tr><td><code>fontStyle</code></td><td><code>string</code></td><td>刻度标签文字的字体风格。</td></tr><tr><td><code>fontWeight</code></td><td><code>string</code></td><td>刻度标签文字的字体粗细。</td></tr><tr><td><code>fontFamily</code></td><td><code>string</code></td><td>刻度标签文字的字体系列。</td></tr><tr><td><code>fontSize</code></td><td><code>number</code></td><td>刻度标签文字的字体大小。</td></tr><tr><td><code>align</code></td><td><code>string</code></td><td>刻度标签文字水平对齐方式。</td></tr><tr><td><code>verticalAlign</code></td><td><code>string</code></td><td>刻度标签文字垂直对齐方式。</td></tr><tr><td><code>lineHeight</code></td><td><code>number</code></td><td>刻度标签文字的行高。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code>&#x2F;<code>Object</code></td><td>刻度标签背景色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>刻度标签边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>刻度标签边框宽度。</td></tr><tr><td><code>borderRadius</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>刻度标签边框圆角。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>刻度标签内边距。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>刻度标签文字的阴影颜色。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>刻度标签文字的阴影模糊度。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>刻度标签文字的阴影水平偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>刻度标签文字的阴影垂直偏移。</td></tr><tr><td><code>textBorderColor</code></td><td><code>string</code></td><td>刻度标签文字的描边颜色。</td></tr><tr><td><code>textBorderWidth</code></td><td><code>number</code></td><td>刻度标签文字的描边宽度。</td></tr><tr><td><code>textShadowColor</code></td><td><code>string</code></td><td>刻度标签文字的阴影颜色。</td></tr><tr><td><code>textShadowBlur</code></td><td><code>number</code></td><td>刻度标签文字的阴影模糊度。</td></tr><tr><td><code>textShadowOffsetX</code></td><td><code>number</code></td><td>刻度标签文字的阴影水平偏移。</td></tr><tr><td><code>textShadowOffsetY</code></td><td><code>number</code></td><td>刻度标签文字的阴影垂直偏移。</td></tr></tbody></table><p><strong><font color="yellow">注意点：</font></strong></p><ol><li>axisTick和axisLabel的<code>interval</code>用于显示标签和刻度线之间的间隔。<ul><li>axisLabel默认值为<code>auto</code>，系统根据标签名自动调整标签之间的间隔。</li><li>axisLabel值为0，默认显示所有的的标签，值为n，则每隔n个数据项显示一个标签。</li><li>axisLine默认值为<code>auto</code>，系统根据标签名自动调整刻度线之间的间隔。</li><li>axisLine值为0，默认显示和标签数量相同的刻度线，值为n，则每隔n个标签显示一个刻度线。</li></ul></li><li><font color="yellow">axisLabel的<code>interval</code>只适用于<code>category</code>类别轴，如果轴是<code>value</code>，数值是连续的，则<code>interval</code>不起作用</font>。标签的数量由分割线的数量决定。通过<code>splitLine</code>样式设置分割线数量。</li><li>axisLabel的样式配置可以直接在组件元素中配置，也可以在<code>textStyle</code>在配置。</li></ol><h2 id="ECharts-Grid配置项"><a href="#ECharts-Grid配置项" class="headerlink" title="ECharts Grid配置项"></a>ECharts Grid配置项</h2><p><code>grid</code>配置项在ECharts中用于设置图表的网络布局和样式，用于控制图表的坐标轴区域。一个容器可以放置多个网格<code>grid</code>，不同网站中可以绘制不同的坐标轴。</p><p><font color="yellow">Grid常用配置项的汇总如下：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示 grid 组件。</td></tr><tr><td><code>left</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器左侧的距离，可以是百分比或者像素值。</td></tr><tr><td><code>right</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器右侧的距离，可以是百分比或者像素值。</td></tr><tr><td><code>top</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器顶部的距离，可以是百分比或者像素值。</td></tr><tr><td><code>bottom</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域离容器底部的距离，可以是百分比或者像素值。</td></tr><tr><td><code>containLabel</code></td><td><code>boolean</code></td><td>是否包含坐标轴标签在 grid 区域内。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code>&#x2F;<code>Object</code></td><td>grid 区域的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>grid 区域的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>grid 区域的边框宽度。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>grid 区域的阴影颜色。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>grid 区域的阴影模糊度。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>grid 区域阴影的水平偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>grid 区域阴影的垂直偏移。</td></tr><tr><td><code>height</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域的高度，可以是百分比或者像素值。</td></tr><tr><td><code>width</code></td><td><code>number</code>&#x2F;<code>string</code></td><td>grid 区域的宽度，可以是百分比或者像素值。</td></tr><tr><td><code>containLabel</code></td><td><code>boolean</code></td><td>是否使 grid 区域包含坐标轴标签，避免标签被截断。</td></tr><tr><td><code>opacity</code></td><td><code>number</code></td><td>grid 区域的透明度，取值范围 0~1。</td></tr></tbody></table><h3 id="多重网格"><a href="#多重网格" class="headerlink" title="多重网格"></a>多重网格</h3><img src="/2024/07/23/2024-07-23/%E5%9B%BE6.png" class title="图6"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在文章开头代码的基础上进行修改。</span><br><span class="hljs-keyword">const</span> option=&#123;<br>    <span class="hljs-attr">grid</span>:[<br>        &#123;<br>            <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//初始化为false,</span><br>            <span class="hljs-attr">left</span>:<span class="hljs-string">&quot;5%&quot;</span>,<br>            <span class="hljs-attr">right</span>:<span class="hljs-string">&quot;5%&quot;</span>,<br>            <span class="hljs-attr">containLabel</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//包含了轴标签</span><br>            <span class="hljs-attr">height</span>:<span class="hljs-string">&quot;35%&quot;</span>, <span class="hljs-comment">//网络高度</span><br>            <span class="hljs-comment">//设置网络样式，前提是show为true.</span><br>            <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.7</span>, <span class="hljs-comment">//透明度</span><br>            <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;yellow&quot;</span>,<br>            <span class="hljs-attr">shadowBlur</span>: <span class="hljs-number">200</span>, <span class="hljs-comment">//阴影模糊程度</span><br>            <span class="hljs-attr">shadowColor</span>: <span class="hljs-string">&quot;yellow&quot;</span>,<br>            <span class="hljs-attr">shadomOffsetX</span>:<span class="hljs-number">0</span>, <span class="hljs-comment">//阴影偏移</span><br>            <span class="hljs-attr">shadomOffsetY</span>:<span class="hljs-number">0</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-comment">//网络二</span><br>            <span class="hljs-attr">show</span>:<span class="hljs-literal">false</span>,<br>            <span class="hljs-attr">left</span>:<span class="hljs-string">&quot;5%&quot;</span>,<br>            <span class="hljs-attr">right</span>:<span class="hljs-string">&quot;5%&quot;</span><br>            <span class="hljs-attr">containLabel</span>:<span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">top</span>:<span class="hljs-string">&quot;50%&quot;</span>,<br>            <span class="hljs-attr">height</span>:<span class="hljs-string">&quot;35%&quot;</span><br>        &#125;<br>    ],<br>    <span class="hljs-comment">//XY轴</span><br>  <span class="hljs-attr">xAxis</span>:[&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">data</span>:dataX,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">gridIndex</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">//绑定网络二</span><br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;category&quot;</span>,<br>    <span class="hljs-attr">data</span>:dataX,<br>    <span class="hljs-attr">position</span>:<span class="hljs-string">&quot;top&quot;</span>,<br>  &#125;<br>  ],<br>  <span class="hljs-attr">yAxis</span>:[&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>    <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>    <span class="hljs-attr">max</span>:<span class="hljs-number">1</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;value&quot;</span>,<br>      <span class="hljs-attr">min</span>:<span class="hljs-number">0</span>,<br>      <span class="hljs-attr">max</span>:<span class="hljs-number">1</span>,<br>      <span class="hljs-attr">inverse</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//坐标反转</span><br>      <span class="hljs-attr">gridIndex</span>:<span class="hljs-number">1</span>, <span class="hljs-comment">//绑定网络二</span><br>    &#125;<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ECharts图表元素的位置调整"><a href="#ECharts图表元素的位置调整" class="headerlink" title="ECharts图表元素的位置调整"></a>ECharts图表元素的位置调整</h2><p>如<code>grid</code>的位置调整一样，<font color="yellow">ECharts大部分图表元素都是通过<code>top</code>，<code>bottom</code>，<code>left</code>，<code>right</code>四个配置项来调整组件元素在图表或者网络中的位置。</font>也就是元素上下左右的间距。</p><p>配置项的值类型有：</p><ul><li><code>number</code>：以像素为单位的绝对值。<code>top=20</code>即20px像素。</li><li><code>string</code>：父容器高度或者宽度的百分比。<code>top=&quot;20%&quot;</code>即相对于父容器宽度的20%大小。</li><li><code>auto</code>：自动计算位置，通常在响应式布局中使用。<code>top=&quot;auto&quot;</code>。</li><li><code>center</code>：将元素垂直居中（在某些配置中支持）。</li></ul><h2 id="ECharts-Label配置项"><a href="#ECharts-Label配置项" class="headerlink" title="ECharts Label配置项"></a>ECharts Label配置项</h2><p>ECharts很多元素都有是有标签或者说类似文本框属性，例如轴标签、legend标签、title标签，因此它们有很多通用的配置项。而在<code>series.label</code>和<code>axis.axisLabel</code>就有Label配置项，基本会涵盖所有的配置项。</p><p><font color="yellow">ECharts Label 配置项总结表</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示标签。</td></tr><tr><td><code>position</code></td><td><code>string</code></td><td>标签的位置，支持 <code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>、<code>inside</code>、<code>insideLeft</code>、<code>insideRight</code>、<code>insideTop</code>、<code>insideBottom</code>。<font color="yellow">在series中起作用</font>。</td></tr><tr><td><code>formatter</code></td><td><code>string</code>&#x2F;<code>Function</code></td><td>标签内容格式器，可以是字符串模板或者回调函数。</td></tr><tr><td><code>color</code></td><td><code>string</code></td><td>标签文字颜色。</td></tr><tr><td><code>fontStyle</code></td><td><code>string</code></td><td>标签文字风格，例如 <code>&#39;normal&#39;</code>、<code>&#39;italic&#39;</code>、<code>&#39;oblique&#39;</code>。</td></tr><tr><td><code>fontWeight</code></td><td><code>string</code></td><td>标签文字粗细，例如 <code>&#39;normal&#39;</code>、<code>&#39;bold&#39;</code>。</td></tr><tr><td><code>fontFamily</code></td><td><code>string</code></td><td>标签文字字体，例如 <code>&#39;sans-serif&#39;</code>、<code>&#39;serif&#39;</code>。</td></tr><tr><td><code>fontSize</code></td><td><code>number</code></td><td>标签文字大小。</td></tr><tr><td><code>lineHeight</code></td><td><code>number</code></td><td>标签文字行高。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code></td><td>标签的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>标签的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>标签的边框宽度。</td></tr><tr><td><code>borderRadius</code></td><td><code>number</code></td><td>标签的边框圆角。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>标签的内边距。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>标签的阴影颜色。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>标签的阴影模糊度。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>标签阴影的水平偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>标签阴影的垂直偏移。</td></tr></tbody></table><p>可以看到这些配置项几乎在<code>grid</code>中都存在，在后面我们会看到很多元素都具备这些配置项。</p><h2 id="ECharts-Legend配置项"><a href="#ECharts-Legend配置项" class="headerlink" title="ECharts Legend配置项"></a>ECharts Legend配置项</h2><p><font color="yellow">Legend 常用属性总结表：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示图例，默认为 <code>true</code>。</td></tr><tr><td><code>type</code></td><td><code>string</code></td><td>图例类型，可选 <code>&#39;plain&#39;</code>（普通图例）或 <code>&#39;scroll&#39;</code>（可滚动图例）。</td></tr><tr><td><code>data</code></td><td><code>Array</code></td><td>图例的数据项，可以是字符串数组或对象数组，每个字符串或对象代表一个系列。</td></tr><tr><td><code>selected</code></td><td><code>Object</code></td><td>图例选中状态，用于控制哪些系列被选中（显示）或未选中（隐藏）。</td></tr><tr><td><code>orient</code></td><td><code>string</code></td><td>图例的布局朝向，可选 <code>&#39;horizontal&#39;</code>（水平）或 <code>&#39;vertical&#39;</code>（垂直）。</td></tr><tr><td><code>left</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器左侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>right</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器右侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>top</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器上侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>bottom</code></td><td><code>string</code>&#x2F;<code>number</code></td><td>图例组件离容器下侧的距离，可以是具体的像素值或相对百分比。</td></tr><tr><td><code>align</code></td><td><code>string</code></td><td>图例标记和文本的对齐方式，可选 <code>&#39;auto&#39;</code>，<code>&#39;left&#39;</code>，<code>&#39;right&#39;</code>。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>图例的内边距，单位为像素。可以是单个值或数组（分别表示上、右、下、左的内边距）。</td></tr><tr><td><code>itemGap</code></td><td><code>number</code></td><td>图例项之间的间隔，单位为像素。</td></tr><tr><td><code>itemWidth</code></td><td><code>number</code></td><td>图例标记的宽度，单位为像素。</td></tr><tr><td><code>itemHeight</code></td><td><code>number</code></td><td>图例标记的高度，单位为像素。</td></tr><tr><td><code>textStyle</code></td><td><code>Object</code></td><td>图例文本的样式，包括颜色、字体、大小等。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code></td><td>图例的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>图例的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>图例的边框线宽。</td></tr><tr><td><code>borderRadius</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>图例的边框圆角，可以是单个值或数组（分别表示左上、右上、右下、左下的圆角半径）。</td></tr><tr><td><code>shadowBlur</code></td><td><code>number</code></td><td>图例的阴影模糊大小。</td></tr><tr><td><code>shadowColor</code></td><td><code>string</code></td><td>图例的阴影颜色。</td></tr><tr><td><code>shadowOffsetX</code></td><td><code>number</code></td><td>图例的阴影 X 偏移。</td></tr><tr><td><code>shadowOffsetY</code></td><td><code>number</code></td><td>图例的阴影 Y 偏移。</td></tr><tr><td><code>formatter</code></td><td><code>Function</code>&#x2F;<code>string</code></td><td>用于格式化图例文本，支持字符串模板和回调函数。</td></tr><tr><td><code>selectedMode</code></td><td><code>boolean</code>&#x2F;<code>string</code></td><td>图例选择的模式，默认为 <code>true</code>。可选 <code>&#39;single&#39;</code> 或 <code>&#39;multiple&#39;</code>。</td></tr><tr><td><code>inactiveColor</code></td><td><code>string</code></td><td>图例关闭时的颜色。</td></tr><tr><td><code>tooltip</code></td><td><code>Object</code></td><td>图例的 tooltip 配置项。</td></tr></tbody></table><p>大部分配置项和<code>grid</code>是相似的。</p><img src="/2024/07/23/2024-07-23/%E5%9B%BE7.png" class title="图7"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在文章开头代码的基础上进行修改。</span><br><span class="hljs-comment">//首先将数据系列复制至5份。</span><br><span class="hljs-keyword">const</span> option = &#123;<br>  <span class="hljs-comment">//图例</span><br>  <span class="hljs-attr">legend</span>:&#123;<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;grey&quot;</span>,<br>    <span class="hljs-attr">textStyle</span>:&#123;<br>      <span class="hljs-attr">fontSize</span>:<span class="hljs-number">20</span>,<br>      <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>    &#125;,<br>    <br>    <span class="hljs-comment">//图例的配置项</span><br>    <span class="hljs-attr">orient</span>:<span class="hljs-string">&quot;horizontal&quot;</span>, <span class="hljs-comment">//水平或者垂直分布</span><br>    <span class="hljs-attr">padding</span>:<span class="hljs-number">10</span>,<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-comment">//滚动图例</span><br>    <span class="hljs-attr">left</span>:<span class="hljs-string">&quot;70%&quot;</span>,<br>    <span class="hljs-attr">align</span>:<span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-comment">//对齐方式</span><br>    <span class="hljs-attr">itemWidth</span>:<span class="hljs-number">50</span>, <span class="hljs-comment">//图例标记的样式修改。</span><br>    <span class="hljs-attr">itemHeight</span>:<span class="hljs-number">30</span>,<br>    <span class="hljs-attr">selected</span>:&#123; <span class="hljs-comment">//初始化哪些系列被选中。 </span><br>      <span class="hljs-string">&quot;line1&quot;</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&quot;line2&quot;</span>:<span class="hljs-literal">false</span>,<br>      <span class="hljs-string">&quot;line3&quot;</span>:<span class="hljs-literal">false</span>,<br>      <span class="hljs-string">&quot;line4&quot;</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-string">&quot;line5&quot;</span>:<span class="hljs-literal">false</span>,<br>    &#125;,<br>    <span class="hljs-attr">selectedMode</span>:<span class="hljs-string">&quot;single&quot;</span>, <span class="hljs-comment">//single表示最多只能有一个被选中。</span><br>    <span class="hljs-attr">tooltip</span>:&#123; <span class="hljs-comment">//图例小型的提示框</span><br>      <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&quot;red&quot;</span>,<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ECharts-Tooltip配置项"><a href="#ECharts-Tooltip配置项" class="headerlink" title="ECharts Tooltip配置项"></a>ECharts Tooltip配置项</h2><p><font color="yellow">ECharts Tooltip 配置项总结表：</font></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>show</code></td><td><code>boolean</code></td><td>是否显示 tooltip。</td></tr><tr><td><code>trigger</code></td><td><code>string</code></td><td>触发类型，支持 ‘item’（数据项触发）、’axis’（坐标轴触发）、’none’（不显示）。</td></tr><tr><td><code>triggerOn</code></td><td><code>string</code></td><td>触发条件，支持 ‘mousemove’（鼠标移动）、’click’（点击）、’mousemove</td></tr><tr><td><code>axisPointer</code></td><td><code>Object</code></td><td>坐标轴指示器配置项。</td></tr><tr><td><code>formatter</code></td><td><code>string</code>&#x2F;<code>Function</code></td><td>提示框内容格式器。可以是字符串模板或者回调函数。</td></tr><tr><td><code>backgroundColor</code></td><td><code>string</code>&#x2F;<code>Object</code></td><td>提示框的背景颜色。</td></tr><tr><td><code>borderColor</code></td><td><code>string</code></td><td>提示框的边框颜色。</td></tr><tr><td><code>borderWidth</code></td><td><code>number</code></td><td>提示框的边框宽度。</td></tr><tr><td><code>padding</code></td><td><code>number</code>&#x2F;<code>Array</code></td><td>提示框的内边距。</td></tr><tr><td><code>textStyle</code></td><td><code>Object</code></td><td>提示框的文字样式配置项，包括颜色、字体大小、字体粗细等。</td></tr><tr><td><code>extraCssText</code></td><td><code>string</code></td><td>自定义的 CSS 样式，支持全局 CSS 属性。</td></tr><tr><td><code>transitionDuration</code></td><td><code>number</code></td><td>动画过渡时间，单位为秒。</td></tr><tr><td><code>confine</code></td><td><code>boolean</code></td><td>是否将提示框限制在图表区域内。</td></tr><tr><td><code>enterable</code></td><td><code>boolean</code></td><td>是否允许鼠标进入 tooltip 区域。</td></tr><tr><td><code>showContent</code></td><td><code>boolean</code></td><td>是否显示 tooltip 内容。</td></tr></tbody></table><p>根据<a href="https://cxdlogver.github.io/2024/07/22/2024-07-22/"><strong>ECharts使用（1)</strong></a>中的第一个例子，我们只要理解<code>tooltip</code>提示框和<code>axisPointer</code>轴标签指示器在图表中位置，就很好理解配置项的内容。</p><p><code>tooltip</code>是一个指示框，用于显示坐标轴某一个点的坐标信息。根据<code>trigger</code>有两种触发模式。</p><ul><li><code>item</code>数据项触发：当鼠标指到数据系列的数据项时，才出现提示框，并给出数据点信息。</li><li><code>axis</code>坐标轴触发：当鼠标指在坐标轴的任意一个位置时，都会出现提示框，给出与鼠标当前位置最近的所有数据项信息。</li></ul><p><code>triggerOn</code>触发条件，<code>click</code>表示只有点击时才出现提示框，<code>mousemove</code>鼠标移到时就出现提示框。默认是<code>mousemove</code>。</p><p><code>tooltip</code>是一个文本框，因此相关的渲染以及<code>textStyle</code>配置都有，用于样式的配置。</p><p><code>axisPointer</code>是呈现在坐标轴上的轴标签指示器，声明它则<code>tooltip</code>默认<code>trigger:axis</code>。它作为标签，有<code>label</code>配置，在<code>label</code>中有标签的相关的渲染以及<code>textStyle</code>配置，和legend等元素类似。因此渲染不再做介绍。</p><p><code>axisPointer</code>的触发类型<code>type</code>有三种：</p><ul><li><code>line</code>：只有一条垂直于X轴的线。</li><li><code>cross</code>：有两条相互垂直的线。</li><li><code>shadow</code>:用一块阴影矩形代替垂直于X轴的线。</li></ul><img src="/2024/07/23/2024-07-23/%E5%9B%BE8.png" class title="图8"><p><font color="yellow">对应的有<code>crossStyle</code>、<code>lineStyle</code>、<code>shadowStyle</code>配置项进行渲染。</font></p>]]></content>
    
    
    
    <tags>
      
      <tag>每日总结</tag>
      
      <tag>EChars</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
