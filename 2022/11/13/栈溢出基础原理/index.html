<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>栈溢出基础原理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="article">
<meta property="og:title" content="栈溢出基础原理">
<meta property="og:url" content="http://example.com/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/.com//image-20220213224820235.png">
<meta property="og:image" content="http://example.com/.com//image-20220213231828239.png">
<meta property="og:image" content="http://example.com/.com//271650059007975.jpg">
<meta property="og:image" content="http://example.com/.com//image-20220214161648989.png">
<meta property="article:published_time" content="2022-11-13T08:20:54.000Z">
<meta property="article:modified_time" content="2022-11-13T13:41:49.987Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="栈溢出">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.com//image-20220213224820235.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-栈溢出基础原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-11-13T08:20:54.000Z" itemprop="datePublished">2022-11-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">漏洞利用</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      栈溢出基础原理
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id><a href="#" class="headerlink" title></a><span id="more"></span></h1><h2 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h2><ol>
<li>进程的内存主要由哪几部分构成，其中栈结构主要保存什么内容？</li>
<li>栈帧结构是什么样的？寄存器起到哪些作用？</li>
<li>X86和X86_64的栈结构有哪些不同之处？</li>
<li>对栈操作的大致过程是怎样的？</li>
<li>栈溢出的原理是什么？</li>
</ol>
<h2 id="基础栈介绍"><a href="#基础栈介绍" class="headerlink" title="基础栈介绍"></a><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/#_2">基础栈介绍</a></h2><p>每个程序在运行时都有<strong>虚拟地址空间</strong>，其中某一部分就是该程序对应的栈，用于<strong>保存<u>函数调用信息</u>和<u>局部变量</u><strong>。此外，常见的操作也是压栈与出栈。需要注意的是，</strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。</p>
<p><img src="/.com//image-20220213224820235.png" alt="栈结构"></p>
<p>进程使用的内存大致可以分成四个部分：代码区、数据区、堆区、栈区。这个将在《程序员的自我修养》读书笔记中重点分析。</p>
<p>32 位和 64 位程序有以下简单的区别</p>
<ul>
<li>x86<strong>函数参数</strong>在<strong>函数返回地址</strong>的上方</li>
<li>x64中前六个整型或指针参数依次保存在<strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</li>
</ul>
<h2 id="C语言函数调用栈（一）"><a href="#C语言函数调用栈（一）" class="headerlink" title="C语言函数调用栈（一）"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clover-toeic/p/3755401.html">C语言函数调用栈（一）</a></h2><p>程序的执行可以看作是连续的函数调用，函数调用的过程通常使用堆栈实现。其中栈上的主要保存：</p>
<ol>
<li>函数参数</li>
<li>函数返回地址</li>
<li>临时保存寄存器原有值(即函数调用的上下文)</li>
<li>存储本地局部变量</li>
</ol>
<p>栈帧指针寄存器FP，在Intel CPU中用BP作帧指针。</p>
<p><img src="/.com//image-20220213231828239.png" alt="寄存器使用"></p>
<blockquote>
<p>寄存器<u><strong>%eax、%edx和%ecx</strong></u>主调函数保存寄存器由主调函数显式的保存到栈中，先于返回地址进入栈中。</p>
<p>寄存器<u><strong>%ebx、%esi和%edi</strong></u>被调函数保存寄存器由被调函数保存到栈中，后于返回地址进入栈中。</p>
</blockquote>
<h3 id="栈帧结构"><a href="#栈帧结构" class="headerlink" title="栈帧结构"></a><strong>栈帧结构</strong></h3><p><img src="/.com//271650059007975.jpg" alt="栈帧"></p>
<blockquote>
<p><strong>实参N-1 -&gt; 主调函数返回地址 -&gt; 主调函数帧基指针EBP -&gt; 被调函数局部变量1-N</strong></p>
</blockquote>
<p>x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。</p>
<p>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(通常都是EAX)</p>
<h2 id="C语言函数调用栈-二"><a href="#C语言函数调用栈-二" class="headerlink" title="C语言函数调用栈(二)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clover-toeic/p/3756668.html">C语言函数调用栈(二)</a></h2><h3 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a><strong>函数调用约定</strong></h3><p>函数通过选择特定的调用约定，来表明其希望以<strong>特定方式</strong>接收参数。主要有几个方面</p>
<ol>
<li><strong>函数参数的传递顺序和方式：</strong> 最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。</li>
<li><strong>栈的维护方式：</strong> 主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。</li>
<li><strong>名字修饰策略：</strong>又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。</li>
</ol>
<h4 id="cdecl调用约定"><a href="#cdecl调用约定" class="headerlink" title="cdecl调用约定"></a><strong>cdecl调用约定</strong></h4><ul>
<li>C调用约定，是C&#x2F;C++编译器默认的函数调用约定。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。</li>
<li>可以支持可变参数函数，即参数的数量不定。最左边的参数最接近栈顶位置。调用时即使实参和形参数目不符也不会导致堆栈错误</li>
</ul>
<h4 id="stdcall调用约定"><a href="#stdcall调用约定" class="headerlink" title="stdcall调用约定"></a><strong>stdcall调用约定</strong></h4><ul>
<li>WinAPI采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。</li>
<li>仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；</li>
</ul>
<h4 id="x86函数参数传递方法"><a href="#x86函数参数传递方法" class="headerlink" title="x86函数参数传递方法"></a><strong>x86函数参数传递方法</strong></h4><p>x86处理器ABI规范中规定，所有传递给被调函数的参数都通过堆栈来完成，其压栈顺序是以函数参数从右到左的顺序。当向被调函数传递参数时，所有参数最后形成一个数组。由于采用从右到左的压栈顺序，数组中参数的顺序(下标0<del>N-1)与函数参数声明顺序(Para1</del> N)一致。因此，在函数中若知道第一个参数地址和各参数占用字节数，就可通过访问数组的方式去访问每个参数。</p>
<p>X86_64 中前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</p>
<h2 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stackoverflow-basic/">栈溢出原理</a></h2><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p>
<ul>
<li>程序必须向栈上写入数据。</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<p>前提：PIE保护关闭</p>
<p><a target="_blank" rel="noopener" href="http://tttang.com/archive/1361/#toc__1">寻找危险函数</a></p>
<p><a target="_blank" rel="noopener" href="http://tttang.com/archive/1361/#toc__2">确定填充长度</a></p>
<p><img src="/.com//image-20220214161648989.png" alt="栈表"></p>
<blockquote>
<p>s表示<code>push ebp</code>的地址，r表示函数的返回地址，指定地址应该覆盖r所在的地址</p>
</blockquote>
<h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><blockquote>
<p>问题1：进程的内存主要由哪几部分构成，其中栈结构主要保存什么内容？</p>
</blockquote>
<p>进程的内存主要由代码段、数据段、堆段、栈段构成。函数的调用关系等信息会动态地保存在内存的栈区，因此栈结构用于保存<u><strong>函数调用信息</strong></u>和<u><strong>局部变量</strong></u>。包括<u><strong>函数参数</strong></u>（例如主调函数传递给被调函数的参数）、<u><strong>函数返回地址</strong></u>（被调函数执行结束以后需要返回到主调函数）、<u><strong>函数局部变量</strong></u>、<u><strong>寄存器的值</strong></u>（被调函数调用一些寄存器之前，可能需要先将寄存器中的值保存到栈中，因为寄存器中可能保存着主调函数需要使用的值）。</p>
<blockquote>
<p>问题2：栈帧结构是什么样的？寄存器起到哪些作用？</p>
</blockquote>
<p>寄存器用于存放程序执行中用到的数据和指令。在函数调用的过程中起到重要的作用。<u><strong>栈帧</strong></u>是每一个函数占用的一个独立的区域，栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。</p>
<p><strong>EBP（帧基指针）：</strong>EBP指向是每一个栈帧的基址。一个栈的基址存放的是函数的返回地址。当调用函数栈帧压入堆栈的时候。执行的指令是 :<code>push eip</code> <code>mov ebp esp</code>。函数返回之前，EBP始终指向栈帧的基址，因此函数中对大部分数据的访问都基于EBP进行，通常用<strong>EBP + 偏移地址</strong>作为一个符号的地址。</p>
<p><strong>ESP（栈顶指针）：</strong>ESP通常指向一个栈帧的顶点，但是在出栈入栈的时候ESP的值是不断发生改变的。</p>
<p>其他寄存器在函数存档和函数返回参数的时候也会起到作用。若返回值不超过4字节，通常将其保存在EAX寄存器中。具体内容看<strong>“函数使用约定”</strong>和<strong>“ x86函数返回值传递方法”</strong>。</p>
<blockquote>
<p>问题3：X86和X86_64的栈结构有哪些不同之处？</p>
</blockquote>
<p>最大的不同就是x86平台将参数压入调用栈中。而x86_64平台调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。<strong>这一点需要重点注意</strong>。</p>
<blockquote>
<p>问题4：对栈操作的大致过程是怎样的？</p>
</blockquote>
<ol>
<li>当主调函数调用被调函数的时候，操作系统需要使用寄存器先对主调函数进行存档，然后，按照将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。此时EBP并没有发生改变，所以函数参数是存放在主调函数的栈帧中的。<u>同时主调函数可能会把一些不希望被调函数覆盖的寄存器（如%eax、%edx和%ecx）中的值先压入栈（保存了主调函数信息的值）</u></li>
<li>使用CALL等跳转指令以后，EIP发生的跳转，被调函数的栈帧进入栈中。然后返回地址放入被调函数的基地址<u><strong>（<code>push eip</code>）</strong></u>，随后设置帧基指针EBP<u><strong>（<code>mov ebp esp</code>）</strong></u>。</li>
<li>被调函数局部变量依次被压入栈，如果将数组压入栈，会执行<code>sub esp X</code>分配X大小的栈空间给数组。<u>同时被调函数也会把一些不能被覆盖的寄存器中的值压入栈</u>，才能调用寄存器。</li>
<li>被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。</li>
<li>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。</li>
<li>一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放<u><strong>（<code>mov esp ebp</code>）</strong></u>。然后 恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器<u>（**<code>pop ebp</code><strong>）</strong></u>。两个指令合并称为leave指令**</li>
<li>被调函数将控制权交还主调函数(使用<strong>ret</strong>指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。</li>
<li>主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。</li>
</ol>
<p><strong>需要注意的点：</strong></p>
<ul>
<li>我们不能直观的判断出被调函数的某个局部变量或者某个参数距离返回地址之间的大小。因为<u><strong>返回地址前后都不定数量的寄存器被压入栈</strong></u>。只能通过调试软件进行分析。</li>
<li>一定要注意x86平台是将参数直接压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。</li>
</ul>
<blockquote>
<p>问题5：栈溢出的原理是什么？</p>
</blockquote>
<p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。那么就可以：</p>
<ul>
<li>修改相邻栈中变量的值。</li>
<li>修改函数的返回地址，使返回地址跳转到我们希望进入的地址。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/" data-id="clyucrvsz00066wtohr5x6fmn" data-title="栈溢出基础原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="tag">栈溢出</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          层次分析法
        
      </div>
    </a>
  
  
    <a href="/2022/04/19/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">hexo博客搭建</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/">数学建模</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">漏洞利用</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="tag">栈溢出</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/" rel="tag">评价模型</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" style="font-size: 10px;">栈溢出</a> <a href="/tags/%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">评价模型</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/21/text/">text</a>
          </li>
        
          <li>
            <a href="/2024/07/21/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2022/11/14/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/">层次分析法</a>
          </li>
        
          <li>
            <a href="/2022/11/13/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">栈溢出基础原理</a>
          </li>
        
          <li>
            <a href="/2022/04/19/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">hexo博客搭建</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>