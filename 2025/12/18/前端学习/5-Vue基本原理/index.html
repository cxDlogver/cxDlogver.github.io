

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/dog.png">
  <link rel="icon" href="/img/dog.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Xiang Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="如何描述Vue采用的MVVM框架？ 如何描述Vue2的响应式原理 （流程&#x2F;数据劫持原理）？ 如何描述Vue3的响应式原理 （与Vue2差异 &#x2F; Proxy &#x2F; Reflect)？ 数据代理的思想？">
<meta property="og:type" content="article">
<meta property="og:title" content="5.Vue基本原理">
<meta property="og:url" content="http://example.com/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="相">
<meta property="og:description" content="如何描述Vue采用的MVVM框架？ 如何描述Vue2的响应式原理 （流程&#x2F;数据劫持原理）？ 如何描述Vue3的响应式原理 （与Vue2差异 &#x2F; Proxy &#x2F; Reflect)？ 数据代理的思想？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251217223808740.png">
<meta property="og:image" content="http://example.com/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251218021138928.png">
<meta property="og:image" content="http://example.com/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20250903140313714.png">
<meta property="article:published_time" content="2025-12-17T20:17:10.000Z">
<meta property="article:modified_time" content="2025-12-17T20:32:01.985Z">
<meta property="article:author" content="Xiang Chen">
<meta property="article:tag" content="前端面试题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251217223808740.png">
  
  
  
  <title>5.Vue基本原理 - 相</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>相</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="5.Vue基本原理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-18 04:17" pubdate>
          2025年12月18日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          43 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">5.Vue基本原理</h1>
            
            
              <div class="markdown-body">
                
                <ol>
<li>如何描述Vue采用的MVVM框架？</li>
<li>如何描述Vue2的响应式原理 （流程&#x2F;数据劫持原理）？</li>
<li>如何描述Vue3的响应式原理 （与Vue2差异 &#x2F; Proxy &#x2F; Reflect)？</li>
<li>数据代理的思想？</li>
</ol>
<span id="more"></span>

<h2 id="Vue的基本原理"><a href="#Vue的基本原理" class="headerlink" title="Vue的基本原理"></a>Vue的基本原理</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=145">145_尚硅谷Vue3技术_回顾Vue2的响应式原理_哔哩哔哩_bilibili</a></p>
</blockquote>
<h3 id="1-MVVM框架"><a href="#1-MVVM框架" class="headerlink" title="1.MVVM框架"></a>1.MVVM框架</h3><img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251217223808740.png" srcset="/img/loading.gif" lazyload class title="image-20251217223808740">

<p>根据MVVM库的特点：</p>
<p>MVVM（Model–View–ViewModel）是一种通过 <strong>ViewModel</strong> 作为中介，实现 <strong>View 与 Model 双向同步</strong> 的设计模式。</p>
<ul>
<li><strong>Model</strong>：数据层，负责数据状态与业务逻辑</li>
<li><strong>View</strong>：视图层，负责页面展示</li>
<li><strong>ViewModel</strong>：连接 View 和 Model，负责数据同步与视图更新</li>
</ul>
<p><strong>在 Vue 中的具体对应</strong></p>
<ul>
<li><strong>View</strong>：HTML 模板（如 <code>&lt;input&gt;</code>、<code>&#123;&#123; value &#125;&#125;</code>）</li>
<li><strong>Model</strong>：<code>data</code> 中定义的数据对象</li>
<li><strong>ViewModel</strong>：<code>vm = new Vue(&#123;...&#125;)</code> 创建的 Vue 实例</li>
</ul>
<p>先举一个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>	&lt;div id=&#x27;root&#x27;&gt;<br>        &lt;input v-model=&quot;value&quot;&gt;<br>        &lt;p&gt;value的值为 &#123;&#123;value&#125;&#125; &lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>    new Vue(&#123;<br>        el:&quot;#root&quot;,<br>        data:&#123;<br>            value:123<br>        &#125;<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>在上面这个示例中，当我们在浏览器浏览器输入框修改value的值时，data中的value会同步修改。这是从<code>view-&gt;model</code>的过程。当data的value一旦被修改，页面就要重新渲染，那么<code>&lt;p&gt;</code>中的模板语句被修改。这是<code>model-&gt;view</code>的过程。</p>
<h4 id="【view-model】"><a href="#【view-model】" class="headerlink" title="【view-&gt;model】"></a>【<code>view-&gt;model</code>】</h4><p>当用户在输入框中输入内容时：</p>
<ol>
<li>用户操作视图（View）</li>
<li><strong>DOM 事件触发</strong>（如 <code>input</code> 事件）</li>
<li>事件回调中修改 <code>data.value</code></li>
<li>数据更新完成（Model 被修改）</li>
</ol>
<p>关键结论</p>
<ul>
<li>这一过程本质是 <strong>DOM 事件监听 + 回调赋值</strong></li>
<li>属于 <strong>浏览器 + JavaScript 的原生机制</strong></li>
<li><strong>不是 Vue 响应式原理的内容</strong></li>
</ul>
<p>Vue 在这里只是：</p>
<ul>
<li>通过<font color="#409eff"><strong>数据绑定</strong></font><code>Data Bingdings</code>，自动绑定了事件，省去了手写监听与赋值的代码</li>
</ul>
<h4 id="【model-view】"><a href="#【model-view】" class="headerlink" title="【model-&gt;view】"></a>【<code>model-&gt;view</code>】</h4><p>当 <code>data.value</code> 被修改后，页面中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>value 的值为 &#123;&#123; value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>能够自动更新，这一过程才是 <strong>Vue 响应式系统真正解决的问题</strong>。</p>
<ul>
<li>Vue 在初始化时，对 <code>data</code> 中的数据进行了 <strong><font color="#409eff">数据劫持</font></strong></li>
<li>每个被使用到的数据，都通过 <font color="#409eff"><strong>发布者–订阅者模式</strong></font> 与对应的视图更新逻辑建立了关联</li>
<li>当数据发生变化时：<ul>
<li>Vue 内部触发对应的 <strong>更新通知</strong></li>
<li>相关的视图更新函数被执行</li>
<li>页面完成重新渲染</li>
</ul>
</li>
</ul>
<p><strong>用一句话高度总结</strong></p>
<p>Vue 的双向数据绑定并不是一个统一机制，而是：</p>
<ul>
<li><strong>view → model</strong>：通过 DOM 事件监听实现（JS 原生机制）</li>
<li><strong>model → view</strong>：通过数据劫持 + 发布订阅机制实现（Vue 响应式系统核心）</li>
</ul>
<h3 id="2-Vue的响应式原理"><a href="#2-Vue的响应式原理" class="headerlink" title="2.Vue的响应式原理"></a>2.Vue的响应式原理</h3><p>Vue 的响应式原理，本质上是：<strong>数据劫持负责“感知变化”，发布–订阅机制负责“通知变化”</strong>两者配合，实现 <code>model → view</code> 的自动更新。</p>
<ul>
<li>数据劫持是指：通过拦截数据的读取（get）和修改（set）操作，使系统在数据被访问或变更时能够感知到这一行为，并触发相应的依赖收集或更新逻辑。</li>
<li>发布者–订阅者模式： 简单来说，就是发布者发布信号（数据变化），订阅者当信号绑定到自己的方法上。当信号被触发，所有绑定了信号的订阅者都执行，和Qt中的信号与槽机制很像。</li>
</ul>
<p>当响应式数据发生变化时，数据修改行为会被拦截并感知，随后由依赖系统通知所有依赖该数据的订阅者，订阅者执行各自的更新函数，从而驱动相关视图重新渲染。</p>
<p>Vue2响应式原理的流程图如下：</p>
<img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20251218021138928.png" srcset="/img/loading.gif" lazyload class title="image-20251218021138928">

<p>核心代码(先不看，直接看流程)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-title function_">defineReactive</span>(obj, key, obj[key]));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Observer: 负责把对象的属性转为 getter/setter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(val); <span class="hljs-comment">// 递归处理嵌套对象</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 依赖收集</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;<br>        dep.<span class="hljs-title function_">depend</span>();<br>      &#125;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>        val = newVal;<br>        <span class="hljs-title function_">observe</span>(newVal); <span class="hljs-comment">// 如果赋值对象，继续劫持</span><br>        <span class="hljs-comment">// 通知更新</span><br>        dep.<span class="hljs-title function_">notify</span>();<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// Dep: 管理依赖的容器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">depend</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>);<br>  &#125;<br>  <span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">watcher</span> =&gt;</span> watcher.<span class="hljs-title function_">update</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Watcher: 观察者，依赖更新时执行回调</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">vm, expOrFn, cb</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>();<br>  &#125;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 设置当前 watcher</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);  <span class="hljs-comment">// 执行取值，会触发数据的 getter</span><br>    <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空，防止污染</span><br>  &#125;<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上述例子为示例，完整流程如下：</p>
<h4 id="【第一阶段：初始化】"><a href="#【第一阶段：初始化】" class="headerlink" title="【第一阶段：初始化】"></a>【第一阶段：初始化】</h4><p>第 0 步：在页面渲染之前初始化数据劫持</p>
<p>在实例化 Vue 时，Vue 会遍历 <code>data</code> 对象中的所有属性，并使用 <code>Object.defineProperty</code> 给每个属性添加 getter 和 setter，当属性被访问，调用<code>getter</code>方法， 当属性被修改，调用<code>setter</code>方法， 具体细节见下一节。</p>
<p>第 1 步：Compile 解析模板</p>
<p>以模板为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>Compile 在解析模板时，会分别处理不同类型的绑定。</p>
<hr>
<p>第 2 步：处理 <code>v-model</code>（双通道中的 view → model）</p>
<p>Compile 遇到：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>它会做两件事，这就使<strong>数据绑定</strong>，也是<code>v-model</code>的原理。</p>
<p>（1）初始化视图（数据 → 视图）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-property">value</span> = vm.<span class="hljs-property">msg</span>;<br></code></pre></td></tr></table></figure>

<p>（2）绑定 DOM 事件（视图 → 数据）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  vm.<span class="hljs-property">msg</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这一过程的性质：</p>
<ul>
<li>属于 DOM 事件监听</li>
<li>属于 JavaScript 原生机制</li>
<li><strong>不属于 Vue 响应式核心</strong></li>
</ul>
<p>到此为止：</p>
<ul>
<li>view → model 的通道已建立</li>
<li>只是“赋值”，还没有响应式更新</li>
</ul>
<hr>
<p>第 3 步：Compile 处理插值表达式</p>
<p>Compile 遇到：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>此时 Compile 明确两件事：</p>
<ol>
<li>这个 DOM 节点 <strong>依赖 <code>msg</code></strong></li>
<li>当 <code>msg</code> 变化时，<strong>应该如何更新 DOM</strong></li>
</ol>
<p>于是 Compile 生成一个<strong>更新函数</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateText</span>(<span class="hljs-params"></span>) &#123;<br>  node.<span class="hljs-property">textContent</span> = vm.<span class="hljs-property">msg</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>这是一个普通的 JS 函数</li>
<li>它不是 DOM 事件</li>
<li>它只是“更新逻辑的描述”</li>
</ul>
<hr>
<p>第 4 步：Compile 创建 Watcher</p>
<p>Compile 将更新函数交给 Watcher：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, <span class="hljs-string">&#x27;msg&#x27;</span>, updateText);<br></code></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li>Watcher 内部保存了更新函数</li>
<li>Watcher 尚未执行更新</li>
<li>Watcher 需要和数据建立关系</li>
</ul>
<hr>
<p>第 5 步：Watcher 实例化时完成依赖收集</p>
<p>在 Watcher 构造过程中，会发生一次关键操作，参考<strong>核心代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = watcher;<br>vm.<span class="hljs-property">msg</span>;        <span class="hljs-comment">// 触发 getter</span><br><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>结果是：</p>
<ul>
<li><code>msg</code> 的 getter 被触发</li>
<li><code>msg</code> 对应的 Dep 发现当前存在 Dep.target</li>
<li>Dep 将该 Watcher 收集为自己的订阅者</li>
</ul>
<p>到此为止：</p>
<ul>
<li>数据知道“谁依赖我”</li>
<li>Watcher 知道“我依赖哪个数据”</li>
<li>依赖关系建立完成</li>
<li>页面尚未发生变化</li>
</ul>
<p>注意：</p>
<ul>
<li>每个数据都有一个Dep容器</li>
<li>Dep容器存储所有以该数据相关的Watcher</li>
<li>一个DOM节点 * 一个数据 &#x3D;  一个Watcher， DOM节点是订阅者，<code>msg</code>是发布者， <code>msg</code>修改触发信号， 也就是发布者-订阅者机制已经建立。</li>
</ul>
<h4 id="【第二阶段：运行时】"><a href="#【第二阶段：运行时】" class="headerlink" title="【第二阶段：运行时】"></a>【第二阶段：运行时】</h4><p>第 6 步：数据发生变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;world&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>触发 setter：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>  dep.<span class="hljs-title function_">notify</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>第 7 步：Dep 通知所有 Watcher</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">dep.<span class="hljs-title function_">notify</span>(<span class="hljs-params"></span>) &#123;<br>  watchers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.<span class="hljs-title function_">update</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>第 8 步：Watcher 执行更新逻辑</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>();   <span class="hljs-comment">// 执行 Compile 创建的更新函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>第 9 步：视图更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">node.<span class="hljs-property">textContent</span> = vm.<span class="hljs-property">msg</span>;<br></code></pre></td></tr></table></figure>

<p>视图更新会重新触发属性的<code>getter</code>方法，检测 Watcher 是否已经在 dep 中不会重复添加。</p>
<p>完整流程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">【初始化阶段】<br>Compile<br>  ↓<br>生成 DOM 更新函数<br>  ↓<br>创建 Watcher<br>  ↓<br>Watcher 读取数据<br>  ↓<br>数据 <span class="hljs-keyword">getter</span> 收集 Watcher 到 Dep<br><br>【运行阶段】<br>数据被修改<br>  ↓<br><span class="hljs-keyword">setter</span> 触发<br>  ↓<br>dep.notify()<br>  ↓<br>watcher.update()<br>  ↓<br>执行更新函数<br>  ↓<br>视图更新<br></code></pre></td></tr></table></figure>

<h4 id="【数据劫持】"><a href="#【数据劫持】" class="headerlink" title="【数据劫持】"></a>【数据劫持】</h4><p>我们分析Vue2中数据劫持的机制。</p>
<p><strong><code>Object.defineProperty</code></strong></p>
<p>在了解数据响应式的原理之前，我们先熟悉<code>Object.defineProperty</code>方法。</p>
<p><code>Object.defineProperty(obj, prop, descriptor)</code>是JS中用于为对象添加属性的方法。</p>
<ul>
<li><strong>obj</strong>：要定义属性的对象</li>
<li><strong>prop</strong>：要定义的属性名</li>
<li><strong>descriptor</strong>：属性描述符（决定属性的行为）</li>
</ul>
<p><strong>属性描述符分类两大类</strong></p>
<ol>
<li>数据描述符</li>
</ol>
<p>用于直接定义一个普通属性的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Tom&quot;</span>,<br>  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,     <span class="hljs-comment">// 是否可以修改</span><br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 是否可以枚举（for...in / Object.keys）</span><br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 是否可以删除或重新定义</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>value</code>：属性值</li>
<li><code>writable</code>：能否修改</li>
<li><code>enumerable</code>：能否枚举</li>
<li><code>configurable</code>：能否删除或重新定义属性</li>
</ul>
<ol start="2">
<li>存取描述符</li>
</ol>
<p>通过 getter 和 setter 控制属性访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;&#125;;<br><span class="hljs-keyword">let</span> ageValue = <span class="hljs-number">20</span>;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(person, <span class="hljs-string">&quot;age&quot;</span>, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getter 被调用&quot;</span>);<br>    <span class="hljs-keyword">return</span> ageValue;<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setter 被调用:&quot;</span>, newVal);<br>    ageValue = newVal;<br>  &#125;,<br>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// getter 被调用 -&gt; 20</span><br>person.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;         <span class="hljs-comment">// setter 被调用: 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">age</span>); <span class="hljs-comment">// getter 被调用 -&gt; 30</span><br></code></pre></td></tr></table></figure>

<p>对于Vue的<code>data</code>对象，创建一个Observe对象，<code>data</code>中的所有属性都会在Observe上创建，并且有<code>getter</code>和<code>setter</code>方法。将<code>vm._data = obs</code>，这样当数据修改时，调用的是<code>observe</code>的方法，由<code>observe</code>修改<code>data</code>的属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, key, obj[key]));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Observer: 负责把对象的属性转为 getter/setter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) &#123;<br>  <span class="hljs-title function_">observe</span>(val); <span class="hljs-comment">// 递归处理嵌套对象</span><br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>        val = newVal;<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br><br>obs = <span class="hljs-keyword">new</span> <span class="hljs-title function_">observe</span>(data)<br><span class="hljs-keyword">let</span> vm = &#123;&#125;<br>vm.<span class="hljs-property">_data</span> = data = obs<br></code></pre></td></tr></table></figure>

<h4 id="【局限性】"><a href="#【局限性】" class="headerlink" title="【局限性】"></a>【局限性】</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=ff414aaf189e3a685358d2a984fd4742&p=34">034_尚硅谷Vue技术_Vue监测数据的原理_对象_哔哩哔哩_bilibili</a></p>
</blockquote>
<ol>
<li><p><strong>不能监听对象属性的新增&#x2F;删除</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;a&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;);<br>obj.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 没有劫持到</span><br></code></pre></td></tr></table></figure>

<p>需要 <code>Vue.set(obj, &#39;b&#39;, 2)</code> 来实现。</p>
</li>
<li><p><strong>不能监听数组下标变化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;  <span class="hljs-comment">// Vue2 监听不到</span><br></code></pre></td></tr></table></figure>

<p>两者都是由于没有<code>setter</code>和<code>getter</code>方法，无法进行数据劫持。通过以下方式可以解决</p>
<ul>
<li><code>this.$set() / Vue.set()</code></li>
<li><code>this.$delete() / Vue.delete()</code></li>
<li>使用<code>push, pop, shift, unshift, splice</code></li>
</ul>
</li>
<li><p><strong>初始化时需要递归遍历</strong></p>
</li>
</ol>
<ul>
<li>Vue2 会在初始化时递归调用 <code>defineProperty</code> 劫持所有属性，这对深层嵌套对象性能不好。</li>
</ul>
<h3 id="3-Vue3的响应式原理"><a href="#3-Vue3的响应式原理" class="headerlink" title="3.Vue3的响应式原理"></a>3.Vue3的响应式原理</h3><p>首先明确 Vue3 和 Vue2 在<strong>思想层面完全一致</strong>：</p>
<ul>
<li>数据劫持（拦截 get &#x2F; set）</li>
<li>依赖收集</li>
<li>依赖触发更新（发布–订阅思想）</li>
</ul>
<p>但是调用的方法和API不同。但不再有 <strong>Observer &#x2F; Dep &#x2F; Watcher</strong> 这些类名；它们被 <strong>Proxy + Map&#x2F;Set + effect 函数</strong> 替代</p>
<p>Vue 3 使用 Proxy 对对象进行代理拦截：在读取属性时通过 track 完成依赖收集；在修改属性时通过 trigger 触发依赖更新。与 Vue 2 逐属性 defineProperty 不同，Proxy 天然支持新增&#x2F;删除属性以及更多操作类型，并可采用惰性代理降低初始化成本。</p>
<h4 id="【第一阶段：初始化】-1"><a href="#【第一阶段：初始化】-1" class="headerlink" title="【第一阶段：初始化】"></a>【第一阶段：初始化】</h4><p>第 0 步：在首次渲染之前完成“响应式包装”（Proxy）</p>
<p>Vue 3 中不再是“遍历 data 每个属性 defineProperty”，而是：</p>
<ul>
<li><code>reactive(data)</code> 返回一个 Proxy</li>
<li>Proxy 在 <strong>get &#x2F; set</strong> 时拦截并执行 <code>track / trigger</code>， <code>track</code>是依赖收集，<code>trigger</code>是依赖触发。</li>
</ul>
<p>示意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure>

<p>这一步一定发生在首次渲染之前，否则 render 读取数据时无法 track 依赖。</p>
<hr>
<p>第 1 步：模板被编译为 render（概念上对应 Compile 解析）</p>
<p>Vue 3 的 render 大致可以抽象成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 读取 state.msg（会触发 Proxy.get -&gt; track）</span><br>  input.<span class="hljs-property">value</span> = state.<span class="hljs-property">msg</span>;<br>  p.<span class="hljs-property">textContent</span> = state.<span class="hljs-property">msg</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>真实 Vue 会生成 VNode 并 patch，但不影响响应式因果链。</p>
<hr>
<p>第 2 步：处理 <code>v-model</code>（view → model 仍然是 DOM 事件）</p>
<ul>
<li>DOM 事件监听属于 JS 原生机制</li>
<li>Vue 只是在框架层帮你组织好“监听 + 赋值”</li>
</ul>
<p>等价示意：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  state.<span class="hljs-property">msg</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>; <span class="hljs-comment">// Proxy.set -&gt; trigger</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>到此为止：</p>
<ul>
<li>view → model 通道建立</li>
<li>但响应式更新链路要靠下面的 effect 才能自动跑起来</li>
</ul>
<hr>
<p>第 3 步：创建渲染 effect（等价于 Vue 2 的“创建渲染 Watcher”）</p>
<p>Vue 3 中对应的是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 首次执行：读取 state.msg -&gt; track 收集依赖</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这一句是 Vue 3 运行时的关键点：</p>
<ul>
<li>effect 首次执行 render</li>
<li>render 内部读取 <code>state.msg</code></li>
<li>触发 <code>Proxy.get</code> → <code>track(target, &#39;msg&#39;)</code></li>
<li>把当前 effect 记录到依赖图 <code>targetMap</code> 的对应集合里</li>
</ul>
<p>到此为止：</p>
<ul>
<li>依赖关系已建立</li>
<li><strong>effect 是“订阅者&#x2F;更新单元”</strong></li>
<li><code>state.msg</code> 的依赖集合里已经有这个 effect</li>
</ul>
<hr>
<h4 id="【第二阶段：运行时】-1"><a href="#【第二阶段：运行时】-1" class="headerlink" title="【第二阶段：运行时】"></a>【第二阶段：运行时】</h4><p>第 4 步：数据发生变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">state.<span class="hljs-property">msg</span> = <span class="hljs-string">&#x27;world&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>触发：</p>
<ul>
<li><code>Proxy.set</code></li>
<li>进而 <code>trigger(target, &#39;msg&#39;)</code></li>
</ul>
<hr>
<p>第 5 步：trigger 通知所有依赖该属性的 effect</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">dep.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">eff</span> =&gt;</span> <span class="hljs-title function_">eff</span>());<br></code></pre></td></tr></table></figure>

<p>这一步等价于 Vue 2 的：</p>
<ul>
<li><code>dep.notify() -&gt; watcher.update()</code></li>
</ul>
<hr>
<p>第 6 步：effect 重新执行 render，完成视图更新</p>
<p>effect 再次执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 再次读取 state.msg</span><br></code></pre></td></tr></table></figure>

<p>因此：</p>
<ul>
<li>视图更新会再次触发 <code>Proxy.get</code></li>
<li>会再次走到 <code>track</code></li>
<li>但依赖集合是 <code>Set</code>，不会重复添加同一个 effect</li>
</ul>
<p>结论：</p>
<ul>
<li><strong>getter（Proxy.get）会重复触发</strong></li>
<li><strong>effect 不会重新创建，只会重复执行</strong></li>
<li><strong>依赖不会重复收集（Set 去重）</strong></li>
</ul>
<hr>
<p>完整流程（Vue 3 文字版固化）</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf">【初始化阶段】<br>reactive(data) 创建 Proxy<br>  ↓<br>编译得到 render（概念上）<br>  ↓<br>effect(() =&gt; render())  首次执行 render<br>  ↓<br>render 读取 <span class="hljs-keyword">state</span>.msg<br>  ↓<br>Proxy.get -&gt; track 收集 effect 到依赖图<br><br>【运行阶段】<br><span class="hljs-keyword">state</span>.msg 被修改<br>  ↓<br>Proxy.<span class="hljs-built_in">set</span> -&gt; trigger<br>  ↓<br>trigger 找到依赖该 key 的 effects<br>  ↓<br>重新执行 effect（不会重新创建）<br>  ↓<br>render 再次执行 -&gt; 视图更新<br></code></pre></td></tr></table></figure>

<h4 id="【Proxy和Reflect】"><a href="#【Proxy和Reflect】" class="headerlink" title="【Proxy和Reflect】"></a>【<code>Proxy</code>和<code>Reflect</code>】</h4><p><code>Proxy</code>和<code>Reflect</code>是ES6新增的属性。</p>
<p>调用 <code>reactive(state)</code>时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> &#125; &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>此时发生的事情是：</p>
<ul>
<li>创建了 <strong>state 的 Proxy</strong></li>
<li>内部对象 <code>a</code>、<code>b</code>、<code>c</code> 还是普通对象</li>
</ul>
<p>Vue 3 不会在创建 <code>reactive</code> 时就递归地把所有嵌套对象都变成响应式，而是在“第一次访问某个嵌套对象时”，才对它进行 <code>reactive</code> 包装。</p>
<p><strong>Proxy</strong> 用来创建对象的代理，可以拦截对对象的各种操作。</p>
<p>基本语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>target</strong>：原始对象</li>
<li><strong>handler</strong>：一个对象，定义拦截操作（trap）</li>
</ul>
<p>常用 trap：</p>
<table>
<thead>
<tr>
<th>trap</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>读取属性时触发</td>
</tr>
<tr>
<td>set</td>
<td>修改属性时触发</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>删除属性时触发</td>
</tr>
<tr>
<td>has</td>
<td><code>key in obj</code> 时触发</td>
</tr>
<tr>
<td>ownKeys</td>
<td><code>Object.keys</code> &#x2F; <code>for...in</code> 时触发</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取属性 <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置属性 <span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    target[key] = value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;);<br><br>proxyObj.<span class="hljs-property">a</span>;      <span class="hljs-comment">// 读取属性 a</span><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">20</span>; <span class="hljs-comment">// 设置属性 a = 20</span><br></code></pre></td></tr></table></figure>

<p><strong>Reflect</strong> 提供与对象操作对应的方法，是一种原生的操作封装。它的目的是 <strong>用函数形式实现对象的默认行为</strong>，可以和 Proxy 的 handler 配合使用。</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>对应操作</th>
</tr>
</thead>
<tbody><tr>
<td>Reflect.get(target, key, receiver)</td>
<td>对象读取属性</td>
</tr>
<tr>
<td>Reflect.set(target, key, value, receiver)</td>
<td>对象设置属性</td>
</tr>
<tr>
<td>Reflect.deleteProperty(target, key)</td>
<td>删除属性</td>
</tr>
<tr>
<td>Reflect.has(target, key)</td>
<td><code>key in obj</code></td>
</tr>
<tr>
<td>Reflect.ownKeys(target)</td>
<td><code>Object.keys</code> &#x2F; <code>Object.getOwnPropertyNames</code></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<br><span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`读取 <span class="hljs-subst">$&#123;key&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver); <span class="hljs-comment">// 默认行为</span><br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`修改 <span class="hljs-subst">$&#123;key&#125;</span> = <span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver); <span class="hljs-comment">// 默认行为</span><br>  &#125;<br>&#125;);<br><br>proxyObj.<span class="hljs-property">a</span>;      <span class="hljs-comment">// 读取 a</span><br>proxyObj.<span class="hljs-property">a</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 修改 a = 100</span><br></code></pre></td></tr></table></figure>

<p>使用 Reflect 的好处：将Object,Function所有的操作<strong>统一到了一个对象下面</strong> ，<strong>也统一了操作方式</strong> 。 优化了一些报错，相比于Object代码健壮性更强。</p>
<blockquote>
<p><strong>整体描述</strong></p>
</blockquote>
<p>Vue 是基于 MVVM 架构实现的渐进式前端框架，其中 Model 负责保存数据和业务状态，View 是模板和最终的 DOM，ViewModel 即 Vue 实例负责把二者连接起来并实现数据与视图的双向绑定。框架通过响应式系统把数据的读写和视图更新耦合起来：在 Vue2 中，框架在初始化时会递归遍历 <code>data</code>，对每个属性使用 <code>Object.defineProperty</code> 设置 getter 和 setter；在组件渲染阶段执行渲染函数时，读取响应式属性会触发 getter，getter 中利用一个全局指针（<code>Dep.target</code>）将当前正在执行的 Watcher（渲染 Watcher、computed 的惰性 Watcher，或用户通过 <code>watch</code>&#x2F;<code>$watch</code> 创建的 Watcher）加入该属性对应的依赖管理器 Dep，从而建立“属性 → 订阅者（Watcher）”的关系；当属性被修改时，setter 被触发，调用 Dep.notify 通知所有依赖该属性的 Watcher 去更新。视图到数据的反向链路由模板编译时产生的指令完成，例如 <code>v-model</code> 实际上会编译为 <code>:value=&quot;xxx&quot;</code> 与 <code>@input=&quot;xxx = $event.target.value&quot;</code>，用户输入触发事件处理器写回数据，写回数据触发 setter，再通过依赖链更新视图。Vue2 中对数组采用覆盖变异方法（如重写 <code>push</code>、<code>splice</code>）来拦截变更，但不能检测通过下标直接赋值或新增&#x2F;删除对象属性（需要 <code>Vue.set</code>&#x2F;<code>Vue.delete</code>），且初始化时对深层对象的递归劫持开销较大。</p>
<p>为了解决这些局限，Vue3 将响应式内核替换为 <code>Proxy</code> + <code>Reflect</code> 的实现：<code>reactive</code> 返回一个 Proxy，<code>get</code>&#x2F;<code>set</code>&#x2F;<code>deleteProperty</code> 等拦截器配合 <code>track</code>&#x2F;<code>trigger</code> 在内部维护依赖映射结构 <code>targetMap</code>（WeakMap → Map（key → Set(effects)））；当一个 effect（等价于 Vue2 的 Watcher）在执行时读取属性会被 <code>track</code> 收集为依赖，写操作或删除操作会通过 <code>trigger</code> 找到相关 effect 并重新执行。Proxy 的优点是能拦截属性新增与删除、数组下标与长度变化，并且采用按需（懒）代理嵌套对象以减少初始化开销，从而使得对数组和新增属性的监测更自然、性能更优。</p>
<p>视图更新层面，模板在构建阶段被编译为渲染函数（render），渲染函数执行生成虚拟 DOM（VNode）；响应式变化触发渲染 Watcher &#x2F; effect 重新执行渲染函数产生新的 VNode，框架通过虚拟 DOM 的 diff 算法比较新旧 VNode 并以最小化的方式 patch 到真实 DOM。为了提高并发修改的性能，Vue 会把多个同步的数据修改合并为一次异步批量更新（维护更新队列并使用微任务&#x2F;<code>nextTick</code> 调度），Vue3 在 diff 的子节点重排上用 keyed 优化和最长递增子序列（LIS）等策略进一步减少 DOM 移动。</p>
<p>总之，Vue 的关键是把数据变动的“通知”链和视图的“渲染”链通过依赖收集连接起来：Vue2 用 <code>Object.defineProperty</code> + Dep&#x2F;Watcher 实现，存在新增&#x2F;数组索引检测等局限；Vue3 用 <code>Proxy</code> + <code>track/trigger</code>（基于 WeakMap→Map→Set 的依赖表）解决这些问题并带来性能与语义上的改进；而 <code>v-model</code>、computed、watch、渲染队列与虚拟 DOM 则是建立在这套响应式核心之上的常用抽象。</p>
<h3 id="4-数据代理"><a href="#4-数据代理" class="headerlink" title="4.数据代理"></a>4.数据代理</h3><p>创建一个简单的vue实例时：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>初识Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 引入Vue --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span><br><span class="language-javascript">			<span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//阻止 vue 在启动时生成生产提示。</span></span><br><span class="language-javascript">			<span class="hljs-comment">//创建Vue实例</span></span><br><span class="language-javascript">			<span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">				<span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;#demo&#x27;</span>, <span class="hljs-comment">//el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。</span></span><br><span class="language-javascript">				<span class="hljs-attr">data</span>:&#123; <span class="hljs-comment">//data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。</span></span><br><span class="language-javascript">					<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;atguigu&#x27;</span>,</span><br><span class="language-javascript">					<span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;北京&#x27;</span></span><br><span class="language-javascript">				&#125;</span><br><span class="language-javascript">			&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>在命令行终端中，可以通过<code>vm.name</code>和<code>vm.address</code>来访问数据。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">name</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">name</span><br>vm.<span class="hljs-property">address</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">address</span><br></code></pre></td></tr></table></figure>

<ul>
<li>当修改<code>vm.name</code>时，<code>vm._data.name</code>会同步修改。</li>
</ul>
<h4 id="理解数据代理"><a href="#理解数据代理" class="headerlink" title="理解数据代理"></a>理解数据代理</h4><p>在前面我们说VMMV的 Model 实际上就是<code>data</code>属性中是数据，当我们创建一个vue的实例对象的时候。Vue会帮我们将数据进行一些处理。</p>
<ul>
<li>首先将数据从<code>data</code>中取出放到<code>_data</code>中，并进行数据劫持的相关操作（后面提到）</li>
<li>将数据从<code>_data</code>中复制了一份在<code>vm</code>实例对象上，对 <code>vm</code> 实例的属性访问，转发到 <code>vm._data</code> 上。<strong>（数据代理）</strong></li>
</ul>
<img src="/2025/12/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/5-Vue%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/image-20250903140313714.png" srcset="/img/loading.gif" lazyload class title="image-20250903140313714">

<blockquote>
<p>要注意的是，数据代理的作用是减少代码量，让开发体验更好。与响应式没有关系。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">addr</span> === vm.<span class="hljs-property">_data</span>.<span class="hljs-property">addr</span> === vm.<span class="hljs-property">data</span>.<span class="hljs-property">addr</span> ( === vm.<span class="hljs-property">observe</span>.<span class="hljs-property">addr</span>)<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" class="category-chain-item">前端学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" class="print-no-link">#前端面试题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>5.Vue基本原理</div>
      <div>http://example.com/2025/12/18/前端学习/5-Vue基本原理/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Xiang Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年12月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/12/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/Vue3%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" title="Vue3快速上手">
                        <span class="hidden-mobile">Vue3快速上手</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"xXfj7jVpB8fiyIpWQbXJP1Gj-gzGzoHsz","appKey":"RoFR6Po4mFIHocqHXZ42PUGO","path":"window.location.pathname","placeholder":"输入你的评论","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
