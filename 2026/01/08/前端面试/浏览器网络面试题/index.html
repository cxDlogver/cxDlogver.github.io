

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/dog.png">
  <link rel="icon" href="/img/dog.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Xiang Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="跨域问题面试题 1：什么是跨域？为什么会有跨域问题？回答模板： 跨域本质是浏览器的同源策略限制。 同源指的是：协议、域名、端口三者完全一致。 只要三者中任意一个不同，浏览器就会认为是跨域，从而限制前端脚本读取响应内容，以防止恶意网站窃取用户数据。 需要注意的是：跨域是浏览器层面的安全限制，服务器本身并不受影响。 面试题 2：同源策略限制了哪些行为？回答模板： 同源策略主要限制的是：  JS 读取跨">
<meta property="og:type" content="article">
<meta property="og:title" content="【⭐】浏览器&#x2F;网络相关面试题">
<meta property="og:url" content="http://example.com/2026/01/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="相">
<meta property="og:description" content="跨域问题面试题 1：什么是跨域？为什么会有跨域问题？回答模板： 跨域本质是浏览器的同源策略限制。 同源指的是：协议、域名、端口三者完全一致。 只要三者中任意一个不同，浏览器就会认为是跨域，从而限制前端脚本读取响应内容，以防止恶意网站窃取用户数据。 需要注意的是：跨域是浏览器层面的安全限制，服务器本身并不受影响。 面试题 2：同源策略限制了哪些行为？回答模板： 同源策略主要限制的是：  JS 读取跨">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2026-01-08T08:44:32.000Z">
<meta property="article:modified_time" content="2026-01-10T22:54:43.491Z">
<meta property="article:author" content="Xiang Chen">
<meta property="article:tag" content="前端工程">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>【⭐】浏览器/网络相关面试题 - 相</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>相</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【⭐】浏览器/网络相关面试题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2026-01-08 16:44" pubdate>
          2026年1月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          123 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【⭐】浏览器/网络相关面试题</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><h3 id="面试题-1：什么是跨域？为什么会有跨域问题？"><a href="#面试题-1：什么是跨域？为什么会有跨域问题？" class="headerlink" title="面试题 1：什么是跨域？为什么会有跨域问题？"></a>面试题 1：什么是跨域？为什么会有跨域问题？</h3><p><strong>回答模板：</strong><br> 跨域本质是<strong>浏览器的同源策略限制</strong>。<br> 同源指的是：<strong>协议、域名、端口</strong>三者完全一致。<br> 只要三者中任意一个不同，浏览器就会认为是跨域，从而<strong>限制前端脚本读取响应内容</strong>，以防止恶意网站窃取用户数据。<br> 需要注意的是：<strong>跨域是浏览器层面的安全限制，服务器本身并不受影响</strong>。</p>
<h3 id="面试题-2：同源策略限制了哪些行为？"><a href="#面试题-2：同源策略限制了哪些行为？" class="headerlink" title="面试题 2：同源策略限制了哪些行为？"></a>面试题 2：同源策略限制了哪些行为？</h3><p><strong>回答模板：</strong><br> 同源策略主要限制的是：</p>
<ul>
<li>JS 读取跨域响应内容（<code>response / responseText</code>）</li>
<li>跨域 Cookie 的自动携带与读取</li>
<li>跨域 DOM、Storage 的访问</li>
</ul>
<p>但<strong>不会限制请求是否发出</strong>，例如：<br> <code>img / script / link / form</code> 都可以发起跨域请求，并且能够绕过跨域问题</p>
<h3 id="面试题-3：前端常见的跨域解决方案有哪些？"><a href="#面试题-3：前端常见的跨域解决方案有哪些？" class="headerlink" title="面试题 3：前端常见的跨域解决方案有哪些？"></a>面试题 3：前端常见的跨域解决方案有哪些？</h3><p>第一种：CORS（跨域资源共享，最标准）</p>
<p>CORS 是 <strong>浏览器制定的一套跨域访问规范</strong>。<br> 浏览器会根据这套规范，<strong>通过请求头和响应头来判断是否允许跨域访问</strong>。</p>
<p>核心思想是：</p>
<blockquote>
<p><strong>是否允许跨域，不由前端决定，而是由服务器通过响应头声明。</strong></p>
</blockquote>
<p>服务器可以通过设置诸如：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code></li>
<li><code>Access-Control-Allow-Methods</code></li>
<li><code>Access-Control-Allow-Headers</code></li>
<li><code>Access-Control-Allow-Credentials</code></li>
</ul>
<p>来精细化控制哪些源、哪些方法、哪些请求头可以跨域访问。</p>
<p>CORS 支持：</p>
<ul>
<li>所有 HTTP 方法</li>
<li>复杂请求</li>
<li>Cookie &#x2F; 认证信息</li>
</ul>
<p>因此它是<strong>生产环境中最规范、最安全、最常用的跨域方案</strong>。</p>
<hr>
<p>第二种：反向代理（工程中非常常见）</p>
<p>反向代理的核心原理是：</p>
<blockquote>
<p><strong>浏览器与服务器之间存在跨域限制，但服务器与服务器之间不存在跨域问题。</strong></p>
</blockquote>
<p>具体做法是：</p>
<ul>
<li>在前端同源的服务器上设置一台代理服务器（如 Nginx、开发服务器）</li>
<li>浏览器请求代理服务器（同源请求）</li>
<li>代理服务器再向真实后端服务器转发请求</li>
<li>后端返回数据给代理服务器</li>
<li>代理服务器再将数据转发给浏览器</li>
</ul>
<p>从浏览器视角来看：</p>
<ul>
<li>请求始终是<strong>同源请求</strong></li>
<li>因此<strong>不会触发跨域问题</strong></li>
</ul>
<p>这种方式：</p>
<ul>
<li><strong>开发环境非常常见</strong></li>
<li>生产环境也常用于 API 网关、统一入口</li>
</ul>
<hr>
<p>第三种：JSONP（已过时）</p>
<p>JSONP 是一种<strong>早期的跨域解决方案</strong>，原理是：</p>
<ul>
<li>利用 <code>&lt;script&gt;</code> 标签<strong>不受同源策略限制</strong></li>
<li>通过 URL 参数传递一个回调函数名</li>
<li>服务器返回一段<strong>调用该回调函数的 JS 代码</strong></li>
<li>浏览器执行这段 JS，从而获取数据</li>
</ul>
<p>这种方式的缺点非常明显：</p>
<ul>
<li><strong>只支持 GET 请求</strong></li>
<li>存在安全风险</li>
<li>不符合现代前后端分离架构</li>
</ul>
<p>因此 <strong>现在基本已经被淘汰，不推荐使用</strong>。</p>
<ul>
<li>有安全风险，基本不再推荐</li>
</ul>
<h3 id="面试题-4：为什么有的请求会触发-CORS-预检（OPTIONS）？"><a href="#面试题-4：为什么有的请求会触发-CORS-预检（OPTIONS）？" class="headerlink" title="面试题 4：为什么有的请求会触发 CORS 预检（OPTIONS）？"></a>面试题 4：为什么有的请求会触发 CORS 预检（OPTIONS）？</h3><blockquote>
<p>浏览器根据 CORS 规范将跨域请求分为简单请求和非简单请求。<br> 当请求不满足简单请求条件，比如使用 <code>application/json</code> 或自定义请求头时，会先发送一次 <code>OPTIONS</code> 预检请求，用于确认服务器是否允许跨域访问。<br> 预检结果可以通过 <code>Access-Control-Max-Age</code> 缓存，避免每次都触发。</p>
</blockquote>
<p>标准回答模板</p>
<p>有些请求会触发 CORS 预检，是因为<strong>浏览器根据 CORS 规范，将跨域请求分为「简单请求」和「非简单请求」两类</strong>。</p>
<p>当浏览器判定当前请求是<strong>非简单请求</strong>时，会在真正的业务请求之前，<strong>先自动发送一次 <code>OPTIONS</code> 预检请求</strong>，用来确认服务器是否允许该跨域请求。</p>
<hr>
<p>一、什么情况下会触发预检请求？</p>
<p>只要请求<strong>不满足简单请求的条件</strong>，浏览器就会触发 <code>OPTIONS</code> 预检。</p>
<hr>
<p>二、什么是简单请求？</p>
<p>简单请求必须<strong>同时满足以下三个条件</strong>：</p>
<h4 id="1️⃣-请求方法只能是三种之一"><a href="#1️⃣-请求方法只能是三种之一" class="headerlink" title="1️⃣ 请求方法只能是三种之一"></a>1️⃣ 请求方法只能是三种之一</h4><ul>
<li><code>GET</code></li>
<li><code>POST</code></li>
<li><code>HEAD</code></li>
</ul>
<hr>
<h4 id="2️⃣-请求头只能是-CORS-规范允许的“安全请求头”"><a href="#2️⃣-请求头只能是-CORS-规范允许的“安全请求头”" class="headerlink" title="2️⃣ 请求头只能是 CORS 规范允许的“安全请求头”"></a>2️⃣ 请求头只能是 CORS 规范允许的“安全请求头”</h4><p>通常情况下：</p>
<blockquote>
<p><strong>只要不手动添加自定义请求头（如 <code>Authorization</code>），就满足这一条件</strong></p>
</blockquote>
<hr>
<h4 id="3️⃣-Content-Type-只能是以下三种之一"><a href="#3️⃣-Content-Type-只能是以下三种之一" class="headerlink" title="3️⃣ Content-Type 只能是以下三种之一"></a>3️⃣ Content-Type 只能是以下三种之一</h4><ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencoded</code></li>
</ul>
<p>⚠️ <strong>重点：</strong></p>
<blockquote>
<p><code>application/json</code> <strong>不属于简单请求的 Content-Type</strong></p>
</blockquote>
<p>因此：</p>
<ul>
<li>只要使用 <code>application/json</code> 发送请求</li>
<li>浏览器就会将其判定为 <strong>非简单请求</strong></li>
<li>从而触发 <code>OPTIONS</code> 预检</li>
</ul>
<hr>
<p>三、什么是 OPTIONS 预检请求？</p>
<p><code>OPTIONS</code> 预检请求的作用是：</p>
<blockquote>
<p><strong>在真正发送跨域请求之前，先询问服务器是否允许本次跨域访问</strong></p>
</blockquote>
<p>服务器会在预检响应中返回：</p>
<ul>
<li>是否允许该源访问</li>
<li>是否允许该请求方法</li>
<li>是否允许这些请求头</li>
<li>是否允许携带 Cookie</li>
</ul>
<p>如果预检通过：</p>
<ul>
<li>浏览器才会发送真正的业务请求（GET &#x2F; POST 等）</li>
</ul>
<p>如果预检失败：</p>
<ul>
<li><strong>浏览器直接拦截</strong></li>
<li>业务请求根本不会发出</li>
</ul>
<hr>
<p>四、为什么不是每次都发送 OPTIONS？</p>
<p>CORS 允许服务器通过响应头：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Access</span>-Control-<span class="hljs-built_in">Max</span>-Age<br></code></pre></td></tr></table></figure>

<p>指定：</p>
<blockquote>
<p><strong>预检结果的缓存时间</strong></p>
</blockquote>
<p>在该时间内：</p>
<ul>
<li>浏览器不会重复发送 OPTIONS</li>
<li>可以直接复用上一次的预检结果</li>
<li>这是 CORS 的重要性能优化机制</li>
</ul>
<h3 id="面试题-5-一次非简单请求的完整校验是怎样的？"><a href="#面试题-5-一次非简单请求的完整校验是怎样的？" class="headerlink" title="面试题 5: 一次非简单请求的完整校验是怎样的？"></a>面试题 5: 一次非简单请求的完整校验是怎样的？</h3><h3 id="标准回答模板（紧凑版）"><a href="#标准回答模板（紧凑版）" class="headerlink" title="标准回答模板（紧凑版）"></a>标准回答模板（紧凑版）</h3><p>一次<strong>非简单跨域请求</strong>的完整校验流程，严格按照 <strong>CORS 规范</strong>分为以下几个步骤：</p>
<hr>
<p><strong>1️⃣ 浏览器判定请求类型</strong><br> 浏览器在发起请求前，会先根据 CORS 规则判断是否为非简单请求：</p>
<ul>
<li>使用了非简单方法</li>
<li>使用了自定义请求头（如 <code>Authorization</code>）</li>
<li><code>Content-Type</code> 为 <code>application/json</code><br> 只要满足任意一条，就会进入预检流程。</li>
</ul>
<hr>
<p><strong>2️⃣ 发送 OPTIONS 预检请求</strong><br> 浏览器自动向目标服务器发送 <code>OPTIONS</code> 请求，用于“探测”是否允许跨域。<br> 预检请求中会携带：</p>
<ul>
<li><code>Origin</code></li>
<li><code>Access-Control-Request-Method</code></li>
<li><code>Access-Control-Request-Headers</code></li>
</ul>
<hr>
<p><strong>3️⃣ 服务器返回预检响应</strong><br> 服务器根据自身 CORS 配置返回响应头：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code></li>
<li><code>Access-Control-Allow-Methods</code></li>
<li><code>Access-Control-Allow-Headers</code></li>
<li>（可选）<code>Access-Control-Allow-Credentials</code></li>
<li>（可选）<code>Access-Control-Max-Age</code></li>
</ul>
<hr>
<p><strong>4️⃣ 浏览器校验预检结果</strong><br> 浏览器会对响应头进行校验：</p>
<ul>
<li>源是否被允许</li>
<li>方法是否被允许</li>
<li>请求头是否被允许</li>
</ul>
<p>若任意一项不通过，流程直接终止，<strong>业务请求不会发送</strong>。</p>
<hr>
<p><strong>5️⃣ 发送真正的业务请求</strong><br> 预检通过后，浏览器才会发送真正的跨域请求（GET &#x2F; POST &#x2F; PUT 等），并携带 Cookie（如已开启 credentials）。</p>
<hr>
<p><strong>6️⃣ 浏览器校验业务响应</strong><br> 浏览器再次检查业务响应中的 CORS 头：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code></li>
<li><code>Access-Control-Allow-Credentials</code><br> 校验通过后，JS 才能正常读取响应数据。</li>
</ul>
<hr>
<p><strong>7️⃣ 预检结果缓存（性能优化）</strong><br> 如果服务器返回了 <code>Access-Control-Max-Age</code>，<br> 在有效期内，相同请求将<strong>不再重复发送 OPTIONS 预检</strong>。</p>
<hr>
<h3 id="面试题-6：跨域请求为什么-Cookie-传不过去？"><a href="#面试题-6：跨域请求为什么-Cookie-传不过去？" class="headerlink" title="面试题 6：跨域请求为什么 Cookie 传不过去？"></a>面试题 6：跨域请求为什么 Cookie 传不过去？</h3><p><strong>回答模板：</strong><br> 跨域 Cookie 需要<strong>前后端同时满足条件</strong>：</p>
<ul>
<li>前端：<ul>
<li><code>xhr.withCredentials = true</code></li>
</ul>
</li>
<li>后端：<ul>
<li><code>Access-Control-Allow-Credentials: true</code></li>
<li><code>Access-Control-Allow-Origin</code> 不能为 <code>*</code></li>
</ul>
</li>
</ul>
<p>缺一不可，否则浏览器会直接拦截 Cookie。</p>
<hr>
<h3 id="面试题-7：OPTIONS-请求失败会发生什么？"><a href="#面试题-7：OPTIONS-请求失败会发生什么？" class="headerlink" title="面试题 7：OPTIONS 请求失败会发生什么？"></a>面试题 7：OPTIONS 请求失败会发生什么？</h3><p><strong>回答模板：</strong><br> 如果 OPTIONS 预检失败：</p>
<ul>
<li>浏览器<strong>不会发送真正的业务请求</strong></li>
<li>控制台会直接报 CORS 错误</li>
<li>后端日志中通常只看到 OPTIONS，没有 GET&#x2F;POST</li>
</ul>
<p>这是前端“看似请求没发出去”的常见原因。</p>
<h3 id="面试题-8：开发环境是怎么解决跨域的？"><a href="#面试题-8：开发环境是怎么解决跨域的？" class="headerlink" title="面试题 8：开发环境是怎么解决跨域的？"></a>面试题 8：开发环境是怎么解决跨域的？</h3><p><strong>回答模板：</strong><br> 开发环境通常使用<strong>本地代理</strong>：</p>
<ul>
<li>Vite &#x2F; Webpack Dev Server</li>
<li>将 <code>/api</code> 请求代理到真实后端</li>
<li>浏览器认为请求仍然是同源</li>
</ul>
<p>这种方式<strong>只解决开发阶段问题</strong>，生产环境仍需 CORS 或网关代理。</p>
<hr>
<h3 id="面试题-9：为什么-Postman-没有跨域问题？"><a href="#面试题-9：为什么-Postman-没有跨域问题？" class="headerlink" title="面试题 9：为什么 Postman 没有跨域问题？"></a>面试题 9：为什么 Postman 没有跨域问题？</h3><p><strong>回答模板：</strong><br> 因为跨域是<strong>浏览器的安全策略</strong>。<br> Postman、curl、后端服务之间的请求：</p>
<ul>
<li>不受同源策略限制</li>
<li>可以自由访问任何接口</li>
</ul>
<p>这也是“Postman 能通，前端不通”的根本原因。</p>
<h3 id="面试题10：-Nginx-的特点是什么？常见的三大作用？"><a href="#面试题10：-Nginx-的特点是什么？常见的三大作用？" class="headerlink" title="面试题10： Nginx 的特点是什么？常见的三大作用？"></a>面试题10： Nginx 的特点是什么？常见的三大作用？</h3><blockquote>
<p>Nginx 是一个高性能的 Web 服务器和反向代理服务器，采用事件驱动模型，支持高并发、低内存占用。<br> 常见三大作用是：作为静态资源服务器、反向代理服务器以及负载均衡器，在前后端分离和高并发架构中非常常见。</p>
</blockquote>
<p>一、Nginx 的核心特点（先说优势）</p>
<p><strong>标准回答模板：</strong><br> Nginx 是一个<strong>高性能的 Web 服务器和反向代理服务器</strong>，核心特点是：</p>
<ul>
<li><strong>事件驱动、异步非阻塞 I&#x2F;O</strong>（单进程可支撑大量并发）</li>
<li><strong>高并发、低内存占用</strong>（C10K 问题的经典解决方案）</li>
<li><strong>配置简单、模块化清晰</strong></li>
<li><strong>稳定性强，适合长期运行</strong></li>
</ul>
<p>一句话概括：</p>
<blockquote>
<p>Nginx 用更少的资源，支撑更多的并发连接。</p>
</blockquote>
<hr>
<p>二、Nginx 的三大常见作用（必考重点）</p>
<hr>
<p>1️⃣ Web 服务器（静态资源服务器）</p>
<p><strong>作用说明：</strong></p>
<ul>
<li>直接对外提供 HTTP 服务</li>
<li>高效处理：<ul>
<li>HTML</li>
<li>CSS &#x2F; JS</li>
<li>图片 &#x2F; 视频等静态资源</li>
</ul>
</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>静态资源处理能力极强</li>
<li>比后端应用服务器（如 Node &#x2F; Java）更省资源</li>
<li>常用于<strong>前后端分离架构中的静态资源托管</strong></li>
</ul>
<hr>
<p>2️⃣ 反向代理服务器（最常用）</p>
<p><strong>作用说明：</strong></p>
<ul>
<li>浏览器 → Nginx → 后端服务</li>
<li>客户端只感知 Nginx，不直接访问后端</li>
</ul>
<p><strong>典型用途：</strong></p>
<ul>
<li><strong>解决跨域问题</strong></li>
<li>隐藏真实后端地址</li>
<li>统一入口（API Gateway）</li>
<li>请求转发、权限隔离</li>
</ul>
<p><strong>核心原理一句话：</strong></p>
<blockquote>
<p>浏览器与 Nginx 同源，服务器与服务器之间不存在跨域问题。</p>
</blockquote>
<hr>
<p>3️⃣ 负载均衡器（高并发架构核心）</p>
<p><strong>作用说明：</strong></p>
<ul>
<li>将请求分发到多台后端服务器</li>
<li>避免单点瓶颈</li>
</ul>
<p><strong>常见策略：</strong></p>
<ul>
<li>轮询（默认）</li>
<li>权重轮询</li>
<li>IP Hash</li>
<li>最少连接数</li>
</ul>
<p><strong>典型场景：</strong></p>
<ul>
<li>高并发 Web 服务</li>
<li>微服务架构</li>
<li>集群部署</li>
</ul>
<h3 id="面试题11：Web-服务器和应用服务器的区别是什么？"><a href="#面试题11：Web-服务器和应用服务器的区别是什么？" class="headerlink" title="面试题11：Web 服务器和应用服务器的区别是什么？"></a>面试题11：Web 服务器和应用服务器的区别是什么？</h3><p>标准回答模板</p>
<p>Web 服务器和应用服务器的核心区别在于：<br> <strong>Web 服务器主要负责处理 HTTP 请求和静态资源，而应用服务器负责执行业务逻辑并生成动态内容。</strong></p>
<hr>
<p><strong>Web 服务器：</strong></p>
<ul>
<li>主要职责是接收 HTTP 请求、返回静态资源（HTML、CSS、JS、图片等）</li>
<li>也常作为反向代理，将请求转发给后端应用</li>
<li>特点是高并发、低资源消耗</li>
<li>常见的有：Nginx、Apache</li>
</ul>
<p><strong>应用服务器：</strong></p>
<ul>
<li>主要职责是执行业务逻辑，处理动态请求</li>
<li>通常需要访问数据库、缓存等后端资源</li>
<li>返回的是动态生成的数据或页面（如 JSON、HTML）</li>
<li>常见的有：Node.js、Tomcat、Spring Boot、Django 等</li>
</ul>
<hr>
<p><strong>实际项目中通常是两者配合使用：</strong></p>
<ul>
<li>Web 服务器作为统一入口，处理静态资源和请求转发</li>
<li>应用服务器专注于业务逻辑处理</li>
</ul>
<hr>
<p>一句话总结（面试加分）</p>
<blockquote>
<p>Web 服务器负责“接收和转发请求、提供静态资源”，<br> 应用服务器负责“执行业务逻辑、生成动态数据”，<br> 两者分工协作是现代 Web 架构的常见模式。</p>
</blockquote>
<hr>
<p>30 秒极简版</p>
<blockquote>
<p>Web 服务器主要处理 HTTP 和静态资源，比如 Nginx；<br> 应用服务器主要处理业务逻辑和动态请求，比如 Node 或 Java 服务；<br> 实际项目中通常由 Web 服务器作为入口，再将请求交给应用服务器处理。</p>
</blockquote>
<h3 id="面试题12：-手写Nginx和Vue配置代理服务器的代码？"><a href="#面试题12：-手写Nginx和Vue配置代理服务器的代码？" class="headerlink" title="面试题12： 手写Nginx和Vue配置代理服务器的代码？"></a>面试题12： 手写Nginx和Vue配置代理服务器的代码？</h3><p><code>nginx</code></p>
<blockquote>
<p>放到 <code>nginx.conf</code> 的 <code>http &#123;&#125;</code> 里或单独的 <code>conf.d/app.conf</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">server &#123;<br>  listen <span class="hljs-number">80</span>;<br>  server_name localhost;<br><br>  # 反向代理：/api -&gt; 后端<br>  location /api/ &#123;<br>    proxy_pass <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1:8080/;  # 注意结尾的 /</span><br>    proxy_set_header <span class="hljs-title class_">Host</span> $host;<br>    proxy_set_header X-<span class="hljs-title class_">Real</span>-<span class="hljs-variable constant_">IP</span> $remote_addr;<br>    proxy_set_header X-<span class="hljs-title class_">Forwarded</span>-<span class="hljs-title class_">For</span> $proxy_add_x_forwarded_for;<br>    proxy_set_header X-<span class="hljs-title class_">Forwarded</span>-<span class="hljs-title class_">Proto</span> $scheme;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果你希望把 <code>/api</code> 前缀去掉再转发（上面已经是“去掉”的效果），关键就是 <code>location /api/</code> + <code>proxy_pass .../</code> **都带尾部 <code>/</code>**。</p>
</blockquote>
<p><code>vite.config.ts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vite&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://127.0.0.1:8080&quot;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// 如果后端不需要 /api 前缀就打开下面这行</span><br>        <span class="hljs-comment">// rewrite: (path) =&gt; path.replace(/^\/api/, &quot;&quot;),</span><br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><h3 id="面试题1：一次完整的-URL-请求通常会经历哪些步骤？"><a href="#面试题1：一次完整的-URL-请求通常会经历哪些步骤？" class="headerlink" title="面试题1：一次完整的 URL 请求通常会经历哪些步骤？"></a>面试题1：一次完整的 URL 请求通常会经历哪些步骤？</h3><blockquote>
<p>一次完整的 URL 请求通常会经历：<strong>URL 解析 → DNS 解析 → 建立连接（TCP&#x2F;UDP + TLS）→ 发送 HTTP 请求 → 服务端处理并返回 → 浏览器接收与缓存处理 → 解析渲染页面（HTML&#x2F;CSS&#x2F;JS）→ 资源加载与执行 → 首屏呈现与后续交互</strong>。</p>
</blockquote>
<p><strong>1）输入 URL 与浏览器预处理</strong></p>
<ul>
<li><strong>解析 URL</strong>：协议（http&#x2F;https）、域名、端口、路径、query、hash</li>
<li><strong>HSTS&#x2F;升级</strong>：可能把 http 自动升级为 https</li>
<li><strong>查缓存&#x2F;预连接</strong>：浏览器可能命中 <strong>DNS 缓存 &#x2F; 连接池 &#x2F; HTTP 缓存</strong>，命中则跳过部分步骤</li>
</ul>
<p><strong>2）DNS 解析（把域名变成 IP）</strong></p>
<ul>
<li>查询顺序通常是：<strong>浏览器 DNS 缓存 → 系统缓存 → hosts → 本地 DNS → 递归解析（根&#x2F;顶级&#x2F;权威）</strong></li>
<li>结果会有 <strong>TTL</strong>，决定缓存时长</li>
<li>性能优化：<code>dns-prefetch</code>、减少跨域域名数量</li>
</ul>
<p><strong>3）建立连接（传输层 + 安全层）</strong></p>
<p><strong>3.1 TCP（三次握手）</strong>（HTTP&#x2F;1.1、HTTP&#x2F;2 通常跑在 TCP 上）</p>
<ul>
<li>SYN → SYN&#x2F;ACK → ACK</li>
<li>建立后进入连接复用（Keep-Alive）</li>
</ul>
<p><strong>3.2 TLS 握手（HTTPS 才有）</strong></p>
<ul>
<li>证书校验、协商加密套件、生成会话密钥</li>
<li>优化点：TLS1.3、会话复用、OCSP Stapling</li>
</ul>
<blockquote>
<p>补充：HTTP&#x2F;3 基于 **QUIC(UDP)**，把“传输层握手 + TLS”合并加速，减少延迟（面试可加分一句）。</p>
</blockquote>
<p><strong>4）发送 HTTP 请求（应用层）</strong></p>
<ul>
<li>组成：<strong>请求行（method&#x2F;path）+ headers + body</strong></li>
<li>常见行为：<ul>
<li>携带 Cookie &#x2F; Authorization</li>
<li><code>Accept-Encoding</code> 触发 gzip&#x2F;br 压缩</li>
<li>跨域且“非简单请求”会先发 <strong>OPTIONS 预检</strong></li>
</ul>
</li>
</ul>
<p><strong>5）服务端处理与返回响应</strong></p>
<ul>
<li>典型链路：<strong>CDN&#x2F;反向代理(Nginx) → 应用服务器 → DB&#x2F;缓存&#x2F;微服务</strong></li>
<li>返回：<strong>状态码、响应头（缓存&#x2F;类型&#x2F;长度）、响应体</strong></li>
<li>性能指标：TTFB（Time To First Byte）</li>
</ul>
<p><strong>6）浏览器接收响应：缓存与连接管理</strong></p>
<ul>
<li>根据响应头决定缓存策略：<ul>
<li>强缓存：<code>Cache-Control: max-age</code> &#x2F; <code>Expires</code></li>
<li>协商缓存：<code>ETag/If-None-Match</code>、<code>Last-Modified/If-Modified-Since</code></li>
</ul>
</li>
<li><code>304 Not Modified</code> 走协商缓存，减少下载</li>
</ul>
<p><strong>7）解析与渲染（浏览器渲染流水线）</strong></p>
<ul>
<li><strong>解析 HTML → DOM</strong></li>
<li><strong>解析 CSS → CSSOM</strong></li>
<li>DOM + CSSOM → <strong>Render Tree</strong></li>
<li><strong>Layout（回流）→ Paint（绘制）→ Composite（合成）</strong></li>
<li>JS 可能阻塞解析（尤其是同步脚本），并触发重排&#x2F;重绘</li>
</ul>
<p><strong>8）资源加载与执行（并行&#x2F;优先级）</strong></p>
<ul>
<li>遇到 <code>link/script/img</code> 会发起更多请求</li>
<li>HTTP&#x2F;2 多路复用提升并发效率；浏览器也有优先级调度</li>
<li><code>defer/async</code>、<code>preload/prefetch</code> 会影响加载顺序与首屏</li>
</ul>
<p><strong>9）页面可用：首屏、交互、后续请求</strong></p>
<ul>
<li>首屏渲染完成后进入交互期</li>
<li>SPA 场景下：后续路由切换多为 <strong>JS 驱动渲染</strong>，但接口请求仍走同样的网络链路</li>
</ul>
<h3 id="面试题2：DNS解析的步骤是什么？"><a href="#面试题2：DNS解析的步骤是什么？" class="headerlink" title="面试题2：DNS解析的步骤是什么？"></a>面试题2：DNS解析的步骤是什么？</h3><p><strong>步骤：</strong></p>
<ol>
<li><strong>浏览器缓存</strong>：检查是否有未过期的 DNS 记录（TTL）</li>
<li><strong>操作系统缓存 &#x2F; hosts</strong>：本地 DNS Cache 与 hosts 文件</li>
<li><strong>本地 DNS 服务器（递归解析器）</strong>：通常由运营商或企业提供</li>
<li><strong>根域名服务器（.）</strong>：返回对应的顶级域服务器地址</li>
<li><strong>顶级域服务器（TLD，如 .com）</strong>：返回目标域名的权威 DNS 服务器</li>
<li><strong>权威 DNS 服务器</strong>：返回最终解析结果（A &#x2F; AAAA &#x2F; CNAME）</li>
<li><strong>结果缓存并返回</strong>：递归服务器、OS、浏览器按 TTL 缓存，浏览器使用 IP 建立连接</li>
</ol>
<blockquote>
<p>客户端<strong>递归</strong>地把解析任务交给本地 DNS，本地 DNS 再<strong>迭代</strong>地向各级域名服务器查询，最终拿到 IP 并返回。</p>
</blockquote>
<h3 id="面试3：TCP-连接是怎么建立的？"><a href="#面试3：TCP-连接是怎么建立的？" class="headerlink" title="面试3：TCP 连接是怎么建立的？"></a>面试3：<strong>TCP 连接是怎么建立的？</strong></h3><p><strong>口述模板：</strong></p>
<p>TCP 通过<strong>三次握手</strong>建立连接，核心目的有三个：<br> <strong>确认双方收发能力、同步初始序列号、防止历史连接误建立。</strong></p>
<p>第一次，<strong>客户端发送 SYN</strong>，表示我要建立连接，并告诉服务端我的初始序列号；</p>
<p>第二次，<strong>服务端返回 SYN + ACK</strong>，表示我收到了你的请求，同时告诉客户端我的初始序列号；</p>
<p>第三次，<strong>客户端再回一个 ACK</strong>，表示我确认收到了你的确认，至此双方状态一致，连接建立完成。</p>
<h4 id="面试题：三次握手过程中如果报文丢失，会发生什么？"><a href="#面试题：三次握手过程中如果报文丢失，会发生什么？" class="headerlink" title="面试题：三次握手过程中如果报文丢失，会发生什么？"></a>面试题：<strong>三次握手过程中如果报文丢失，会发生什么？</strong></h4><p>TCP 在三次握手过程中，对任意一次报文丢失都设计了<strong>超时重传和状态回退机制</strong>。</p>
<hr>
<p>第一种情况：第一次 SYN 丢失</p>
<p>客户端发送 SYN 后进入 <strong>SYN-SENT 状态</strong>。<br> 如果服务器没有收到该 SYN，就不会返回任何响应。<br> 客户端在超时后会<strong>重传 SYN</strong>，多次失败后连接建立失败。</p>
<hr>
<p>第二种情况：第二次 SYN+ACK 丢失</p>
<p>服务器收到 SYN 后，会返回 <strong>SYN+ACK</strong>，并进入 <strong>SYN-RECEIVED（半连接）状态</strong>。<br> 如果这个 SYN+ACK 丢失：</p>
<ul>
<li>客户端仍处于 SYN-SENT，会<strong>重传 SYN</strong></li>
<li>服务器在半连接状态下，会<strong>重传 SYN+ACK</strong></li>
</ul>
<p>双方不断重试，直到成功完成握手或超时清理半连接。</p>
<hr>
<p>第三种情况：第三次 ACK 丢失</p>
<p>客户端收到 SYN+ACK 后，会立即发送 ACK，并认为连接已建立。<br> 如果这个 ACK 丢失：</p>
<ul>
<li>服务器仍停留在 <strong>SYN-RECEIVED 状态</strong></li>
<li>会再次发送 SYN+ACK</li>
<li>客户端每次收到重复的 SYN+ACK，都会<strong>重新发送 ACK</strong></li>
</ul>
<p>最终服务器收到 ACK，连接建立；否则超时释放半连接。</p>
<hr>
<p>总结收尾（一定要说）</p>
<blockquote>
<p>三次握手的设计可以确保通信双方都具备收发能力，<br> 并同步初始序列号，同时防止服务器因异常或丢包长期处于半连接状态。</p>
</blockquote>
<h4 id="什么不能两次握手？"><a href="#什么不能两次握手？" class="headerlink" title="什么不能两次握手？"></a><strong>什么不能两次握手？</strong></h4><p><strong>口述模板：</strong></p>
<p>如果只有两次握手，服务端无法确认客户端是否真的收到了确认包，<br> 一旦出现<strong>延迟的旧 SYN 报文</strong>，服务端可能会错误地建立连接，造成资源浪费。<br> 第三次握手的作用，就是<strong>确认客户端的接收能力并清理历史请求</strong>。</p>
<h3 id="面试题：为什么-TCP-不能只用两次握手？"><a href="#面试题：为什么-TCP-不能只用两次握手？" class="headerlink" title="面试题：为什么 TCP 不能只用两次握手？"></a>面试题：<strong>为什么 TCP 不能只用两次握手？</strong></h3><p>口述回答模板（清晰版）</p>
<p>TCP 不能只用两次握手，<strong>核心原因是无法避免服务器长期处于半连接状态，从而占用服务器资源</strong>。</p>
<hr>
<p>第一层原因：<strong>无法确认客户端的接收能力</strong></p>
<p>如果只有两次握手：<br> 客户端发送 <strong>SYN</strong>，服务器返回 <strong>SYN + ACK</strong> 后就认为连接建立。</p>
<p>但如果这个 <strong>SYN + ACK 丢失</strong>：</p>
<ul>
<li>服务器已经进入 <strong>半连接状态（SYN-RECEIVED）</strong></li>
<li>客户端由于收不到响应，会判断连接失败</li>
<li>服务器却无法确认客户端是否存在，<strong>只能等待超时</strong></li>
</ul>
<p>第三次握手的 ACK，作用就是<strong>明确告诉服务器：客户端确实收到了你的响应</strong>。</p>
<hr>
<p>第二层原因：<strong>无法防止历史延迟的 SYN 造成错误连接</strong></p>
<p>如果网络中存在<strong>延迟的旧 SYN 报文</strong>：</p>
<ul>
<li>客户端早已放弃该连接</li>
<li>延迟的 SYN 在之后到达服务器</li>
</ul>
<p>在两次握手模型下：</p>
<ul>
<li>服务器会误认为这是一次新的连接请求</li>
<li>从而建立一个<strong>无效的半连接</strong></li>
</ul>
<p>第三次 ACK 可以明确区分：</p>
<ul>
<li>这是一次真实的当前连接</li>
<li>还是一条历史失效请求</li>
</ul>
<hr>
<p>第三层原因（安全层面）：<strong>容易被 SYN Flood 攻击</strong></p>
<p>如果只有两次握手：<br> 攻击者可以持续向服务器发送大量 <strong>SYN 请求</strong>，<br> 但<strong>从不发送最后的确认</strong>。</p>
<p>服务器就会：</p>
<ul>
<li>维持大量半连接</li>
<li>占用 TCP 控制块和内存资源</li>
<li>导致正常用户无法建立连接</li>
</ul>
<p>这类攻击称为 <strong>SYN Flood（半连接攻击）</strong>。</p>
<hr>
<p>总结收尾（一定要说）</p>
<blockquote>
<p>第三次握手的存在，不仅是为了完成连接确认，<br> 更重要的是<strong>防止服务器因异常、延迟或攻击长期处于半连接状态</strong>，<br> 从而保证 TCP 连接的可靠性和安全性。</p>
</blockquote>
<h3 id="面试题：TCP-连接是怎么断开的？"><a href="#面试题：TCP-连接是怎么断开的？" class="headerlink" title="面试题：TCP 连接是怎么断开的？"></a>面试题：<strong>TCP 连接是怎么断开的？</strong></h3><p><strong>口述模板：</strong></p>
<p>TCP 通过<strong>四次挥手</strong>断开连接，<br> 这是因为 TCP 是<strong>全双工协议</strong>，双方的发送方向必须<strong>分别关闭</strong>。</p>
<hr>
<p>第一次挥手：客户端 → 服务器（FIN）</p>
<p>客户端向服务器发送 <strong>FIN 报文</strong>，<br> 表示：<strong>客户端已经没有数据要发送了</strong>，<br> 此时客户端进入 <strong>FIN-WAIT-1 状态</strong>。</p>
<hr>
<p>第二次挥手：服务器 → 客户端（ACK）</p>
<p>服务器收到 FIN 后，返回 <strong>ACK 报文</strong>，<br> 表示：<strong>已确认客户端的关闭请求</strong>。</p>
<p>此时：</p>
<ul>
<li>客户端不再发送数据</li>
<li>但服务器仍然可以向客户端发送数据</li>
<li>连接尚未完全关闭</li>
</ul>
<hr>
<p>第三次挥手：服务器 → 客户端（FIN）</p>
<p>当服务器把<strong>剩余数据全部发送完毕后</strong>，<br> 会向客户端发送 <strong>FIN 报文</strong>，<br> 表示：<strong>服务器也准备关闭发送方向</strong>。</p>
<hr>
<p>第四次挥手：客户端 → 服务器（ACK）</p>
<p>客户端收到服务器的 FIN 后，<br> 返回 <strong>ACK 报文</strong>，<br> 至此，服务器连接关闭，客户端进入 <strong>TIME_WAIT 状态</strong>。</p>
<hr>
<h4 id="为什么断开是四次，而建立是三次？"><a href="#为什么断开是四次，而建立是三次？" class="headerlink" title="为什么断开是四次，而建立是三次？"></a><strong>为什么断开是四次，而建立是三次？</strong></h4><p><strong>口述模板：</strong></p>
<p>建立连接时，服务端可以把 <strong>SYN 和 ACK 合并发送</strong>，是因为<strong>服务器在确认客户端关闭请求时，可能还有数据没有发送完</strong>。</p>
<ul>
<li>第二次的 <strong>ACK</strong>：只是确认客户端“我知道你要关了”</li>
<li>第三次的 <strong>FIN</strong>：是服务器真正关闭自己发送方向的请求</li>
</ul>
<p>这两个动作<strong>在时间上不一定同时发生</strong>，<br> 因此一般不能合并发送。</p>
<h4 id="TIME-WAIT-状态的作用"><a href="#TIME-WAIT-状态的作用" class="headerlink" title="TIME_WAIT 状态的作用"></a>TIME_WAIT 状态的作用</h4><p><strong>口述模板：</strong></p>
<p>客户端在发送最后一个 ACK 后，并不会立刻关闭连接，<br> 而是进入 <strong>TIME_WAIT 状态</strong>，通常持续 <strong>2MSL</strong>。</p>
<p>TIME_WAIT 的作用有两点：</p>
<ol>
<li><strong>确保服务器能够收到最后一个 ACK</strong></li>
<li><strong>防止旧连接的延迟报文影响新连接</strong></li>
</ol>
<p>因此，TIME_WAIT 状态<strong>经常出现在客户端</strong>，<br> 因为<strong>主动关闭连接的一方会进入 TIME_WAIT</strong>。</p>
<h3 id="面试题：TCP-是怎么保证可靠传输的？"><a href="#面试题：TCP-是怎么保证可靠传输的？" class="headerlink" title="面试题：TCP 是怎么保证可靠传输的？"></a>面试题：<strong>TCP 是怎么保证可靠传输的？</strong></h3><p><strong>口述模板：</strong></p>
<p>TCP 通过五个核心机制保证可靠性：<br> <strong>序列号保证顺序、ACK 确认接收、超时重传防止丢包、滑动窗口保证连续传输、<br> 流量控制和拥塞控制防止压垮接收方和网络。</strong></p>
<hr>
<h3 id="面试题：流量控制和拥塞控制有什么区别？"><a href="#面试题：流量控制和拥塞控制有什么区别？" class="headerlink" title="面试题：流量控制和拥塞控制有什么区别？"></a>面试题：<strong>流量控制和拥塞控制有什么区别？</strong></h3><p><strong>口述模板：</strong></p>
<p><strong>流量控制</strong>关注的是<strong>接收方是否接得住</strong>，<br> TCP 通过<strong>接收窗口 rwnd</strong>实现，<br> 接收方在 ACK 中告诉发送方还能接收多少数据，<br> 发送方发送的数据量不能超过 rwnd，<br> 本身<strong>没有复杂算法</strong>，是一个动态窗口调节机制。</p>
<p><strong>拥塞控制</strong>关注的是<strong>网络是否扛得住</strong>，<br> TCP 通过<strong>拥塞窗口 cwnd</strong>控制发送速率，<br> 实际发送窗口大小是 **min(rwnd, cwnd)**，<br> 拥塞控制包含一套完整算法体系。</p>
<p>经典的拥塞控制算法包括：<br> <strong>慢启动</strong>：cwnd 从小开始指数增长；<br> <strong>拥塞避免</strong>：达到阈值后线性增长；<br> <strong>快重传</strong>：收到 3 个重复 ACK 立即重传；<br> <strong>快恢复</strong>：重传后不回慢启动，直接进入拥塞避免。</p>
<h4 id="TCP-拥塞控制完整流程"><a href="#TCP-拥塞控制完整流程" class="headerlink" title="TCP 拥塞控制完整流程"></a>TCP 拥塞控制完整流程</h4><p>1️⃣ 慢启动（Slow Start）</p>
<ul>
<li>连接建立后，<strong>cwnd 从 1 MSS 开始</strong></li>
<li><strong>每收到一个 ACK，cwnd 翻倍增长</strong></li>
<li>目的：<strong>快速探测网络的承载能力</strong></li>
<li>当 <strong>cwnd ≥ ssthresh（慢启动阈值）</strong> → 进入拥塞避免</li>
</ul>
<hr>
<p>2️⃣ 拥塞避免（Congestion Avoidance）</p>
<ul>
<li>cwnd <strong>不再指数增长</strong></li>
<li>改为：<strong>每个 RTT 线性增长 1 MSS</strong></li>
<li>目的：<strong>避免过快增长引发网络拥塞</strong></li>
<li>如果此阶段<strong>发生丢包</strong> → 触发重传机制</li>
</ul>
<hr>
<p>3️⃣ 快重传（Fast Retransmit）</p>
<ul>
<li>如果发送方收到 <strong>3 个重复 ACK</strong></li>
<li>判断：<strong>某个数据包丢失</strong></li>
<li><strong>不等待超时，立即重传丢失报文</strong></li>
<li>同时调整阈值：<ul>
<li><code>ssthresh = 当前 cwnd / 2</code></li>
</ul>
</li>
</ul>
<hr>
<p>4️⃣ 快恢复（Fast Recovery）</p>
<ul>
<li>重传完成后：<ul>
<li><strong>cwnd 直接降到 ssthresh</strong></li>
<li><strong>不回到慢启动</strong></li>
</ul>
</li>
<li>直接进入 <strong>拥塞避免阶段</strong></li>
<li>目的：<strong>快速恢复吞吐量，避免从头开始</strong></li>
</ul>
<hr>
<p>一句话流程总结（强背）</p>
<blockquote>
<p>TCP 先慢启动指数增长，<br> 到阈值后拥塞避免线性增长，<br> 出现丢包触发快重传，<br> 再通过快恢复直接回到拥塞避免。</p>
</blockquote>
<h3 id="面试题：TCP-和-UDP-有什么区别？"><a href="#面试题：TCP-和-UDP-有什么区别？" class="headerlink" title="面试题：TCP 和 UDP 有什么区别？"></a>面试题：TCP 和 UDP 有什么区别？</h3><p>口述模板（紧凑版）</p>
<p>TCP 和 UDP 的核心区别是：<br> <strong>TCP 面向连接、可靠、有序；UDP 无连接、不可靠、无序，但实时性更好。</strong></p>
<p><strong>连接方式</strong>：</p>
<ul>
<li>TCP 需要三次握手、四次挥手</li>
<li>UDP 直接发送，不建立连接</li>
</ul>
<p><strong>可靠性</strong>：</p>
<ul>
<li>TCP 通过序列号、ACK、重传、流量控制和拥塞控制保证可靠</li>
<li>UDP 不确认、不重传、不保证顺序</li>
</ul>
<p><strong>数据形式</strong>：</p>
<ul>
<li>TCP 面向字节流，可能粘包</li>
<li>UDP 面向报文，保留消息边界</li>
</ul>
<p><strong>性能特点</strong>：</p>
<ul>
<li>TCP 延迟较高但稳定</li>
<li>UDP 延迟低、开销小</li>
</ul>
<p><strong>典型场景</strong>：</p>
<ul>
<li>TCP：HTTP&#x2F;HTTPS、文件传输</li>
<li>UDP：音视频、实时通信、DNS</li>
</ul>
<h3 id="面试题：WebSocket-可以代替-UDP-的适用场景吗？"><a href="#面试题：WebSocket-可以代替-UDP-的适用场景吗？" class="headerlink" title="面试题：WebSocket 可以代替 UDP 的适用场景吗？"></a>面试题：<strong>WebSocket 可以代替 UDP 的适用场景吗？</strong></h3><p>口述模板（先给结论）</p>
<p><strong>WebSocket 不能完全代替 UDP 的适用场景，只能覆盖其中一部分。</strong><br> 因为两者的“实时性”来源于<strong>不同的层次</strong>。</p>
<hr>
<p>一、WebSocket 的实时性是什么？</p>
<p><strong>口述模板：</strong></p>
<p>WebSocket 的实时性体现在<strong>应用层</strong>，<br> 它相对于 HTTP 的优势在于：</p>
<ul>
<li>连接是<strong>长连接</strong></li>
<li><strong>服务器可以主动向客户端推送数据</strong></li>
</ul>
<p>但 WebSocket <strong>本质仍然是基于 TCP 的</strong>，<br> 数据依然以 <strong>TCP 报文</strong>传输，<br> 必须满足 TCP 的可靠性机制，包括：</p>
<ul>
<li>流量控制</li>
<li>拥塞控制</li>
<li>超时重传</li>
<li>有序传输</li>
</ul>
<p>因此，WebSocket 的实时性是<br> <strong>“可靠前提下的实时”</strong>。</p>
<hr>
<p>二、UDP 的实时性是什么？</p>
<p><strong>口述模板：</strong></p>
<p>UDP 的实时性体现在<strong>传输层</strong>，<br> 它通过<strong>主动牺牲可靠性</strong>来换取极低延迟。</p>
<p>UDP 的特点是：</p>
<ul>
<li>无连接</li>
<li>不确认</li>
<li>不重传</li>
<li>无流量控制、无拥塞控制</li>
</ul>
<p>数据一发即走，<br> <strong>延迟最低，但可能丢包、乱序</strong>。</p>
<hr>
<p>三、为什么 WebSocket 不能代替 UDP？</p>
<p><strong>口述模板：</strong></p>
<p>由于 WebSocket 运行在 TCP 之上，<br> 必须遵守 TCP 的可靠性和控制机制，<br> 在网络拥塞或丢包时：</p>
<ul>
<li>会等待确认</li>
<li>会触发重传</li>
<li>会降低发送速率</li>
</ul>
<p>这些机制虽然保证了可靠性，<br> 但也决定了 <strong>WebSocket 无法达到 UDP 的超低延迟</strong>。</p>
<hr>
<p>四、各自适用场景（面试官很爱听）</p>
<p><strong>WebSocket 适用场景：</strong></p>
<ul>
<li>即时聊天（IM）</li>
<li>实时通知 &#x2F; 推送</li>
<li>在线协作</li>
<li>实时监控面板<br> 👉 <strong>要求实时，但不能丢消息</strong></li>
</ul>
<p><strong>UDP 适用场景：</strong></p>
<ul>
<li>音视频通话 &#x2F; 直播</li>
<li>实时游戏状态同步</li>
<li>高速传感器数据<br> 👉 <strong>允许丢数据，但不能卡</strong></li>
</ul>
<h3 id="面试题：浏览器缓存有哪些？强缓存和协商缓存有什么区别？"><a href="#面试题：浏览器缓存有哪些？强缓存和协商缓存有什么区别？" class="headerlink" title="面试题：浏览器缓存有哪些？强缓存和协商缓存有什么区别？"></a>面试题：<strong>浏览器缓存有哪些？强缓存和协商缓存有什么区别？</strong></h3><p>口述模板（先给结论）</p>
<p>浏览器缓存主要分为<strong>强缓存</strong>和<strong>协商缓存</strong>。<br> <strong>强缓存优先级最高，其次才是协商缓存。</strong></p>
<hr>
<p>一、强缓存（Strong Cache）</p>
<p><strong>口述模板：</strong></p>
<p>强缓存是指<strong>浏览器直接从本地读取资源</strong>，<br> <strong>不再向服务器发送 HTTP 请求</strong>。</p>
<p>强缓存通过响应头来控制：</p>
<ul>
<li>**<code>Expires</code>**：设置一个绝对过期时间（HTTP&#x2F;1.0）</li>
<li>**<code>Cache-Control: max-age</code>**：设置相对过期时间（HTTP&#x2F;1.1，优先级更高）</li>
</ul>
<p>只要资源在有效期内：</p>
<ul>
<li>浏览器直接使用缓存</li>
<li>状态码通常显示为 <strong>200（from cache）</strong></li>
</ul>
<hr>
<p>二、协商缓存（Conditional Cache）</p>
<p><strong>口述模板：</strong></p>
<p>当强缓存<strong>失效或未命中</strong>时，<br> 浏览器会向服务器发送请求，<br> <strong>询问资源是否发生变化</strong>，这就是协商缓存。</p>
<p>协商缓存依赖的字段主要有：</p>
<ul>
<li><strong><code>Last-Modified / If-Modified-Since</code></strong></li>
<li><strong><code>ETag / If-None-Match</code></strong></li>
</ul>
<p>如果资源<strong>没有发生变化</strong>：</p>
<ul>
<li>服务器返回 <strong>304 Not Modified</strong></li>
<li>浏览器继续使用本地缓存</li>
</ul>
<p>如果资源<strong>发生变化</strong>：</p>
<ul>
<li>服务器返回 <strong>200 + 最新资源</strong></li>
<li>浏览器更新本地缓存</li>
</ul>
<h4 id="浏览器缓存本质是什么？"><a href="#浏览器缓存本质是什么？" class="headerlink" title="浏览器缓存本质是什么？"></a>浏览器缓存本质是什么？</h4><p><strong>口述模板：</strong></p>
<p>浏览器缓存本质上是 <strong>HTTP 缓存机制</strong>，<br> 用于<strong>减少网络请求、提升加载性能</strong>。</p>
<p>它的特点是：</p>
<ul>
<li>缓存的是 <strong>HTTP 请求返回的资源</strong></li>
<li>是否缓存、缓存多久 <strong>由服务器响应头控制</strong></li>
<li><strong>浏览器自动管理</strong>，前端不可精细干预</li>
<li>参与 <strong>强缓存 &#x2F; 协商缓存 &#x2F; 304</strong> 流程</li>
</ul>
<p>所以它是<strong>网络通信过程的一部分</strong>。</p>
<h4 id="点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h4><ul>
<li><strong>点击刷新按钮或者按 F5：</strong>浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>
<li><strong>用户按 Ctrl+F5（强制刷新）：</strong>浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>
<li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>
</ul>
<h3 id="面试题：浏览器的存储方式有哪些？"><a href="#面试题：浏览器的存储方式有哪些？" class="headerlink" title="面试题：浏览器的存储方式有哪些？"></a>面试题：浏览器的存储方式有哪些？</h3><p>从工程视角看，浏览器存储主要分为四类：协议级存储 Cookie、页面级状态存储 Web Storage、本地数据层 IndexedDB，以及网络缓存层 Cache API。</p>
<p>Cookie 是 HTTP 协议级存储机制，主要用于会话保持和身份识别，最大特点是会在满足条件时自动随请求发送给服务器，并支持 HttpOnly、Secure、SameSite 等安全属性，因此非常适合存放 Session ID 等高安全信息，但不适合存储业务数据。</p>
<p>localStorage 和 sessionStorage 属于 Web Storage，用于在前端持久化保存少量状态数据，不参与 HTTP 请求。二者区别在于生命周期：localStorage 是持久化的、同源多标签共享；sessionStorage 只在当前标签页有效。它们都是同步 API，适合存储用户偏好或页面中间态，但不适合高频、大数据或安全敏感信息。</p>
<p>IndexedDB 是浏览器内置的本地数据库，支持异步 API、对象存储、索引和事务，能够存储大规模结构化数据。所有读写操作必须在事务中完成，通过原子提交和自动回滚保证数据一致性，因此 IndexedDB 通常作为前端的数据层，用于离线应用、大数据缓存或实时系统的数据缓冲。</p>
<p>Cache API 是用于缓存 HTTP 请求与响应的存储机制，通常与 Service Worker 配合使用，主要解决静态资源缓存、接口响应缓存、离线访问和首屏性能优化等问题。它缓存的是 Request-Response，而不是业务对象，与 IndexedDB 的职责是明确区分的。</p>
<p>总体来说，浏览器存储并不是相互替代关系，而是协议层、状态层、数据层和网络层各司其职，在实际工程中往往需要组合使用。</p>
<h3 id="面试题：HTTP-不同版本协议的区别？"><a href="#面试题：HTTP-不同版本协议的区别？" class="headerlink" title="面试题：HTTP 不同版本协议的区别？"></a>面试题：HTTP 不同版本协议的区别？</h3><p>口述模板（按时间线）</p>
<p><strong>HTTP&#x2F;1.0</strong></p>
<ul>
<li>短连接，请求完成即断开</li>
<li>每个请求都要重新建 TCP 连接，效率低</li>
</ul>
<p><strong>HTTP&#x2F;1.1</strong></p>
<ul>
<li>支持长连接（Keep-Alive）</li>
<li>支持 Host 头，完善缓存控制</li>
<li>仍然是<strong>串行请求</strong>，存在队头阻塞</li>
</ul>
<p><strong>HTTP&#x2F;2</strong></p>
<ul>
<li>基于 TCP</li>
<li><strong>多路复用</strong>：一个连接并发多个请求</li>
<li>二进制分帧、头部压缩、服务端推送</li>
<li>解决应用层队头阻塞，但仍受 TCP 丢包影响</li>
</ul>
<p><strong>HTTP&#x2F;3</strong></p>
<ul>
<li>基于 <strong>QUIC（UDP）</strong>，不再使用 TCP</li>
<li>每个流独立，<strong>彻底解决队头阻塞</strong></li>
<li>建连更快（0-RTT），支持连接迁移</li>
</ul>
<h3 id="面试题：HTTPS-是什么？它是如何保证安全性的？"><a href="#面试题：HTTPS-是什么？它是如何保证安全性的？" class="headerlink" title="面试题：HTTPS 是什么？它是如何保证安全性的？"></a>面试题：<strong>HTTPS 是什么？它是如何保证安全性的？</strong></h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://cxdlogver.github.io/2025/12/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/9-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/">9.浏览器安全协议 - 相</a></p>
</blockquote>
<p>HTTPS（HyperText Transfer Protocol Secure）是 <strong>HTTP + TLS&#x2F;SSL</strong> 的组合。<br> 它的本质是：<strong>在 HTTP 的基础上，通过 TLS 协议为通信提供安全保障</strong>，确保浏览器与服务器之间的数据传输是安全的。</p>
<p>HTTPS 主要解决三个问题：</p>
<ul>
<li><strong>数据是否被窃听</strong></li>
<li><strong>数据是否被篡改</strong></li>
<li><strong>服务器身份是否可信</strong></li>
</ul>
<blockquote>
<p>HTTPS 通过非对称加密完成身份认证和密钥协商，再使用对称加密进行高效的数据传输，并结合完整性校验，保证通信过程不被窃听和篡改。</p>
</blockquote>
<p>HTTPS 本质上是 <strong>HTTP + TLS 协议</strong>，它的核心作用是 <strong>在不安全的网络环境中，保证浏览器与服务器之间通信的安全性</strong>，主要解决三类问题：<strong>数据是否被窃听、是否被篡改、以及服务器身份是否可信</strong>。</p>
<p>首先，HTTP 本身是明文传输的，如果只做数据完整性校验，比如使用哈希函数，中间人依然可以截获请求、修改内容、重新计算摘要，再转发给服务器，这样完整性校验仍然可以通过，所以 <strong>单纯依赖哈希并不能保证安全</strong>。</p>
<p>因此 HTTPS 的第二层是 <strong>对数据进行加密传输</strong>。在实际通信过程中，HTTPS 使用的是 <strong>对称加密算法</strong>。对称加密的特点是通信双方使用同一把密钥进行加解密，性能高、速度快，适合 HTTP 这种高频、持续的数据传输场景。</p>
<p>但对称加密存在一个核心问题：<strong>通信双方必须先安全地协商出这把对称密钥</strong>，而密钥协商本身又需要通过网络进行，这时网络仍然是不安全的。</p>
<p>为了解决这个问题，HTTPS 引入了 <strong>非对称加密机制</strong>。非对称加密有一对密钥：公钥和私钥。公钥是公开的，私钥只由服务器持有。客户端可以使用服务器的公钥加密数据，只有持有私钥的服务器才能解密，这样可以保证密钥协商过程不被中间人破解。</p>
<p>在这个过程中，服务器会通过 <strong>数字证书</strong> 将自己的公钥发送给客户端。客户端会对证书进行校验，以确认服务器身份的真实性，从而防止中间人伪造服务器。</p>
<p><strong>整个流程包括：</strong></p>
<p><strong>客户端发起请求</strong></p>
<ul>
<li>发送支持的加密算法</li>
<li>发送一个随机数</li>
</ul>
<p><strong>服务器响应</strong></p>
<ul>
<li>返回服务器随机数</li>
<li>返回服务器公钥</li>
<li>返回服务器证书</li>
</ul>
<p><strong>客户端校验证书</strong></p>
<ul>
<li>确认服务器身份可信</li>
</ul>
<p><strong>生成会话密钥</strong></p>
<ul>
<li>双方基于随机数 + 协商结果</li>
<li>得到同一把对称密钥</li>
</ul>
<p><strong>最终确认</strong></p>
<ul>
<li>双方发送加密校验消息</li>
<li>确认握手未被篡改</li>
</ul>
<p><strong>正式通信</strong></p>
<ul>
<li>使用对称加密 + 完整性校验</li>
<li>保证安全传输</li>
</ul>
<h4 id="一、为什么不用非对称加密直接加密所有数据？"><a href="#一、为什么不用非对称加密直接加密所有数据？" class="headerlink" title="一、为什么不用非对称加密直接加密所有数据？"></a>一、为什么不用非对称加密直接加密所有数据？</h4><p><strong>结论一句话：</strong><br> 因为<strong>非对称加密性能开销太大，不适合用于大量、持续的数据传输</strong>。</p>
<p><strong>展开说明：</strong></p>
<ol>
<li>非对称加密（如 RSA）计算复杂<ul>
<li>涉及大整数运算</li>
<li>加解密速度远慢于对称加密</li>
</ul>
</li>
<li>HTTP 通信是高频、连续的数据流<ul>
<li>一个页面可能包含大量请求和响应</li>
<li>如果全部用非对称加密，会严重影响性能和延迟</li>
</ul>
</li>
</ol>
<hr>
<h4 id="二、证书为什么能够解决身份认证问题？"><a href="#二、证书为什么能够解决身份认证问题？" class="headerlink" title="二、证书为什么能够解决身份认证问题？"></a>二、证书为什么能够解决身份认证问题？</h4><p><strong>结论一句话：</strong><br> 因为<strong>数字证书通过可信第三方（CA）对服务器公钥进行背书，防止公钥被伪造</strong>。</p>
<p><strong>展开说明：</strong></p>
<ol>
<li>服务器自己声明“这是我的公钥”是不可信的<ul>
<li>中间人也可以伪造一对公私钥</li>
<li>客户端无法判断公钥属于谁</li>
</ul>
</li>
<li>数字证书由 CA 机构签发<ul>
<li>CA 会校验服务器身份</li>
<li>再用 CA 的私钥对服务器公钥进行签名</li>
</ul>
</li>
<li>客户端内置了可信 CA 的公钥<ul>
<li>可以验证证书签名是否合法</li>
<li>从而确认：<ul>
<li>公钥未被篡改</li>
<li>公钥确实属于目标服务器</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>结论强化：</strong><br> 证书解决的是 <strong>“这个公钥到底是不是这个服务器的”</strong> 问题。</p>
<hr>
<h4 id="三、TLS-握手中的随机数是干什么的？"><a href="#三、TLS-握手中的随机数是干什么的？" class="headerlink" title="三、TLS 握手中的随机数是干什么的？"></a>三、TLS 握手中的随机数是干什么的？</h4><p><strong>结论一句话：</strong><br> 随机数用于 <strong>保证每一次 HTTPS 会话生成的密钥都是唯一的，防止重放和密钥复用攻击</strong>。</p>
<p><strong>展开说明：</strong></p>
<ol>
<li>TLS 握手过程中<ul>
<li>客户端和服务器都会各自生成随机数</li>
<li>这些随机数参与会话密钥的生成</li>
</ul>
</li>
<li>即使使用相同的证书和算法<ul>
<li>不同随机数会生成不同的会话密钥</li>
<li>保证每次连接的独立性</li>
</ul>
</li>
<li>安全意义在于：<ul>
<li>防止攻击者复用历史密钥</li>
<li>防止重放旧的加密通信内容</li>
</ul>
</li>
</ol>
<h3 id="面试题：常见网络攻击类型有哪些？"><a href="#面试题：常见网络攻击类型有哪些？" class="headerlink" title="面试题：常见网络攻击类型有哪些？"></a>面试题：常见网络攻击类型有哪些？</h3><p>1️⃣ 中间人攻击（Man-in-the-Middle, MITM）</p>
<p><strong>核心特征：</strong><br> 攻击者同时与客户端和服务器通信，双方都以为在“直连”。</p>
<p><strong>常见形式：</strong></p>
<ul>
<li>HTTP 明文劫持</li>
<li>伪造 HTTPS 证书</li>
<li>Wi-Fi 钓鱼热点</li>
</ul>
<p><strong>危害：</strong></p>
<ul>
<li>窃听数据</li>
<li>篡改请求和响应</li>
<li>注入恶意内容</li>
</ul>
<p><strong>HTTPS 主要就是为了解决这一类问题。</strong></p>
<hr>
<p>2️⃣ 重放攻击（Replay Attack）</p>
<p><strong>攻击方式：</strong></p>
<ul>
<li>攻击者截获一段合法请求</li>
<li>在之后的时间重复发送该请求</li>
</ul>
<p><strong>典型场景：</strong></p>
<ul>
<li>重复提交转账请求</li>
<li>重复使用已认证的数据包</li>
</ul>
<p><strong>防御方式：</strong></p>
<ul>
<li>使用随机数（nonce）</li>
<li>使用时间戳</li>
<li>会话级密钥</li>
</ul>
<hr>
<p>3️⃣ 窃听攻击（Eavesdropping）</p>
<p><strong>攻击方式：</strong></p>
<ul>
<li>被动监听网络流量</li>
<li>不修改数据，只读取内容</li>
</ul>
<p><strong>常见于：</strong></p>
<ul>
<li>HTTP 明文通信</li>
<li>公共 Wi-Fi</li>
</ul>
<p><strong>防御方式：</strong></p>
<ul>
<li>加密通信（HTTPS、TLS）</li>
</ul>
<hr>
<p>4️⃣ 数据篡改攻击（Tampering）</p>
<p><strong>攻击方式：</strong></p>
<ul>
<li>修改请求参数</li>
<li>修改响应内容</li>
<li>注入恶意脚本或错误数据</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>如果没有完整性校验，很难发现</li>
</ul>
<p><strong>防御方式：</strong></p>
<ul>
<li>MAC &#x2F; HMAC</li>
<li>TLS 完整性校验</li>
</ul>
<hr>
<p>5️⃣ 身份冒充攻击（Spoofing）</p>
<p><strong>常见类型：</strong></p>
<ul>
<li>IP 欺骗</li>
<li>DNS 欺骗</li>
<li>ARP 欺骗</li>
<li>服务器冒充</li>
</ul>
<p><strong>典型例子：</strong></p>
<ul>
<li>DNS 被污染，访问到假网站</li>
<li>返回伪造服务器证书</li>
</ul>
<p><strong>防御方式：</strong></p>
<ul>
<li>数字证书</li>
<li>CA 验证</li>
<li>DNSSEC（部分场景）</li>
</ul>
<hr>
<p>6️⃣ 会话劫持（Session Hijacking）</p>
<p><strong>攻击方式：</strong></p>
<ul>
<li>窃取 Cookie &#x2F; Session ID</li>
<li>冒充合法用户继续访问</li>
</ul>
<p><strong>常见原因：</strong></p>
<ul>
<li>Cookie 明文传输</li>
<li>XSS 注入</li>
<li>Session 固定攻击</li>
</ul>
<p><strong>防御方式：</strong></p>
<ul>
<li>HTTPS</li>
<li>HttpOnly &#x2F; Secure Cookie</li>
<li>Session 失效机制</li>
</ul>
<hr>
<p>7️⃣ 拒绝服务攻击（DoS &#x2F; DDoS）</p>
<p><strong>攻击目标：</strong></p>
<ul>
<li>让服务器无法正常提供服务</li>
</ul>
<p><strong>常见形式：</strong></p>
<ul>
<li>SYN Flood</li>
<li>HTTP Flood</li>
<li>分布式流量攻击（DDoS）</li>
</ul>
<p><strong>防御方式：</strong></p>
<ul>
<li>流量清洗</li>
<li>限流</li>
<li>CDN</li>
</ul>
<h2 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h2><h3 id="面试题：浏览器是如何渲染页面的？（完整流程题）"><a href="#面试题：浏览器是如何渲染页面的？（完整流程题）" class="headerlink" title="面试题：浏览器是如何渲染页面的？（完整流程题）"></a>面试题：浏览器是如何渲染页面的？（完整流程题）</h3><p><strong>口述模板：</strong></p>
<p>浏览器渲染页面可以拆成五个阶段：<br> 解析 HTML 构建 DOM 树，解析 CSS 构建 CSSOM 树，将 DOM 和 CSSOM 合并生成 Render Tree，然后进行 Layout 计算元素的几何信息，最后通过 Paint 将像素绘制到屏幕。</p>
<p>在这个过程中，HTML 解析、CSS 下载是并行的，但 Render Tree 的生成必须等待 DOM 和 CSSOM 都准备完成，这也是 CSS 会影响首屏渲染速度的根本原因。</p>
<hr>
<h3 id="面试题：HTML、CSS、JS-在渲染过程中是如何相互影响的？"><a href="#面试题：HTML、CSS、JS-在渲染过程中是如何相互影响的？" class="headerlink" title="面试题：HTML、CSS、JS 在渲染过程中是如何相互影响的？"></a>面试题：HTML、CSS、JS 在渲染过程中是如何相互影响的？</h3><p><strong>口述模板：</strong></p>
<p>HTML 负责结构，CSS 负责样式，JS 负责行为。<br> HTML 解析过程中可以并行下载 CSS，但 CSS 未解析完成之前，浏览器无法确定元素最终样式，因此会阻塞渲染。</p>
<p>而 JavaScript 因为可能读取或修改 DOM 和 CSSOM，一旦执行就必须保证它看到的是一致的结构和样式，因此默认情况下 JS 会阻塞 HTML 解析和渲染。</p>
<hr>
<h3 id="面试题：async-和-defer-在浏览器层面的本质区别是什么？"><a href="#面试题：async-和-defer-在浏览器层面的本质区别是什么？" class="headerlink" title="面试题：async 和 defer 在浏览器层面的本质区别是什么？"></a>面试题：async 和 defer 在浏览器层面的本质区别是什么？</h3><p><strong>口述模板：</strong></p>
<p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p>
<ul>
<li>执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li>
<li>脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li>
</ul>
<hr>
<h3 id="面试题：CSS-为什么会阻塞-JS-执行？（高级追问）"><a href="#面试题：CSS-为什么会阻塞-JS-执行？（高级追问）" class="headerlink" title="面试题：CSS 为什么会阻塞 JS 执行？（高级追问）"></a>面试题：CSS 为什么会阻塞 JS 执行？（高级追问）</h3><p><strong>口述模板：</strong></p>
<p>如果 JavaScript 中访问了样式相关的 API，比如 <code>getComputedStyle</code>，而 CSSOM 尚未构建完成，浏览器就无法返回正确结果。因此在某些场景下，浏览器会等 CSS 加载和解析完成后再执行 JS，从而保证样式计算的准确性。</p>
<p>这也是为什么把 CSS 放在 head，把 JS 放在 body 底部有利于性能。</p>
<hr>
<h3 id="面试题：DOMContentLoaded-和-load-在渲染流程中的真实含义？"><a href="#面试题：DOMContentLoaded-和-load-在渲染流程中的真实含义？" class="headerlink" title="面试题：DOMContentLoaded 和 load 在渲染流程中的真实含义？"></a>面试题：DOMContentLoaded 和 load 在渲染流程中的真实含义？</h3><p><strong>口述模板：</strong></p>
<p>DOMContentLoaded 表示 HTML 解析完成、DOM 树构建完成，此时可以安全操作 DOM，但不保证图片、字体等资源加载完成。</p>
<p>load 事件则表示页面依赖的所有资源全部加载完成，包括图片、样式、脚本和 iframe，此时页面进入完全可交互状态。</p>
<p>从用户体验角度看，DOMContentLoaded 更接近“页面可用”，而 load 更接近“页面完全加载完成”。</p>
<hr>
<h3 id="面试题：回流（Layout）和重绘（Paint）在渲染中的角色？"><a href="#面试题：回流（Layout）和重绘（Paint）在渲染中的角色？" class="headerlink" title="面试题：回流（Layout）和重绘（Paint）在渲染中的角色？"></a>面试题：回流（Layout）和重绘（Paint）在渲染中的角色？</h3><p><strong>口述模板：</strong></p>
<p>Layout 负责计算元素的几何信息，比如位置和大小；Paint 负责将这些信息转化为像素绘制到屏幕。</p>
<p>修改元素的尺寸、位置、字体大小等会触发回流，而只修改颜色、背景等不影响布局的属性通常只会触发重绘。回流的性能开销远大于重绘，因此在实际开发中需要尽量减少回流次数。</p>
<hr>
<h3 id="面试题：为什么说“减少-DOM-操作可以提升性能”？"><a href="#面试题：为什么说“减少-DOM-操作可以提升性能”？" class="headerlink" title="面试题：为什么说“减少 DOM 操作可以提升性能”？"></a>面试题：为什么说“减少 DOM 操作可以提升性能”？</h3><p><strong>口述模板：</strong></p>
<p>DOM 的任何修改都有可能触发样式重新计算、回流和重绘，尤其是在频繁操作 DOM 时，会导致渲染流水线被反复打断。</p>
<p>因此常见的优化手段包括：<br> 批量修改 DOM、使用文档片段、避免在循环中频繁读取布局信息，以及通过 CSS 动画代替 JS 驱动的动画。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cuggz/feplus/fy7hl8#V6pcu">进程与线程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cuggz/interview/browser#e5da94c4ea214cc0b8f68f36354cfc1b">前端面试题之浏览器原理篇</a></p>
</blockquote>
<h3 id="面试题：什么是进程和线程？"><a href="#面试题：什么是进程和线程？" class="headerlink" title="面试题：什么是进程和线程？"></a>面试题：什么是进程和线程？</h3><p>进程是操作系统进行<strong>资源分配的最小单位</strong>，每个进程都有独立的地址空间、内存、文件描述符等资源。<br> 线程是操作系统进行<strong>CPU 调度的最小单位</strong>，线程必须依附于进程存在，一个进程可以包含多个线程。<br> 同一进程内的线程<strong>共享进程资源</strong>，但各自拥有独立的执行栈和程序计数器，因此线程切换成本比进程更低。</p>
<p><strong>进程和线程的区别可以从三个层面理解：</strong></p>
<p>第一，<strong>本质不同</strong>。<br> 进程是一个正在运行的程序实例，是资源的拥有者；<br> 线程是进程中的执行单元，负责具体的代码执行。</p>
<p>第二，<strong>资源隔离程度不同</strong>。<br> 进程之间资源相互隔离，通信需要通过 IPC；<br> 同一进程内的线程共享内存、全局变量、文件句柄，因此通信成本低，但安全性更弱。</p>
<p>第三，<strong>调度与性能不同</strong>。<br> 线程是 CPU 调度的基本单位，线程切换只涉及寄存器和栈，开销小；<br> 进程切换需要切换地址空间，开销更大，但稳定性和安全性更好。</p>
<p>一句话总结：<br> <strong>进程负责“隔离和资源”，线程负责“并发和执行”。</strong></p>
<hr>
<h3 id="面试题：浏览器的进程有哪些？"><a href="#面试题：浏览器的进程有哪些？" class="headerlink" title="面试题：浏览器的进程有哪些？"></a>面试题：浏览器的进程有哪些？</h3><ul>
<li>1 个浏览器主进程</li>
<li>1 个 GPU 进程</li>
<li>1 个网络进程</li>
<li>多个渲染进程</li>
<li>多个插件进程</li>
</ul>
<p>这些进程的功能：</p>
<ul>
<li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>
<ul>
<li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>
<li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li>
</ul>
<h3 id="面试题：浏览器为什么要多进程"><a href="#面试题：浏览器为什么要多进程" class="headerlink" title="面试题：浏览器为什么要多进程"></a>面试题：<strong>浏览器为什么要多进程</strong></h3><p>浏览器采用多进程架构，主要是为了解决 <strong>稳定性、安全性和性能</strong> 三个问题。<br> 单进程模型下，一个页面崩溃会导致整个浏览器崩溃，而且 JS 阻塞会卡死 UI。<br> 多进程通过把不同页面和功能拆分到独立进程中，实现 <strong>页面隔离、崩溃隔离和安全沙箱</strong>，同时提升多核 CPU 的利用率。</p>
<p>浏览器之所以使用多进程，核心原因有三点：</p>
<p>第一，<strong>稳定性</strong>。<br> 一个渲染进程崩溃，只会影响当前标签页，不会导致整个浏览器退出。</p>
<p>第二，<strong>安全性</strong>。<br> 不同页面运行在不同进程中，配合沙箱机制，可以防止恶意脚本跨站点窃取数据。</p>
<p>第三，<strong>性能与并行能力</strong>。<br> 多进程可以充分利用多核 CPU，让多个页面同时渲染、执行 JS 和发起网络请求。</p>
<p>一句话总结：<br> <strong>多进程是浏览器在复杂网页场景下，实现高并发、高安全、高稳定的基础架构选择。</strong></p>
<hr>
<h3 id="面试题：渲染进程里有哪些线程"><a href="#面试题：渲染进程里有哪些线程" class="headerlink" title="面试题：渲染进程里有哪些线程"></a>面试题：<strong>渲染进程里有哪些线程</strong></h3><p>渲染进程内部是多线程结构，主要包括：</p>
<ol>
<li><strong>GUI 渲染线程</strong>：负责 DOM、CSSOM、布局和绘制</li>
<li><strong>JS 引擎线程</strong>：负责执行 JavaScript</li>
<li><strong>事件触发线程</strong>：管理事件循环</li>
<li><strong>定时器线程</strong>：处理 setTimeout、setInterval</li>
<li><strong>异步网络线程</strong>：处理 fetch、XHR 回调</li>
</ol>
<p>其中 <strong>GUI 渲染线程和 JS 引擎线程互斥执行</strong>。</p>
<p>渲染进程内部最核心的是两条线程：</p>
<p>第一，<strong>GUI 渲染线程</strong><br> 负责解析 HTML 和 CSS，生成 DOM 树、CSSOM，完成布局和绘制。</p>
<p>第二，<strong>JS 引擎线程</strong><br> 负责执行 JavaScript 代码，比如事件回调、同步脚本逻辑。</p>
<p>为了保证页面状态一致性，这两个线程 <strong>不能同时执行</strong>，<br> 所以当 JS 执行时间过长时，会阻塞页面渲染，导致卡顿。</p>
<p>除此之外，还有：</p>
<ul>
<li>事件触发线程：维护事件队列</li>
<li>定时器线程：管理时间到期的回调</li>
<li>网络线程：处理异步请求结果</li>
</ul>
<p>一句话总结：<br> <strong>渲染进程是“多线程协作”，但 JS 与渲染是互斥的。</strong></p>
<h3 id="面试题：一次页面打开涉及哪些进程"><a href="#面试题：一次页面打开涉及哪些进程" class="headerlink" title="面试题：一次页面打开涉及哪些进程"></a>面试题：<strong>一次页面打开涉及哪些进程</strong></h3><p>一次页面打开，主要涉及：</p>
<ol>
<li><strong>浏览器主进程</strong>：处理地址栏输入，创建渲染进程</li>
<li><strong>网络进程</strong>：发起 HTTP 请求，下载 HTML 和资源</li>
<li><strong>渲染进程</strong>：解析 HTML&#x2F;CSS，执行 JS，渲染页面</li>
<li><strong>GPU 进程</strong>：负责页面合成和图形加速（如果需要）</li>
</ol>
<p>完整流程可以分为四步：</p>
<p>第一步，用户输入 URL，<strong>浏览器主进程</strong> 进行导航决策，判断是否新建渲染进程。</p>
<p>第二步，<strong>网络进程</strong> 发起请求，获取 HTML 文档和相关资源。</p>
<p>第三步，HTML 返回后，<strong>渲染进程</strong> 开始解析 HTML、CSS，构建 DOM 树，执行 JS，并进行页面布局和绘制。</p>
<p>第四步，如果涉及动画、3D、Canvas 等，<strong>GPU 进程</strong> 参与页面合成，提高渲染性能。</p>
<p>一句话总结：<br> <strong>主进程负责调度，网络进程负责请求，渲染进程负责页面，GPU 进程负责加速。</strong></p>
<h3 id="面试题：进程之间的通信有哪些？"><a href="#面试题：进程之间的通信有哪些？" class="headerlink" title="面试题：进程之间的通信有哪些？"></a>面试题：进程之间的通信有哪些？</h3><p><strong>进程之间通信，本质是解决两个问题：</strong></p>
<p>第一，<strong>如何把数据从一个进程传给另一个进程</strong>；<br> 第二，<strong>如何在相互隔离的地址空间中保证数据安全和同步</strong>。</p>
<p>因此操作系统提供了多种 IPC 机制，比如 <strong>管道、消息队列、共享内存、信号、Socket</strong>。<br> 其中共享内存效率最高，但需要自己做同步；<br> Socket 最通用，既能进程通信，也能跨机器通信。</p>
<p>进程之间之所以需要通信，是因为 <strong>进程拥有独立的地址空间，不能直接读写彼此内存</strong>。<br> IPC 的核心思想可以总结为三类：</p>
<p>第一类，<strong>基于内核中转的通信</strong><br> 比如管道、消息队列。<br> 数据需要先从进程 A 拷贝到内核，再拷贝到进程 B，安全但性能一般。</p>
<p>第二类，<strong>基于共享内存的通信</strong><br> 多个进程映射同一块物理内存，读写效率最高。<br> 但操作系统只负责“共享”，<strong>不负责同步</strong>，需要配合信号量或互斥锁。</p>
<p>第三类，<strong>基于网络抽象的通信</strong><br> 比如 Socket，把本地进程通信抽象成网络通信模型，通用性最强。</p>
<p>一句话总结：<br> <strong>IPC 的本质是在“隔离”和“共享”之间做权衡。</strong></p>
<p><strong>常见 IPC 方式速记版</strong></p>
<ol>
<li>管道（Pipe）</li>
</ol>
<ul>
<li>半双工</li>
<li>主要用于父子进程</li>
<li>简单，但不适合大量数据</li>
</ul>
<ol start="2">
<li>消息队列</li>
</ol>
<ul>
<li>按消息发送</li>
<li>解耦发送方和接收方</li>
<li>有格式，但性能一般</li>
</ul>
<ol start="3">
<li>共享内存</li>
</ol>
<ul>
<li>速度最快</li>
<li>多进程直接访问同一块内存</li>
<li><strong>必须自己处理并发安全</strong></li>
</ul>
<ol start="4">
<li>信号 &#x2F; 信号量</li>
</ol>
<ul>
<li>信号：通知事件发生</li>
<li>信号量：控制并发访问</li>
<li>常用于同步，而不是大量数据传输</li>
</ul>
<ol start="5">
<li>Socket</li>
</ol>
<ul>
<li>最通用</li>
<li>可本地、可远程</li>
<li>Web 服务、浏览器进程通信常用</li>
</ul>
<p><strong>浏览器多进程之间如何通信？</strong></p>
<p>浏览器通常采用 <strong>基于消息的 IPC</strong>：</p>
<ul>
<li>主进程 ↔ 渲染进程</li>
<li>通过序列化消息进行通信</li>
<li>避免直接共享内存，提升安全性</li>
</ul>
<p>把请求和数据序列化成消息，由主进程、网络进程等统一处理，从而保证安全性和稳定性。</p>
<p>例如：<br> 用户点击页面 → 渲染进程发送事件消息 → 主进程处理 → 返回结果。</p>
<p>网页里写了：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">&#x27;/api/data&#x27;</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>你以为是 JS 在发请求？不是。</p>
<p>真实流程是：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">JS（渲染进程）<br> → 发消息：我要请求这个 <span class="hljs-built_in">URL</span><br> → 网络进程真的去请求<br> → 再把结果“传纸条”回来<br></code></pre></td></tr></table></figure>

<h3 id="面试题：产生死锁的原因和预防方法？"><a href="#面试题：产生死锁的原因和预防方法？" class="headerlink" title="面试题：产生死锁的原因和预防方法？"></a>面试题：产生死锁的原因和预防方法？</h3><p><strong>产生死锁的原因：</strong></p>
<p><strong>（1）竞争资源</strong></p>
<ul>
<li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li>
<li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li>
</ul>
<p><strong>（2）进程间推进顺序非法</strong></p>
<p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li>
</ul>
<p><strong>预防死锁的方法：</strong></p>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="面试题：CDN-和-Service-worker是什么？"><a href="#面试题：CDN-和-Service-worker是什么？" class="headerlink" title="面试题：CDN 和 Service worker是什么？"></a>面试题：CDN 和 Service worker是什么？</h3><p>一、CDN 的介绍（面试模板）</p>
<p><strong>CDN（内容分发网络）</strong> 是通过在全球各地部署边缘节点，把静态资源缓存到离用户最近的节点，从而减少网络延迟、减轻源站压力、提升访问速度。<br> 用户请求资源时，优先从就近节点命中缓存，只有未命中时才回源站。</p>
<hr>
<p>CDN 的核心思想是 <strong>“空间换时间”</strong>。</p>
<p>当用户访问资源时：</p>
<ol>
<li>请求首先到达 CDN 节点</li>
<li>如果节点有缓存，直接返回（命中）</li>
<li>如果没有缓存，向源站请求资源并缓存下来（回源）</li>
</ol>
<p>CDN 主要解决三类问题：</p>
<ul>
<li><strong>访问速度慢</strong>（就近访问）</li>
<li><strong>源站压力大</strong>（请求被分流）</li>
<li><strong>高并发不稳定</strong>（节点分担流量）</li>
</ul>
<p>一句话总结：<br> <strong>CDN 是网络层面的缓存和加速方案。</strong></p>
<p><strong>CDN 通常缓存什么？</strong></p>
<ul>
<li>JS &#x2F; CSS &#x2F; 图片 &#x2F; 视频</li>
<li>部分可缓存的接口响应（配合缓存策略）</li>
</ul>
<p><strong>CDN 是否一定比源站快？</strong><br> 不一定，首次请求或缓存未命中时仍需回源。</p>
<hr>
<p>二、Service Worker 的介绍（面试模板）</p>
<p><strong>Service Worker 是运行在浏览器中的独立脚本线程</strong>，位于页面和网络之间，可以拦截网络请求，实现资源缓存、离线访问和请求控制，是 PWA 的核心能力之一。</p>
<p>Service Worker 的本质是一个 <strong>浏览器侧的网络代理</strong>。</p>
<p>它的特点包括：</p>
<ul>
<li>不运行在主线程，不阻塞页面渲染</li>
<li>可以拦截 <code>fetch</code> 请求</li>
<li>可以把请求结果缓存到 Cache Storage</li>
<li>在离线或弱网环境下返回缓存内容</li>
</ul>
<p>典型工作流程是：</p>
<ol>
<li>页面注册 Service Worker</li>
<li>Service Worker 安装并激活</li>
<li>拦截请求，决定 <strong>走网络 &#x2F; 走缓存 &#x2F; 组合返回</strong></li>
</ol>
<p>一句话总结：<br> <strong>Service Worker 是客户端层面的缓存和请求控制机制。</strong></p>
<p><strong>Service Worker 能缓存接口请求吗？</strong><br> 可以，只要是 <code>fetch</code> 请求，都可以被拦截并缓存。</p>
<p><strong>Service Worker 和 HTTP 缓存的关系？</strong><br> Service Worker 的优先级更高，可以完全绕过 HTTP 缓存规则。</p>
<hr>
<p>CDN 和 Service Worker 都能提升访问速度，但<strong>层级不同、职责不同</strong>：</p>
<ul>
<li>CDN 工作在 <strong>网络侧 &#x2F; 服务器侧</strong></li>
<li>Service Worker 工作在 <strong>浏览器侧 &#x2F; 客户端</strong></li>
</ul>
<p>CDN 解决的是 <strong>“资源怎么更快送到用户”</strong>，<br> Service Worker 解决的是 <strong>“浏览器怎么更聪明地用资源”</strong>。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>CDN</th>
<th>Service Worker</th>
</tr>
</thead>
<tbody><tr>
<td>工作位置</td>
<td>网络边缘节点</td>
<td>浏览器内部</td>
</tr>
<tr>
<td>是否依赖浏览器</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>是否支持离线</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>控制粒度</td>
<td>粗（文件级）</td>
<td>细（请求级）</td>
</tr>
<tr>
<td>典型用途</td>
<td>静态资源加速</td>
<td>离线、缓存策略</td>
</tr>
</tbody></table>
<blockquote>
<p>实际项目中，通常 <strong>CDN + Service Worker 结合使用</strong>：<br> CDN 负责首次访问和大规模分发，<br> Service Worker 负责二次访问、离线体验和弱网优化。</p>
</blockquote>
<h3 id="面试题：HTTP-状态码概念"><a href="#面试题：HTTP-状态码概念" class="headerlink" title="面试题：HTTP 状态码概念"></a>面试题：HTTP 状态码概念</h3><p>HTTP 状态码用于表示服务器对请求的处理结果，按首位数字分为五类。</p>
<hr>
<p>状态码分类</p>
<ul>
<li><strong>1xx</strong>：信息（处理中）</li>
<li><strong>2xx</strong>：成功</li>
<li><strong>3xx</strong>：重定向</li>
<li><strong>4xx</strong>：客户端错误</li>
<li><strong>5xx</strong>：服务器错误</li>
</ul>
<hr>
<p>高频状态码（必背）</p>
<p><strong>2xx</strong></p>
<ul>
<li><strong>200 OK</strong>：请求成功</li>
<li><strong>201 Created</strong>：资源创建成功</li>
<li><strong>204 No Content</strong>：成功但无返回体</li>
</ul>
<p><strong>3xx</strong></p>
<ul>
<li><strong>301 Moved Permanently</strong>：永久重定向（可缓存）</li>
<li><strong>302 Found</strong>：临时重定向</li>
<li><strong>304 Not Modified</strong>：资源未修改，使用缓存</li>
</ul>
<p><strong>4xx</strong></p>
<ul>
<li><strong>400 Bad Request</strong>：请求参数或格式错误</li>
<li><strong>401 Unauthorized</strong>：未认证（未登录 &#x2F; token 失效）</li>
<li><strong>403 Forbidden</strong>：已认证但无权限</li>
<li><strong>404 Not Found</strong>：资源不存在</li>
</ul>
<p><strong>5xx</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong>：服务器内部错误</li>
<li><strong>502 Bad Gateway</strong>：网关收到无效上游响应</li>
<li><strong>503 Service Unavailable</strong>：服务不可用（过载 &#x2F; 维护）</li>
<li><strong>504 Gateway Timeout</strong>：网关请求上游超时</li>
</ul>
<hr>
<p>面试一句话总结</p>
<blockquote>
<p><strong>2xx 成功，3xx 跳转，4xx 客户端错，5xx 服务端错；401 是没身份，403 是没权限，304 是用缓存。</strong></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" class="category-chain-item">前端面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/" class="print-no-link">#前端工程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【⭐】浏览器/网络相关面试题</div>
      <div>http://example.com/2026/01/08/前端面试/浏览器网络面试题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Xiang Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2026年1月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2026/01/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/Vue-Router%E9%9D%A2%E8%AF%95%E9%A2%98/" title="【⭐】Vue Router面试题">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【⭐】Vue Router面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2026/01/08/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/El-Menu%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9AVue-Router/" title="El-Menu如何绑定Vue Router？">
                        <span class="hidden-mobile">El-Menu如何绑定Vue Router？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"xXfj7jVpB8fiyIpWQbXJP1Gj-gzGzoHsz","appKey":"RoFR6Po4mFIHocqHXZ42PUGO","path":"window.location.pathname","placeholder":"输入你的评论","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
